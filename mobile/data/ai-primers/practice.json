{
  "category": "Practice",
  "cards": [
    {
      "id": "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Some Drawbacks of the Transformer?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The runtime of Transformer architecture is quadratic in the length of the input sequence, which means it can be slow when processing long documents or taking characters as inputs. In other words, computing all pairs of interactions during self-attention means our computation grows quadratically with the sequence length, i.e., <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-8-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-42\" style=\"width: 3.701em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.076em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1003.02em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-43\"><span class=\"mi\" id=\"MathJax-Span-44\" style=\"font-family: STIXGeneral-Italic;\">O</span><span class=\"mo\" id=\"MathJax-Span-45\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-46\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-47\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.732em;\"><span class=\"mn\" id=\"MathJax-Span-48\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-49\" style=\"font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-50\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-8\">O(T^2 d)</script>, where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-9-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-51\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-52\"><span class=\"mi\" id=\"MathJax-Span-53\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-9\">T</script> is the sequence length, and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-10-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-54\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-55\"><span class=\"mi\" id=\"MathJax-Span-56\" style=\"font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>d</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-10\">d</script> is the dimensionality. Note that for recurrent models, it only grew linearly!\n    <ul>\n      <li>Say, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-11-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi><mo>=</mo><mn>1000</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-57\" style=\"width: 4.534em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.753em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.75em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-58\"><span class=\"mi\" id=\"MathJax-Span-59\" style=\"font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-60\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-61\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1000</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>d</mi><mo>=</mo><mn>1000</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-11\">d = 1000</script>. So, for a single (shortish) sentence, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-12-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>&amp;#x2264;</mo><mn>30</mn><mo stretchy=&quot;false&quot;>&amp;#x21D2;</mo><msup><mi>T</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msup><mo>&amp;#x2264;</mo><mn>900</mn><mo stretchy=&quot;false&quot;>&amp;#x21D2;</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo>&amp;#x2248;</mo><mn>900</mn><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-62\" style=\"width: 17.815em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 14.846em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1014.85em, 2.763em, -999.997em); top: -2.497em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-63\"><span class=\"mi\" id=\"MathJax-Span-64\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-65\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≤</span><span class=\"mn\" id=\"MathJax-Span-66\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">30</span><span class=\"mo\" id=\"MathJax-Span-67\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">⇒</span><span class=\"msubsup\" id=\"MathJax-Span-68\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-69\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-70\"><span class=\"mrow\" id=\"MathJax-Span-71\"><span class=\"mn\" id=\"MathJax-Span-72\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-73\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≤</span><span class=\"mn\" id=\"MathJax-Span-74\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">900</span><span class=\"mo\" id=\"MathJax-Span-75\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">⇒</span><span class=\"msubsup\" id=\"MathJax-Span-76\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-77\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.732em;\"><span class=\"mn\" id=\"MathJax-Span-78\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-79\" style=\"font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-80\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≈</span><span class=\"mn\" id=\"MathJax-Span-81\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">900</span><span class=\"mi\" id=\"MathJax-Span-82\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.503em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.184em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi><mo>≤</mo><mn>30</mn><mo stretchy=\"false\">⇒</mo><msup><mi>T</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msup><mo>≤</mo><mn>900</mn><mo stretchy=\"false\">⇒</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo>≈</mo><mn>900</mn><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-12\">T \\leq 30 \\Rightarrow T^{2} \\leq 900 \\Rightarrow T^2 d \\approx 900K</script>. Note that in practice, we set a bound such as <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-13-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>=</mo><mn>512</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-83\" style=\"width: 4.065em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.388em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.39em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-84\"><span class=\"mi\" id=\"MathJax-Span-85\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-86\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-87\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">512</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi><mo>=</mo><mn>512</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-13\">T=512</script>. Imagine working on long documents with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-14-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>&amp;#x2265;</mo><mn>10</mn><mo>,</mo><mn>000</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-88\" style=\"width: 5.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.794em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.79em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-89\"><span class=\"mi\" id=\"MathJax-Span-90\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-91\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≥</span><span class=\"mn\" id=\"MathJax-Span-92\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">10</span><span class=\"mo\" id=\"MathJax-Span-93\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-94\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">000</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi><mo>≥</mo><mn>10</mn><mo>,</mo><mn>000</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-14\">T \\geq 10,000</script>!?</li>\n    </ul>\n  </li>\n  <li>Wouldn’t it be nice for Transformers if we didn’t have to compute pair-wise interactions between each word pair in the sentence? Recent studies such as:\n    <ul>\n      <li><a href=\"https://arxiv.org/abs/2005.00743\">Synthesizer: Rethinking Self-Attention in Transformer Models</a></li>\n      <li><a href=\"https://arxiv.org/abs/2006.04768\">Linformer: Self-Attention with Linear Complexity</a></li>\n      <li><a href=\"https://arxiv.org/abs/2009.14794\">Rethinking Attention with Performers</a></li>\n      <li><a href=\"https://arxiv.org/abs/2007.14062\">Big Bird: Transformers for Longer Sequences</a></li>\n      <li>… show that decent performance levels can be achieved without computing interactions between all word-pairs (such as by approximating pair-wise attention).</li>\n    </ul>\n  </li>\n  <li>Compared to CNNs, the data appetite of transformers is obscenely high. CNNs are still sample efficient, which makes them great candidates for low-resource tasks. This is especially true for image/video generation tasks where an exceptionally large amount of data is needed, even for CNN architectures (and thus implies that Transformer architectures would have a ridiculously high data requirement). For example, the recent <a href=\"https://arxiv.org/abs/2103.00020\">CLIP</a> architecture by Radford et al. was trained with CNN-based ResNets as vision backbones (and not a ViT-like transformer architecture). While transformers do offer accuracy bumps once their data requirement is satisfied, CNNs offer a way to deliver decent accuracy performance in tasks where the amount of data available is not exceptionally high. Both architectures thus have their usecases.</li>\n  <li>The runtime of the Transformer architecture is quadratic in the length of the input sequence. Computing attention over all word-pairs requires the number of edges in the graph to scale quadratically with the number of nodes, i.e., in an <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-15-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-95\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-96\"><span class=\"mi\" id=\"MathJax-Span-97\" style=\"font-family: STIXGeneral-Italic;\">n</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-15\">n</script> word sentence, a Transformer would be doing computations over <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-16-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-98\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.148em, 1000.94em, 2.294em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-99\"><span class=\"msubsup\" id=\"MathJax-Span-100\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-101\" style=\"font-family: STIXGeneral-Italic;\">n</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-102\"><span class=\"mrow\" id=\"MathJax-Span-103\"><span class=\"mn\" id=\"MathJax-Span-104\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mi>n</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-16\">n^{2}</script> pairs of words. This implies a large parameter count (implying high memory footprint) and thereby high computational complexity. More in the section on <a href=\"https://aman.ai/primers/ai/transformers/#what-would-we-like-to-fix-about-the-transformer\">What Would We Like to Fix about the Transformer?</a></li>\n  <li>High compute requirements has a negative impact on power and battery life requirements, especially for portable device targets.</li>\n  <li>Overall, a transformer requires higher computational power, more data, power/battery life, and memory footprint, for it to offer better performance (in terms of say, accuracy) compared to its conventional competitors.</li>\n</ul>\n<ul>\n      <li>Say, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-11-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi><mo>=</mo><mn>1000</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-57\" style=\"width: 4.534em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.753em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.75em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-58\"><span class=\"mi\" id=\"MathJax-Span-59\" style=\"font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-60\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-61\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1000</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>d</mi><mo>=</mo><mn>1000</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-11\">d = 1000</script>. So, for a single (shortish) sentence, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-12-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>&amp;#x2264;</mo><mn>30</mn><mo stretchy=&quot;false&quot;>&amp;#x21D2;</mo><msup><mi>T</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msup><mo>&amp;#x2264;</mo><mn>900</mn><mo stretchy=&quot;false&quot;>&amp;#x21D2;</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo>&amp;#x2248;</mo><mn>900</mn><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-62\" style=\"width: 17.815em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 14.846em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1014.85em, 2.763em, -999.997em); top: -2.497em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-63\"><span class=\"mi\" id=\"MathJax-Span-64\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-65\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≤</span><span class=\"mn\" id=\"MathJax-Span-66\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">30</span><span class=\"mo\" id=\"MathJax-Span-67\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">⇒</span><span class=\"msubsup\" id=\"MathJax-Span-68\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-69\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-70\"><span class=\"mrow\" id=\"MathJax-Span-71\"><span class=\"mn\" id=\"MathJax-Span-72\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-73\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≤</span><span class=\"mn\" id=\"MathJax-Span-74\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">900</span><span class=\"mo\" id=\"MathJax-Span-75\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">⇒</span><span class=\"msubsup\" id=\"MathJax-Span-76\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-77\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.732em;\"><span class=\"mn\" id=\"MathJax-Span-78\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-79\" style=\"font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-80\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≈</span><span class=\"mn\" id=\"MathJax-Span-81\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">900</span><span class=\"mi\" id=\"MathJax-Span-82\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.503em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.184em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi><mo>≤</mo><mn>30</mn><mo stretchy=\"false\">⇒</mo><msup><mi>T</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msup><mo>≤</mo><mn>900</mn><mo stretchy=\"false\">⇒</mo><msup><mi>T</mi><mn>2</mn></msup><mi>d</mi><mo>≈</mo><mn>900</mn><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-12\">T \\leq 30 \\Rightarrow T^{2} \\leq 900 \\Rightarrow T^2 d \\approx 900K</script>. Note that in practice, we set a bound such as <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-13-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>=</mo><mn>512</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-83\" style=\"width: 4.065em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.388em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.39em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-84\"><span class=\"mi\" id=\"MathJax-Span-85\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-86\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-87\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">512</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi><mo>=</mo><mn>512</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-13\">T=512</script>. Imagine working on long documents with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-14-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mo>&amp;#x2265;</mo><mn>10</mn><mo>,</mo><mn>000</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-88\" style=\"width: 5.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.794em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.79em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-89\"><span class=\"mi\" id=\"MathJax-Span-90\" style=\"font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-91\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≥</span><span class=\"mn\" id=\"MathJax-Span-92\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">10</span><span class=\"mo\" id=\"MathJax-Span-93\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-94\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">000</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>T</mi><mo>≥</mo><mn>10</mn><mo>,</mo><mn>000</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-14\">T \\geq 10,000</script>!?</li>\n    </ul>\n<ul>\n      <li><a href=\"https://arxiv.org/abs/2005.00743\">Synthesizer: Rethinking Self-Attention in Transformer Models</a></li>\n      <li><a href=\"https://arxiv.org/abs/2006.04768\">Linformer: Self-Attention with Linear Complexity</a></li>\n      <li><a href=\"https://arxiv.org/abs/2009.14794\">Rethinking Attention with Performers</a></li>\n      <li><a href=\"https://arxiv.org/abs/2007.14062\">Big Bird: Transformers for Longer Sequences</a></li>\n      <li>… show that decent performance levels can be achieved without computing interactions between all word-pairs (such as by approximating pair-wise attention).</li>\n    </ul>",
      "contentMarkdown": "*   The runtime of Transformer architecture is quadratic in the length of the input sequence, which means it can be slow when processing long documents or taking characters as inputs. In other words, computing all pairs of interactions during self-attention means our computation grows quadratically with the sequence length, i.e., O(T2d)O(T2d)O(T^2 d), where TTT is the sequence length, and ddd is the dimensionality. Note that for recurrent models, it only grew linearly!\n    *   Say, d\\=1000d\\=1000d = 1000. So, for a single (shortish) sentence, T≤30⇒T2≤900⇒T2d≈900KT≤30⇒T2≤900⇒T2d≈900KT \\\\leq 30 \\\\Rightarrow T^{2} \\\\leq 900 \\\\Rightarrow T^2 d \\\\approx 900K. Note that in practice, we set a bound such as T\\=512T\\=512T=512. Imagine working on long documents with T≥10,000T≥10,000T \\\\geq 10,000!?\n*   Wouldn’t it be nice for Transformers if we didn’t have to compute pair-wise interactions between each word pair in the sentence? Recent studies such as:\n    *   [Synthesizer: Rethinking Self-Attention in Transformer Models](https://arxiv.org/abs/2005.00743)\n    *   [Linformer: Self-Attention with Linear Complexity](https://arxiv.org/abs/2006.04768)\n    *   [Rethinking Attention with Performers](https://arxiv.org/abs/2009.14794)\n    *   [Big Bird: Transformers for Longer Sequences](https://arxiv.org/abs/2007.14062)\n    *   … show that decent performance levels can be achieved without computing interactions between all word-pairs (such as by approximating pair-wise attention).\n*   Compared to CNNs, the data appetite of transformers is obscenely high. CNNs are still sample efficient, which makes them great candidates for low-resource tasks. This is especially true for image/video generation tasks where an exceptionally large amount of data is needed, even for CNN architectures (and thus implies that Transformer architectures would have a ridiculously high data requirement). For example, the recent [CLIP](https://arxiv.org/abs/2103.00020) architecture by Radford et al. was trained with CNN-based ResNets as vision backbones (and not a ViT-like transformer architecture). While transformers do offer accuracy bumps once their data requirement is satisfied, CNNs offer a way to deliver decent accuracy performance in tasks where the amount of data available is not exceptionally high. Both architectures thus have their usecases.\n*   The runtime of the Transformer architecture is quadratic in the length of the input sequence. Computing attention over all word-pairs requires the number of edges in the graph to scale quadratically with the number of nodes, i.e., in an nnn word sentence, a Transformer would be doing computations over n2n2n^{2} pairs of words. This implies a large parameter count (implying high memory footprint) and thereby high computational complexity. More in the section on [What Would We Like to Fix about the Transformer?](https://aman.ai/primers/ai/transformers/#what-would-we-like-to-fix-about-the-transformer)\n*   High compute requirements has a negative impact on power and battery life requirements, especially for portable device targets.\n*   Overall, a transformer requires higher computational power, more data, power/battery life, and memory footprint, for it to offer better performance (in terms of say, accuracy) compared to its conventional competitors.\n\n*   Say, d\\=1000d\\=1000d = 1000. So, for a single (shortish) sentence, T≤30⇒T2≤900⇒T2d≈900KT≤30⇒T2≤900⇒T2d≈900KT \\\\leq 30 \\\\Rightarrow T^{2} \\\\leq 900 \\\\Rightarrow T^2 d \\\\approx 900K. Note that in practice, we set a bound such as T\\=512T\\=512T=512. Imagine working on long documents with T≥10,000T≥10,000T \\\\geq 10,000!?\n\n*   [Synthesizer: Rethinking Self-Attention in Transformer Models](https://arxiv.org/abs/2005.00743)\n*   [Linformer: Self-Attention with Linear Complexity](https://arxiv.org/abs/2006.04768)\n*   [Rethinking Attention with Performers](https://arxiv.org/abs/2009.14794)\n*   [Big Bird: Transformers for Longer Sequences](https://arxiv.org/abs/2007.14062)\n*   … show that decent performance levels can be achieved without computing interactions between all word-pairs (such as by approximating pair-wise attention).",
      "order": 1,
      "orderInChapter": 1,
      "difficulty": 3,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "cnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 533,
        "contentLength": 31749
      },
      "nextCards": [
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3"
      ],
      "relatedCards": [
        "ai-dl-comp-drawbacks-of-transformers-compared-to-rnnsgruslstm-8",
        "ai-model-acceleration-grouped-query-attention-gqa-6",
        "ai-vision-language-models-two-stream-models-vilbert-4",
        "ai-vision-language-models-single-stream-models-5",
        "ai-ml-runtimes-architecture-33"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-drawbacks-of-the-transformer?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5",
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6"
      ]
    },
    {
      "id": "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Do We Initialize Weights Randomly? / What If We Initialize the Weights with the Same Values?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>If all weights are initialized with the same values, all neurons in each layer give you the same outputs (and thus redundantly learn the same features) which implies the model will never learn. This is the reason that the weights are initialized with random numbers.</li>\n  <li>Detailed explanation:\n    <ul>\n      <li>The optimization algorithms we usually use for training neural networks are deterministic. Gradient descent, the most basic algorithm, that is a base for the more complicated ones, is defined in terms of partial derivatives</li>\n    </ul>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-17-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msub><mi>&amp;#x03B8;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi></mrow></msub><mo>:=</mo><msub><mi>&amp;#x03B8;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi></mrow></msub><mo>&amp;#x2212;</mo><mi>&amp;#x03B1;</mi><mfrac><mi mathvariant=&quot;normal&quot;>&amp;#x2202;</mi><mrow><mi mathvariant=&quot;normal&quot;>&amp;#x2202;</mi><msub><mi>&amp;#x03B8;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi></mrow></msub></mrow></mfrac><mi>J</mi><mo stretchy=&quot;false&quot;>(</mo><mi mathvariant=&quot;normal&quot;>&amp;#x0398;</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-105\" style=\"width: 9.846em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 8.18em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.68em, 1008.13em, 3.336em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-106\"><span class=\"msubsup\" id=\"MathJax-Span-107\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-108\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-109\"><span class=\"mrow\" id=\"MathJax-Span-110\"><span class=\"mi\" id=\"MathJax-Span-111\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-112\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">:<span style=\"font-family: STIXGeneral-Regular; font-style: normal; font-weight: normal;\">=</span></span><span class=\"msubsup\" id=\"MathJax-Span-113\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-114\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-115\"><span class=\"mrow\" id=\"MathJax-Span-116\"><span class=\"mi\" id=\"MathJax-Span-117\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-118\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-119\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">α</span><span class=\"mfrac\" id=\"MathJax-Span-120\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.685em; left: 50%; margin-left: -0.258em;\"><span class=\"mi\" id=\"MathJax-Span-121\" style=\"font-family: STIXGeneral-Regular;\">∂</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.18em, 1001.2em, 4.482em, -999.997em); top: -3.331em; left: 50%; margin-left: -0.622em;\"><span class=\"mrow\" id=\"MathJax-Span-122\"><span class=\"mi\" id=\"MathJax-Span-123\" style=\"font-family: STIXGeneral-Regular;\">∂</span><span class=\"msubsup\" id=\"MathJax-Span-124\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-125\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-126\"><span class=\"mrow\" id=\"MathJax-Span-127\"><span class=\"mi\" id=\"MathJax-Span-128\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1001.36em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 1.357em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-129\" style=\"font-family: STIXGeneral-Italic;\">J<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-130\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-131\" style=\"font-family: STIXGeneral-Regular;\">Θ</span><span class=\"mo\" id=\"MathJax-Span-132\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -1.247em; border-left: 0px solid; width: 0px; height: 2.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><msub><mi>θ</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>j</mi></mrow></msub><mo>:=</mo><msub><mi>θ</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>j</mi></mrow></msub><mo>−</mo><mi>α</mi><mfrac><mi mathvariant=\"normal\">∂</mi><mrow><mi mathvariant=\"normal\">∂</mi><msub><mi>θ</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>j</mi></mrow></msub></mrow></mfrac><mi>J</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Θ</mi><mo stretchy=\"false\">)</mo></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-17\">\\theta_{j}:=\\theta_{j}-\\alpha \\frac{\\partial}{\\partial \\theta_{j}} J(\\Theta)</script>\n\n    <ul>\n      <li>\n        <p>A <a href=\"https://en.wikipedia.org/wiki/Partial_derivative\">partial derivative</a> tells you how does the change of the optimized function is affected by the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-18-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B8;</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-133\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.73em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-134\"><span class=\"msubsup\" id=\"MathJax-Span-135\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-136\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-137\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>θ</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-18\">\\theta_j</script> parameter. If all the parameters are the same, they all have the same impact on the result, so will change by the same quantity. If you change all the parameters by the same value, they will keep being the same. In such a case, each neuron will be doing the same thing, they will be redundant and there would be no point in having multiple neurons. There is no point in wasting your compute repeating exactly the same operations multiple times. In other words, the model does not learn because error is propagated back through the weights in proportion to the values of the weights. This means that all hidden units connected directly to the output units will get identical error signals, and, since the weight changes depend on the error signals, the weights from those units to the output units will be the same.</p>\n      </li>\n      <li>\n        <p>When you initialize the neurons randomly, each of them will hopefully be evolving during the optimization in a different “direction”, they will be learning to detect different features from the data. You can think of early layers as of doing automatic feature engineering for you, by transforming the data, that are used by the final layer of the network. If all the learned features are the same, it would be a wasted effort.</p>\n      </li>\n      <li>\n        <p><a href=\"https://arxiv.org/abs/1803.03635v1\">The Lottery Ticket Hypothesis: Training Pruned Neural Networks by Frankle and Carbin</a> explores the hypothesis that the big neural networks are so effective because randomly initializing multiple parameters helps our luck by drawing the lucky “lottery ticket” parameters that work well for the problem.</p>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>The optimization algorithms we usually use for training neural networks are deterministic. Gradient descent, the most basic algorithm, that is a base for the more complicated ones, is defined in terms of partial derivatives</li>\n    </ul>\n<ul>\n      <li>\n        <p>A <a href=\"https://en.wikipedia.org/wiki/Partial_derivative\">partial derivative</a> tells you how does the change of the optimized function is affected by the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-18-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B8;</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-133\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.73em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-134\"><span class=\"msubsup\" id=\"MathJax-Span-135\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-136\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-137\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>θ</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-18\">\\theta_j</script> parameter. If all the parameters are the same, they all have the same impact on the result, so will change by the same quantity. If you change all the parameters by the same value, they will keep being the same. In such a case, each neuron will be doing the same thing, they will be redundant and there would be no point in having multiple neurons. There is no point in wasting your compute repeating exactly the same operations multiple times. In other words, the model does not learn because error is propagated back through the weights in proportion to the values of the weights. This means that all hidden units connected directly to the output units will get identical error signals, and, since the weight changes depend on the error signals, the weights from those units to the output units will be the same.</p>\n      </li>\n      <li>\n        <p>When you initialize the neurons randomly, each of them will hopefully be evolving during the optimization in a different “direction”, they will be learning to detect different features from the data. You can think of early layers as of doing automatic feature engineering for you, by transforming the data, that are used by the final layer of the network. If all the learned features are the same, it would be a wasted effort.</p>\n      </li>\n      <li>\n        <p><a href=\"https://arxiv.org/abs/1803.03635v1\">The Lottery Ticket Hypothesis: Training Pruned Neural Networks by Frankle and Carbin</a> explores the hypothesis that the big neural networks are so effective because randomly initializing multiple parameters helps our luck by drawing the lucky “lottery ticket” parameters that work well for the problem.</p>\n      </li>\n    </ul>\n<p>A <a href=\"https://en.wikipedia.org/wiki/Partial_derivative\">partial derivative</a> tells you how does the change of the optimized function is affected by the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-18-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B8;</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-133\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.73em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-134\"><span class=\"msubsup\" id=\"MathJax-Span-135\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-136\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-137\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>θ</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-18\">\\theta_j</script> parameter. If all the parameters are the same, they all have the same impact on the result, so will change by the same quantity. If you change all the parameters by the same value, they will keep being the same. In such a case, each neuron will be doing the same thing, they will be redundant and there would be no point in having multiple neurons. There is no point in wasting your compute repeating exactly the same operations multiple times. In other words, the model does not learn because error is propagated back through the weights in proportion to the values of the weights. This means that all hidden units connected directly to the output units will get identical error signals, and, since the weight changes depend on the error signals, the weights from those units to the output units will be the same.</p>\n<p>When you initialize the neurons randomly, each of them will hopefully be evolving during the optimization in a different “direction”, they will be learning to detect different features from the data. You can think of early layers as of doing automatic feature engineering for you, by transforming the data, that are used by the final layer of the network. If all the learned features are the same, it would be a wasted effort.</p>\n<p><a href=\"https://arxiv.org/abs/1803.03635v1\">The Lottery Ticket Hypothesis: Training Pruned Neural Networks by Frankle and Carbin</a> explores the hypothesis that the big neural networks are so effective because randomly initializing multiple parameters helps our luck by drawing the lucky “lottery ticket” parameters that work well for the problem.</p>",
      "contentMarkdown": "*   If all weights are initialized with the same values, all neurons in each layer give you the same outputs (and thus redundantly learn the same features) which implies the model will never learn. This is the reason that the weights are initialized with random numbers.\n*   Detailed explanation:\n    \n    *   The optimization algorithms we usually use for training neural networks are deterministic. Gradient descent, the most basic algorithm, that is a base for the more complicated ones, is defined in terms of partial derivatives\n    \n    θj:\\=θj−α∂∂θjJ(Θ)θj:=θj−α∂∂θjJ(Θ)\n    \n    \\\\theta\\_{j}:=\\\\theta\\_{j}-\\\\alpha \\\\frac{\\\\partial}{\\\\partial \\\\theta\\_{j}} J(\\\\Theta)\n    *   A [partial derivative](https://en.wikipedia.org/wiki/Partial_derivative) tells you how does the change of the optimized function is affected by the θjθj\\\\theta\\_j parameter. If all the parameters are the same, they all have the same impact on the result, so will change by the same quantity. If you change all the parameters by the same value, they will keep being the same. In such a case, each neuron will be doing the same thing, they will be redundant and there would be no point in having multiple neurons. There is no point in wasting your compute repeating exactly the same operations multiple times. In other words, the model does not learn because error is propagated back through the weights in proportion to the values of the weights. This means that all hidden units connected directly to the output units will get identical error signals, and, since the weight changes depend on the error signals, the weights from those units to the output units will be the same.\n        \n    *   When you initialize the neurons randomly, each of them will hopefully be evolving during the optimization in a different “direction”, they will be learning to detect different features from the data. You can think of early layers as of doing automatic feature engineering for you, by transforming the data, that are used by the final layer of the network. If all the learned features are the same, it would be a wasted effort.\n        \n    *   [The Lottery Ticket Hypothesis: Training Pruned Neural Networks by Frankle and Carbin](https://arxiv.org/abs/1803.03635v1) explores the hypothesis that the big neural networks are so effective because randomly initializing multiple parameters helps our luck by drawing the lucky “lottery ticket” parameters that work well for the problem.\n        \n\n*   The optimization algorithms we usually use for training neural networks are deterministic. Gradient descent, the most basic algorithm, that is a base for the more complicated ones, is defined in terms of partial derivatives\n\n*   A [partial derivative](https://en.wikipedia.org/wiki/Partial_derivative) tells you how does the change of the optimized function is affected by the θjθj\\\\theta\\_j parameter. If all the parameters are the same, they all have the same impact on the result, so will change by the same quantity. If you change all the parameters by the same value, they will keep being the same. In such a case, each neuron will be doing the same thing, they will be redundant and there would be no point in having multiple neurons. There is no point in wasting your compute repeating exactly the same operations multiple times. In other words, the model does not learn because error is propagated back through the weights in proportion to the values of the weights. This means that all hidden units connected directly to the output units will get identical error signals, and, since the weight changes depend on the error signals, the weights from those units to the output units will be the same.\n    \n*   When you initialize the neurons randomly, each of them will hopefully be evolving during the optimization in a different “direction”, they will be learning to detect different features from the data. You can think of early layers as of doing automatic feature engineering for you, by transforming the data, that are used by the final layer of the network. If all the learned features are the same, it would be a wasted effort.\n    \n*   [The Lottery Ticket Hypothesis: Training Pruned Neural Networks by Frankle and Carbin](https://arxiv.org/abs/1803.03635v1) explores the hypothesis that the big neural networks are so effective because randomly initializing multiple parameters helps our luck by drawing the lucky “lottery ticket” parameters that work well for the problem.\n    \n\nA [partial derivative](https://en.wikipedia.org/wiki/Partial_derivative) tells you how does the change of the optimized function is affected by the θjθj\\\\theta\\_j parameter. If all the parameters are the same, they all have the same impact on the result, so will change by the same quantity. If you change all the parameters by the same value, they will keep being the same. In such a case, each neuron will be doing the same thing, they will be redundant and there would be no point in having multiple neurons. There is no point in wasting your compute repeating exactly the same operations multiple times. In other words, the model does not learn because error is propagated back through the weights in proportion to the values of the weights. This means that all hidden units connected directly to the output units will get identical error signals, and, since the weight changes depend on the error signals, the weights from those units to the output units will be the same.\n\nWhen you initialize the neurons randomly, each of them will hopefully be evolving during the optimization in a different “direction”, they will be learning to detect different features from the data. You can think of early layers as of doing automatic feature engineering for you, by transforming the data, that are used by the final layer of the network. If all the learned features are the same, it would be a wasted effort.\n\n[The Lottery Ticket Hypothesis: Training Pruned Neural Networks by Frankle and Carbin](https://arxiv.org/abs/1803.03635v1) explores the hypothesis that the big neural networks are so effective because randomly initializing multiple parameters helps our luck by drawing the lucky “lottery ticket” parameters that work well for the problem.",
      "order": 2,
      "orderInChapter": 2,
      "difficulty": 3,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "optimization",
        "gradient descent"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 970,
        "contentLength": 19690
      },
      "nextCards": [
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4"
      ],
      "relatedCards": [
        "ai-double-descent-epoch-wise-double-descent-3",
        "ai-model-debugging-weight-initialization-11",
        "ai-decision-trees-and-ensemble-methods-can-decision-trees-be-fine-tuned-ie-do-they-have-i-18",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7",
        "ai-diffusion-models-general-overview-4"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-do-we-initialize-weights-randomly?-/-what-if-we-initialize-the-weights-with-the-same-values?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5",
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6"
      ]
    },
    {
      "id": "ai-interview-describe-learning-rate-scheduleannealing-3",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Describe Learning Rate Schedule/annealing.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Am optimizer is typically used with a learning rate schedule that involves a short warmup phase, a constant hold phase and an exponential decay phase. The decay/annealing is typically done using a cosine learning rate schedule over a number of cycles (Loshchilov &amp; Hutter, 2016).</li>\n</ul>",
      "contentMarkdown": "*   Am optimizer is typically used with a learning rate schedule that involves a short warmup phase, a constant hold phase and an exponential decay phase. The decay/annealing is typically done using a cosine learning rate schedule over a number of cycles (Loshchilov & Hutter, 2016).",
      "order": 3,
      "orderInChapter": 3,
      "difficulty": 2,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 46,
        "contentLength": 305
      },
      "nextCards": [
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#describe-learning-rate-schedule/annealing.",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5",
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6"
      ]
    },
    {
      "id": "ai-interview-explain-meanaverage-in-terms-of-attention-4",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Mean/average in Terms of Attention.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Averaging is equivalent to uniform attention.</li>\n</ul>",
      "contentMarkdown": "*   Averaging is equivalent to uniform attention.",
      "order": 4,
      "orderInChapter": 4,
      "difficulty": 2,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "attention"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 7,
        "contentLength": 67
      },
      "nextCards": [
        "ai-interview-what-is-convergence-in-k-means-clustering-5",
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6"
      ],
      "relatedCards": [
        "ai-attention-the-bottleneck-problem-2",
        "ai-attention-how-attention-solves-the-bottleneck-problem-4",
        "ai-attention-theoretical-complexity-9",
        "ai-attention-lightning-attention-14",
        "ai-flashattention-tiling-and-recomputation-strategy-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-mean/average-in-terms-of-attention.",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-what-is-convergence-in-k-means-clustering-5",
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6"
      ]
    },
    {
      "id": "ai-interview-what-is-convergence-in-k-means-clustering-5",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Convergence in K-means Clustering?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In case of <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-19-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-138\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-139\"><span class=\"mi\" id=\"MathJax-Span-140\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-19\">k</script>-means clustering, the word convergence means the algorithm has successfully completed clustering or grouping of data points in <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-20-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-141\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-142\"><span class=\"mi\" id=\"MathJax-Span-143\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-20\">k</script> number of clusters. The algorithm determines that it has grouped/clustered the data points into correct clusters if the centroids (<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-21-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-144\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-145\"><span class=\"mi\" id=\"MathJax-Span-146\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-21\">k</script> values) in the last two consequent iterations are same then the algorithm is said to have converged. However, in practice, people often use a less strict criteria for convergence, for e.g., the difference in the values of last two iterations needs to be less than a low threshold.</li>\n</ul>",
      "contentMarkdown": "*   In case of kkk\\-means clustering, the word convergence means the algorithm has successfully completed clustering or grouping of data points in kkk number of clusters. The algorithm determines that it has grouped/clustered the data points into correct clusters if the centroids (kkk values) in the last two consequent iterations are same then the algorithm is said to have converged. However, in practice, people often use a less strict criteria for convergence, for e.g., the difference in the values of last two iterations needs to be less than a low threshold.",
      "order": 5,
      "orderInChapter": 5,
      "difficulty": 3,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 91,
        "contentLength": 4384
      },
      "nextCards": [
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6",
        "ai-interview-popular-machine-learning-models-pros-and-cons-7"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-convergence-in-k-means-clustering?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6"
      ]
    },
    {
      "id": "ai-interview-list-some-debug-stepsreasons-for-your-ml-model-und-6",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "List Some Debug Steps/reasons for Your ML Model Underperforming on the Test Data",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li><strong>Insufficient quantity of training data</strong>: Machine learning algorithms need a large amount of data to be able to learn the underlying statistics from the data and work properly. Even for simple problems, the models will typically need thousands of examples.</li>\n  <li><strong>Nonrepresentative training data</strong>: In order for the model to generalize well, your training data should be representative of what is expected to be seen in the production. If the training data is nonrepresentative of the production data or is different this is known as data mismatch.</li>\n  <li><strong>Poor quality data</strong>: Since the learning models will use the data to learn the underlying pattern and statistics from it. It is critical that the data are rich in information and be of good quality. Having training data that are full of outliers, errors, noise, and missing data will decrease the ability of the model to learn from data, and then the model will act poorly on new data.</li>\n  <li><strong>Irrelevant features</strong>: As the famous quote says “garbage in, garbage out”. Your machine learning model will be only able to learn if the data contains relevant features and not too many irrelevant features.</li>\n  <li><strong>Overfitting the training data</strong>: Overfitting happens when the model is too complex relative to the size of the data and its quality, which will result in learning more about the pattern in the noise of the data or very specific patterns in the data which the model will not be able to generalize for new instances.</li>\n  <li><strong>Underfitting the training data</strong>: Underfitting is the opposite of overfitting, the model is too simple to learn any of the patterns in the training data. This could be known when the training error is large and also the validation and test error is large.</li>\n</ul>",
      "contentMarkdown": "*   **Insufficient quantity of training data**: Machine learning algorithms need a large amount of data to be able to learn the underlying statistics from the data and work properly. Even for simple problems, the models will typically need thousands of examples.\n*   **Nonrepresentative training data**: In order for the model to generalize well, your training data should be representative of what is expected to be seen in the production. If the training data is nonrepresentative of the production data or is different this is known as data mismatch.\n*   **Poor quality data**: Since the learning models will use the data to learn the underlying pattern and statistics from it. It is critical that the data are rich in information and be of good quality. Having training data that are full of outliers, errors, noise, and missing data will decrease the ability of the model to learn from data, and then the model will act poorly on new data.\n*   **Irrelevant features**: As the famous quote says “garbage in, garbage out”. Your machine learning model will be only able to learn if the data contains relevant features and not too many irrelevant features.\n*   **Overfitting the training data**: Overfitting happens when the model is too complex relative to the size of the data and its quality, which will result in learning more about the pattern in the noise of the data or very specific patterns in the data which the model will not be able to generalize for new instances.\n*   **Underfitting the training data**: Underfitting is the opposite of overfitting, the model is too simple to learn any of the patterns in the training data. This could be known when the training error is large and also the validation and test error is large.",
      "order": 6,
      "orderInChapter": 6,
      "difficulty": 2,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 294,
        "contentLength": 1871
      },
      "nextCards": [
        "ai-interview-popular-machine-learning-models-pros-and-cons-7",
        "ai-interview-define-correlation-8"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-overview-1",
        "ai-decision-trees-and-ensemble-methods-overview-7",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#list-some-debug-steps/reasons-for-your-ml-model-underperforming-on-the-test-data",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-popular-machine-learning-models-pros-and-cons-7",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Popular Machine Learning Models: Pros and Cons",
      "subtitle": "Deep Learning",
      "contentHtml": "<h4 id=\"linear-regression\">Linear Regression</h4>\n<h5 id=\"pros\">Pros</h5>\n<ul>\n  <li>Simple to implement and efficient to train.</li>\n  <li>Overfitting can be reduced by regularization.</li>\n  <li>Performs well when the dataset is linearly separable.</li>\n</ul>\n<h5 id=\"cons\">Cons</h5>\n<ul>\n  <li>Assumes that the data is independent which is rare in real life.</li>\n  <li>Prone to noise and overfitting.</li>\n  <li>Sensitive to outliers.</li>\n</ul>\n<h4 id=\"logistic-regression\">Logistic Regression</h4>\n<h5 id=\"pros-1\">Pros</h5>\n<ul>\n  <li>Less prone to over-fitting but it can overfit in high dimensional datasets.</li>\n  <li>Efficient when the dataset has features that are linearly separable.</li>\n  <li>Easy to implement and efficient to train.</li>\n</ul>\n<h5 id=\"cons-1\">Cons</h5>\n<ul>\n  <li>Should not be used when the number of observations are lesser than the number of features.</li>\n  <li>Assumption of linearity which is rare in practice.</li>\n  <li>Can only be used to predict discrete functions.</li>\n</ul>\n<h4 id=\"support-vector-machines\">Support Vector Machines</h4>\n<h5 id=\"pros-2\">Pros</h5>\n<ul>\n  <li>Good at high dimensional data.</li>\n  <li>Can work on small dataset.</li>\n  <li>Can solve non-linear problems.</li>\n</ul>\n<h5 id=\"cons-2\">Cons</h5>\n<ul>\n  <li>Inefficient on large data.</li>\n  <li>Requires picking the right kernel.</li>\n</ul>\n<h4 id=\"decision-trees\">Decision Trees</h4>\n<ul>\n  <li>Decision Trees can be used for both classification and regression.</li>\n  <li>For classification, you can simply return the majority vote of the trees.</li>\n  <li>For regression, you can return the averaged values of the trees.</li>\n</ul>\n<h5 id=\"pros-3\">Pros</h5>\n<ul>\n  <li>Can solve non-linear problems.</li>\n  <li>Can work on high-dimensional data with excellent accuracy.</li>\n  <li>Easy to visualize and explain.</li>\n</ul>\n<h5 id=\"cons-3\">Cons</h5>\n<ul>\n  <li>Overfitting. Might be resolved by random forest.</li>\n  <li>A small change in the data can lead to a large change in the structure of the optimal decision tree.</li>\n  <li>Calculations can get very complex.</li>\n</ul>\n<h4 id=\"k-nearest-neighbor\">K-Nearest Neighbor</h4>\n<ul>\n  <li>k-Nearest Neighbor (kNN) can be used for both classification and regression.</li>\n  <li>For classification, you can simply return the majority vote of the nearest neighbors.</li>\n  <li>For regression, you can return the averaged values of the nearest neighbors.</li>\n</ul>\n<h5 id=\"pros-4\">Pros</h5>\n<ul>\n  <li>Can make predictions without training.</li>\n  <li>Time complexity is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-22-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-147\" style=\"width: 2.294em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.878em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1001.83em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-148\"><span class=\"mi\" id=\"MathJax-Span-149\" style=\"font-family: STIXGeneral-Italic;\">O</span><span class=\"mo\" id=\"MathJax-Span-150\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-151\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mo\" id=\"MathJax-Span-152\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-22\">O(n)</script>.</li>\n  <li>Can be used for both classification and regression.</li>\n</ul>\n<h5 id=\"cons-4\">Cons</h5>\n<ul>\n  <li>Does not work well with large dataset.</li>\n  <li>Sensitive to noisy data, missing values and outliers.</li>\n  <li>Need feature scaling.</li>\n  <li>Choose the correct <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-23-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-153\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-154\"><span class=\"mi\" id=\"MathJax-Span-155\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-23\">K</script> value.</li>\n</ul>\n<h4 id=\"k-means-clustering\">K-Means Clustering</h4>\n<ul>\n  <li>k-Means Clustering (kMC) is a classifier.</li>\n</ul>\n<h5 id=\"pros-5\">Pros</h5>\n<ul>\n  <li>Simple to implement.</li>\n  <li>Scales to large data sets.</li>\n  <li>Guarantees convergence.</li>\n  <li>Easily adapts to new examples.</li>\n  <li>Generalizes to clusters of different shapes and sizes.</li>\n</ul>\n<h5 id=\"cons-5\">Cons</h5>\n<ul>\n  <li>Sensitive to the outliers.</li>\n  <li>Choosing the k values manually is tough.</li>\n  <li>Dependent on initial values.</li>\n  <li>Scalability decreases when dimension increases.</li>\n</ul>\n<h4 id=\"principal-component-analysis\">Principal Component Analysis</h4>\n<ul>\n  <li>Principal Component Analysis (PCA) is a dimensionality reduction technique that reduces correlated (features that show co-variance) features and projects them to a lower-dimensional space.</li>\n</ul>\n<h5 id=\"pros-6\">Pros</h5>\n<ul>\n  <li>Reduce correlated features.</li>\n  <li>Improve performance.</li>\n  <li>Reduce overfitting.</li>\n</ul>\n<h5 id=\"cons-6\">Cons</h5>\n<ul>\n  <li>Principal components are less interpretable.</li>\n  <li>Information loss.</li>\n  <li>Must standardize data before implementing PCA.</li>\n</ul>\n<h4 id=\"naive-bayes\">Naive Bayes</h4>\n<h5 id=\"pros-7\">Pros</h5>\n<ul>\n  <li>Training period is less.</li>\n  <li>Better suited for categorical inputs.</li>\n  <li>Easy to implement.</li>\n</ul>\n<h5 id=\"cons-7\">Cons</h5>\n<ul>\n  <li>Assumes that all features are independent which is rarely happening in real life.</li>\n  <li>Zero Frequency.</li>\n  <li>Estimations can be wrong in some cases.</li>\n</ul>\n<h4 id=\"ann\">ANN</h4>\n<h5 id=\"pros-8\">Pros</h5>\n<ul>\n  <li>Have fault tolerance.</li>\n  <li>Have the ability to learn and model non-linear and complex relationships.</li>\n  <li>Can generalize on unseen data.</li>\n</ul>\n<h5 id=\"cons-8\">Cons</h5>\n<ul>\n  <li>Long training time.</li>\n  <li>Non-guaranteed convergence.</li>\n  <li>Black box. Hard to explain solution.</li>\n  <li>Hardware dependence.</li>\n  <li>Requires user’s ability to translate the problem.</li>\n</ul>\n<h4 id=\"adaboost\">Adaboost</h4>\n<h5 id=\"pros-9\">Pros</h5>\n<ul>\n  <li>Relatively robust to overfitting.</li>\n  <li>High accuracy.</li>\n  <li>Easy to understand and to visualize.</li>\n</ul>\n<h5 id=\"cons-9\">Cons</h5>\n<ul>\n  <li>Sensitive to noise data.</li>\n  <li>Affected by outliers.</li>\n  <li>Not optimized for speed.</li>\n</ul>",
      "contentMarkdown": "#### Linear Regression\n\n##### Pros\n\n*   Simple to implement and efficient to train.\n*   Overfitting can be reduced by regularization.\n*   Performs well when the dataset is linearly separable.\n\n##### Cons\n\n*   Assumes that the data is independent which is rare in real life.\n*   Prone to noise and overfitting.\n*   Sensitive to outliers.\n\n#### Logistic Regression\n\n##### Pros\n\n*   Less prone to over-fitting but it can overfit in high dimensional datasets.\n*   Efficient when the dataset has features that are linearly separable.\n*   Easy to implement and efficient to train.\n\n##### Cons\n\n*   Should not be used when the number of observations are lesser than the number of features.\n*   Assumption of linearity which is rare in practice.\n*   Can only be used to predict discrete functions.\n\n#### Support Vector Machines\n\n##### Pros\n\n*   Good at high dimensional data.\n*   Can work on small dataset.\n*   Can solve non-linear problems.\n\n##### Cons\n\n*   Inefficient on large data.\n*   Requires picking the right kernel.\n\n#### Decision Trees\n\n*   Decision Trees can be used for both classification and regression.\n*   For classification, you can simply return the majority vote of the trees.\n*   For regression, you can return the averaged values of the trees.\n\n##### Pros\n\n*   Can solve non-linear problems.\n*   Can work on high-dimensional data with excellent accuracy.\n*   Easy to visualize and explain.\n\n##### Cons\n\n*   Overfitting. Might be resolved by random forest.\n*   A small change in the data can lead to a large change in the structure of the optimal decision tree.\n*   Calculations can get very complex.\n\n#### K-Nearest Neighbor\n\n*   k-Nearest Neighbor (kNN) can be used for both classification and regression.\n*   For classification, you can simply return the majority vote of the nearest neighbors.\n*   For regression, you can return the averaged values of the nearest neighbors.\n\n##### Pros\n\n*   Can make predictions without training.\n*   Time complexity is O(n)O(n)O(n).\n*   Can be used for both classification and regression.\n\n##### Cons\n\n*   Does not work well with large dataset.\n*   Sensitive to noisy data, missing values and outliers.\n*   Need feature scaling.\n*   Choose the correct KKK value.\n\n#### K-Means Clustering\n\n*   k-Means Clustering (kMC) is a classifier.\n\n##### Pros\n\n*   Simple to implement.\n*   Scales to large data sets.\n*   Guarantees convergence.\n*   Easily adapts to new examples.\n*   Generalizes to clusters of different shapes and sizes.\n\n##### Cons\n\n*   Sensitive to the outliers.\n*   Choosing the k values manually is tough.\n*   Dependent on initial values.\n*   Scalability decreases when dimension increases.\n\n#### Principal Component Analysis\n\n*   Principal Component Analysis (PCA) is a dimensionality reduction technique that reduces correlated (features that show co-variance) features and projects them to a lower-dimensional space.\n\n##### Pros\n\n*   Reduce correlated features.\n*   Improve performance.\n*   Reduce overfitting.\n\n##### Cons\n\n*   Principal components are less interpretable.\n*   Information loss.\n*   Must standardize data before implementing PCA.\n\n#### Naive Bayes\n\n##### Pros\n\n*   Training period is less.\n*   Better suited for categorical inputs.\n*   Easy to implement.\n\n##### Cons\n\n*   Assumes that all features are independent which is rarely happening in real life.\n*   Zero Frequency.\n*   Estimations can be wrong in some cases.\n\n#### ANN\n\n##### Pros\n\n*   Have fault tolerance.\n*   Have the ability to learn and model non-linear and complex relationships.\n*   Can generalize on unseen data.\n\n##### Cons\n\n*   Long training time.\n*   Non-guaranteed convergence.\n*   Black box. Hard to explain solution.\n*   Hardware dependence.\n*   Requires user’s ability to translate the problem.\n\n#### Adaboost\n\n##### Pros\n\n*   Relatively robust to overfitting.\n*   High accuracy.\n*   Easy to understand and to visualize.\n\n##### Cons\n\n*   Sensitive to noise data.\n*   Affected by outliers.\n*   Not optimized for speed.",
      "order": 7,
      "orderInChapter": 7,
      "difficulty": 3,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 615,
        "contentLength": 8097
      },
      "nextCards": [
        "ai-interview-define-correlation-8",
        "ai-interview-what-is-a-correlation-coefficient-9"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-what-is-multicollinearity-11",
        "ai-linear-logistic-regression-how-to-detect-and-address-multicollinearity-12",
        "ai-decision-trees-and-ensemble-methods-regularization-in-decision-trees-13",
        "ai-decision-trees-and-ensemble-methods-summary-of-regularization-parameters-15",
        "ai-decision-trees-and-ensemble-methods-why-are-decision-trees-rarely-used-by-themselves-w-20"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#popular-machine-learning-models:-pros-and-cons",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-define-correlation-8",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Define Correlation",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Correlation is the degree to which two variables are linearly related. This is an important step in bi-variate data analysis. In the broadest sense correlation is actually any statistical relationship, whether causal or not, between two random variables in bivariate data.</li>\n</ul>\n<blockquote>\n  <p>An important rule to remember is that correlation doesn’t imply causation.</p>\n</blockquote>\n<p>An important rule to remember is that correlation doesn’t imply causation.</p>\n<ul>\n  <li>Let’s understand through two examples as to what it actually implies.</li>\n</ul>\n<ol>\n  <li>The consumption of ice-cream increases during the summer months. There is a strong correlation between the sales of ice-cream units. In this particular example, we see there is a causal relationship also as the extreme summers do push the sale of ice-creams up.</li>\n  <li>Ice-creams sales also have a strong correlation with shark attacks. Now as we can see very clearly here, the shark attacks are most definitely not caused due to ice-creams. So, there is no causation here.</li>\n</ol>\n<ul>\n  <li>Hence, we can understand that the correlation doesn’t ALWAYS imply causation!</li>\n</ul>",
      "contentMarkdown": "*   Correlation is the degree to which two variables are linearly related. This is an important step in bi-variate data analysis. In the broadest sense correlation is actually any statistical relationship, whether causal or not, between two random variables in bivariate data.\n\n> An important rule to remember is that correlation doesn’t imply causation.\n\nAn important rule to remember is that correlation doesn’t imply causation.\n\n*   Let’s understand through two examples as to what it actually implies.\n\n1.  The consumption of ice-cream increases during the summer months. There is a strong correlation between the sales of ice-cream units. In this particular example, we see there is a causal relationship also as the extreme summers do push the sale of ice-creams up.\n2.  Ice-creams sales also have a strong correlation with shark attacks. Now as we can see very clearly here, the shark attacks are most definitely not caused due to ice-creams. So, there is no causation here.\n\n*   Hence, we can understand that the correlation doesn’t ALWAYS imply causation!",
      "order": 8,
      "orderInChapter": 8,
      "difficulty": 2,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 169,
        "contentLength": 1179
      },
      "nextCards": [
        "ai-interview-what-is-a-correlation-coefficient-9",
        "ai-interview-explain-pearsons-correlation-coefficient-10"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#define-correlation",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-a-correlation-coefficient-9",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is a Correlation Coefficient?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>A correlation coefficient is a statistical measure of the strength of the relationship between the relative movements of two variables. The values range between -1.0 and 1.0. A correlation of -1.0 shows a perfect negative correlation, while a correlation of 1.0 shows a perfect positive correlation. A correlation of 0.0 shows no linear relationship between the movement of the two variables.</li>\n</ul>",
      "contentMarkdown": "*   A correlation coefficient is a statistical measure of the strength of the relationship between the relative movements of two variables. The values range between -1.0 and 1.0. A correlation of -1.0 shows a perfect negative correlation, while a correlation of 1.0 shows a perfect positive correlation. A correlation of 0.0 shows no linear relationship between the movement of the two variables.",
      "order": 9,
      "orderInChapter": 9,
      "difficulty": 2,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 62,
        "contentLength": 414
      },
      "nextCards": [
        "ai-interview-explain-pearsons-correlation-coefficient-10",
        "ai-interview-explain-spearmans-correlation-coefficient-11"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-a-correlation-coefficient?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-pearsons-correlation-coefficient-10",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Pearson’s Correlation Coefficient",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p><strong>Wikipedia Definition:</strong> In statistics, the Pearson correlation coefficient also referred to as Pearson’s r or the bivariate correlation is a statistic that measures the linear correlation between two variables X and Y. It has a value between +1 and −1. A value of +1 is a total positive linear correlation, 0 is no linear correlation, and −1 is a total negative linear correlation.</p>\n  </li>\n  <li>\n    <p><strong>Important Inference to keep in mind:</strong> The Pearson correlation can evaluate ONLY a linear relationship between two continuous variables (A relationship is linear only when a change in one variable is associated with a proportional change in the other variable)</p>\n  </li>\n  <li>\n    <p><strong>Example use case:</strong> We can use the Pearson correlation to evaluate whether an increase in age leads to an increase in blood pressure.</p>\n  </li>\n  <li>\n    <p>Below is an example (source: <a href=\"https://en.wikipedia.org/wiki/Correlation_and_dependence\">Wikipedia</a>) of how the Pearson correlation coefficient (r) varies with the strength and the direction of the relationship between the two variables. Note that when no linear relationship could be established (refer to graphs in the third column), the Pearson coefficient yields a value of zero.</p>\n  </li>\n</ul>\n<p><strong>Wikipedia Definition:</strong> In statistics, the Pearson correlation coefficient also referred to as Pearson’s r or the bivariate correlation is a statistic that measures the linear correlation between two variables X and Y. It has a value between +1 and −1. A value of +1 is a total positive linear correlation, 0 is no linear correlation, and −1 is a total negative linear correlation.</p>\n<p><strong>Important Inference to keep in mind:</strong> The Pearson correlation can evaluate ONLY a linear relationship between two continuous variables (A relationship is linear only when a change in one variable is associated with a proportional change in the other variable)</p>\n<p><strong>Example use case:</strong> We can use the Pearson correlation to evaluate whether an increase in age leads to an increase in blood pressure.</p>\n<p>Below is an example (source: <a href=\"https://en.wikipedia.org/wiki/Correlation_and_dependence\">Wikipedia</a>) of how the Pearson correlation coefficient (r) varies with the strength and the direction of the relationship between the two variables. Note that when no linear relationship could be established (refer to graphs in the third column), the Pearson coefficient yields a value of zero.</p>\n<p><img src=\"/primers/ai/assets/interview/coeff1.png\" alt=\"\"></p>",
      "contentMarkdown": "*   **Wikipedia Definition:** In statistics, the Pearson correlation coefficient also referred to as Pearson’s r or the bivariate correlation is a statistic that measures the linear correlation between two variables X and Y. It has a value between +1 and −1. A value of +1 is a total positive linear correlation, 0 is no linear correlation, and −1 is a total negative linear correlation.\n    \n*   **Important Inference to keep in mind:** The Pearson correlation can evaluate ONLY a linear relationship between two continuous variables (A relationship is linear only when a change in one variable is associated with a proportional change in the other variable)\n    \n*   **Example use case:** We can use the Pearson correlation to evaluate whether an increase in age leads to an increase in blood pressure.\n    \n*   Below is an example (source: [Wikipedia](https://en.wikipedia.org/wiki/Correlation_and_dependence)) of how the Pearson correlation coefficient (r) varies with the strength and the direction of the relationship between the two variables. Note that when no linear relationship could be established (refer to graphs in the third column), the Pearson coefficient yields a value of zero.\n    \n\n**Wikipedia Definition:** In statistics, the Pearson correlation coefficient also referred to as Pearson’s r or the bivariate correlation is a statistic that measures the linear correlation between two variables X and Y. It has a value between +1 and −1. A value of +1 is a total positive linear correlation, 0 is no linear correlation, and −1 is a total negative linear correlation.\n\n**Important Inference to keep in mind:** The Pearson correlation can evaluate ONLY a linear relationship between two continuous variables (A relationship is linear only when a change in one variable is associated with a proportional change in the other variable)\n\n**Example use case:** We can use the Pearson correlation to evaluate whether an increase in age leads to an increase in blood pressure.\n\nBelow is an example (source: [Wikipedia](https://en.wikipedia.org/wiki/Correlation_and_dependence)) of how the Pearson correlation coefficient (r) varies with the strength and the direction of the relationship between the two variables. Note that when no linear relationship could be established (refer to graphs in the third column), the Pearson coefficient yields a value of zero.\n\n![](/primers/ai/assets/interview/coeff1.png)",
      "order": 10,
      "orderInChapter": 10,
      "difficulty": 2,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 359,
        "contentLength": 2640
      },
      "nextCards": [
        "ai-interview-explain-spearmans-correlation-coefficient-11",
        "ai-interview-compare-pearson-and-spearman-coefficients-12"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-pearson’s-correlation-coefficient",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-spearmans-correlation-coefficient-11",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Spearman’s Correlation Coefficient",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p><strong>Wikipedia Definition:</strong> In statistics, Spearman’s rank correlation coefficient or Spearman’s ρ, named after Charles Spearman is a non-parametric measure of rank correlation (statistical dependence between the rankings of two variables). It assesses how well the relationship between two variables can be described using a monotonic function.</p>\n  </li>\n  <li>\n    <p><strong>Important Inference to keep in mind:</strong> The Spearman correlation can evaluate a monotonic relationship between two variables — Continous or Ordinal and it is based on the ranked values for each variable rather than the raw data.</p>\n  </li>\n  <li>\n    <p><strong>What is a monotonic relationship?</strong></p>\n\n    <ul>\n      <li>A monotonic relationship is a relationship that does one of the following:\n        <ul>\n          <li>As the value of one variable increases, so does the value of the other variable, OR,</li>\n          <li>As the value of one variable increases, the other variable value decreases.</li>\n        </ul>\n      </li>\n      <li>But, not exactly at a constant rate whereas in a linear relationship the rate of increase/decrease is constant.</li>\n    </ul>\n  </li>\n</ul>\n<p><strong>Wikipedia Definition:</strong> In statistics, Spearman’s rank correlation coefficient or Spearman’s ρ, named after Charles Spearman is a non-parametric measure of rank correlation (statistical dependence between the rankings of two variables). It assesses how well the relationship between two variables can be described using a monotonic function.</p>\n<p><strong>Important Inference to keep in mind:</strong> The Spearman correlation can evaluate a monotonic relationship between two variables — Continous or Ordinal and it is based on the ranked values for each variable rather than the raw data.</p>\n<p><strong>What is a monotonic relationship?</strong></p>\n<ul>\n      <li>A monotonic relationship is a relationship that does one of the following:\n        <ul>\n          <li>As the value of one variable increases, so does the value of the other variable, OR,</li>\n          <li>As the value of one variable increases, the other variable value decreases.</li>\n        </ul>\n      </li>\n      <li>But, not exactly at a constant rate whereas in a linear relationship the rate of increase/decrease is constant.</li>\n    </ul>\n<ul>\n          <li>As the value of one variable increases, so does the value of the other variable, OR,</li>\n          <li>As the value of one variable increases, the other variable value decreases.</li>\n        </ul>\n<p><img src=\"/primers/ai/assets/interview/coeff2.png\" alt=\"\"></p>\n<ul>\n  <li><strong>Example use case:</strong> Whether the order in which employees complete a test exercise is related to the number of months they have been employed or correlation between the IQ of a person with the number of hours spent in front of TV per week.</li>\n</ul>",
      "contentMarkdown": "*   **Wikipedia Definition:** In statistics, Spearman’s rank correlation coefficient or Spearman’s ρ, named after Charles Spearman is a non-parametric measure of rank correlation (statistical dependence between the rankings of two variables). It assesses how well the relationship between two variables can be described using a monotonic function.\n    \n*   **Important Inference to keep in mind:** The Spearman correlation can evaluate a monotonic relationship between two variables — Continous or Ordinal and it is based on the ranked values for each variable rather than the raw data.\n    \n*   **What is a monotonic relationship?**\n    \n    *   A monotonic relationship is a relationship that does one of the following:\n        *   As the value of one variable increases, so does the value of the other variable, OR,\n        *   As the value of one variable increases, the other variable value decreases.\n    *   But, not exactly at a constant rate whereas in a linear relationship the rate of increase/decrease is constant.\n\n**Wikipedia Definition:** In statistics, Spearman’s rank correlation coefficient or Spearman’s ρ, named after Charles Spearman is a non-parametric measure of rank correlation (statistical dependence between the rankings of two variables). It assesses how well the relationship between two variables can be described using a monotonic function.\n\n**Important Inference to keep in mind:** The Spearman correlation can evaluate a monotonic relationship between two variables — Continous or Ordinal and it is based on the ranked values for each variable rather than the raw data.\n\n**What is a monotonic relationship?**\n\n*   A monotonic relationship is a relationship that does one of the following:\n    *   As the value of one variable increases, so does the value of the other variable, OR,\n    *   As the value of one variable increases, the other variable value decreases.\n*   But, not exactly at a constant rate whereas in a linear relationship the rate of increase/decrease is constant.\n\n*   As the value of one variable increases, so does the value of the other variable, OR,\n*   As the value of one variable increases, the other variable value decreases.\n\n![](/primers/ai/assets/interview/coeff2.png)\n\n*   **Example use case:** Whether the order in which employees complete a test exercise is related to the number of months they have been employed or correlation between the IQ of a person with the number of hours spent in front of TV per week.",
      "order": 11,
      "orderInChapter": 11,
      "difficulty": 2,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 379,
        "contentLength": 2906
      },
      "nextCards": [
        "ai-interview-compare-pearson-and-spearman-coefficients-12",
        "ai-interview-how-to-choose-between-pearson-and-spearman-correla-13"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-spearman’s-correlation-coefficient",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-compare-pearson-and-spearman-coefficients-12",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Compare Pearson and Spearman Coefficients",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The fundamental difference between the two correlation coefficients is that the Pearson coefficient works with a linear relationship between the two variables whereas the Spearman Coefficient works with monotonic relationships as well.</li>\n  <li>One more difference is that Pearson works with raw data values of the variables whereas Spearman works with rank-ordered variables.</li>\n  <li>Now, if we feel that a scatterplot is visually indicating a “might be monotonic, might be linear” relationship, our best bet would be to apply Spearman and not Pearson. No harm would be done by switching to Spearman even if the data turned out to be perfectly linear. But, if it’s not exactly linear and we use Pearson’s coefficient then we’ll miss out on the information that Spearman could capture.</li>\n  <li>\n    <p>Let’s look at some examples (source: <a href=\"https://support.minitab.com/en-us/minitab-express/1/help-and-how-to/modeling-statistics/regression/supporting-topics/basics/a-comparison-of-the-pearson-and-spearman-correlation-methods/#:~:text=The%20Pearson%20correlation%20evaluates%20the%20linear%20relationship%20between%20two%20continuous%20variables.&amp;text=The%20Spearman%20correlation%20coefficient%20is,evaluate%20relationships%20involving%20ordinal%20variables.\">A comparison of the Pearson and Spearman correlation methods</a>):</p>\n  </li>\n  <li>Pearson = +1, Spearman = +1:</li>\n</ul>\n<p>Let’s look at some examples (source: <a href=\"https://support.minitab.com/en-us/minitab-express/1/help-and-how-to/modeling-statistics/regression/supporting-topics/basics/a-comparison-of-the-pearson-and-spearman-correlation-methods/#:~:text=The%20Pearson%20correlation%20evaluates%20the%20linear%20relationship%20between%20two%20continuous%20variables.&amp;text=The%20Spearman%20correlation%20coefficient%20is,evaluate%20relationships%20involving%20ordinal%20variables.\">A comparison of the Pearson and Spearman correlation methods</a>):</p>\n<p><img src=\"/primers/ai/assets/interview/coeff3.png\" alt=\"\"></p>\n<ul>\n  <li>Pearson = +0.851, Spearman = +1 (This is a monotonically increasing relationship, thus Spearman is exactly 1)</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/coeff4.png\" alt=\"\"></p>\n<ul>\n  <li>Pearson = −0.093, Spearman = −0.093</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/coeff5.png\" alt=\"\"></p>\n<ul>\n  <li>Pearson = −1, Spearman = −1</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/coeff6.png\" alt=\"\"></p>\n<ul>\n  <li>Pearson = −0.799, Spearman = −1 (This is a monotonically decreasing relationship, thus Spearman is exactly 1)</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/coeff7.png\" alt=\"\"></p>\n<ul>\n  <li>Note that both of these coefficients cannot capture any other kind of non-linear relationships. Thus, if a scatterplot indicates a relationship that cannot be expressed by a linear or monotonic function, then both of these coefficients must not be used to determine the strength of the relationship between the variables.</li>\n</ul>",
      "contentMarkdown": "*   The fundamental difference between the two correlation coefficients is that the Pearson coefficient works with a linear relationship between the two variables whereas the Spearman Coefficient works with monotonic relationships as well.\n*   One more difference is that Pearson works with raw data values of the variables whereas Spearman works with rank-ordered variables.\n*   Now, if we feel that a scatterplot is visually indicating a “might be monotonic, might be linear” relationship, our best bet would be to apply Spearman and not Pearson. No harm would be done by switching to Spearman even if the data turned out to be perfectly linear. But, if it’s not exactly linear and we use Pearson’s coefficient then we’ll miss out on the information that Spearman could capture.\n*   Let’s look at some examples (source: [A comparison of the Pearson and Spearman correlation methods](https://support.minitab.com/en-us/minitab-express/1/help-and-how-to/modeling-statistics/regression/supporting-topics/basics/a-comparison-of-the-pearson-and-spearman-correlation-methods/#:~:text=The%20Pearson%20correlation%20evaluates%20the%20linear%20relationship%20between%20two%20continuous%20variables.&text=The%20Spearman%20correlation%20coefficient%20is,evaluate%20relationships%20involving%20ordinal%20variables.)):\n    \n*   Pearson = +1, Spearman = +1:\n\nLet’s look at some examples (source: [A comparison of the Pearson and Spearman correlation methods](https://support.minitab.com/en-us/minitab-express/1/help-and-how-to/modeling-statistics/regression/supporting-topics/basics/a-comparison-of-the-pearson-and-spearman-correlation-methods/#:~:text=The%20Pearson%20correlation%20evaluates%20the%20linear%20relationship%20between%20two%20continuous%20variables.&text=The%20Spearman%20correlation%20coefficient%20is,evaluate%20relationships%20involving%20ordinal%20variables.)):\n\n![](/primers/ai/assets/interview/coeff3.png)\n\n*   Pearson = +0.851, Spearman = +1 (This is a monotonically increasing relationship, thus Spearman is exactly 1)\n\n![](/primers/ai/assets/interview/coeff4.png)\n\n*   Pearson = −0.093, Spearman = −0.093\n\n![](/primers/ai/assets/interview/coeff5.png)\n\n*   Pearson = −1, Spearman = −1\n\n![](/primers/ai/assets/interview/coeff6.png)\n\n*   Pearson = −0.799, Spearman = −1 (This is a monotonically decreasing relationship, thus Spearman is exactly 1)\n\n![](/primers/ai/assets/interview/coeff7.png)\n\n*   Note that both of these coefficients cannot capture any other kind of non-linear relationships. Thus, if a scatterplot indicates a relationship that cannot be expressed by a linear or monotonic function, then both of these coefficients must not be used to determine the strength of the relationship between the variables.",
      "order": 12,
      "orderInChapter": 12,
      "difficulty": 2,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 269,
        "contentLength": 3005
      },
      "nextCards": [
        "ai-interview-how-to-choose-between-pearson-and-spearman-correla-13",
        "ai-interview-explain-the-central-limit-theorem-and-give-example-14"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#compare-pearson-and-spearman-coefficients",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-to-choose-between-pearson-and-spearman-correla-13",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How to Choose Between Pearson and Spearman Correlation?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>If you want to explore your data it is best to compute both, since the relation between the Spearman (S) and Pearson (P) correlations will give some information. Briefly, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-24-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-156\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-157\"><span class=\"mi\" id=\"MathJax-Span-158\" style=\"font-family: STIXGeneral-Italic;\">S<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-24\">S</script> is computed on ranks and so depicts monotonic relationships while <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-25-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-159\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-160\"><span class=\"mi\" id=\"MathJax-Span-161\" style=\"font-family: STIXGeneral-Italic;\">P</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-25\">P</script> is on true values and depicts linear relationships.</p>\n  </li>\n  <li>\n    <p>As an example, if you set:</p>\n  </li>\n</ul>\n<p>If you want to explore your data it is best to compute both, since the relation between the Spearman (S) and Pearson (P) correlations will give some information. Briefly, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-24-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-156\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-157\"><span class=\"mi\" id=\"MathJax-Span-158\" style=\"font-family: STIXGeneral-Italic;\">S<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-24\">S</script> is computed on ranks and so depicts monotonic relationships while <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-25-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-159\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-160\"><span class=\"mi\" id=\"MathJax-Span-161\" style=\"font-family: STIXGeneral-Italic;\">P</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-25\">P</script> is on true values and depicts linear relationships.</p>\n<p>As an example, if you set:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code0\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code0\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">100</span><span class=\"p\">);</span>  \n<span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>                         <span class=\"o\">%</span> <span class=\"n\">then</span><span class=\"p\">,</span>\n<span class=\"n\">corr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"s\">'type'</span><span class=\"p\">,</span><span class=\"s\">'Spearman'</span><span class=\"p\">);</span>      <span class=\"o\">%</span> <span class=\"n\">will</span> <span class=\"n\">equal</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">and</span> \n<span class=\"n\">corr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"s\">'type'</span><span class=\"p\">,</span><span class=\"s\">'Pearson'</span><span class=\"p\">);</span>       <span class=\"o\">%</span> <span class=\"n\">will</span> <span class=\"n\">be</span> <span class=\"n\">about</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"mf\">0.25</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code0\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code0\"><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">100</span><span class=\"p\">);</span>  \n<span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>                         <span class=\"o\">%</span> <span class=\"n\">then</span><span class=\"p\">,</span>\n<span class=\"n\">corr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"s\">'type'</span><span class=\"p\">,</span><span class=\"s\">'Spearman'</span><span class=\"p\">);</span>      <span class=\"o\">%</span> <span class=\"n\">will</span> <span class=\"n\">equal</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"ow\">and</span> \n<span class=\"n\">corr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"s\">'type'</span><span class=\"p\">,</span><span class=\"s\">'Pearson'</span><span class=\"p\">);</span>       <span class=\"o\">%</span> <span class=\"n\">will</span> <span class=\"n\">be</span> <span class=\"n\">about</span> <span class=\"n\">equal</span> <span class=\"n\">to</span> <span class=\"mf\">0.25</span>\n</code></pre>\n<ul>\n  <li>This is because <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-26-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-162\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-163\"><span class=\"mi\" id=\"MathJax-Span-164\" style=\"font-family: STIXGeneral-Italic;\">y</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-26\">y</script> increases monotonically with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-27-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-165\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-166\"><span class=\"mi\" id=\"MathJax-Span-167\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-27\">x</script> so the Spearman correlation is perfect, but not linearly, so the Pearson correlation is imperfect.</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code1\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code1\"><span class=\"n\">corr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"s\">'type'</span><span class=\"p\">,</span><span class=\"s\">'Pearson'</span><span class=\"p\">);</span>  <span class=\"o\">%</span> <span class=\"n\">will</span> <span class=\"n\">equal</span> <span class=\"mi\">1</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code1\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code1\"><span class=\"n\">corr</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"s\">'type'</span><span class=\"p\">,</span><span class=\"s\">'Pearson'</span><span class=\"p\">);</span>  <span class=\"o\">%</span> <span class=\"n\">will</span> <span class=\"n\">equal</span> <span class=\"mi\">1</span>\n</code></pre>\n<ul>\n  <li>Doing both is interesting because if you have <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-28-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi><mo>&amp;gt;</mo><mi>P</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-168\" style=\"width: 2.763em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.294em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.29em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-169\"><span class=\"mi\" id=\"MathJax-Span-170\" style=\"font-family: STIXGeneral-Italic;\">S<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-171\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">&gt;</span><span class=\"mi\" id=\"MathJax-Span-172\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">P</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>S</mi><mo>&gt;</mo><mi>P</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-28\">S > P</script>, that means that you have a correlation that is monotonic but not linear. Since it is good to have linearity in statistics (it is easier) you can try to apply a transformation on <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-29-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-173\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-174\"><span class=\"mi\" id=\"MathJax-Span-175\" style=\"font-family: STIXGeneral-Italic;\">y</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-29\">y</script> (such a log).</li>\n</ul>",
      "contentMarkdown": "*   If you want to explore your data it is best to compute both, since the relation between the Spearman (S) and Pearson (P) correlations will give some information. Briefly, SSS is computed on ranks and so depicts monotonic relationships while PPP is on true values and depicts linear relationships.\n    \n*   As an example, if you set:\n    \n\nIf you want to explore your data it is best to compute both, since the relation between the Spearman (S) and Pearson (P) correlations will give some information. Briefly, SSS is computed on ranks and so depicts monotonic relationships while PPP is on true values and depicts linear relationships.\n\nAs an example, if you set:\n\n![](https://aman.ai/images/copy.png)\n\n`x=(1:100);   y=exp(x);                         % then, corr(x,y,'type','Spearman');      % will equal 1, and  corr(x,y,'type','Pearson');       % will be about equal to 0.25`\n\n![](https://aman.ai/images/copy.png)\n\n`x=(1:100);   y=exp(x);                         % then, corr(x,y,'type','Spearman');      % will equal 1, and  corr(x,y,'type','Pearson');       % will be about equal to 0.25`\n\n*   This is because yyy increases monotonically with xxx so the Spearman correlation is perfect, but not linearly, so the Pearson correlation is imperfect.\n\n![](https://aman.ai/images/copy.png)\n\n`corr(x,log(y),'type','Pearson');  % will equal 1`\n\n![](https://aman.ai/images/copy.png)\n\n`corr(x,log(y),'type','Pearson');  % will equal 1`\n\n*   Doing both is interesting because if you have S\\>PS\\>PS > P, that means that you have a correlation that is monotonic but not linear. Since it is good to have linearity in statistics (it is easier) you can try to apply a transformation on yyy (such a log).",
      "order": 13,
      "orderInChapter": 13,
      "difficulty": 3,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 235,
        "contentLength": 15979
      },
      "nextCards": [
        "ai-interview-explain-the-central-limit-theorem-and-give-example-14",
        "ai-interview-describe-the-motivation-behind-random-forests-and--15"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-to-choose-between-pearson-and-spearman-correlation?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-central-limit-theorem-and-give-example-14",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain the Central Limit Theorem and Give Examples of When You Can Use It in a Real-world Problem?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The center limit theorem states that if any random variable, regardless of the distribution, is sampled a large enough times, the sample mean will be approximately normally distributed. This allows for studying the properties of any statistical distribution as long as there is a large enough sample size.</li>\n</ul>",
      "contentMarkdown": "*   The center limit theorem states that if any random variable, regardless of the distribution, is sampled a large enough times, the sample mean will be approximately normally distributed. This allows for studying the properties of any statistical distribution as long as there is a large enough sample size.",
      "order": 14,
      "orderInChapter": 14,
      "difficulty": 2,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 49,
        "contentLength": 327
      },
      "nextCards": [
        "ai-interview-describe-the-motivation-behind-random-forests-and--15",
        "ai-interview-mention-three-ways-to-make-your-model-robust-to-ou-16"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-central-limit-theorem-and-give-examples-of-when-you-can-use-it-in-a-real-world-problem?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-describe-the-motivation-behind-random-forests-and--15",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Describe the Motivation Behind Random Forests and Mention Two Reasons Why They are Better Than Individual Decision Trees?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The motivation behind random forest or ensemble models in general in layman’s terms, Let’s say we have a question/problem to solve we bring 100 people and ask each of them the question/problem and record their solution. Next, we prepare a solution which is a combination/ a mixture of all the solutions provided by these 100 people. We will find that the aggregated solution will be close to the actual solution. This is known as the “Wisdom of the crowd” and this is the motivation behind Random Forests. We take weak learners (ML models) specifically, Decision Trees in the case of Random Forest &amp; aggregate their results to get good predictions by removing dependency on a particular set of features. In regression, we take the mean and for Classification, we take the majority vote of the classifiers.</li>\n  <li>A random forest is generally better than a decision tree, however, you should note that no algorithm is better than the other it will always depend on the use case &amp; the dataset [Check the No Free Lunch Theorem in the first comment]. Reasons why random forests allow for stronger prediction than individual decision trees:\n  1) Decision trees are prone to overfit whereas random forest generalizes better on unseen data as it is using randomness in feature selection as well as during sampling of the data. Therefore, random forests have lower variance compared to that of the decision tree without substantially increasing the error due to bias.\n  2) Generally, ensemble models like Random Forest perform better as they are aggregations of various models (Decision Trees in the case of Random Forest), using the concept of the “Wisdom of the crowd.”</li>\n</ul>",
      "contentMarkdown": "*   The motivation behind random forest or ensemble models in general in layman’s terms, Let’s say we have a question/problem to solve we bring 100 people and ask each of them the question/problem and record their solution. Next, we prepare a solution which is a combination/ a mixture of all the solutions provided by these 100 people. We will find that the aggregated solution will be close to the actual solution. This is known as the “Wisdom of the crowd” and this is the motivation behind Random Forests. We take weak learners (ML models) specifically, Decision Trees in the case of Random Forest & aggregate their results to get good predictions by removing dependency on a particular set of features. In regression, we take the mean and for Classification, we take the majority vote of the classifiers.\n*   A random forest is generally better than a decision tree, however, you should note that no algorithm is better than the other it will always depend on the use case & the dataset \\[Check the No Free Lunch Theorem in the first comment\\]. Reasons why random forests allow for stronger prediction than individual decision trees: 1) Decision trees are prone to overfit whereas random forest generalizes better on unseen data as it is using randomness in feature selection as well as during sampling of the data. Therefore, random forests have lower variance compared to that of the decision tree without substantially increasing the error due to bias. 2) Generally, ensemble models like Random Forest perform better as they are aggregations of various models (Decision Trees in the case of Random Forest), using the concept of the “Wisdom of the crowd.”",
      "order": 15,
      "orderInChapter": 15,
      "difficulty": 2,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 278,
        "contentLength": 1697
      },
      "nextCards": [
        "ai-interview-mention-three-ways-to-make-your-model-robust-to-ou-16",
        "ai-interview-given-two-arrays-write-a-python-function-to-return-17"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#describe-the-motivation-behind-random-forests-and-mention-two-reasons-why-they-are-better-than-individual-decision-trees?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-mention-three-ways-to-make-your-model-robust-to-ou-16",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Mention Three Ways to Make Your Model Robust to Outliers?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ol>\n  <li>\n    <p>Investigating the outliers is always the first step in understanding how to treat them. After you understand the nature of why the outliers occurred you can apply one of the several methods mentioned below.</p>\n  </li>\n  <li>\n    <p>Add regularization that will reduce variance, for example, L1 or L2 regularization.</p>\n  </li>\n  <li>\n    <p>Use tree-based models (random forest, gradient boosting ) that are generally less affected by outliers.</p>\n  </li>\n  <li>\n    <p>Winsorize the data. Winsorizing or winsorization is the transformation of statistics by limiting extreme values in the statistical data to reduce the effect of possibly spurious outliers. In numerical data, if the distribution is almost normal using the Z-score we can detect the outliers and treat them by either removing or capping them with some value.\nIf the distribution is skewed using IQR we can detect and treat it by again either removing or capping it with some value. In categorical data check for value_count in the percentage if we have very few records from some category, either we can remove it or can cap it with some categorical value like others.</p>\n  </li>\n  <li>\n    <p>Transform the data, for example, you do a log transformation when the response variable follows an exponential distribution or is right-skewed.</p>\n  </li>\n  <li>\n    <p>Use more robust error metrics such as MAE or Huber loss instead of MSE.</p>\n  </li>\n  <li>\n    <p>Remove the outliers, only do this if you are certain that the outliers are true anomalies that are not worth adding to your model. This should be your last consideration since dropping them means losing information.</p>\n  </li>\n</ol>\n<p>Investigating the outliers is always the first step in understanding how to treat them. After you understand the nature of why the outliers occurred you can apply one of the several methods mentioned below.</p>\n<p>Add regularization that will reduce variance, for example, L1 or L2 regularization.</p>\n<p>Use tree-based models (random forest, gradient boosting ) that are generally less affected by outliers.</p>\n<p>Winsorize the data. Winsorizing or winsorization is the transformation of statistics by limiting extreme values in the statistical data to reduce the effect of possibly spurious outliers. In numerical data, if the distribution is almost normal using the Z-score we can detect the outliers and treat them by either removing or capping them with some value.\nIf the distribution is skewed using IQR we can detect and treat it by again either removing or capping it with some value. In categorical data check for value_count in the percentage if we have very few records from some category, either we can remove it or can cap it with some categorical value like others.</p>\n<p>Transform the data, for example, you do a log transformation when the response variable follows an exponential distribution or is right-skewed.</p>\n<p>Use more robust error metrics such as MAE or Huber loss instead of MSE.</p>\n<p>Remove the outliers, only do this if you are certain that the outliers are true anomalies that are not worth adding to your model. This should be your last consideration since dropping them means losing information.</p>",
      "contentMarkdown": "1.  Investigating the outliers is always the first step in understanding how to treat them. After you understand the nature of why the outliers occurred you can apply one of the several methods mentioned below.\n    \n2.  Add regularization that will reduce variance, for example, L1 or L2 regularization.\n    \n3.  Use tree-based models (random forest, gradient boosting ) that are generally less affected by outliers.\n    \n4.  Winsorize the data. Winsorizing or winsorization is the transformation of statistics by limiting extreme values in the statistical data to reduce the effect of possibly spurious outliers. In numerical data, if the distribution is almost normal using the Z-score we can detect the outliers and treat them by either removing or capping them with some value. If the distribution is skewed using IQR we can detect and treat it by again either removing or capping it with some value. In categorical data check for value\\_count in the percentage if we have very few records from some category, either we can remove it or can cap it with some categorical value like others.\n    \n5.  Transform the data, for example, you do a log transformation when the response variable follows an exponential distribution or is right-skewed.\n    \n6.  Use more robust error metrics such as MAE or Huber loss instead of MSE.\n    \n7.  Remove the outliers, only do this if you are certain that the outliers are true anomalies that are not worth adding to your model. This should be your last consideration since dropping them means losing information.\n    \n\nInvestigating the outliers is always the first step in understanding how to treat them. After you understand the nature of why the outliers occurred you can apply one of the several methods mentioned below.\n\nAdd regularization that will reduce variance, for example, L1 or L2 regularization.\n\nUse tree-based models (random forest, gradient boosting ) that are generally less affected by outliers.\n\nWinsorize the data. Winsorizing or winsorization is the transformation of statistics by limiting extreme values in the statistical data to reduce the effect of possibly spurious outliers. In numerical data, if the distribution is almost normal using the Z-score we can detect the outliers and treat them by either removing or capping them with some value. If the distribution is skewed using IQR we can detect and treat it by again either removing or capping it with some value. In categorical data check for value\\_count in the percentage if we have very few records from some category, either we can remove it or can cap it with some categorical value like others.\n\nTransform the data, for example, you do a log transformation when the response variable follows an exponential distribution or is right-skewed.\n\nUse more robust error metrics such as MAE or Huber loss instead of MSE.\n\nRemove the outliers, only do this if you are certain that the outliers are true anomalies that are not worth adding to your model. This should be your last consideration since dropping them means losing information.",
      "order": 16,
      "orderInChapter": 16,
      "difficulty": 3,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 495,
        "contentLength": 3227
      },
      "nextCards": [
        "ai-interview-given-two-arrays-write-a-python-function-to-return-17",
        "ai-interview-given-an-array-find-all-the-duplicates-in-this-arr-18"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-what-is-multicollinearity-11",
        "ai-linear-logistic-regression-how-to-detect-and-address-multicollinearity-12",
        "ai-decision-trees-and-ensemble-methods-regularization-in-decision-trees-13",
        "ai-decision-trees-and-ensemble-methods-summary-of-regularization-parameters-15",
        "ai-decision-trees-and-ensemble-methods-why-are-decision-trees-rarely-used-by-themselves-w-20"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#mention-three-ways-to-make-your-model-robust-to-outliers?",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-given-two-arrays-write-a-python-function-to-return-17",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Given Two Arrays, Write a Python Function to Return the Intersection of the Two. for Example, X = [1,5,9,0] and Y = [3,0,2,9] It Should Return [9,0]",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>A1 (The most repeated one):</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code2\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code2\"><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">).</span><span class=\"n\">intersect</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">))</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code2\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code2\"><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">).</span><span class=\"n\">intersect</span><span class=\"p\">(</span><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">))</span>\n</code></pre>\n<ul>\n  <li>A2:</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code3\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code3\"><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code3\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code3\"><span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">Y</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>\n    <p>Using sets is a very good way to do it since it utilizes a hash map implementation underneath it.</p>\n  </li>\n  <li>\n    <p>A3:</p>\n  </li>\n</ul>\n<p>Using sets is a very good way to do it since it utilizes a hash map implementation underneath it.</p>\n<p>A3:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code4\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code4\"><span class=\"k\">def</span> <span class=\"nf\">common_func</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span><span class=\"p\">):</span>\n<span class=\"n\">Z</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">X</span><span class=\"p\">:</span>\n<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"n\">Y</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">i</span><span class=\"o\">==</span><span class=\"n\">j</span> <span class=\"ow\">and</span> <span class=\"n\">i</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">Z</span><span class=\"p\">:</span>\n<span class=\"n\">Z</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"k\">return</span> <span class=\"n\">Z</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code4\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code4\"><span class=\"k\">def</span> <span class=\"nf\">common_func</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span><span class=\"p\">):</span>\n<span class=\"n\">Z</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">X</span><span class=\"p\">:</span>\n<span class=\"k\">for</span> <span class=\"n\">j</span> <span class=\"ow\">in</span> <span class=\"n\">Y</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">i</span><span class=\"o\">==</span><span class=\"n\">j</span> <span class=\"ow\">and</span> <span class=\"n\">i</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">Z</span><span class=\"p\">:</span>\n<span class=\"n\">Z</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"k\">return</span> <span class=\"n\">Z</span>\n</code></pre>\n<ul>\n  <li>This is also a simple way to do it, however, it leads to the time complexity of O(N*M) so it is better to use sets.</li>\n  <li>Some other answers were mentioned that will work for the mentioned case but will return duplicates for other cases, for example, if X = [1,0,9,9] and Y = [3,0,9,9] it will return [0, 9, 9] not [0,9].</li>\n</ul>\n<p>A1:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code5\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code5\"><span class=\"n\">Res</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">x</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">Y</span><span class=\"p\">]</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code5\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code5\"><span class=\"n\">Res</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">x</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">Y</span><span class=\"p\">]</span>\n</code></pre>\n<p>A2:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code6\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code6\"><span class=\"n\">Z</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">value</span> <span class=\"k\">for</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">X</span> <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">Y</span><span class=\"p\">]</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code6\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code6\"><span class=\"n\">Z</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">value</span> <span class=\"k\">for</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">X</span> <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">Y</span><span class=\"p\">]</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">Z</span><span class=\"p\">)</span>\n</code></pre>\n<p>A3:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code7\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code7\"><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"k\">for</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">y</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"p\">:</span>\n<span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">intersection</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"p\">:</span>\n<span class=\"n\">intersection</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">intersection</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code7\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code7\"><span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"k\">for</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">y</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"p\">:</span>\n<span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">value</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">intersection</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">x</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">d</span><span class=\"p\">:</span>\n<span class=\"n\">intersection</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">intersection</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>The time complexity for this is O(n + m) and the space complexity is O(m), the problem of it is that it returns duplicates.</li>\n</ul>",
      "contentMarkdown": "*   A1 (The most repeated one):\n\n![](https://aman.ai/images/copy.png)\n\n`set(X).intersect(set(Y))`\n\n![](https://aman.ai/images/copy.png)\n\n`set(X).intersect(set(Y))`\n\n*   A2:\n\n![](https://aman.ai/images/copy.png)\n\n`set(X) & set(Y)`\n\n![](https://aman.ai/images/copy.png)\n\n`set(X) & set(Y)`\n\n*   Using sets is a very good way to do it since it utilizes a hash map implementation underneath it.\n    \n*   A3:\n    \n\nUsing sets is a very good way to do it since it utilizes a hash map implementation underneath it.\n\nA3:\n\n![](https://aman.ai/images/copy.png)\n\n`def common_func(X, Y): Z=[] for i in X: for j in Y: if i==j and i not in Z: Z.append(i) return Z`\n\n![](https://aman.ai/images/copy.png)\n\n`def common_func(X, Y): Z=[] for i in X: for j in Y: if i==j and i not in Z: Z.append(i) return Z`\n\n*   This is also a simple way to do it, however, it leads to the time complexity of O(N\\*M) so it is better to use sets.\n*   Some other answers were mentioned that will work for the mentioned case but will return duplicates for other cases, for example, if X = \\[1,0,9,9\\] and Y = \\[3,0,9,9\\] it will return \\[0, 9, 9\\] not \\[0,9\\].\n\nA1:\n\n![](https://aman.ai/images/copy.png)\n\n`Res=[i for i in x if i in Y]`\n\n![](https://aman.ai/images/copy.png)\n\n`Res=[i for i in x if i in Y]`\n\nA2:\n\n![](https://aman.ai/images/copy.png)\n\n`Z = [value for value in X if value in Y] print(Z)`\n\n![](https://aman.ai/images/copy.png)\n\n`Z = [value for value in X if value in Y] print(Z)`\n\nA3:\n\n![](https://aman.ai/images/copy.png)\n\n`d = {} for value in y: if value not in d: d[value] = 1 intersection = [] for value in x: if value in d: intersection.append(value)  print(intersection)`\n\n![](https://aman.ai/images/copy.png)\n\n`d = {} for value in y: if value not in d: d[value] = 1 intersection = [] for value in x: if value in d: intersection.append(value)  print(intersection)`\n\n*   The time complexity for this is O(n + m) and the space complexity is O(m), the problem of it is that it returns duplicates.",
      "order": 17,
      "orderInChapter": 17,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 304,
        "contentLength": 11586
      },
      "nextCards": [
        "ai-interview-given-an-array-find-all-the-duplicates-in-this-arr-18",
        "ai-interview-what-are-the-differences-and-similarities-between--19"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#given-two-arrays,-write-a-python-function-to-return-the-intersection-of-the-two.-for-example,-x-=-[1,5,9,0]-and-y-=-[3,0,2,9]-it-should-return-[9,0]",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-given-an-array-find-all-the-duplicates-in-this-arr-18",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Given an Array, Find All the Duplicates in This Array for Example: Input: [1,2,3,1,3,6,5] Output: [1,3]",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Approach 1:</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code8\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code8\"><span class=\"n\">set1</span><span class=\"o\">=</span><span class=\"nb\">set</span><span class=\"p\">()</span>\n<span class=\"n\">res</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">set1</span><span class=\"p\">:</span>\n<span class=\"n\">res</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n<span class=\"n\">set1</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code8\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code8\"><span class=\"n\">set1</span><span class=\"o\">=</span><span class=\"nb\">set</span><span class=\"p\">()</span>\n<span class=\"n\">res</span><span class=\"o\">=</span><span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">:</span>\n<span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">set1</span><span class=\"p\">:</span>\n<span class=\"n\">res</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n<span class=\"n\">set1</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>Approach 2:</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code9\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code9\"><span class=\"n\">arr1</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"n\">nums</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">counts</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">arr1</span><span class=\"p\">,</span><span class=\"n\">return_index</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">,</span><span class=\"n\">return_counts</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">counts</span><span class=\"p\">)</span>\n<span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">counts</span><span class=\"o\">!=</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code9\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code9\"><span class=\"n\">arr1</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"n\">nums</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">counts</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"p\">.</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">arr1</span><span class=\"p\">,</span><span class=\"n\">return_index</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">,</span><span class=\"n\">return_counts</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">counts</span><span class=\"p\">)</span>\n<span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">counts</span><span class=\"o\">!=</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</code></pre>\n<ul>\n  <li>Approach 3:</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code10\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code10\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"n\">j</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">).</span><span class=\"n\">items</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">v</span><span class=\"o\">&gt;</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code10\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code10\"><span class=\"n\">a</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n<span class=\"n\">j</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"n\">v</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">).</span><span class=\"n\">items</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"n\">v</span><span class=\"o\">&gt;</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n</code></pre>\n<p>Approach 4:\nUse map (dict), and get the frequency count of each element.\nIterate the map, and print all keys whose values are &gt; 1.</p>",
      "contentMarkdown": "*   Approach 1:\n\n![](https://aman.ai/images/copy.png)\n\n`set1=set() res=[] for i in list: if i in set1: res.append(i) else: set1.add(i) print(res)`\n\n![](https://aman.ai/images/copy.png)\n\n`set1=set() res=[] for i in list: if i in set1: res.append(i) else: set1.add(i) print(res)`\n\n*   Approach 2:\n\n![](https://aman.ai/images/copy.png)\n\n`arr1=np.array([1,2,3,1,3,6,5]) nums,index,counts=np.unique(arr1,return_index=True,return_counts=True) print(nums,index,counts) nums[counts!=1]`\n\n![](https://aman.ai/images/copy.png)\n\n`arr1=np.array([1,2,3,1,3,6,5]) nums,index,counts=np.unique(arr1,return_index=True,return_counts=True) print(nums,index,counts) nums[counts!=1]`\n\n*   Approach 3:\n\n![](https://aman.ai/images/copy.png)\n\n`a=[1,2,3,1,3,6,5] j=[i for (i,v) in Counter(a).items() if v>1]`\n\n![](https://aman.ai/images/copy.png)\n\n`a=[1,2,3,1,3,6,5] j=[i for (i,v) in Counter(a).items() if v>1]`\n\nApproach 4: Use map (dict), and get the frequency count of each element. Iterate the map, and print all keys whose values are > 1.",
      "order": 18,
      "orderInChapter": 18,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 92,
        "contentLength": 8746
      },
      "nextCards": [
        "ai-interview-what-are-the-differences-and-similarities-between--19",
        "ai-interview-small-file-and-big-file-problem-in-big-data-20"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#given-an-array,-find-all-the-duplicates-in-this-array-for-example:-input:-[1,2,3,1,3,6,5]-output:-[1,3]",
      "scrapedAt": "2025-12-28T11:58:12.835Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-differences-and-similarities-between--19",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Differences and Similarities Between Gradient Boosting and Random Forest? and What are the Advantage and Disadvantages of Each When Compared to Each Other?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li><strong>Similarities:</strong>\n    <ol>\n      <li>Both these algorithms are decision-tree based algorithms</li>\n      <li>Both these algorithms are ensemble algorithms</li>\n      <li>Both are flexible models and do not need much data preprocessing.</li>\n    </ol>\n  </li>\n  <li><strong>Differences:</strong>\n    <ol>\n      <li>Random forests (Uses Bagging): Trees are arranged in a parallel fashion where the results of all trees are aggregated at the end through averaging or majority vote. Every tree is constructed independently of the other trees</li>\n      <li>Gradient boosting (Uses Boosting): Trees are arranged in a series sequential fashion where every tree tries to minimize the error of the previous tree. Every tree is dependent on the previous tree.</li>\n    </ol>\n  </li>\n  <li><strong>Advantages of gradient boosting over random forests:</strong>\n    <ol>\n      <li>Gradient boosting can be more accurate than Random forests because we train them to minimize the previous tree’s error.</li>\n      <li>Gradient boosting is capable of capturing complex patterns in the data.</li>\n      <li>Gradient boosting is better than random forest when used on unbalanced data sets.</li>\n    </ol>\n  </li>\n  <li><strong>Advantages of random forests over gradient boosting :</strong>\n    <ol>\n      <li>Random forest is less prone to overfit as compared to gradient boosting.</li>\n      <li>Random forest has faster training as trees are created parallelly &amp; independent of each other.</li>\n    </ol>\n  </li>\n  <li><strong>The disadvantage of GB over RF:</strong>\n    <ol>\n      <li>Gradient boosting is more prone to overfitting than random forests due to their focus on mistakes during training iterations and the lack of independence in tree building.</li>\n      <li>If the data is noisy the boosted trees might overfit and start modeling the noise.</li>\n      <li>In GB training might take longer because every tree is created sequentially.</li>\n      <li>Tuning the hyperparameters of gradient boosting is harder than those of random forest.</li>\n    </ol>\n  </li>\n</ul>\n<ol>\n      <li>Both these algorithms are decision-tree based algorithms</li>\n      <li>Both these algorithms are ensemble algorithms</li>\n      <li>Both are flexible models and do not need much data preprocessing.</li>\n    </ol>\n<ol>\n      <li>Random forests (Uses Bagging): Trees are arranged in a parallel fashion where the results of all trees are aggregated at the end through averaging or majority vote. Every tree is constructed independently of the other trees</li>\n      <li>Gradient boosting (Uses Boosting): Trees are arranged in a series sequential fashion where every tree tries to minimize the error of the previous tree. Every tree is dependent on the previous tree.</li>\n    </ol>\n<ol>\n      <li>Gradient boosting can be more accurate than Random forests because we train them to minimize the previous tree’s error.</li>\n      <li>Gradient boosting is capable of capturing complex patterns in the data.</li>\n      <li>Gradient boosting is better than random forest when used on unbalanced data sets.</li>\n    </ol>\n<ol>\n      <li>Random forest is less prone to overfit as compared to gradient boosting.</li>\n      <li>Random forest has faster training as trees are created parallelly &amp; independent of each other.</li>\n    </ol>\n<ol>\n      <li>Gradient boosting is more prone to overfitting than random forests due to their focus on mistakes during training iterations and the lack of independence in tree building.</li>\n      <li>If the data is noisy the boosted trees might overfit and start modeling the noise.</li>\n      <li>In GB training might take longer because every tree is created sequentially.</li>\n      <li>Tuning the hyperparameters of gradient boosting is harder than those of random forest.</li>\n    </ol>",
      "contentMarkdown": "*   **Similarities:**\n    1.  Both these algorithms are decision-tree based algorithms\n    2.  Both these algorithms are ensemble algorithms\n    3.  Both are flexible models and do not need much data preprocessing.\n*   **Differences:**\n    1.  Random forests (Uses Bagging): Trees are arranged in a parallel fashion where the results of all trees are aggregated at the end through averaging or majority vote. Every tree is constructed independently of the other trees\n    2.  Gradient boosting (Uses Boosting): Trees are arranged in a series sequential fashion where every tree tries to minimize the error of the previous tree. Every tree is dependent on the previous tree.\n*   **Advantages of gradient boosting over random forests:**\n    1.  Gradient boosting can be more accurate than Random forests because we train them to minimize the previous tree’s error.\n    2.  Gradient boosting is capable of capturing complex patterns in the data.\n    3.  Gradient boosting is better than random forest when used on unbalanced data sets.\n*   **Advantages of random forests over gradient boosting :**\n    1.  Random forest is less prone to overfit as compared to gradient boosting.\n    2.  Random forest has faster training as trees are created parallelly & independent of each other.\n*   **The disadvantage of GB over RF:**\n    1.  Gradient boosting is more prone to overfitting than random forests due to their focus on mistakes during training iterations and the lack of independence in tree building.\n    2.  If the data is noisy the boosted trees might overfit and start modeling the noise.\n    3.  In GB training might take longer because every tree is created sequentially.\n    4.  Tuning the hyperparameters of gradient boosting is harder than those of random forest.\n\n1.  Both these algorithms are decision-tree based algorithms\n2.  Both these algorithms are ensemble algorithms\n3.  Both are flexible models and do not need much data preprocessing.\n\n1.  Random forests (Uses Bagging): Trees are arranged in a parallel fashion where the results of all trees are aggregated at the end through averaging or majority vote. Every tree is constructed independently of the other trees\n2.  Gradient boosting (Uses Boosting): Trees are arranged in a series sequential fashion where every tree tries to minimize the error of the previous tree. Every tree is dependent on the previous tree.\n\n1.  Gradient boosting can be more accurate than Random forests because we train them to minimize the previous tree’s error.\n2.  Gradient boosting is capable of capturing complex patterns in the data.\n3.  Gradient boosting is better than random forest when used on unbalanced data sets.\n\n1.  Random forest is less prone to overfit as compared to gradient boosting.\n2.  Random forest has faster training as trees are created parallelly & independent of each other.\n\n1.  Gradient boosting is more prone to overfitting than random forests due to their focus on mistakes during training iterations and the lack of independence in tree building.\n2.  If the data is noisy the boosted trees might overfit and start modeling the noise.\n3.  In GB training might take longer because every tree is created sequentially.\n4.  Tuning the hyperparameters of gradient boosting is harder than those of random forest.",
      "order": 19,
      "orderInChapter": 19,
      "difficulty": 3,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 514,
        "contentLength": 3833
      },
      "nextCards": [
        "ai-interview-small-file-and-big-file-problem-in-big-data-20",
        "ai-interview-what-are-l1-and-l2-regularization-what-are-the-dif-21"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-differences-and-similarities-between-gradient-boosting-and-random-forest?-and-what-are-the-advantage-and-disadvantages-of-each-when-compared-to-each-other?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-small-file-and-big-file-problem-in-big-data-20",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Small File and Big File Problem in Big Data",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The “small file problem” is kind of notorious in the big data space.</li>\n  <li>Did you know there’s also the “Big/large file problem”?</li>\n  <li>Say you have a billion records. The small file problem would be like.. 10 records per file and 100 million files. Combining all these files is slow, terrible, and has made many data engineers cry.</li>\n  <li>The large file problem would be the opposite problem. 1 billion records in 1 file. This is also a huge problem because how do you parallelize 1 file? You can’t without splitting it up first.</li>\n  <li>To avoid crying, the solution is sizing your files the right way. Aiming for between 100-200 MBs for file is usually best. In this contrived example, you’d have a 1000 files each with 1 million records.</li>\n  <li>It is worth seeing the spread of files and the size and understanding what optimal file size works out best.</li>\n  <li>Too low and you have the risk of more files, too high and the parallelism isn’t going to be effective.</li>\n  <li>It is recommended to understand up parallelism, and block size and seeing how the distribution of your data (in files) is before adding an arbitrary default file size value.</li>\n</ul>",
      "contentMarkdown": "*   The “small file problem” is kind of notorious in the big data space.\n*   Did you know there’s also the “Big/large file problem”?\n*   Say you have a billion records. The small file problem would be like.. 10 records per file and 100 million files. Combining all these files is slow, terrible, and has made many data engineers cry.\n*   The large file problem would be the opposite problem. 1 billion records in 1 file. This is also a huge problem because how do you parallelize 1 file? You can’t without splitting it up first.\n*   To avoid crying, the solution is sizing your files the right way. Aiming for between 100-200 MBs for file is usually best. In this contrived example, you’d have a 1000 files each with 1 million records.\n*   It is worth seeing the spread of files and the size and understanding what optimal file size works out best.\n*   Too low and you have the risk of more files, too high and the parallelism isn’t going to be effective.\n*   It is recommended to understand up parallelism, and block size and seeing how the distribution of your data (in files) is before adding an arbitrary default file size value.",
      "order": 20,
      "orderInChapter": 20,
      "difficulty": 3,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 205,
        "contentLength": 1200
      },
      "nextCards": [
        "ai-interview-what-are-l1-and-l2-regularization-what-are-the-dif-21",
        "ai-interview-what-are-the-bias-and-variance-in-a-machine-learni-22"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#small-file-and-big-file-problem-in-big-data",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-l1-and-l2-regularization-what-are-the-dif-21",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are L1 and L2 Regularization? What are the Differences Between the Two?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Regularization is a technique used to avoid overfitting by trying to make the model more simple. One way to apply regularization is by adding the weights to the loss function. This is done in order to consider minimizing unimportant weights. In L1 regularization we add the sum of the absolute of the weights to the loss function. In L2 regularization we add the sum of the squares of the weights to the loss function.</li>\n  <li>So both L1 and L2 regularization are ways to reduce overfitting, but to understand the difference it’s better to know how they are calculated:\n    <ul>\n      <li>Loss (L2) : Cost function + <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-30-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-176\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-177\"><span class=\"mi\" id=\"MathJax-Span-178\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-30\">L</script> * <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-31-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mi>s</mi><mn>2</mn></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-179\" style=\"width: 4.273em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1003.54em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-180\"><span class=\"mi\" id=\"MathJax-Span-181\" style=\"font-family: STIXGeneral-Italic;\">w</span><span class=\"mi\" id=\"MathJax-Span-182\" style=\"font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-183\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mi\" id=\"MathJax-Span-184\" style=\"font-family: STIXGeneral-Italic;\">g</span><span class=\"mi\" id=\"MathJax-Span-185\" style=\"font-family: STIXGeneral-Italic;\">h</span><span class=\"mi\" id=\"MathJax-Span-186\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"msubsup\" id=\"MathJax-Span-187\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-188\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.367em;\"><span class=\"mn\" id=\"MathJax-Span-189\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mi>s</mi><mn>2</mn></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-31\">weights^2</script></li>\n      <li>Loss (L1) : Cost function + <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-32-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-190\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-191\"><span class=\"mi\" id=\"MathJax-Span-192\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-32\">L</script> * <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-33-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-193\" style=\"width: 4.482em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.701em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.6em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-194\"><span class=\"mo\" id=\"MathJax-Span-195\" style=\"font-family: STIXGeneral-Regular;\">‖</span><span class=\"mi\" id=\"MathJax-Span-196\" style=\"font-family: STIXGeneral-Italic;\">w</span><span class=\"mi\" id=\"MathJax-Span-197\" style=\"font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-198\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mi\" id=\"MathJax-Span-199\" style=\"font-family: STIXGeneral-Italic;\">g</span><span class=\"mi\" id=\"MathJax-Span-200\" style=\"font-family: STIXGeneral-Italic;\">h</span><span class=\"mi\" id=\"MathJax-Span-201\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-202\" style=\"font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-203\" style=\"font-family: STIXGeneral-Regular;\">‖</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo fence=\"false\" stretchy=\"false\">‖</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo fence=\"false\" stretchy=\"false\">‖</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-33\">\\|weights\\|</script>\n        <ul>\n          <li>Where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-34-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-204\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-205\"><span class=\"mi\" id=\"MathJax-Span-206\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-34\">L</script> is the regularization parameter</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>L2 regularization penalizes huge parameters preventing any of the single parameters to get too large. But weights never become zeros. It adds parameters square to the loss. Preventing the model from overfitting on any single feature.</li>\n  <li>L1 regularization penalizes weights by adding a term to the loss function which is the absolute value of the loss. This leads to it removing small values of the parameters leading in the end to the parameter hitting zero and staying there for the rest of the epochs. Removing this specific variable completely from our calculation. So, It helps in simplifying our model. It is also helpful for feature selection as it shrinks the coefficient to zero which is not significant in the model.</li>\n</ul>\n<ul>\n      <li>Loss (L2) : Cost function + <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-30-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-176\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-177\"><span class=\"mi\" id=\"MathJax-Span-178\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-30\">L</script> * <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-31-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mi>s</mi><mn>2</mn></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-179\" style=\"width: 4.273em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1003.54em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-180\"><span class=\"mi\" id=\"MathJax-Span-181\" style=\"font-family: STIXGeneral-Italic;\">w</span><span class=\"mi\" id=\"MathJax-Span-182\" style=\"font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-183\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mi\" id=\"MathJax-Span-184\" style=\"font-family: STIXGeneral-Italic;\">g</span><span class=\"mi\" id=\"MathJax-Span-185\" style=\"font-family: STIXGeneral-Italic;\">h</span><span class=\"mi\" id=\"MathJax-Span-186\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"msubsup\" id=\"MathJax-Span-187\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-188\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.367em;\"><span class=\"mn\" id=\"MathJax-Span-189\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><msup><mi>s</mi><mn>2</mn></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-31\">weights^2</script></li>\n      <li>Loss (L1) : Cost function + <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-32-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-190\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-191\"><span class=\"mi\" id=\"MathJax-Span-192\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-32\">L</script> * <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-33-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-193\" style=\"width: 4.482em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.701em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.6em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-194\"><span class=\"mo\" id=\"MathJax-Span-195\" style=\"font-family: STIXGeneral-Regular;\">‖</span><span class=\"mi\" id=\"MathJax-Span-196\" style=\"font-family: STIXGeneral-Italic;\">w</span><span class=\"mi\" id=\"MathJax-Span-197\" style=\"font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-198\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mi\" id=\"MathJax-Span-199\" style=\"font-family: STIXGeneral-Italic;\">g</span><span class=\"mi\" id=\"MathJax-Span-200\" style=\"font-family: STIXGeneral-Italic;\">h</span><span class=\"mi\" id=\"MathJax-Span-201\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-202\" style=\"font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-203\" style=\"font-family: STIXGeneral-Regular;\">‖</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo fence=\"false\" stretchy=\"false\">‖</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo fence=\"false\" stretchy=\"false\">‖</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-33\">\\|weights\\|</script>\n        <ul>\n          <li>Where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-34-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-204\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-205\"><span class=\"mi\" id=\"MathJax-Span-206\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-34\">L</script> is the regularization parameter</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-34-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-204\" style=\"width: 0.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.63em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-205\"><span class=\"mi\" id=\"MathJax-Span-206\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-34\">L</script> is the regularization parameter</li>\n        </ul>",
      "contentMarkdown": "*   Regularization is a technique used to avoid overfitting by trying to make the model more simple. One way to apply regularization is by adding the weights to the loss function. This is done in order to consider minimizing unimportant weights. In L1 regularization we add the sum of the absolute of the weights to the loss function. In L2 regularization we add the sum of the squares of the weights to the loss function.\n*   So both L1 and L2 regularization are ways to reduce overfitting, but to understand the difference it’s better to know how they are calculated:\n    *   Loss (L2) : Cost function + LLL \\* weights2weights2weights^2\n    *   Loss (L1) : Cost function + LLL \\* ‖weights‖‖weights‖\\\\|weights\\\\|\n        *   Where LLL is the regularization parameter\n*   L2 regularization penalizes huge parameters preventing any of the single parameters to get too large. But weights never become zeros. It adds parameters square to the loss. Preventing the model from overfitting on any single feature.\n*   L1 regularization penalizes weights by adding a term to the loss function which is the absolute value of the loss. This leads to it removing small values of the parameters leading in the end to the parameter hitting zero and staying there for the rest of the epochs. Removing this specific variable completely from our calculation. So, It helps in simplifying our model. It is also helpful for feature selection as it shrinks the coefficient to zero which is not significant in the model.\n\n*   Loss (L2) : Cost function + LLL \\* weights2weights2weights^2\n*   Loss (L1) : Cost function + LLL \\* ‖weights‖‖weights‖\\\\|weights\\\\|\n    *   Where LLL is the regularization parameter\n\n*   Where LLL is the regularization parameter",
      "order": 21,
      "orderInChapter": 21,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "loss function",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 283,
        "contentLength": 20495
      },
      "nextCards": [
        "ai-interview-what-are-the-bias-and-variance-in-a-machine-learni-22",
        "ai-interview-briefly-explain-the-ab-testing-and-its-application-23"
      ],
      "relatedCards": [
        "ai-diffusion-models-integration-with-mse-46",
        "ai-loss-mean-absolute-error-mae-l1-loss-9",
        "ai-regularization-graphical-treatment-6",
        "ai-regularization-l2l2l2-regularization-weight-shrinkage-ie-uniform--8",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-l1-and-l2-regularization?-what-are-the-differences-between-the-two?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-bias-and-variance-in-a-machine-learni-22",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Bias and Variance in a Machine Learning Model and Explain the Bias-variance Trade-off?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>The goal of any supervised machine learning model is to estimate the mapping function (f) that predicts the target variable (y) given input (x). The prediction error can be broken down into three parts:</p>\n\n    <ul>\n      <li>\n        <p>Bias: The bias is the simplifying assumption made by the model to make the target function easy to learn. Low bias suggests fewer assumptions made about the form of the target function. High bias suggests more assumptions made about the form of the target data. The smaller the bias error the better the model is. If the bias error is high, this means that the model is underfitting the training data.</p>\n      </li>\n      <li>\n        <p>Variance: Variance is the amount that the estimate of the target function will change if different training data was used. The target function is estimated from the training data by a machine learning algorithm, so we should expect the algorithm to have some variance. Ideally, it should not change too much from one training dataset to the next, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables. If the variance error is high this indicates that the model overfits the training data.</p>\n      </li>\n      <li>\n        <p>Irreducible error: It is the error introduced from the chosen framing of the problem and may be caused by factors like unknown variables that influence the mapping of the input variables to the output variable. The irreducible error cannot be reduced regardless of what algorithm is used.</p>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <p>The goal of any supervised machine learning algorithm is to achieve low bias and low variance. In turn, the algorithm should achieve good prediction performance. The parameterization of machine learning algorithms is often a battle to balance out bias and variance.</p>\n    <ul>\n      <li>For example, if you want to predict the housing prices given a large set of potential predictors. A model with high bias but low variance, such as linear regression will be easy to implement, but it will oversimplify the problem resulting in high bias and low variance. This high bias and low variance would mean in this context that the predicted house prices are frequently off from the market value, but the value of the variance of these predicted prices is low.</li>\n      <li>On the other side, a model with low bias and high variance such as a neural network will lead to predicted house prices closer to the market value, but with predictions varying widely based on the input features.</li>\n    </ul>\n  </li>\n</ul>\n<p>The goal of any supervised machine learning model is to estimate the mapping function (f) that predicts the target variable (y) given input (x). The prediction error can be broken down into three parts:</p>\n<ul>\n      <li>\n        <p>Bias: The bias is the simplifying assumption made by the model to make the target function easy to learn. Low bias suggests fewer assumptions made about the form of the target function. High bias suggests more assumptions made about the form of the target data. The smaller the bias error the better the model is. If the bias error is high, this means that the model is underfitting the training data.</p>\n      </li>\n      <li>\n        <p>Variance: Variance is the amount that the estimate of the target function will change if different training data was used. The target function is estimated from the training data by a machine learning algorithm, so we should expect the algorithm to have some variance. Ideally, it should not change too much from one training dataset to the next, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables. If the variance error is high this indicates that the model overfits the training data.</p>\n      </li>\n      <li>\n        <p>Irreducible error: It is the error introduced from the chosen framing of the problem and may be caused by factors like unknown variables that influence the mapping of the input variables to the output variable. The irreducible error cannot be reduced regardless of what algorithm is used.</p>\n      </li>\n    </ul>\n<p>Bias: The bias is the simplifying assumption made by the model to make the target function easy to learn. Low bias suggests fewer assumptions made about the form of the target function. High bias suggests more assumptions made about the form of the target data. The smaller the bias error the better the model is. If the bias error is high, this means that the model is underfitting the training data.</p>\n<p>Variance: Variance is the amount that the estimate of the target function will change if different training data was used. The target function is estimated from the training data by a machine learning algorithm, so we should expect the algorithm to have some variance. Ideally, it should not change too much from one training dataset to the next, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables. If the variance error is high this indicates that the model overfits the training data.</p>\n<p>Irreducible error: It is the error introduced from the chosen framing of the problem and may be caused by factors like unknown variables that influence the mapping of the input variables to the output variable. The irreducible error cannot be reduced regardless of what algorithm is used.</p>\n<p>The goal of any supervised machine learning algorithm is to achieve low bias and low variance. In turn, the algorithm should achieve good prediction performance. The parameterization of machine learning algorithms is often a battle to balance out bias and variance.</p>\n<ul>\n      <li>For example, if you want to predict the housing prices given a large set of potential predictors. A model with high bias but low variance, such as linear regression will be easy to implement, but it will oversimplify the problem resulting in high bias and low variance. This high bias and low variance would mean in this context that the predicted house prices are frequently off from the market value, but the value of the variance of these predicted prices is low.</li>\n      <li>On the other side, a model with low bias and high variance such as a neural network will lead to predicted house prices closer to the market value, but with predictions varying widely based on the input features.</li>\n    </ul>",
      "contentMarkdown": "*   The goal of any supervised machine learning model is to estimate the mapping function (f) that predicts the target variable (y) given input (x). The prediction error can be broken down into three parts:\n    \n    *   Bias: The bias is the simplifying assumption made by the model to make the target function easy to learn. Low bias suggests fewer assumptions made about the form of the target function. High bias suggests more assumptions made about the form of the target data. The smaller the bias error the better the model is. If the bias error is high, this means that the model is underfitting the training data.\n        \n    *   Variance: Variance is the amount that the estimate of the target function will change if different training data was used. The target function is estimated from the training data by a machine learning algorithm, so we should expect the algorithm to have some variance. Ideally, it should not change too much from one training dataset to the next, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables. If the variance error is high this indicates that the model overfits the training data.\n        \n    *   Irreducible error: It is the error introduced from the chosen framing of the problem and may be caused by factors like unknown variables that influence the mapping of the input variables to the output variable. The irreducible error cannot be reduced regardless of what algorithm is used.\n        \n*   The goal of any supervised machine learning algorithm is to achieve low bias and low variance. In turn, the algorithm should achieve good prediction performance. The parameterization of machine learning algorithms is often a battle to balance out bias and variance.\n    \n    *   For example, if you want to predict the housing prices given a large set of potential predictors. A model with high bias but low variance, such as linear regression will be easy to implement, but it will oversimplify the problem resulting in high bias and low variance. This high bias and low variance would mean in this context that the predicted house prices are frequently off from the market value, but the value of the variance of these predicted prices is low.\n    *   On the other side, a model with low bias and high variance such as a neural network will lead to predicted house prices closer to the market value, but with predictions varying widely based on the input features.\n\nThe goal of any supervised machine learning model is to estimate the mapping function (f) that predicts the target variable (y) given input (x). The prediction error can be broken down into three parts:\n\n*   Bias: The bias is the simplifying assumption made by the model to make the target function easy to learn. Low bias suggests fewer assumptions made about the form of the target function. High bias suggests more assumptions made about the form of the target data. The smaller the bias error the better the model is. If the bias error is high, this means that the model is underfitting the training data.\n    \n*   Variance: Variance is the amount that the estimate of the target function will change if different training data was used. The target function is estimated from the training data by a machine learning algorithm, so we should expect the algorithm to have some variance. Ideally, it should not change too much from one training dataset to the next, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables. If the variance error is high this indicates that the model overfits the training data.\n    \n*   Irreducible error: It is the error introduced from the chosen framing of the problem and may be caused by factors like unknown variables that influence the mapping of the input variables to the output variable. The irreducible error cannot be reduced regardless of what algorithm is used.\n    \n\nBias: The bias is the simplifying assumption made by the model to make the target function easy to learn. Low bias suggests fewer assumptions made about the form of the target function. High bias suggests more assumptions made about the form of the target data. The smaller the bias error the better the model is. If the bias error is high, this means that the model is underfitting the training data.\n\nVariance: Variance is the amount that the estimate of the target function will change if different training data was used. The target function is estimated from the training data by a machine learning algorithm, so we should expect the algorithm to have some variance. Ideally, it should not change too much from one training dataset to the next, meaning that the algorithm is good at picking out the hidden underlying mapping between the inputs and the output variables. If the variance error is high this indicates that the model overfits the training data.\n\nIrreducible error: It is the error introduced from the chosen framing of the problem and may be caused by factors like unknown variables that influence the mapping of the input variables to the output variable. The irreducible error cannot be reduced regardless of what algorithm is used.\n\nThe goal of any supervised machine learning algorithm is to achieve low bias and low variance. In turn, the algorithm should achieve good prediction performance. The parameterization of machine learning algorithms is often a battle to balance out bias and variance.\n\n*   For example, if you want to predict the housing prices given a large set of potential predictors. A model with high bias but low variance, such as linear regression will be easy to implement, but it will oversimplify the problem resulting in high bias and low variance. This high bias and low variance would mean in this context that the predicted house prices are frequently off from the market value, but the value of the variance of these predicted prices is low.\n*   On the other side, a model with low bias and high variance such as a neural network will lead to predicted house prices closer to the market value, but with predictions varying widely based on the input features.",
      "order": 22,
      "orderInChapter": 22,
      "difficulty": 3,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1035,
        "contentLength": 6505
      },
      "nextCards": [
        "ai-interview-briefly-explain-the-ab-testing-and-its-application-23",
        "ai-interview-mention-three-ways-to-handle-missing-or-corrupted--24"
      ],
      "relatedCards": [
        "ai-AIDetect-stylometry-3",
        "ai-context-length-extension-ntk-neural-tangent-kernel-3",
        "ai-decision-trees-and-ensemble-methods-stacking-stacked-generalization-10",
        "ai-decision-trees-and-ensemble-methods-bagging-vs-boosting-vs-stacking-11",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-bias-and-variance-in-a-machine-learning-model-and-explain-the-bias-variance-trade-off?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-briefly-explain-the-ab-testing-and-its-application-23",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Briefly Explain the A/B Testing and Its Application? What are Some Common Pitfalls Encountered in A/B Testing?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>A/B testing helps us to determine whether a change in something will cause a change in performance significantly or not. So in other words you aim to statistically estimate the impact of a given change within your digital product (for example). You measure success and counter metrics on at least 1 treatment vs 1 control group (there can be more than 1 XP group for multivariate tests).</p>\n  </li>\n  <li>Applications:\n    <ol>\n      <li>\n        <p>Consider the example of a general store that sells bread packets but not butter, for a year. If we want to check whether its sale depends on the butter or not, then suppose the store also sells butter and sales for next year are observed. Now we can determine whether selling butter can significantly increase/decrease or doesn’t affect the sale of bread.</p>\n      </li>\n      <li>\n        <p>While developing the landing page of a website you create 2 different versions of the page. You define a criteria for success eg. conversion rate. Then define your hypothesis,</p>\n        <ul>\n          <li>Null hypothesis (H): No difference between the performance of the 2 versions.</li>\n          <li>Alternative hypothesis (H’): version A will perform better than B.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>\n    <p>Note that you will have to split your traffic randomly (to avoid sample bias) into 2 versions. The split doesn’t have to be symmetric, you just need to set the minimum sample size for each version to avoid undersample bias.</p>\n  </li>\n  <li>\n    <p>Now if version A gives better results than version B, we will still have to statistically prove that results derived from our sample represent the entire population. Now one of the very common tests used to do so is 2 sample t-test where we use values of significance level (alpha) and p-value to see which hypothesis is right. If p-value&lt;alpha, H is rejected.</p>\n  </li>\n  <li>Common pitfalls:\n    <ol>\n      <li>Wrong success metrics inadequate to the business problem</li>\n      <li>Lack of counter metric, as you might add friction to the product regardless along with the positive impact</li>\n      <li>Sample mismatch: heterogeneous control and treatment, unequal variances</li>\n      <li>Underpowered test: too small sample or XP running too short 5. Not accounting for network effects (introduce bias within measurement)</li>\n    </ol>\n  </li>\n</ul>\n<p>A/B testing helps us to determine whether a change in something will cause a change in performance significantly or not. So in other words you aim to statistically estimate the impact of a given change within your digital product (for example). You measure success and counter metrics on at least 1 treatment vs 1 control group (there can be more than 1 XP group for multivariate tests).</p>\n<ol>\n      <li>\n        <p>Consider the example of a general store that sells bread packets but not butter, for a year. If we want to check whether its sale depends on the butter or not, then suppose the store also sells butter and sales for next year are observed. Now we can determine whether selling butter can significantly increase/decrease or doesn’t affect the sale of bread.</p>\n      </li>\n      <li>\n        <p>While developing the landing page of a website you create 2 different versions of the page. You define a criteria for success eg. conversion rate. Then define your hypothesis,</p>\n        <ul>\n          <li>Null hypothesis (H): No difference between the performance of the 2 versions.</li>\n          <li>Alternative hypothesis (H’): version A will perform better than B.</li>\n        </ul>\n      </li>\n    </ol>\n<p>Consider the example of a general store that sells bread packets but not butter, for a year. If we want to check whether its sale depends on the butter or not, then suppose the store also sells butter and sales for next year are observed. Now we can determine whether selling butter can significantly increase/decrease or doesn’t affect the sale of bread.</p>\n<p>While developing the landing page of a website you create 2 different versions of the page. You define a criteria for success eg. conversion rate. Then define your hypothesis,</p>\n<ul>\n          <li>Null hypothesis (H): No difference between the performance of the 2 versions.</li>\n          <li>Alternative hypothesis (H’): version A will perform better than B.</li>\n        </ul>\n<p>Note that you will have to split your traffic randomly (to avoid sample bias) into 2 versions. The split doesn’t have to be symmetric, you just need to set the minimum sample size for each version to avoid undersample bias.</p>\n<p>Now if version A gives better results than version B, we will still have to statistically prove that results derived from our sample represent the entire population. Now one of the very common tests used to do so is 2 sample t-test where we use values of significance level (alpha) and p-value to see which hypothesis is right. If p-value&lt;alpha, H is rejected.</p>\n<ol>\n      <li>Wrong success metrics inadequate to the business problem</li>\n      <li>Lack of counter metric, as you might add friction to the product regardless along with the positive impact</li>\n      <li>Sample mismatch: heterogeneous control and treatment, unequal variances</li>\n      <li>Underpowered test: too small sample or XP running too short 5. Not accounting for network effects (introduce bias within measurement)</li>\n    </ol>",
      "contentMarkdown": "*   A/B testing helps us to determine whether a change in something will cause a change in performance significantly or not. So in other words you aim to statistically estimate the impact of a given change within your digital product (for example). You measure success and counter metrics on at least 1 treatment vs 1 control group (there can be more than 1 XP group for multivariate tests).\n    \n*   Applications:\n    1.  Consider the example of a general store that sells bread packets but not butter, for a year. If we want to check whether its sale depends on the butter or not, then suppose the store also sells butter and sales for next year are observed. Now we can determine whether selling butter can significantly increase/decrease or doesn’t affect the sale of bread.\n        \n    2.  While developing the landing page of a website you create 2 different versions of the page. You define a criteria for success eg. conversion rate. Then define your hypothesis,\n        \n        *   Null hypothesis (H): No difference between the performance of the 2 versions.\n        *   Alternative hypothesis (H’): version A will perform better than B.\n*   Note that you will have to split your traffic randomly (to avoid sample bias) into 2 versions. The split doesn’t have to be symmetric, you just need to set the minimum sample size for each version to avoid undersample bias.\n    \n*   Now if version A gives better results than version B, we will still have to statistically prove that results derived from our sample represent the entire population. Now one of the very common tests used to do so is 2 sample t-test where we use values of significance level (alpha) and p-value to see which hypothesis is right. If p-value<alpha, H is rejected.\n    \n*   Common pitfalls:\n    1.  Wrong success metrics inadequate to the business problem\n    2.  Lack of counter metric, as you might add friction to the product regardless along with the positive impact\n    3.  Sample mismatch: heterogeneous control and treatment, unequal variances\n    4.  Underpowered test: too small sample or XP running too short 5. Not accounting for network effects (introduce bias within measurement)\n\nA/B testing helps us to determine whether a change in something will cause a change in performance significantly or not. So in other words you aim to statistically estimate the impact of a given change within your digital product (for example). You measure success and counter metrics on at least 1 treatment vs 1 control group (there can be more than 1 XP group for multivariate tests).\n\n1.  Consider the example of a general store that sells bread packets but not butter, for a year. If we want to check whether its sale depends on the butter or not, then suppose the store also sells butter and sales for next year are observed. Now we can determine whether selling butter can significantly increase/decrease or doesn’t affect the sale of bread.\n    \n2.  While developing the landing page of a website you create 2 different versions of the page. You define a criteria for success eg. conversion rate. Then define your hypothesis,\n    \n    *   Null hypothesis (H): No difference between the performance of the 2 versions.\n    *   Alternative hypothesis (H’): version A will perform better than B.\n\nConsider the example of a general store that sells bread packets but not butter, for a year. If we want to check whether its sale depends on the butter or not, then suppose the store also sells butter and sales for next year are observed. Now we can determine whether selling butter can significantly increase/decrease or doesn’t affect the sale of bread.\n\nWhile developing the landing page of a website you create 2 different versions of the page. You define a criteria for success eg. conversion rate. Then define your hypothesis,\n\n*   Null hypothesis (H): No difference between the performance of the 2 versions.\n*   Alternative hypothesis (H’): version A will perform better than B.\n\nNote that you will have to split your traffic randomly (to avoid sample bias) into 2 versions. The split doesn’t have to be symmetric, you just need to set the minimum sample size for each version to avoid undersample bias.\n\nNow if version A gives better results than version B, we will still have to statistically prove that results derived from our sample represent the entire population. Now one of the very common tests used to do so is 2 sample t-test where we use values of significance level (alpha) and p-value to see which hypothesis is right. If p-value<alpha, H is rejected.\n\n1.  Wrong success metrics inadequate to the business problem\n2.  Lack of counter metric, as you might add friction to the product regardless along with the positive impact\n3.  Sample mismatch: heterogeneous control and treatment, unequal variances\n4.  Underpowered test: too small sample or XP running too short 5. Not accounting for network effects (introduce bias within measurement)",
      "order": 23,
      "orderInChapter": 23,
      "difficulty": 3,
      "estimatedMinutes": 5,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 813,
        "contentLength": 5432
      },
      "nextCards": [
        "ai-interview-mention-three-ways-to-handle-missing-or-corrupted--24",
        "ai-interview-how-do-you-avoid-overfitting-try-one-or-more-of-th-25"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#briefly-explain-the-a/b-testing-and-its-application?-what-are-some-common-pitfalls-encountered-in-a/b-testing?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-mention-three-ways-to-handle-missing-or-corrupted--24",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Mention Three Ways to Handle Missing or Corrupted Data in Adataset?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>In general, real-world data often has a lot of missing values. The cause of missing values can be data corruption or failure to record data. The handling of missing data is very important during the preprocessing of the dataset as many machine learning algorithms do not support missing values. However, you should start by asking the data owner/stakeholder about the missing or corrupted data. It might be at the data entry level, because of file encoding, etc. which if aligned, can be handled without the need to use advanced techniques.</p>\n  </li>\n  <li>\n    <p>There are different ways to handle missing data, we will discuss only three of them:</p>\n\n    <ol>\n      <li>\n        <p>Deleting the row with missing values</p>\n\n        <ul>\n          <li>The first method to handle missing values is to delete the rows or columns that have null values. This is an easy and fast method and leads to a robust model, however, it will lead to the loss of a lot of information depending on the amount of missing data and can only be applied if the missing data represent a small percentage of the whole dataset.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Using learning algorithms that support missing values</p>\n\n        <ul>\n          <li>Some machine learning algorithms are robust to missing values in the dataset. The K-NN algorithm can ignore a column from a distance measure when there are missing values. Naive Bayes can also support missing values when making a prediction. Another algorithm that can handle a dataset with missing values or null values is the random forest model and Xgboost (check the post in the first comment), as it can work on non-linear and categorical data. The problem with this method is that these models’ implementation in the scikit-learn library does not support handling missing values, so you will have to implement it yourself.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Missing value imputation</p>\n\n        <ul>\n          <li>Data imputation means the substitution of estimated values for missing or inconsistent data in your dataset. There are different ways to estimate the values that will replace the missing value. The simplest one is to replace the missing value with the most repeated value in the row or the column. Another simple way is to replace it with the mean, median, or mode of the rest of the row or the column. This advantage of this is that it is an easy and fast way to handle the missing data, but it might lead to data leakage and does not factor the covariance between features. A better way is to use a machine learning model to learn the pattern between the data and predict the missing values, this is a very good method to estimate the missing values that will not lead to data leakage and will factor the covariance between the feature, the drawback of this method is the computational complexity especially if your dataset is large.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n</ul>\n<p>In general, real-world data often has a lot of missing values. The cause of missing values can be data corruption or failure to record data. The handling of missing data is very important during the preprocessing of the dataset as many machine learning algorithms do not support missing values. However, you should start by asking the data owner/stakeholder about the missing or corrupted data. It might be at the data entry level, because of file encoding, etc. which if aligned, can be handled without the need to use advanced techniques.</p>\n<p>There are different ways to handle missing data, we will discuss only three of them:</p>\n<ol>\n      <li>\n        <p>Deleting the row with missing values</p>\n\n        <ul>\n          <li>The first method to handle missing values is to delete the rows or columns that have null values. This is an easy and fast method and leads to a robust model, however, it will lead to the loss of a lot of information depending on the amount of missing data and can only be applied if the missing data represent a small percentage of the whole dataset.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Using learning algorithms that support missing values</p>\n\n        <ul>\n          <li>Some machine learning algorithms are robust to missing values in the dataset. The K-NN algorithm can ignore a column from a distance measure when there are missing values. Naive Bayes can also support missing values when making a prediction. Another algorithm that can handle a dataset with missing values or null values is the random forest model and Xgboost (check the post in the first comment), as it can work on non-linear and categorical data. The problem with this method is that these models’ implementation in the scikit-learn library does not support handling missing values, so you will have to implement it yourself.</li>\n        </ul>\n      </li>\n      <li>\n        <p>Missing value imputation</p>\n\n        <ul>\n          <li>Data imputation means the substitution of estimated values for missing or inconsistent data in your dataset. There are different ways to estimate the values that will replace the missing value. The simplest one is to replace the missing value with the most repeated value in the row or the column. Another simple way is to replace it with the mean, median, or mode of the rest of the row or the column. This advantage of this is that it is an easy and fast way to handle the missing data, but it might lead to data leakage and does not factor the covariance between features. A better way is to use a machine learning model to learn the pattern between the data and predict the missing values, this is a very good method to estimate the missing values that will not lead to data leakage and will factor the covariance between the feature, the drawback of this method is the computational complexity especially if your dataset is large.</li>\n        </ul>\n      </li>\n    </ol>\n<p>Deleting the row with missing values</p>\n<ul>\n          <li>The first method to handle missing values is to delete the rows or columns that have null values. This is an easy and fast method and leads to a robust model, however, it will lead to the loss of a lot of information depending on the amount of missing data and can only be applied if the missing data represent a small percentage of the whole dataset.</li>\n        </ul>\n<p>Using learning algorithms that support missing values</p>\n<ul>\n          <li>Some machine learning algorithms are robust to missing values in the dataset. The K-NN algorithm can ignore a column from a distance measure when there are missing values. Naive Bayes can also support missing values when making a prediction. Another algorithm that can handle a dataset with missing values or null values is the random forest model and Xgboost (check the post in the first comment), as it can work on non-linear and categorical data. The problem with this method is that these models’ implementation in the scikit-learn library does not support handling missing values, so you will have to implement it yourself.</li>\n        </ul>\n<p>Missing value imputation</p>\n<ul>\n          <li>Data imputation means the substitution of estimated values for missing or inconsistent data in your dataset. There are different ways to estimate the values that will replace the missing value. The simplest one is to replace the missing value with the most repeated value in the row or the column. Another simple way is to replace it with the mean, median, or mode of the rest of the row or the column. This advantage of this is that it is an easy and fast way to handle the missing data, but it might lead to data leakage and does not factor the covariance between features. A better way is to use a machine learning model to learn the pattern between the data and predict the missing values, this is a very good method to estimate the missing values that will not lead to data leakage and will factor the covariance between the feature, the drawback of this method is the computational complexity especially if your dataset is large.</li>\n        </ul>",
      "contentMarkdown": "*   In general, real-world data often has a lot of missing values. The cause of missing values can be data corruption or failure to record data. The handling of missing data is very important during the preprocessing of the dataset as many machine learning algorithms do not support missing values. However, you should start by asking the data owner/stakeholder about the missing or corrupted data. It might be at the data entry level, because of file encoding, etc. which if aligned, can be handled without the need to use advanced techniques.\n    \n*   There are different ways to handle missing data, we will discuss only three of them:\n    \n    1.  Deleting the row with missing values\n        \n        *   The first method to handle missing values is to delete the rows or columns that have null values. This is an easy and fast method and leads to a robust model, however, it will lead to the loss of a lot of information depending on the amount of missing data and can only be applied if the missing data represent a small percentage of the whole dataset.\n    2.  Using learning algorithms that support missing values\n        \n        *   Some machine learning algorithms are robust to missing values in the dataset. The K-NN algorithm can ignore a column from a distance measure when there are missing values. Naive Bayes can also support missing values when making a prediction. Another algorithm that can handle a dataset with missing values or null values is the random forest model and Xgboost (check the post in the first comment), as it can work on non-linear and categorical data. The problem with this method is that these models’ implementation in the scikit-learn library does not support handling missing values, so you will have to implement it yourself.\n    3.  Missing value imputation\n        \n        *   Data imputation means the substitution of estimated values for missing or inconsistent data in your dataset. There are different ways to estimate the values that will replace the missing value. The simplest one is to replace the missing value with the most repeated value in the row or the column. Another simple way is to replace it with the mean, median, or mode of the rest of the row or the column. This advantage of this is that it is an easy and fast way to handle the missing data, but it might lead to data leakage and does not factor the covariance between features. A better way is to use a machine learning model to learn the pattern between the data and predict the missing values, this is a very good method to estimate the missing values that will not lead to data leakage and will factor the covariance between the feature, the drawback of this method is the computational complexity especially if your dataset is large.\n\nIn general, real-world data often has a lot of missing values. The cause of missing values can be data corruption or failure to record data. The handling of missing data is very important during the preprocessing of the dataset as many machine learning algorithms do not support missing values. However, you should start by asking the data owner/stakeholder about the missing or corrupted data. It might be at the data entry level, because of file encoding, etc. which if aligned, can be handled without the need to use advanced techniques.\n\nThere are different ways to handle missing data, we will discuss only three of them:\n\n1.  Deleting the row with missing values\n    \n    *   The first method to handle missing values is to delete the rows or columns that have null values. This is an easy and fast method and leads to a robust model, however, it will lead to the loss of a lot of information depending on the amount of missing data and can only be applied if the missing data represent a small percentage of the whole dataset.\n2.  Using learning algorithms that support missing values\n    \n    *   Some machine learning algorithms are robust to missing values in the dataset. The K-NN algorithm can ignore a column from a distance measure when there are missing values. Naive Bayes can also support missing values when making a prediction. Another algorithm that can handle a dataset with missing values or null values is the random forest model and Xgboost (check the post in the first comment), as it can work on non-linear and categorical data. The problem with this method is that these models’ implementation in the scikit-learn library does not support handling missing values, so you will have to implement it yourself.\n3.  Missing value imputation\n    \n    *   Data imputation means the substitution of estimated values for missing or inconsistent data in your dataset. There are different ways to estimate the values that will replace the missing value. The simplest one is to replace the missing value with the most repeated value in the row or the column. Another simple way is to replace it with the mean, median, or mode of the rest of the row or the column. This advantage of this is that it is an easy and fast way to handle the missing data, but it might lead to data leakage and does not factor the covariance between features. A better way is to use a machine learning model to learn the pattern between the data and predict the missing values, this is a very good method to estimate the missing values that will not lead to data leakage and will factor the covariance between the feature, the drawback of this method is the computational complexity especially if your dataset is large.\n\nDeleting the row with missing values\n\n*   The first method to handle missing values is to delete the rows or columns that have null values. This is an easy and fast method and leads to a robust model, however, it will lead to the loss of a lot of information depending on the amount of missing data and can only be applied if the missing data represent a small percentage of the whole dataset.\n\nUsing learning algorithms that support missing values\n\n*   Some machine learning algorithms are robust to missing values in the dataset. The K-NN algorithm can ignore a column from a distance measure when there are missing values. Naive Bayes can also support missing values when making a prediction. Another algorithm that can handle a dataset with missing values or null values is the random forest model and Xgboost (check the post in the first comment), as it can work on non-linear and categorical data. The problem with this method is that these models’ implementation in the scikit-learn library does not support handling missing values, so you will have to implement it yourself.\n\nMissing value imputation\n\n*   Data imputation means the substitution of estimated values for missing or inconsistent data in your dataset. There are different ways to estimate the values that will replace the missing value. The simplest one is to replace the missing value with the most repeated value in the row or the column. Another simple way is to replace it with the mean, median, or mode of the rest of the row or the column. This advantage of this is that it is an easy and fast way to handle the missing data, but it might lead to data leakage and does not factor the covariance between features. A better way is to use a machine learning model to learn the pattern between the data and predict the missing values, this is a very good method to estimate the missing values that will not lead to data leakage and will factor the covariance between the feature, the drawback of this method is the computational complexity especially if your dataset is large.",
      "order": 24,
      "orderInChapter": 24,
      "difficulty": 3,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1289,
        "contentLength": 8107
      },
      "nextCards": [
        "ai-interview-how-do-you-avoid-overfitting-try-one-or-more-of-th-25",
        "ai-interview-data-science-mlinterview-are-hard---regardless-whi-26"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-overview-1",
        "ai-decision-trees-and-ensemble-methods-overview-7",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#mention-three-ways-to-handle-missing-or-corrupted-data-in-adataset?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-avoid-overfitting-try-one-or-more-of-th-25",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Avoid #overfitting? Try One (or More) of the Following:",
      "subtitle": "Deep Learning",
      "contentHtml": "<ol>\n  <li>\n    <p>Training with more data, which makes the signal stronger and clearer, and can enable the model to detect the signal better. One way to do this is to use #dataaugmentation strategies</p>\n  </li>\n  <li>\n    <p>Reducing the number of features in order to avoid the curse of dimensionality (which occurs when the amount of data is too low to support highly-dimensional models), which is a common cause for overfitting</p>\n  </li>\n  <li>\n    <p>Using cross-validation. This technique works because the model is unlikely to make the same mistake on multiple different samples, and hence, errors will be evened out</p>\n  </li>\n  <li>\n    <p>Using early stopping to end the training process before the model starts learning the noise</p>\n  </li>\n  <li>\n    <p>Using regularization and minimizing the adjusted loss function. Regularization works because it discourages learning a model that’s overly complex or flexible</p>\n  </li>\n  <li>\n    <p>Using ensemble learning, which ensures that the weaknesses of a model are compensated by the other ones</p>\n  </li>\n</ol>\n<p>Training with more data, which makes the signal stronger and clearer, and can enable the model to detect the signal better. One way to do this is to use #dataaugmentation strategies</p>\n<p>Reducing the number of features in order to avoid the curse of dimensionality (which occurs when the amount of data is too low to support highly-dimensional models), which is a common cause for overfitting</p>\n<p>Using cross-validation. This technique works because the model is unlikely to make the same mistake on multiple different samples, and hence, errors will be evened out</p>\n<p>Using early stopping to end the training process before the model starts learning the noise</p>\n<p>Using regularization and minimizing the adjusted loss function. Regularization works because it discourages learning a model that’s overly complex or flexible</p>\n<p>Using ensemble learning, which ensures that the weaknesses of a model are compensated by the other ones</p>",
      "contentMarkdown": "1.  Training with more data, which makes the signal stronger and clearer, and can enable the model to detect the signal better. One way to do this is to use #dataaugmentation strategies\n    \n2.  Reducing the number of features in order to avoid the curse of dimensionality (which occurs when the amount of data is too low to support highly-dimensional models), which is a common cause for overfitting\n    \n3.  Using cross-validation. This technique works because the model is unlikely to make the same mistake on multiple different samples, and hence, errors will be evened out\n    \n4.  Using early stopping to end the training process before the model starts learning the noise\n    \n5.  Using regularization and minimizing the adjusted loss function. Regularization works because it discourages learning a model that’s overly complex or flexible\n    \n6.  Using ensemble learning, which ensures that the weaknesses of a model are compensated by the other ones\n    \n\nTraining with more data, which makes the signal stronger and clearer, and can enable the model to detect the signal better. One way to do this is to use #dataaugmentation strategies\n\nReducing the number of features in order to avoid the curse of dimensionality (which occurs when the amount of data is too low to support highly-dimensional models), which is a common cause for overfitting\n\nUsing cross-validation. This technique works because the model is unlikely to make the same mistake on multiple different samples, and hence, errors will be evened out\n\nUsing early stopping to end the training process before the model starts learning the noise\n\nUsing regularization and minimizing the adjusted loss function. Regularization works because it discourages learning a model that’s overly complex or flexible\n\nUsing ensemble learning, which ensures that the weaknesses of a model are compensated by the other ones",
      "order": 25,
      "orderInChapter": 25,
      "difficulty": 3,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "loss function",
        "regularization",
        "cross-validation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 294,
        "contentLength": 2030
      },
      "nextCards": [
        "ai-interview-data-science-mlinterview-are-hard---regardless-whi-26",
        "ai-interview-order-of-execution-of-an-sql-query-in-detail-27"
      ],
      "relatedCards": [
        "ai-ml-comp-support-vector-machines-5",
        "ai-loss-mean-absolute-error-mae-l1-loss-9",
        "ai-model-debugging-overfitting-8",
        "ai-regularization-benefits-of-weight-decay-1",
        "ai-regularization-graphical-treatment-6"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-avoid-#overfitting?-try-one-(or-more)-of-the-following:",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-data-science-mlinterview-are-hard---regardless-whi-26",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Data Science /#MLinterview are Hard - Regardless Which Side of the Table You are On.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>As a jobseeker, it can be really hard to shine, especially when the questions asked have little to no relevance to the actual job. How are you supposed to showcase your ability to build models when the entire interview revolves are binary search trees?</p>\n  </li>\n  <li>\n    <p>As a hiring manager, it’s close to impossible to evaluate modeling skills by just talking to someone, and false positives are really frequent. A question that dramatically reduces the noise on both sides:</p>\n  </li>\n</ul>\n<p>As a jobseeker, it can be really hard to shine, especially when the questions asked have little to no relevance to the actual job. How are you supposed to showcase your ability to build models when the entire interview revolves are binary search trees?</p>\n<p>As a hiring manager, it’s close to impossible to evaluate modeling skills by just talking to someone, and false positives are really frequent. A question that dramatically reduces the noise on both sides:</p>\n<blockquote>\n  <p>“What is the most machine learning complex concept you came across, and how would you explain it to yourself that would have made it easier for you to understand it before you learned it?”</p>\n</blockquote>\n<p>“What is the most machine learning complex concept you came across, and how would you explain it to yourself that would have made it easier for you to understand it before you learned it?”</p>\n<ul>\n  <li>\n    <p>The answer will tell you a lot more about the candidate than you might think:</p>\n\n    <ul>\n      <li>90% of candidates answer “overfitting”. If they’re junior and explain it really well and they’re junior, it means they’re detailed-oriented and try to gain a thorough understanding of the field, but they sure could show more ambition; if they don’t, it means their understanding of the fundamentals is extremely basic.</li>\n      <li>If they answer back-propagation, and they can explain it well, it means they’re more math-oriented than the average and will probably be a good candidate for a research role as an applied DS role.</li>\n      <li>If their answer has something to do with a brand-new ML concept, , and they can explain it well, it means they’re growth-oriented and well-read.</li>\n      <li>Generally speaking, if they answer something overly complicated and pompous, but can’t explain it well, it means they’re trying to impress but have an overall shallow understanding - a good rule of thumb is not hire them.</li>\n    </ul>\n  </li>\n  <li>Now, if you are a candidate, or an ML professional, keep asking yourself that question: “What is the most sophisticated concept, model or architecture you know of?” If you keep giving the same answer, maybe you’ve become complacent, and it’s time for you to learn something new.</li>\n  <li>How would you explain it to a newbie? As Einstein said, if “you can’t explain it simply, you don’t understand it well enough”.</li>\n</ul>\n<p>The answer will tell you a lot more about the candidate than you might think:</p>\n<ul>\n      <li>90% of candidates answer “overfitting”. If they’re junior and explain it really well and they’re junior, it means they’re detailed-oriented and try to gain a thorough understanding of the field, but they sure could show more ambition; if they don’t, it means their understanding of the fundamentals is extremely basic.</li>\n      <li>If they answer back-propagation, and they can explain it well, it means they’re more math-oriented than the average and will probably be a good candidate for a research role as an applied DS role.</li>\n      <li>If their answer has something to do with a brand-new ML concept, , and they can explain it well, it means they’re growth-oriented and well-read.</li>\n      <li>Generally speaking, if they answer something overly complicated and pompous, but can’t explain it well, it means they’re trying to impress but have an overall shallow understanding - a good rule of thumb is not hire them.</li>\n    </ul>",
      "contentMarkdown": "*   As a jobseeker, it can be really hard to shine, especially when the questions asked have little to no relevance to the actual job. How are you supposed to showcase your ability to build models when the entire interview revolves are binary search trees?\n    \n*   As a hiring manager, it’s close to impossible to evaluate modeling skills by just talking to someone, and false positives are really frequent. A question that dramatically reduces the noise on both sides:\n    \n\nAs a jobseeker, it can be really hard to shine, especially when the questions asked have little to no relevance to the actual job. How are you supposed to showcase your ability to build models when the entire interview revolves are binary search trees?\n\nAs a hiring manager, it’s close to impossible to evaluate modeling skills by just talking to someone, and false positives are really frequent. A question that dramatically reduces the noise on both sides:\n\n> “What is the most machine learning complex concept you came across, and how would you explain it to yourself that would have made it easier for you to understand it before you learned it?”\n\n“What is the most machine learning complex concept you came across, and how would you explain it to yourself that would have made it easier for you to understand it before you learned it?”\n\n*   The answer will tell you a lot more about the candidate than you might think:\n    \n    *   90% of candidates answer “overfitting”. If they’re junior and explain it really well and they’re junior, it means they’re detailed-oriented and try to gain a thorough understanding of the field, but they sure could show more ambition; if they don’t, it means their understanding of the fundamentals is extremely basic.\n    *   If they answer back-propagation, and they can explain it well, it means they’re more math-oriented than the average and will probably be a good candidate for a research role as an applied DS role.\n    *   If their answer has something to do with a brand-new ML concept, , and they can explain it well, it means they’re growth-oriented and well-read.\n    *   Generally speaking, if they answer something overly complicated and pompous, but can’t explain it well, it means they’re trying to impress but have an overall shallow understanding - a good rule of thumb is not hire them.\n*   Now, if you are a candidate, or an ML professional, keep asking yourself that question: “What is the most sophisticated concept, model or architecture you know of?” If you keep giving the same answer, maybe you’ve become complacent, and it’s time for you to learn something new.\n*   How would you explain it to a newbie? As Einstein said, if “you can’t explain it simply, you don’t understand it well enough”.\n\nThe answer will tell you a lot more about the candidate than you might think:\n\n*   90% of candidates answer “overfitting”. If they’re junior and explain it really well and they’re junior, it means they’re detailed-oriented and try to gain a thorough understanding of the field, but they sure could show more ambition; if they don’t, it means their understanding of the fundamentals is extremely basic.\n*   If they answer back-propagation, and they can explain it well, it means they’re more math-oriented than the average and will probably be a good candidate for a research role as an applied DS role.\n*   If their answer has something to do with a brand-new ML concept, , and they can explain it well, it means they’re growth-oriented and well-read.\n*   Generally speaking, if they answer something overly complicated and pompous, but can’t explain it well, it means they’re trying to impress but have an overall shallow understanding - a good rule of thumb is not hire them.",
      "order": 26,
      "orderInChapter": 26,
      "difficulty": 3,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 628,
        "contentLength": 3962
      },
      "nextCards": [
        "ai-interview-order-of-execution-of-an-sql-query-in-detail-27",
        "ai-interview-explain-briefly-the-logistic-regression-model-and--28"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-overview-1",
        "ai-decision-trees-and-ensemble-methods-overview-7",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#data-science-/#mlinterview-are-hard---regardless-which-side-of-the-table-you-are-on.",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-order-of-execution-of-an-sql-query-in-detail-27",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Order of Execution of an SQL Query in Detail",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Each query begins with finding the data that we need in a database, and then filtering that data down into something that can be processed and understood as quickly as possible.</p>\n  </li>\n  <li>\n    <p>Because each part of the query is executed sequentially, it’s important to understand the order of execution so that you know what results are accessible where.</p>\n  </li>\n  <li>\n    <p>Consider the below mentioned query :</p>\n  </li>\n</ul>\n<p>Each query begins with finding the data that we need in a database, and then filtering that data down into something that can be processed and understood as quickly as possible.</p>\n<p>Because each part of the query is executed sequentially, it’s important to understand the order of execution so that you know what results are accessible where.</p>\n<p>Consider the below mentioned query :</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code11\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code11\">SELECT DISTINCT column, AGG_FUNC(column_or_expression), …\nFROM mytable\nJOIN another_table\nON mytable.column = another_table.column\nWHERE constraint_expression\nGROUP BY column\nHAVING constraint_expression\nORDER BY column ASC/DESC\nLIMIT count OFFSET COUNT;\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code11\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code11\">SELECT DISTINCT column, AGG_FUNC(column_or_expression), …\nFROM mytable\nJOIN another_table\nON mytable.column = another_table.column\nWHERE constraint_expression\nGROUP BY column\nHAVING constraint_expression\nORDER BY column ASC/DESC\nLIMIT count OFFSET COUNT;\n</code></pre>\n<ul>\n  <li>Query order of execution:</li>\n</ul>\n<p>1.FROMandJOINs</p>\n<ul>\n  <li>TheFROMclause, and subsequentJOINs are first executed to determine the total working set of data that is being queried. This includes subqueries in this clause, and can cause temporary tables to be created under the hood containing all the columns and rows of the tables being joined.</li>\n</ul>\n<p>2.WHERE</p>\n<ul>\n  <li>Once we have the total working set of data, the first-passWHEREconstraints are applied to the individual rows, and rows that do not satisfy the constraint are discarded. Each of the constraints can only access columns directly from the tables requested in theFROMclause. Aliases in theSELECTpart of the query are not accessible in most databases since they may include expressions dependent on parts of the query that have not yet executed.</li>\n</ul>\n<p>3.GROUP BY</p>\n<ul>\n  <li>The remaining rows after theWHEREconstraints are applied are then grouped based on common values in the column specified in theGROUP BYclause. As a result of the grouping, there will only be as many rows as there are unique values in that column. Implicitly, this means that you should only need to use this when you have aggregate functions in your query.</li>\n</ul>\n<p>4.HAVING</p>\n<ul>\n  <li>If the query has aGROUP BYclause, then the constraints in theHAVINGclause are then applied to the grouped rows, discard the grouped rows that don’t satisfy the constraint. Like theWHEREclause, aliases are also not accessible from this step in most databases.</li>\n</ul>\n<p>5.SELECT</p>\n<ul>\n  <li>Any expressions in theSELECTpart of the query are finally computed.</li>\n</ul>\n<p>6.DISTINCT</p>\n<ul>\n  <li>Of the remaining rows, rows with duplicate values in the column marked asDISTINCTwill be discarded.</li>\n</ul>\n<p>7.ORDER BY</p>\n<ul>\n  <li>If an order is specified by theORDER BYclause, the rows are then sorted by the specified data in either ascending or descending order. Since all the expressions in theSELECTpart of the query have been computed, you can reference aliases in this clause.</li>\n</ul>\n<p>8.LIMIT/OFFSET</p>\n<ul>\n  <li>Finally, the rows that fall outside the range specified by theLIMITandOFFSETare discarded, leaving the final set of rows to be returned from the query.</li>\n</ul>",
      "contentMarkdown": "*   Each query begins with finding the data that we need in a database, and then filtering that data down into something that can be processed and understood as quickly as possible.\n    \n*   Because each part of the query is executed sequentially, it’s important to understand the order of execution so that you know what results are accessible where.\n    \n*   Consider the below mentioned query :\n    \n\nEach query begins with finding the data that we need in a database, and then filtering that data down into something that can be processed and understood as quickly as possible.\n\nBecause each part of the query is executed sequentially, it’s important to understand the order of execution so that you know what results are accessible where.\n\nConsider the below mentioned query :\n\n![](https://aman.ai/images/copy.png)\n\n`SELECT DISTINCT column, AGG_FUNC(column_or_expression), … FROM mytable JOIN another_table ON mytable.column = another_table.column WHERE constraint_expression GROUP BY column HAVING constraint_expression ORDER BY column ASC/DESC LIMIT count OFFSET COUNT;`\n\n![](https://aman.ai/images/copy.png)\n\n`SELECT DISTINCT column, AGG_FUNC(column_or_expression), … FROM mytable JOIN another_table ON mytable.column = another_table.column WHERE constraint_expression GROUP BY column HAVING constraint_expression ORDER BY column ASC/DESC LIMIT count OFFSET COUNT;`\n\n*   Query order of execution:\n\n1.FROMandJOINs\n\n*   TheFROMclause, and subsequentJOINs are first executed to determine the total working set of data that is being queried. This includes subqueries in this clause, and can cause temporary tables to be created under the hood containing all the columns and rows of the tables being joined.\n\n2.WHERE\n\n*   Once we have the total working set of data, the first-passWHEREconstraints are applied to the individual rows, and rows that do not satisfy the constraint are discarded. Each of the constraints can only access columns directly from the tables requested in theFROMclause. Aliases in theSELECTpart of the query are not accessible in most databases since they may include expressions dependent on parts of the query that have not yet executed.\n\n3.GROUP BY\n\n*   The remaining rows after theWHEREconstraints are applied are then grouped based on common values in the column specified in theGROUP BYclause. As a result of the grouping, there will only be as many rows as there are unique values in that column. Implicitly, this means that you should only need to use this when you have aggregate functions in your query.\n\n4.HAVING\n\n*   If the query has aGROUP BYclause, then the constraints in theHAVINGclause are then applied to the grouped rows, discard the grouped rows that don’t satisfy the constraint. Like theWHEREclause, aliases are also not accessible from this step in most databases.\n\n5.SELECT\n\n*   Any expressions in theSELECTpart of the query are finally computed.\n\n6.DISTINCT\n\n*   Of the remaining rows, rows with duplicate values in the column marked asDISTINCTwill be discarded.\n\n7.ORDER BY\n\n*   If an order is specified by theORDER BYclause, the rows are then sorted by the specified data in either ascending or descending order. Since all the expressions in theSELECTpart of the query have been computed, you can reference aliases in this clause.\n\n8.LIMIT/OFFSET\n\n*   Finally, the rows that fall outside the range specified by theLIMITandOFFSETare discarded, leaving the final set of rows to be returned from the query.",
      "order": 27,
      "orderInChapter": 27,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 518,
        "contentLength": 4318
      },
      "nextCards": [
        "ai-interview-explain-briefly-the-logistic-regression-model-and--28",
        "ai-interview-describe-briefly-the-hypothesis-testing-and-p-valu-29"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#order-of-execution-of-an-sql-query-in-detail",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-briefly-the-logistic-regression-model-and--28",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Briefly the Logistic Regression Model and State an Example of When You Have Used It Recently?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Logistic regression is used to calculate the probability of occurrence of an event in the form of a dependent output variable based on independent input variables. Logistic regression is commonly used to estimate the probability that an instance belongs to a particular class. If the probability is bigger than 0.5 then it will belong to that class (positive) and if it is below 0.5 it will belong to the other class. This will make it a binary classifier.</li>\n  <li>It is important to remember that the Logistic regression isn’t a classification model, it’s an ordinary type of regression algorithm, and it was developed and used before machine learning, but it can be used in classification when we put a threshold to determine specific categories.</li>\n  <li>There is a lot of classification applications to it: classify email as spam or not, identify whether the patient is healthy or not, etc.</li>\n</ul>",
      "contentMarkdown": "*   Logistic regression is used to calculate the probability of occurrence of an event in the form of a dependent output variable based on independent input variables. Logistic regression is commonly used to estimate the probability that an instance belongs to a particular class. If the probability is bigger than 0.5 then it will belong to that class (positive) and if it is below 0.5 it will belong to the other class. This will make it a binary classifier.\n*   It is important to remember that the Logistic regression isn’t a classification model, it’s an ordinary type of regression algorithm, and it was developed and used before machine learning, but it can be used in classification when we put a threshold to determine specific categories.\n*   There is a lot of classification applications to it: classify email as spam or not, identify whether the patient is healthy or not, etc.",
      "order": 28,
      "orderInChapter": 28,
      "difficulty": 3,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 150,
        "contentLength": 921
      },
      "nextCards": [
        "ai-interview-describe-briefly-the-hypothesis-testing-and-p-valu-29",
        "ai-interview-what-is-an-activation-function-and-discuss-the-use-30"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-overview-1",
        "ai-decision-trees-and-ensemble-methods-overview-7",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-briefly-the-logistic-regression-model-and-state-an-example-of-when-you-have-used-it-recently?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-describe-briefly-the-hypothesis-testing-and-p-valu-29",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Describe Briefly the Hypothesis Testing and P-value in Layman’s Terms? and Give a Practical Application for Them?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In Layman’s terms:\n    <ul>\n      <li>Hypothesis test is where you have a current state (null hypothesis) and an alternative state (alternative hypothesis). You assess the results of both of the states and see some differences. You want to decide whether the difference is due to the alternative approach or not.</li>\n      <li>You use the p-value to decide this, where the p-value is the likelihood of getting the same results the alternative approach achieved if you keep using the existing approach. It’s the probability to find the result in the gaussian distribution of the results you may get from the existing approach.</li>\n      <li>The rule of thumb is to reject the null hypothesis if the p-value &lt; 0.05, which means that the probability to get these results from the existing approach is &lt;95%. But this % changes according to task and domain.</li>\n      <li>To explain the hypothesis testing in layman’s term with an example, suppose we have two drugs A and B, and we want to determine whether these two drugs are the same or different. This idea of trying to determine whether the drugs are the same or different is called hypothesis testing. The null hypothesis is that the drugs are the same, and the p-value helps us decide whether we should reject the null hypothesis or not.</li>\n      <li>p-values are numbers between 0 and 1, and in this particular case, it helps us to quantify how confident we should be to conclude that drug A is different from drug B. The closer the p-value is to 0, the more confident we are that the drugs A and B are different.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Hypothesis test is where you have a current state (null hypothesis) and an alternative state (alternative hypothesis). You assess the results of both of the states and see some differences. You want to decide whether the difference is due to the alternative approach or not.</li>\n      <li>You use the p-value to decide this, where the p-value is the likelihood of getting the same results the alternative approach achieved if you keep using the existing approach. It’s the probability to find the result in the gaussian distribution of the results you may get from the existing approach.</li>\n      <li>The rule of thumb is to reject the null hypothesis if the p-value &lt; 0.05, which means that the probability to get these results from the existing approach is &lt;95%. But this % changes according to task and domain.</li>\n      <li>To explain the hypothesis testing in layman’s term with an example, suppose we have two drugs A and B, and we want to determine whether these two drugs are the same or different. This idea of trying to determine whether the drugs are the same or different is called hypothesis testing. The null hypothesis is that the drugs are the same, and the p-value helps us decide whether we should reject the null hypothesis or not.</li>\n      <li>p-values are numbers between 0 and 1, and in this particular case, it helps us to quantify how confident we should be to conclude that drug A is different from drug B. The closer the p-value is to 0, the more confident we are that the drugs A and B are different.</li>\n    </ul>",
      "contentMarkdown": "*   In Layman’s terms:\n    *   Hypothesis test is where you have a current state (null hypothesis) and an alternative state (alternative hypothesis). You assess the results of both of the states and see some differences. You want to decide whether the difference is due to the alternative approach or not.\n    *   You use the p-value to decide this, where the p-value is the likelihood of getting the same results the alternative approach achieved if you keep using the existing approach. It’s the probability to find the result in the gaussian distribution of the results you may get from the existing approach.\n    *   The rule of thumb is to reject the null hypothesis if the p-value < 0.05, which means that the probability to get these results from the existing approach is <95%. But this % changes according to task and domain.\n    *   To explain the hypothesis testing in layman’s term with an example, suppose we have two drugs A and B, and we want to determine whether these two drugs are the same or different. This idea of trying to determine whether the drugs are the same or different is called hypothesis testing. The null hypothesis is that the drugs are the same, and the p-value helps us decide whether we should reject the null hypothesis or not.\n    *   p-values are numbers between 0 and 1, and in this particular case, it helps us to quantify how confident we should be to conclude that drug A is different from drug B. The closer the p-value is to 0, the more confident we are that the drugs A and B are different.\n\n*   Hypothesis test is where you have a current state (null hypothesis) and an alternative state (alternative hypothesis). You assess the results of both of the states and see some differences. You want to decide whether the difference is due to the alternative approach or not.\n*   You use the p-value to decide this, where the p-value is the likelihood of getting the same results the alternative approach achieved if you keep using the existing approach. It’s the probability to find the result in the gaussian distribution of the results you may get from the existing approach.\n*   The rule of thumb is to reject the null hypothesis if the p-value < 0.05, which means that the probability to get these results from the existing approach is <95%. But this % changes according to task and domain.\n*   To explain the hypothesis testing in layman’s term with an example, suppose we have two drugs A and B, and we want to determine whether these two drugs are the same or different. This idea of trying to determine whether the drugs are the same or different is called hypothesis testing. The null hypothesis is that the drugs are the same, and the p-value helps us decide whether we should reject the null hypothesis or not.\n*   p-values are numbers between 0 and 1, and in this particular case, it helps us to quantify how confident we should be to conclude that drug A is different from drug B. The closer the p-value is to 0, the more confident we are that the drugs A and B are different.",
      "order": 29,
      "orderInChapter": 29,
      "difficulty": 3,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 538,
        "contentLength": 3187
      },
      "nextCards": [
        "ai-interview-what-is-an-activation-function-and-discuss-the-use-30",
        "ai-interview-if-you-roll-a-dice-three-times-what-is-the-probabi-31"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-overview-1",
        "ai-linear-logistic-regression-assumptions-of-linear-regression-2",
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#describe-briefly-the-hypothesis-testing-and-p-value-in-layman’s-terms?-and-give-a-practical-application-for-them?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-an-activation-function-and-discuss-the-use-30",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is an Activation Function and Discuss the Use of an Activation Function? Explain Three Different Types of Activation Functions?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In mathematical terms, the activation function serves as a gate between the current neuron input and its output, going to the next level. Basically, it decides whether neurons should be activated or not.\nIt is used to introduce non-linearity into a model.</li>\n  <li>Activation functions are added to introduce non-linearity to the network, it doesn’t matter how many layers or how many neurons your net has, the output will be linear combinations of the input in the absence of activation functions. In other words, activation functions are what make a linear regression model different from a neural network. We need non-linearity, to capture more complex features and model more complex variations that simple linear models can not capture.</li>\n  <li>There are a lot of activation functions:\n    <ul>\n      <li>Sigmoid function: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-35-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-207\" style=\"width: 10.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 9.065em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1009.01em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-208\"><span class=\"mi\" id=\"MathJax-Span-209\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-210\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-211\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-212\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-213\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-214\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"texatom\" id=\"MathJax-Span-215\"><span class=\"mrow\" id=\"MathJax-Span-216\"><span class=\"mo\" id=\"MathJax-Span-217\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mo\" id=\"MathJax-Span-218\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-219\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-220\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-221\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">e</span><span class=\"mi\" id=\"MathJax-Span-222\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-223\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-224\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mo\" id=\"MathJax-Span-225\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"mi\" id=\"MathJax-Span-226\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-227\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-228\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-35\">f(x) = 1/(1+exp(-x))</script>.\n        <ul>\n          <li>The output value of it is between 0 and 1, we can use it for classification. It has some problems like the gradient vanishing on the extremes, also it is computationally expensive since it uses exp.</li>\n        </ul>\n      </li>\n      <li>ReLU: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-36-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-229\" style=\"width: 8.076em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 6.721em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1006.67em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-230\"><span class=\"mi\" id=\"MathJax-Span-231\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-232\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-233\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-234\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-235\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-236\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">m</span><span class=\"mi\" id=\"MathJax-Span-237\" style=\"font-family: STIXGeneral-Italic;\">a</span><span class=\"mi\" id=\"MathJax-Span-238\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-239\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-240\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-241\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-242\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-243\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-36\">f(x) = max(0,x)</script>.\n        <ul>\n          <li>it returns 0 if the input is negative and the value of the input if the input is positive. It solves the problem of vanishing gradient for the positive side, however, the problem is still on the negative side. It is fast because we use a linear function in it.</li>\n        </ul>\n      </li>\n      <li>Leaky ReLU:</li>\n    </ul>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-37-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>F</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>,</mo><mi>x</mi><mo>&amp;lt;</mo><mn>0</mn><mi>F</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>&amp;gt;=</mo><mn>0</mn></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-244\" style=\"width: 15.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 13.284em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1013.28em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-245\"><span class=\"mi\" id=\"MathJax-Span-246\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-247\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-248\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-249\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-250\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-251\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">a</span><span class=\"mi\" id=\"MathJax-Span-252\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-253\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-254\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-255\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">&lt;</span><span class=\"mn\" id=\"MathJax-Span-256\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span><span class=\"mi\" id=\"MathJax-Span-257\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-258\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-259\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-260\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-261\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-262\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-263\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-264\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-265\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">&gt;<span style=\"font-family: STIXGeneral-Regular; font-style: normal; font-weight: normal;\">=</span></span><span class=\"mn\" id=\"MathJax-Span-266\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>F</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>,</mo><mi>x</mi><mo>&lt;</mo><mn>0</mn><mi>F</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>&gt;=</mo><mn>0</mn></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-37\">F(x) = ax, x < 0\n  F(x) = x, x >= 0</script>\n  </li>\n  <li>It solves the problem of vanishing gradient on both sides by returning a value “a” on the negative side and it does the same thing as ReLU for the positive side.\n    <ul>\n      <li>Softmax: it is usually used at the last layer for a classification problem because it returns a set of probabilities, where the sum of them is 1. Moreover, it is compatible with cross-entropy loss, which is usually the loss function for classification problems.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Sigmoid function: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-35-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-207\" style=\"width: 10.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 9.065em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1009.01em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-208\"><span class=\"mi\" id=\"MathJax-Span-209\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-210\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-211\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-212\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-213\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-214\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"texatom\" id=\"MathJax-Span-215\"><span class=\"mrow\" id=\"MathJax-Span-216\"><span class=\"mo\" id=\"MathJax-Span-217\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mo\" id=\"MathJax-Span-218\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-219\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-220\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-221\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">e</span><span class=\"mi\" id=\"MathJax-Span-222\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-223\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-224\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mo\" id=\"MathJax-Span-225\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"mi\" id=\"MathJax-Span-226\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-227\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-228\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-35\">f(x) = 1/(1+exp(-x))</script>.\n        <ul>\n          <li>The output value of it is between 0 and 1, we can use it for classification. It has some problems like the gradient vanishing on the extremes, also it is computationally expensive since it uses exp.</li>\n        </ul>\n      </li>\n      <li>ReLU: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-36-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-229\" style=\"width: 8.076em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 6.721em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1006.67em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-230\"><span class=\"mi\" id=\"MathJax-Span-231\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-232\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-233\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-234\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-235\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-236\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">m</span><span class=\"mi\" id=\"MathJax-Span-237\" style=\"font-family: STIXGeneral-Italic;\">a</span><span class=\"mi\" id=\"MathJax-Span-238\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-239\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-240\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-241\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-242\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-243\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>x</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-36\">f(x) = max(0,x)</script>.\n        <ul>\n          <li>it returns 0 if the input is negative and the value of the input if the input is positive. It solves the problem of vanishing gradient for the positive side, however, the problem is still on the negative side. It is fast because we use a linear function in it.</li>\n        </ul>\n      </li>\n      <li>Leaky ReLU:</li>\n    </ul>\n<ul>\n          <li>The output value of it is between 0 and 1, we can use it for classification. It has some problems like the gradient vanishing on the extremes, also it is computationally expensive since it uses exp.</li>\n        </ul>\n<ul>\n          <li>it returns 0 if the input is negative and the value of the input if the input is positive. It solves the problem of vanishing gradient for the positive side, however, the problem is still on the negative side. It is fast because we use a linear function in it.</li>\n        </ul>\n<ul>\n      <li>Softmax: it is usually used at the last layer for a classification problem because it returns a set of probabilities, where the sum of them is 1. Moreover, it is compatible with cross-entropy loss, which is usually the loss function for classification problems.</li>\n    </ul>",
      "contentMarkdown": "*   In mathematical terms, the activation function serves as a gate between the current neuron input and its output, going to the next level. Basically, it decides whether neurons should be activated or not. It is used to introduce non-linearity into a model.\n*   Activation functions are added to introduce non-linearity to the network, it doesn’t matter how many layers or how many neurons your net has, the output will be linear combinations of the input in the absence of activation functions. In other words, activation functions are what make a linear regression model different from a neural network. We need non-linearity, to capture more complex features and model more complex variations that simple linear models can not capture.\n*   There are a lot of activation functions:\n    \n    *   Sigmoid function: f(x)\\=1/(1+exp(−x))f(x)\\=1/(1+exp(−x))f(x) = 1/(1+exp(-x)).\n        *   The output value of it is between 0 and 1, we can use it for classification. It has some problems like the gradient vanishing on the extremes, also it is computationally expensive since it uses exp.\n    *   ReLU: f(x)\\=max(0,x)f(x)\\=max(0,x)f(x) = max(0,x).\n        *   it returns 0 if the input is negative and the value of the input if the input is positive. It solves the problem of vanishing gradient for the positive side, however, the problem is still on the negative side. It is fast because we use a linear function in it.\n    *   Leaky ReLU:\n    \n    F(x)\\=ax,x<0F(x)\\=x,x\\>\\=0F(x)\\=ax,x<0F(x)\\=x,x\\>=0\n    \n    F(x) = ax, x < 0 F(x) = x, x >= 0\n*   It solves the problem of vanishing gradient on both sides by returning a value “a” on the negative side and it does the same thing as ReLU for the positive side.\n    *   Softmax: it is usually used at the last layer for a classification problem because it returns a set of probabilities, where the sum of them is 1. Moreover, it is compatible with cross-entropy loss, which is usually the loss function for classification problems.\n\n*   Sigmoid function: f(x)\\=1/(1+exp(−x))f(x)\\=1/(1+exp(−x))f(x) = 1/(1+exp(-x)).\n    *   The output value of it is between 0 and 1, we can use it for classification. It has some problems like the gradient vanishing on the extremes, also it is computationally expensive since it uses exp.\n*   ReLU: f(x)\\=max(0,x)f(x)\\=max(0,x)f(x) = max(0,x).\n    *   it returns 0 if the input is negative and the value of the input if the input is positive. It solves the problem of vanishing gradient for the positive side, however, the problem is still on the negative side. It is fast because we use a linear function in it.\n*   Leaky ReLU:\n\n*   The output value of it is between 0 and 1, we can use it for classification. It has some problems like the gradient vanishing on the extremes, also it is computationally expensive since it uses exp.\n\n*   it returns 0 if the input is negative and the value of the input if the input is positive. It solves the problem of vanishing gradient for the positive side, however, the problem is still on the negative side. It is fast because we use a linear function in it.\n\n*   Softmax: it is usually used at the last layer for a classification problem because it returns a set of probabilities, where the sum of them is 1. Moreover, it is compatible with cross-entropy loss, which is usually the loss function for classification problems.",
      "order": 30,
      "orderInChapter": 30,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "neural network",
        "loss function",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 552,
        "contentLength": 22401
      },
      "nextCards": [
        "ai-interview-if-you-roll-a-dice-three-times-what-is-the-probabi-31",
        "ai-interview-you-and-your-friend-are-playing-a-game-with-a-fair-32"
      ],
      "relatedCards": [
        "ai-loss-cross-entropy-loss-function-1",
        "ai-support-vector-machines-sigmoid-kernel-12",
        "ai-diffusion-models-simplified-training-objective-noise-prediction-los-12",
        "ai-diffusion-models-simplified-training-objective-noise-prediction-los-13",
        "ai-mixture-of-experts-definition-and-taxonomy-59"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-an-activation-function-and-discuss-the-use-of-an-activation-function?-explain-three-different-types-of-activation-functions?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-if-you-roll-a-dice-three-times-what-is-the-probabi-31",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "If You Roll a Dice Three Times, What is the Probability to Get Two Consecutive Threes?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The answer is 11/216.</li>\n  <li>There are different ways to answer this question:\n    <ul>\n      <li>If we roll a dice three times we can get two consecutive 3’s in three ways:\n        <ol>\n          <li>The first two rolls are 3s and the third is any other number with a probability of 1/6 * 1/6 * 5/6.</li>\n          <li>The first one is not three while the other two rolls are 3s with a probability of 5/6 * 1/6 * 1/6.</li>\n          <li>The last one is that the three rolls are 3s with probability 1/6 ^ 3.\n            <ul>\n              <li>So the final result is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-38-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>5</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>216</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-267\" style=\"width: 18.596em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 15.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1015.42em, 2.555em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-268\"><span class=\"mn\" id=\"MathJax-Span-269\" style=\"font-family: STIXGeneral-Regular;\">2</span><span class=\"mo\" id=\"MathJax-Span-270\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-271\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-272\" style=\"font-family: STIXGeneral-Regular;\">5</span><span class=\"texatom\" id=\"MathJax-Span-273\"><span class=\"mrow\" id=\"MathJax-Span-274\"><span class=\"mo\" id=\"MathJax-Span-275\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-276\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-277\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-278\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-279\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-280\"><span class=\"mrow\" id=\"MathJax-Span-281\"><span class=\"mo\" id=\"MathJax-Span-282\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-283\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"msubsup\" id=\"MathJax-Span-284\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.26em, 4.326em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-285\" style=\"font-family: STIXGeneral-Regular;\">)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-286\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-287\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-288\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mo\" id=\"MathJax-Span-289\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-290\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-291\"><span class=\"mrow\" id=\"MathJax-Span-292\"><span class=\"mo\" id=\"MathJax-Span-293\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-294\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-295\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-296\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mn\" id=\"MathJax-Span-297\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">3</span><span class=\"mo\" id=\"MathJax-Span-298\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-299\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">11</span><span class=\"texatom\" id=\"MathJax-Span-300\"><span class=\"mrow\" id=\"MathJax-Span-301\"><span class=\"mo\" id=\"MathJax-Span-302\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-303\" style=\"font-family: STIXGeneral-Regular;\">216</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>2</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>216</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-38\">2 * (5/6 * (1/6)^2) + (1/6)*3 = 11/216</script>.</li>\n            </ul>\n          </li>\n        </ol>\n      </li>\n      <li>By Inclusion-Exclusion Principle:\n        <ul>\n          <li>Probability of at least two consecutive threes:\n  = Probability of two consecutive threes in first two rolls + Probability of two consecutive threes in last two rolls - Probability of three consecutive threes\n  = 2<em>Probability of two consecutive threes in first two rolls - Probability of three consecutive threes\n  = 2</em>1/6<em>1/6 - 1/6</em>1/6*1/6 \n  = 11/216</li>\n          <li>It can be seen also like this:\n            <ul>\n              <li>The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>If we roll a dice three times we can get two consecutive 3’s in three ways:\n        <ol>\n          <li>The first two rolls are 3s and the third is any other number with a probability of 1/6 * 1/6 * 5/6.</li>\n          <li>The first one is not three while the other two rolls are 3s with a probability of 5/6 * 1/6 * 1/6.</li>\n          <li>The last one is that the three rolls are 3s with probability 1/6 ^ 3.\n            <ul>\n              <li>So the final result is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-38-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>5</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>216</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-267\" style=\"width: 18.596em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 15.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1015.42em, 2.555em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-268\"><span class=\"mn\" id=\"MathJax-Span-269\" style=\"font-family: STIXGeneral-Regular;\">2</span><span class=\"mo\" id=\"MathJax-Span-270\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-271\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-272\" style=\"font-family: STIXGeneral-Regular;\">5</span><span class=\"texatom\" id=\"MathJax-Span-273\"><span class=\"mrow\" id=\"MathJax-Span-274\"><span class=\"mo\" id=\"MathJax-Span-275\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-276\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-277\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-278\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-279\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-280\"><span class=\"mrow\" id=\"MathJax-Span-281\"><span class=\"mo\" id=\"MathJax-Span-282\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-283\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"msubsup\" id=\"MathJax-Span-284\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.26em, 4.326em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-285\" style=\"font-family: STIXGeneral-Regular;\">)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-286\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-287\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-288\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mo\" id=\"MathJax-Span-289\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-290\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-291\"><span class=\"mrow\" id=\"MathJax-Span-292\"><span class=\"mo\" id=\"MathJax-Span-293\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-294\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-295\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-296\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mn\" id=\"MathJax-Span-297\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">3</span><span class=\"mo\" id=\"MathJax-Span-298\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-299\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">11</span><span class=\"texatom\" id=\"MathJax-Span-300\"><span class=\"mrow\" id=\"MathJax-Span-301\"><span class=\"mo\" id=\"MathJax-Span-302\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-303\" style=\"font-family: STIXGeneral-Regular;\">216</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>2</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>216</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-38\">2 * (5/6 * (1/6)^2) + (1/6)*3 = 11/216</script>.</li>\n            </ul>\n          </li>\n        </ol>\n      </li>\n      <li>By Inclusion-Exclusion Principle:\n        <ul>\n          <li>Probability of at least two consecutive threes:\n  = Probability of two consecutive threes in first two rolls + Probability of two consecutive threes in last two rolls - Probability of three consecutive threes\n  = 2<em>Probability of two consecutive threes in first two rolls - Probability of three consecutive threes\n  = 2</em>1/6<em>1/6 - 1/6</em>1/6*1/6 \n  = 11/216</li>\n          <li>It can be seen also like this:\n            <ul>\n              <li>The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n<ol>\n          <li>The first two rolls are 3s and the third is any other number with a probability of 1/6 * 1/6 * 5/6.</li>\n          <li>The first one is not three while the other two rolls are 3s with a probability of 5/6 * 1/6 * 1/6.</li>\n          <li>The last one is that the three rolls are 3s with probability 1/6 ^ 3.\n            <ul>\n              <li>So the final result is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-38-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>5</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>216</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-267\" style=\"width: 18.596em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 15.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1015.42em, 2.555em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-268\"><span class=\"mn\" id=\"MathJax-Span-269\" style=\"font-family: STIXGeneral-Regular;\">2</span><span class=\"mo\" id=\"MathJax-Span-270\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-271\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-272\" style=\"font-family: STIXGeneral-Regular;\">5</span><span class=\"texatom\" id=\"MathJax-Span-273\"><span class=\"mrow\" id=\"MathJax-Span-274\"><span class=\"mo\" id=\"MathJax-Span-275\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-276\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-277\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-278\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-279\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-280\"><span class=\"mrow\" id=\"MathJax-Span-281\"><span class=\"mo\" id=\"MathJax-Span-282\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-283\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"msubsup\" id=\"MathJax-Span-284\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.26em, 4.326em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-285\" style=\"font-family: STIXGeneral-Regular;\">)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-286\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-287\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-288\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mo\" id=\"MathJax-Span-289\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-290\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-291\"><span class=\"mrow\" id=\"MathJax-Span-292\"><span class=\"mo\" id=\"MathJax-Span-293\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-294\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-295\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-296\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mn\" id=\"MathJax-Span-297\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">3</span><span class=\"mo\" id=\"MathJax-Span-298\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-299\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">11</span><span class=\"texatom\" id=\"MathJax-Span-300\"><span class=\"mrow\" id=\"MathJax-Span-301\"><span class=\"mo\" id=\"MathJax-Span-302\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-303\" style=\"font-family: STIXGeneral-Regular;\">216</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>2</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>216</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-38\">2 * (5/6 * (1/6)^2) + (1/6)*3 = 11/216</script>.</li>\n            </ul>\n          </li>\n        </ol>\n<ul>\n              <li>So the final result is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-38-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>5</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>6</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>216</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-267\" style=\"width: 18.596em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 15.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1015.42em, 2.555em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-268\"><span class=\"mn\" id=\"MathJax-Span-269\" style=\"font-family: STIXGeneral-Regular;\">2</span><span class=\"mo\" id=\"MathJax-Span-270\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-271\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-272\" style=\"font-family: STIXGeneral-Regular;\">5</span><span class=\"texatom\" id=\"MathJax-Span-273\"><span class=\"mrow\" id=\"MathJax-Span-274\"><span class=\"mo\" id=\"MathJax-Span-275\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-276\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-277\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-278\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-279\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-280\"><span class=\"mrow\" id=\"MathJax-Span-281\"><span class=\"mo\" id=\"MathJax-Span-282\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-283\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"msubsup\" id=\"MathJax-Span-284\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.26em, 4.326em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-285\" style=\"font-family: STIXGeneral-Regular;\">)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-286\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-287\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-288\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mo\" id=\"MathJax-Span-289\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-290\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"texatom\" id=\"MathJax-Span-291\"><span class=\"mrow\" id=\"MathJax-Span-292\"><span class=\"mo\" id=\"MathJax-Span-293\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-294\" style=\"font-family: STIXGeneral-Regular;\">6</span><span class=\"mo\" id=\"MathJax-Span-295\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-296\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mn\" id=\"MathJax-Span-297\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">3</span><span class=\"mo\" id=\"MathJax-Span-298\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-299\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">11</span><span class=\"texatom\" id=\"MathJax-Span-300\"><span class=\"mrow\" id=\"MathJax-Span-301\"><span class=\"mo\" id=\"MathJax-Span-302\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-303\" style=\"font-family: STIXGeneral-Regular;\">216</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>2</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>5</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>6</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><mn>3</mn><mo>=</mo><mn>11</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>216</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-38\">2 * (5/6 * (1/6)^2) + (1/6)*3 = 11/216</script>.</li>\n            </ul>\n<ul>\n          <li>Probability of at least two consecutive threes:\n  = Probability of two consecutive threes in first two rolls + Probability of two consecutive threes in last two rolls - Probability of three consecutive threes\n  = 2<em>Probability of two consecutive threes in first two rolls - Probability of three consecutive threes\n  = 2</em>1/6<em>1/6 - 1/6</em>1/6*1/6 \n  = 11/216</li>\n          <li>It can be seen also like this:\n            <ul>\n              <li>The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.</li>\n            </ul>",
      "contentMarkdown": "*   The answer is 11/216.\n*   There are different ways to answer this question:\n    *   If we roll a dice three times we can get two consecutive 3’s in three ways:\n        1.  The first two rolls are 3s and the third is any other number with a probability of 1/6 \\* 1/6 \\* 5/6.\n        2.  The first one is not three while the other two rolls are 3s with a probability of 5/6 \\* 1/6 \\* 1/6.\n        3.  The last one is that the three rolls are 3s with probability 1/6 ^ 3.\n            *   So the final result is 2∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162 \\* (5/6 \\* (1/6)^2) + (1/6)\\*3 = 11/216.\n    *   By Inclusion-Exclusion Principle:\n        *   Probability of at least two consecutive threes: = Probability of two consecutive threes in first two rolls + Probability of two consecutive threes in last two rolls - Probability of three consecutive threes = 2_Probability of two consecutive threes in first two rolls - Probability of three consecutive threes = 2_1/6_1/6 - 1/6_1/6\\*1/6 = 11/216\n        *   It can be seen also like this:\n            *   The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.\n\n*   If we roll a dice three times we can get two consecutive 3’s in three ways:\n    1.  The first two rolls are 3s and the third is any other number with a probability of 1/6 \\* 1/6 \\* 5/6.\n    2.  The first one is not three while the other two rolls are 3s with a probability of 5/6 \\* 1/6 \\* 1/6.\n    3.  The last one is that the three rolls are 3s with probability 1/6 ^ 3.\n        *   So the final result is 2∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162 \\* (5/6 \\* (1/6)^2) + (1/6)\\*3 = 11/216.\n*   By Inclusion-Exclusion Principle:\n    *   Probability of at least two consecutive threes: = Probability of two consecutive threes in first two rolls + Probability of two consecutive threes in last two rolls - Probability of three consecutive threes = 2_Probability of two consecutive threes in first two rolls - Probability of three consecutive threes = 2_1/6_1/6 - 1/6_1/6\\*1/6 = 11/216\n    *   It can be seen also like this:\n        *   The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.\n\n1.  The first two rolls are 3s and the third is any other number with a probability of 1/6 \\* 1/6 \\* 5/6.\n2.  The first one is not three while the other two rolls are 3s with a probability of 5/6 \\* 1/6 \\* 1/6.\n3.  The last one is that the three rolls are 3s with probability 1/6 ^ 3.\n    *   So the final result is 2∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162 \\* (5/6 \\* (1/6)^2) + (1/6)\\*3 = 11/216.\n\n*   So the final result is 2∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162∗(5/6∗(1/6)2)+(1/6)∗3\\=11/2162 \\* (5/6 \\* (1/6)^2) + (1/6)\\*3 = 11/216.\n\n*   Probability of at least two consecutive threes: = Probability of two consecutive threes in first two rolls + Probability of two consecutive threes in last two rolls - Probability of three consecutive threes = 2_Probability of two consecutive threes in first two rolls - Probability of three consecutive threes = 2_1/6_1/6 - 1/6_1/6\\*1/6 = 11/216\n*   It can be seen also like this:\n    *   The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.\n\n*   The sample space is made of (x, y, z) tuples where each letter can take a value from 1 to 6, therefore the sample space has 6x6x6=216 values, and the number of outcomes that are considered two consecutive threes is (3,3, X) or (X, 3, 3), the number of possible outcomes is therefore 6 for the first scenario (3,3,1) till (3,3,6) and 6 for the other scenario (1,3,3) till (6,3,3) and subtract the duplicate (3,3,3) which appears in both, and this leaves us with a probability of 11/216.",
      "order": 31,
      "orderInChapter": 31,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 850,
        "contentLength": 28382
      },
      "nextCards": [
        "ai-interview-you-and-your-friend-are-playing-a-game-with-a-fair-32",
        "ai-interview-dimensionality-reduction-techniques-33"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#if-you-roll-a-dice-three-times,-what-is-the-probability-to-get-two-consecutive-threes?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-you-and-your-friend-are-playing-a-game-with-a-fair-32",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "You and Your Friend are Playing a Game with a Fair Coin. the Two of You Will Continue to Toss the Coin Until the Sequence HH or TH Shows Up. If HH Shows up First, You Win, and If TH Shows up First Your Friend Win. What is the Probability of You Winning the Game?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>If T is ever flipped, you cannot then reach HH before your friend reaches TH. Therefore, the probability of you winning this is to flip HH initially. Therefore the sample space will be {HH, HT, TH, TT} and the probability of you winning will be (1/4) and your friend (3/4).</li>\n</ul>",
      "contentMarkdown": "*   If T is ever flipped, you cannot then reach HH before your friend reaches TH. Therefore, the probability of you winning this is to flip HH initially. Therefore the sample space will be {HH, HT, TH, TT} and the probability of you winning will be (1/4) and your friend (3/4).",
      "order": 32,
      "orderInChapter": 32,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 51,
        "contentLength": 295
      },
      "nextCards": [
        "ai-interview-dimensionality-reduction-techniques-33",
        "ai-interview-active-learning-34"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#you-and-your-friend-are-playing-a-game-with-a-fair-coin.-the-two-of-you-will-continue-to-toss-the-coin-until-the-sequence-hh-or-th-shows-up.-if-hh-shows-up-first,-you-win,-and-if-th-shows-up-first-your-friend-win.-what-is-the-probability-of-you-winning-the-game?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-dimensionality-reduction-techniques-33",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Dimensionality Reduction Techniques",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Dimensionality reduction techniques help deal with the curse of dimensionality. Some of these are supervised learning approaches whereas others are unsupervised. Here is a quick summary:</p>\n\n    <ul>\n      <li>PCA - Principal Component Analysis is an unsupervised learning approach and can Handle skewed data easily for dimensionality reduction.</li>\n      <li>LDA - Linear Discriminant Analysis is also a dimensionality reduction technique based on eigenvectors but it also maximizes class separation while doing so. Moreover, it is a supervised Learning approach and it performs better with uniformly distributed data.</li>\n      <li>ICA - Independent Component Analysis aims to maximize the statistical independence between variables and is a Supervised learning approach.</li>\n      <li>MDS - Multi dimensional scaling aims to preserve the Euclidean pairwise distances. It is an Unsupervised learning approach.</li>\n      <li>ISOMAP - Also known as Isometric Mapping is another dimensionality reduction technique which preserves geodesic pairwise distances. It is an unsupervised learning approach. It can handle noisy data well.</li>\n      <li>t-SNE - Called the t-distributed stochastic neighbor embedding preserves local structure and is an Unsupervised learning approach.</li>\n    </ul>\n  </li>\n</ul>\n<p>Dimensionality reduction techniques help deal with the curse of dimensionality. Some of these are supervised learning approaches whereas others are unsupervised. Here is a quick summary:</p>\n<ul>\n      <li>PCA - Principal Component Analysis is an unsupervised learning approach and can Handle skewed data easily for dimensionality reduction.</li>\n      <li>LDA - Linear Discriminant Analysis is also a dimensionality reduction technique based on eigenvectors but it also maximizes class separation while doing so. Moreover, it is a supervised Learning approach and it performs better with uniformly distributed data.</li>\n      <li>ICA - Independent Component Analysis aims to maximize the statistical independence between variables and is a Supervised learning approach.</li>\n      <li>MDS - Multi dimensional scaling aims to preserve the Euclidean pairwise distances. It is an Unsupervised learning approach.</li>\n      <li>ISOMAP - Also known as Isometric Mapping is another dimensionality reduction technique which preserves geodesic pairwise distances. It is an unsupervised learning approach. It can handle noisy data well.</li>\n      <li>t-SNE - Called the t-distributed stochastic neighbor embedding preserves local structure and is an Unsupervised learning approach.</li>\n    </ul>",
      "contentMarkdown": "*   Dimensionality reduction techniques help deal with the curse of dimensionality. Some of these are supervised learning approaches whereas others are unsupervised. Here is a quick summary:\n    \n    *   PCA - Principal Component Analysis is an unsupervised learning approach and can Handle skewed data easily for dimensionality reduction.\n    *   LDA - Linear Discriminant Analysis is also a dimensionality reduction technique based on eigenvectors but it also maximizes class separation while doing so. Moreover, it is a supervised Learning approach and it performs better with uniformly distributed data.\n    *   ICA - Independent Component Analysis aims to maximize the statistical independence between variables and is a Supervised learning approach.\n    *   MDS - Multi dimensional scaling aims to preserve the Euclidean pairwise distances. It is an Unsupervised learning approach.\n    *   ISOMAP - Also known as Isometric Mapping is another dimensionality reduction technique which preserves geodesic pairwise distances. It is an unsupervised learning approach. It can handle noisy data well.\n    *   t-SNE - Called the t-distributed stochastic neighbor embedding preserves local structure and is an Unsupervised learning approach.\n\nDimensionality reduction techniques help deal with the curse of dimensionality. Some of these are supervised learning approaches whereas others are unsupervised. Here is a quick summary:\n\n*   PCA - Principal Component Analysis is an unsupervised learning approach and can Handle skewed data easily for dimensionality reduction.\n*   LDA - Linear Discriminant Analysis is also a dimensionality reduction technique based on eigenvectors but it also maximizes class separation while doing so. Moreover, it is a supervised Learning approach and it performs better with uniformly distributed data.\n*   ICA - Independent Component Analysis aims to maximize the statistical independence between variables and is a Supervised learning approach.\n*   MDS - Multi dimensional scaling aims to preserve the Euclidean pairwise distances. It is an Unsupervised learning approach.\n*   ISOMAP - Also known as Isometric Mapping is another dimensionality reduction technique which preserves geodesic pairwise distances. It is an unsupervised learning approach. It can handle noisy data well.\n*   t-SNE - Called the t-distributed stochastic neighbor embedding preserves local structure and is an Unsupervised learning approach.",
      "order": 33,
      "orderInChapter": 33,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "embedding",
        "supervised learning",
        "unsupervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 345,
        "contentLength": 2622
      },
      "nextCards": [
        "ai-interview-active-learning-34",
        "ai-interview-what-is-the-independence-assumption-for-a-naive-ba-35"
      ],
      "relatedCards": [
        "ai-ann-similarity-search-clustering-based-methods-6",
        "ai-clustering-partitioning-clustering-1",
        "ai-ml-comp-model-ensembles-7",
        "ai-reinforcement-learning-practical-considerations-21",
        "ai-preference-optimization-putting-it-all-together-training-llama-9"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#dimensionality-reduction-techniques",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-active-learning-34",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Active Learning",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Active learning is a semi-supervised ML training paradigm which, like all semi-supervised learning techniques, relies on the usage of partially labeled data.</li>\n  <li>Active Learning consists of dynamically selecting the most relevant data by sequentially:\n    <ul>\n      <li>selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy).</li>\n      <li>getting the selected data annotated.</li>\n      <li>training the model with that sample of annotated training data.</li>\n      <li>running inference on the remaining (unannotated) data.</li>\n    </ul>\n  </li>\n  <li>That last step is used to evaluate which records should be then selected for the next iteration (called a loop). However, since there is no ground truth for the data used in the inference step, one cannot simply decide to feed the – data where the model failed to make the correct prediction, and has instead to use metadata (such as the confidence level of the prediction) to make that decision.</li>\n  <li>The easiest and most common querying strategy used for selecting the next batch of useful data consists of picking the records with the lowest confidence level; this is called the least-confidence querying strategy, which is one of many possible querying strategies.</li>\n</ul>\n<ul>\n      <li>selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy).</li>\n      <li>getting the selected data annotated.</li>\n      <li>training the model with that sample of annotated training data.</li>\n      <li>running inference on the remaining (unannotated) data.</li>\n    </ul>",
      "contentMarkdown": "*   Active learning is a semi-supervised ML training paradigm which, like all semi-supervised learning techniques, relies on the usage of partially labeled data.\n*   Active Learning consists of dynamically selecting the most relevant data by sequentially:\n    *   selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy).\n    *   getting the selected data annotated.\n    *   training the model with that sample of annotated training data.\n    *   running inference on the remaining (unannotated) data.\n*   That last step is used to evaluate which records should be then selected for the next iteration (called a loop). However, since there is no ground truth for the data used in the inference step, one cannot simply decide to feed the – data where the model failed to make the correct prediction, and has instead to use metadata (such as the confidence level of the prediction) to make that decision.\n*   The easiest and most common querying strategy used for selecting the next batch of useful data consists of picking the records with the lowest confidence level; this is called the least-confidence querying strategy, which is one of many possible querying strategies.\n\n*   selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy).\n*   getting the selected data annotated.\n*   training the model with that sample of annotated training data.\n*   running inference on the remaining (unannotated) data.",
      "order": 34,
      "orderInChapter": 34,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "supervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 242,
        "contentLength": 1691
      },
      "nextCards": [
        "ai-interview-what-is-the-independence-assumption-for-a-naive-ba-35",
        "ai-interview-what-are-the-applications-of-bayes-theorem-36"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-ml-comp-naive-bayes-classifier-2",
        "ai-transformers-in-transformers-how-does-categorical-cross-entropy-53",
        "ai-reinforcement-learning-direct-method-dm-26",
        "ai-model-compression-weak-supervision-via-distillation-29"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#active-learning",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-independence-assumption-for-a-naive-ba-35",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Independence Assumption for a Naive Bayes Classifier?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Naive bayes assumes that the feature probabilities are independent given the class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-39-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-304\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-305\"><span class=\"mi\" id=\"MathJax-Span-306\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-39\">c</script>, i.e., the features do not depend on each other are totally uncorrelated.</li>\n  <li>This is why the Naive Bayes algorithm is called “naive”.</li>\n  <li>\n    <p>Mathematically, the features are independent given class:</p>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-40-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtable columnalign=&quot;right left right left right left right left right left right left&quot; rowspacing=&quot;3pt&quot; columnspacing=&quot;0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em&quot; displaystyle=&quot;true&quot;><mtr><mtd><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow></mtd><mtd><mi></mi><mo>=</mo><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow></msub><mo>&amp;#x2223;</mo><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub><mo>,</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow></mtd></mtr><mtr><mtd /><mtd><mi></mi><mo>=</mo><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow></mtd></mtr></mtable></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-307\" style=\"width: 20.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 17.034em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.576em, 1016.83em, 3.232em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-308\"><span class=\"mtable\" id=\"MathJax-Span-309\" style=\"padding-right: 0.159em; padding-left: 0.159em;\"><span style=\"display: inline-block; position: relative; width: 16.721em; height: 0px;\"><span style=\"position: absolute; clip: rect(2.555em, 1005.52em, 4.898em, -999.997em); top: -4.008em; left: 0em;\"><span style=\"display: inline-block; position: relative; width: 5.576em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1005.52em, 4.378em, -999.997em); top: -4.633em; right: 0em;\"><span class=\"mtd\" id=\"MathJax-Span-310\"><span class=\"mrow\" id=\"MathJax-Span-311\"><span class=\"mi\" id=\"MathJax-Span-312\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mrow\" id=\"MathJax-Span-313\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-314\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-315\"><span class=\"msubsup\" id=\"MathJax-Span-316\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-317\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-318\"><span class=\"mrow\" id=\"MathJax-Span-319\"><span class=\"mn\" id=\"MathJax-Span-320\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-321\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"msubsup\" id=\"MathJax-Span-322\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-323\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-324\"><span class=\"mrow\" id=\"MathJax-Span-325\"><span class=\"mn\" id=\"MathJax-Span-326\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-327\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-328\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-329\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.857em, 1000em, 4.169em, -999.997em); top: -3.279em; right: 0em;\"><span class=\"mtd\" id=\"MathJax-Span-364\"><span class=\"mrow\" id=\"MathJax-Span-365\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(2.555em, 1011.1em, 5.055em, -999.997em); top: -4.008em; left: 5.576em;\"><span style=\"display: inline-block; position: relative; width: 11.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1011.1em, 4.378em, -999.997em); top: -4.633em; left: 0em;\"><span class=\"mtd\" id=\"MathJax-Span-330\"><span class=\"mrow\" id=\"MathJax-Span-331\"><span class=\"mi\" id=\"MathJax-Span-332\"></span><span class=\"mo\" id=\"MathJax-Span-333\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-334\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">P</span><span class=\"mrow\" id=\"MathJax-Span-335\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-336\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-337\"><span class=\"msubsup\" id=\"MathJax-Span-338\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-339\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-340\"><span class=\"mrow\" id=\"MathJax-Span-341\"><span class=\"mn\" id=\"MathJax-Span-342\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-343\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-344\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-345\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-346\"><span class=\"mrow\" id=\"MathJax-Span-347\"><span class=\"mn\" id=\"MathJax-Span-348\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-349\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-350\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-351\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mi\" id=\"MathJax-Span-352\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"mrow\" id=\"MathJax-Span-353\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-354\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-355\"><span class=\"msubsup\" id=\"MathJax-Span-356\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-357\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-358\"><span class=\"mrow\" id=\"MathJax-Span-359\"><span class=\"mn\" id=\"MathJax-Span-360\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-361\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-362\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-363\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.18em, 1009.59em, 4.378em, -999.997em); top: -3.279em; left: 0em;\"><span class=\"mtd\" id=\"MathJax-Span-366\"><span class=\"mrow\" id=\"MathJax-Span-367\"><span class=\"mi\" id=\"MathJax-Span-368\"></span><span class=\"mo\" id=\"MathJax-Span-369\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-370\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">P</span><span class=\"mrow\" id=\"MathJax-Span-371\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-372\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-373\"><span class=\"msubsup\" id=\"MathJax-Span-374\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-375\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-376\"><span class=\"mrow\" id=\"MathJax-Span-377\"><span class=\"mn\" id=\"MathJax-Span-378\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-379\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-380\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-381\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mi\" id=\"MathJax-Span-382\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"mrow\" id=\"MathJax-Span-383\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-384\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-385\"><span class=\"msubsup\" id=\"MathJax-Span-386\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-387\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-388\"><span class=\"mrow\" id=\"MathJax-Span-389\"><span class=\"mn\" id=\"MathJax-Span-390\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-391\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-392\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-393\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -1.184em; border-left: 0px solid; width: 0px; height: 2.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mtable columnalign=\"right left right left right left right left right left right left\" rowspacing=\"3pt\" columnspacing=\"0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em\" displaystyle=\"true\"><mtr><mtd><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow></mtd><mtd><mi></mi><mo>=</mo><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>1</mn></mrow></msub><mo>∣</mo><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msub><mo>,</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow></mtd></mtr><mtr><mtd></mtd><mtd><mi></mi><mo>=</mo><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>1</mn></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>2</mn></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow></mtd></mtr></mtable></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-40\">\\begin{aligned}\n  P\\left(X_{1}, X_{2} \\mid Y\\right) &=P\\left(X_{1} \\mid X_{2}, Y\\right) P\\left(X_{2} \\mid Y\\right) \\\\\n  &=P\\left(X_{1} \\mid Y\\right) P\\left(X_{2} \\mid Y\\right)\n  \\end{aligned}</script>\n\n    <ul>\n      <li>More generally:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-41-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow></msub><mo>&amp;#x2026;</mo><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mo>=</mo><munder><mo>&amp;#x220F;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-394\" style=\"width: 15.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 13.232em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1013.18em, 2.711em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-395\"><span class=\"mi\" id=\"MathJax-Span-396\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mrow\" id=\"MathJax-Span-397\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-398\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-399\"><span class=\"msubsup\" id=\"MathJax-Span-400\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-401\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-402\"><span class=\"mrow\" id=\"MathJax-Span-403\"><span class=\"mn\" id=\"MathJax-Span-404\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-405\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">…</span><span class=\"msubsup\" id=\"MathJax-Span-406\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-407\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-408\"><span class=\"mrow\" id=\"MathJax-Span-409\"><span class=\"mi\" id=\"MathJax-Span-410\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-411\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-412\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-413\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-414\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"munderover\" id=\"MathJax-Span-415\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.253em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.94em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-416\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∏</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.992em;\"><span class=\"texatom\" id=\"MathJax-Span-417\"><span class=\"mrow\" id=\"MathJax-Span-418\"><span class=\"mi\" id=\"MathJax-Span-419\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-420\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"mrow\" id=\"MathJax-Span-421\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-422\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-423\"><span class=\"msubsup\" id=\"MathJax-Span-424\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-425\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-426\"><span class=\"mrow\" id=\"MathJax-Span-427\"><span class=\"mi\" id=\"MathJax-Span-428\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-429\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-430\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-431\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>n</mi></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mo>=</mo><munder><mo>∏</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-41\">P\\left(X_{1} \\ldots X_{n} \\mid Y\\right)=\\prod_{i} P\\left(X_{i} \\mid Y\\right)</script></li>\n    </ul>\n  </li>\n</ul>\n<p>Mathematically, the features are independent given class:</p>\n<ul>\n      <li>More generally:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-41-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow></msub><mo>&amp;#x2026;</mo><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mo>=</mo><munder><mo>&amp;#x220F;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></msub><mo>&amp;#x2223;</mo><mi>Y</mi></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-394\" style=\"width: 15.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 13.232em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1013.18em, 2.711em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-395\"><span class=\"mi\" id=\"MathJax-Span-396\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mrow\" id=\"MathJax-Span-397\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-398\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-399\"><span class=\"msubsup\" id=\"MathJax-Span-400\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-401\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-402\"><span class=\"mrow\" id=\"MathJax-Span-403\"><span class=\"mn\" id=\"MathJax-Span-404\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-405\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">…</span><span class=\"msubsup\" id=\"MathJax-Span-406\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.044em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-407\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-408\"><span class=\"mrow\" id=\"MathJax-Span-409\"><span class=\"mi\" id=\"MathJax-Span-410\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-411\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-412\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-413\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-414\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"munderover\" id=\"MathJax-Span-415\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 1.253em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.94em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-416\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∏</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.992em;\"><span class=\"texatom\" id=\"MathJax-Span-417\"><span class=\"mrow\" id=\"MathJax-Span-418\"><span class=\"mi\" id=\"MathJax-Span-419\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-420\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"mrow\" id=\"MathJax-Span-421\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-422\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-423\"><span class=\"msubsup\" id=\"MathJax-Span-424\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-425\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-426\"><span class=\"mrow\" id=\"MathJax-Span-427\"><span class=\"mi\" id=\"MathJax-Span-428\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-429\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"mi\" id=\"MathJax-Span-430\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">Y<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-431\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>1</mn></mrow></msub><mo>…</mo><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>n</mi></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow><mo>=</mo><munder><mo>∏</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><mi>P</mi><mrow><mo>(</mo><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></msub><mo>∣</mo><mi>Y</mi></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-41\">P\\left(X_{1} \\ldots X_{n} \\mid Y\\right)=\\prod_{i} P\\left(X_{i} \\mid Y\\right)</script></li>\n    </ul>",
      "contentMarkdown": "*   Naive bayes assumes that the feature probabilities are independent given the class ccc, i.e., the features do not depend on each other are totally uncorrelated.\n*   This is why the Naive Bayes algorithm is called “naive”.\n*   Mathematically, the features are independent given class:\n    \n    P(X1,X2∣Y)\\=P(X1∣X2,Y)P(X2∣Y)\\=P(X1∣Y)P(X2∣Y)P(X1,X2∣Y)\\=P(X1∣X2,Y)P(X2∣Y)\\=P(X1∣Y)P(X2∣Y)\n    \n    \\\\begin{aligned} P\\\\left(X\\_{1}, X\\_{2} \\\\mid Y\\\\right) &=P\\\\left(X\\_{1} \\\\mid X\\_{2}, Y\\\\right) P\\\\left(X\\_{2} \\\\mid Y\\\\right) \\\\\\\\ &=P\\\\left(X\\_{1} \\\\mid Y\\\\right) P\\\\left(X\\_{2} \\\\mid Y\\\\right) \\\\end{aligned}\n    *   More generally: P(X1…Xn∣Y)\\=∏iP(Xi∣Y)P(X1…Xn∣Y)\\=∏iP(Xi∣Y)P\\\\left(X\\_{1} \\\\ldots X\\_{n} \\\\mid Y\\\\right)=\\\\prod\\_{i} P\\\\left(X\\_{i} \\\\mid Y\\\\right)\n\nMathematically, the features are independent given class:\n\n*   More generally: P(X1…Xn∣Y)\\=∏iP(Xi∣Y)P(X1…Xn∣Y)\\=∏iP(Xi∣Y)P\\\\left(X\\_{1} \\\\ldots X\\_{n} \\\\mid Y\\\\right)=\\\\prod\\_{i} P\\\\left(X\\_{i} \\\\mid Y\\\\right)",
      "order": 35,
      "orderInChapter": 35,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 95,
        "contentLength": 33089
      },
      "nextCards": [
        "ai-interview-what-are-the-applications-of-bayes-theorem-36",
        "ai-interview-explain-briefly-batch-gradient-descent-stochastic--37"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-independence-assumption-for-a-naive-bayes-classifier?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-applications-of-bayes-theorem-36",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Applications of Bayes’ Theorem?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Bayes’ Theorem (also known as “Bayes’ Rule”) is a way to “factor” and re-write conditional probabilities in terms of other probabilities. It is one of THE most useful tools when working with probabilities.</li>\n  <li>It can be applied to:\n    <ul>\n      <li>Avoid critical fallacies—like confusing a low false positive rate with a high probability of having a disease after testing positive.</li>\n      <li>Understand how ROC AUC is impacted by class imbalance.</li>\n      <li>Understand how over/undersampling impacts model calibration, i.e. the accuracy of a model’s probabilities.</li>\n      <li>Create “confidence intervals” for any complex statistical system you can dream up, for any sample size.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Avoid critical fallacies—like confusing a low false positive rate with a high probability of having a disease after testing positive.</li>\n      <li>Understand how ROC AUC is impacted by class imbalance.</li>\n      <li>Understand how over/undersampling impacts model calibration, i.e. the accuracy of a model’s probabilities.</li>\n      <li>Create “confidence intervals” for any complex statistical system you can dream up, for any sample size.</li>\n    </ul>",
      "contentMarkdown": "*   Bayes’ Theorem (also known as “Bayes’ Rule”) is a way to “factor” and re-write conditional probabilities in terms of other probabilities. It is one of THE most useful tools when working with probabilities.\n*   It can be applied to:\n    *   Avoid critical fallacies—like confusing a low false positive rate with a high probability of having a disease after testing positive.\n    *   Understand how ROC AUC is impacted by class imbalance.\n    *   Understand how over/undersampling impacts model calibration, i.e. the accuracy of a model’s probabilities.\n    *   Create “confidence intervals” for any complex statistical system you can dream up, for any sample size.\n\n*   Avoid critical fallacies—like confusing a low false positive rate with a high probability of having a disease after testing positive.\n*   Understand how ROC AUC is impacted by class imbalance.\n*   Understand how over/undersampling impacts model calibration, i.e. the accuracy of a model’s probabilities.\n*   Create “confidence intervals” for any complex statistical system you can dream up, for any sample size.",
      "order": 36,
      "orderInChapter": 36,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 164,
        "contentLength": 1217
      },
      "nextCards": [
        "ai-interview-explain-briefly-batch-gradient-descent-stochastic--37",
        "ai-interview-explain-what-is-information-gain-and-entropy-in-th-38"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-applications-of-bayes’-theorem?",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-briefly-batch-gradient-descent-stochastic--37",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Briefly Batch Gradient Descent, Stochastic Gradient Descent, and Mini-batch Gradient Descent? List the Pros and Cons of Each.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Gradient descent is a generic optimization algorithm capable for finding optimal solutions to a wide range of problems. The general idea of gradient descent is to tweak parameters iteratively in order to minimize a cost function.\n    <ul>\n      <li>Batch Gradient Descent:\n        <ul>\n          <li>In Batch Gradient descent the whole training data is used to minimize the loss function by taking a step towards the nearest minimum by calculating the gradient (the direction of descent).</li>\n          <li>Pros:\n            <ul>\n              <li>Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Stochastic Gradient Descent:\n        <ul>\n          <li>Stochastic Gradient Descent picks up a random instance in the training data set at every step and computes the gradient-based only on that single instance.</li>\n          <li>Pros:\n            <ul>\n              <li>It makes the training much faster as it only works on one instance at a time.</li>\n              <li>It become easier to train using large datasets.</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Mini-batch Gradient:\n        <ul>\n          <li>At each step instead of computing the gradients on the whole data set as in the Batch Gradient Descent or using one random instance as in the Stochastic Gradient Descent, this algorithm computes the gradients on small random sets of instances called mini-batches.</li>\n          <li>Pros:\n            <ul>\n              <li>The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.</li>\n              <li>You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>It might be difficult to escape from local minima.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Batch Gradient Descent:\n        <ul>\n          <li>In Batch Gradient descent the whole training data is used to minimize the loss function by taking a step towards the nearest minimum by calculating the gradient (the direction of descent).</li>\n          <li>Pros:\n            <ul>\n              <li>Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Stochastic Gradient Descent:\n        <ul>\n          <li>Stochastic Gradient Descent picks up a random instance in the training data set at every step and computes the gradient-based only on that single instance.</li>\n          <li>Pros:\n            <ul>\n              <li>It makes the training much faster as it only works on one instance at a time.</li>\n              <li>It become easier to train using large datasets.</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Mini-batch Gradient:\n        <ul>\n          <li>At each step instead of computing the gradients on the whole data set as in the Batch Gradient Descent or using one random instance as in the Stochastic Gradient Descent, this algorithm computes the gradients on small random sets of instances called mini-batches.</li>\n          <li>Pros:\n            <ul>\n              <li>The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.</li>\n              <li>You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>It might be difficult to escape from local minima.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>In Batch Gradient descent the whole training data is used to minimize the loss function by taking a step towards the nearest minimum by calculating the gradient (the direction of descent).</li>\n          <li>Pros:\n            <ul>\n              <li>Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).</li>\n            </ul>\n<ul>\n              <li>Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.</li>\n            </ul>\n<ul>\n          <li>Stochastic Gradient Descent picks up a random instance in the training data set at every step and computes the gradient-based only on that single instance.</li>\n          <li>Pros:\n            <ul>\n              <li>It makes the training much faster as it only works on one instance at a time.</li>\n              <li>It become easier to train using large datasets.</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>It makes the training much faster as it only works on one instance at a time.</li>\n              <li>It become easier to train using large datasets.</li>\n            </ul>\n<ul>\n              <li>Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.</li>\n            </ul>\n<ul>\n          <li>At each step instead of computing the gradients on the whole data set as in the Batch Gradient Descent or using one random instance as in the Stochastic Gradient Descent, this algorithm computes the gradients on small random sets of instances called mini-batches.</li>\n          <li>Pros:\n            <ul>\n              <li>The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.</li>\n              <li>You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.</li>\n            </ul>\n          </li>\n          <li>Cons:\n            <ul>\n              <li>It might be difficult to escape from local minima.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.</li>\n              <li>You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.</li>\n            </ul>\n<ul>\n              <li>It might be difficult to escape from local minima.</li>\n            </ul>\n<p><img src=\"/primers/ai/assets/interview/gd.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Gradient descent is a generic optimization algorithm capable for finding optimal solutions to a wide range of problems. The general idea of gradient descent is to tweak parameters iteratively in order to minimize a cost function.\n    *   Batch Gradient Descent:\n        *   In Batch Gradient descent the whole training data is used to minimize the loss function by taking a step towards the nearest minimum by calculating the gradient (the direction of descent).\n        *   Pros:\n            *   Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).\n        *   Cons:\n            *   Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.\n    *   Stochastic Gradient Descent:\n        *   Stochastic Gradient Descent picks up a random instance in the training data set at every step and computes the gradient-based only on that single instance.\n        *   Pros:\n            *   It makes the training much faster as it only works on one instance at a time.\n            *   It become easier to train using large datasets.\n        *   Cons:\n            *   Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.\n    *   Mini-batch Gradient:\n        *   At each step instead of computing the gradients on the whole data set as in the Batch Gradient Descent or using one random instance as in the Stochastic Gradient Descent, this algorithm computes the gradients on small random sets of instances called mini-batches.\n        *   Pros:\n            *   The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.\n            *   You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.\n        *   Cons:\n            *   It might be difficult to escape from local minima.\n\n*   Batch Gradient Descent:\n    *   In Batch Gradient descent the whole training data is used to minimize the loss function by taking a step towards the nearest minimum by calculating the gradient (the direction of descent).\n    *   Pros:\n        *   Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).\n    *   Cons:\n        *   Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.\n*   Stochastic Gradient Descent:\n    *   Stochastic Gradient Descent picks up a random instance in the training data set at every step and computes the gradient-based only on that single instance.\n    *   Pros:\n        *   It makes the training much faster as it only works on one instance at a time.\n        *   It become easier to train using large datasets.\n    *   Cons:\n        *   Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.\n*   Mini-batch Gradient:\n    *   At each step instead of computing the gradients on the whole data set as in the Batch Gradient Descent or using one random instance as in the Stochastic Gradient Descent, this algorithm computes the gradients on small random sets of instances called mini-batches.\n    *   Pros:\n        *   The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.\n        *   You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.\n    *   Cons:\n        *   It might be difficult to escape from local minima.\n\n*   In Batch Gradient descent the whole training data is used to minimize the loss function by taking a step towards the nearest minimum by calculating the gradient (the direction of descent).\n*   Pros:\n    *   Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).\n*   Cons:\n    *   Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.\n\n*   Since the whole data set is used to calculate the gradient it will be stable and reach the minimum of the cost function without bouncing around the loss function landscape (if the learning rate is chosen correctly).\n\n*   Since batch gradient descent uses all the training set to compute the gradient at every step, it will be very slow especially if the size of the training data is large.\n\n*   Stochastic Gradient Descent picks up a random instance in the training data set at every step and computes the gradient-based only on that single instance.\n*   Pros:\n    *   It makes the training much faster as it only works on one instance at a time.\n    *   It become easier to train using large datasets.\n*   Cons:\n    *   Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.\n\n*   It makes the training much faster as it only works on one instance at a time.\n*   It become easier to train using large datasets.\n\n*   Due to the stochastic (random) nature of this algorithm, this algorithm is much less stable than the batch gradient descent. Instead of gently decreasing until it reaches the minimum, the cost function will bounce up and down, decreasing only on average. Over time it will end up very close to the minimum, but once it gets there it will continue to bounce around, not settling down there. So once the algorithm stops, the final parameters would likely be good but not optimal. For this reason, it is important to use a training schedule to overcome this randomness.\n\n*   At each step instead of computing the gradients on the whole data set as in the Batch Gradient Descent or using one random instance as in the Stochastic Gradient Descent, this algorithm computes the gradients on small random sets of instances called mini-batches.\n*   Pros:\n    *   The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.\n    *   You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.\n*   Cons:\n    *   It might be difficult to escape from local minima.\n\n*   The algorithm’s progress space is less erratic than with Stochastic Gradient Descent, especially with large mini-batches.\n*   You can get a performance boost from hardware optimization of matrix operations, especially when using GPUs.\n\n*   It might be difficult to escape from local minima.\n\n![](/primers/ai/assets/interview/gd.jpeg)",
      "order": 37,
      "orderInChapter": 37,
      "difficulty": 4,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "optimization",
        "gradient descent",
        "loss function"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 1354,
        "contentLength": 10440
      },
      "nextCards": [
        "ai-interview-explain-what-is-information-gain-and-entropy-in-th-38",
        "ai-interview-what-are-some-applications-of-rl-beyond-gaming-and-39"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27",
        "ai-decision-trees-and-ensemble-methods-what-role-does-the-learning-rate-play-in-training--30",
        "ai-regularization-l1l1l1-regularization-feature-selection-and-weight-7",
        "ai-gemma-3n-training-strategy-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-briefly-batch-gradient-descent,-stochastic-gradient-descent,-and-mini-batch-gradient-descent?-list-the-pros-and-cons-of-each.",
      "scrapedAt": "2025-12-28T11:58:12.836Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-what-is-information-gain-and-entropy-in-th-38",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain What is Information Gain and Entropy in the Context of Decision Trees?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Entropy and Information Gain are two key metrics used in determining the relevance of decision making when constructing a decision tree model and to determine the nodes and the best way to split.</li>\n  <li>The idea of a decision tree is to divide the data set into smaller data sets based on the descriptive features until we reach a small enough set that contains data points that fall under one label.</li>\n  <li>Entropy is the measure of impurity, disorder, or uncertainty in a bunch of examples. Entropy controls how a Decision Tree decides to split the data.\nInformation gain calculates the reduction in entropy or surprise from transforming a dataset in some way. It is commonly used in the construction of decision trees from a training dataset, by evaluating the information gain for each variable, and selecting the variable that maximizes the information gain, which in turn minimizes the entropy and best splits the dataset into groups for effective classification.</li>\n</ul>",
      "contentMarkdown": "*   Entropy and Information Gain are two key metrics used in determining the relevance of decision making when constructing a decision tree model and to determine the nodes and the best way to split.\n*   The idea of a decision tree is to divide the data set into smaller data sets based on the descriptive features until we reach a small enough set that contains data points that fall under one label.\n*   Entropy is the measure of impurity, disorder, or uncertainty in a bunch of examples. Entropy controls how a Decision Tree decides to split the data. Information gain calculates the reduction in entropy or surprise from transforming a dataset in some way. It is commonly used in the construction of decision trees from a training dataset, by evaluating the information gain for each variable, and selecting the variable that maximizes the information gain, which in turn minimizes the entropy and best splits the dataset into groups for effective classification.",
      "order": 38,
      "orderInChapter": 38,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 161,
        "contentLength": 999
      },
      "nextCards": [
        "ai-interview-what-are-some-applications-of-rl-beyond-gaming-and-39",
        "ai-interview-you-are-using-a-deep-neural-network-for-a-predicti-40"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-what-is-information-gain-and-entropy-in-the-context-of-decision-trees?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-some-applications-of-rl-beyond-gaming-and-39",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Some Applications of RL Beyond Gaming and Self-driving Cars?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Reinforcement learning is NOT just used in gaming and self-driving cars, here are three common use cases you should know in 2022:</li>\n</ul>\n<ol>\n  <li>\n    <p>Multi-arm bandit testing (MAB)</p>\n\n    <ul>\n      <li>A little bit about reinforcement learning (RL): you train an agent to interact with the environment and figure out the optimum policy which maximizes the reward (a metric you select).</li>\n      <li>MAB is a classic reinforcement learning problem that can be used to help you find a best options out of a lot of treatments in experimentation.</li>\n      <li>Unlike A/B tests, MAB tries to maximizes a metric (reward) during the course of the test. It usually has a lot of treatments to select from. The trade-off is that you can draw causal inference through traditional A/B testing, but it’s hard to analyze each treatment through MAB; however, because it’s dynamic, it might be faster to select the best treatment than A/B testing.</li>\n    </ul>\n  </li>\n  <li>\n    <p>Recommendation engines</p>\n\n    <ul>\n      <li>While traditional matrix factorization works well for recommendation engines, using reinforcement learning can help you maximize metrics like customer engagement and metrics that measure downstream impact.</li>\n      <li>For example, social media can use RL to maximize ‘time spent’ or ‘review score’ when recommending content; so this way, instead of just recommending similar content, you might also help customers discover new content or other popular content they like.</li>\n    </ul>\n  </li>\n  <li>\n    <p>Portfolio Management</p>\n\n    <ul>\n      <li>RL has been used in finance recently as well. Data scientist can train the agent to interact with a trading environment to maximize the return of the portfolio. For example, if the agent selects an allocation of 70% stock, 10% Cash, and 20% bond, the agent gets a positive or negative reward for this allocation. Through iteration, the agent finds out the best allocation.</li>\n      <li>Robo-advisers can also use RL to learn investors risk tolerance.</li>\n      <li>Of course, self-driving cars, gaming, robotics use RL heavily, but I’ve seen data scientists from industries mentioned above (retail, social media, finance) start to use more RL in their day-to-day work.</li>\n    </ul>\n  </li>\n</ol>\n<p>Multi-arm bandit testing (MAB)</p>\n<ul>\n      <li>A little bit about reinforcement learning (RL): you train an agent to interact with the environment and figure out the optimum policy which maximizes the reward (a metric you select).</li>\n      <li>MAB is a classic reinforcement learning problem that can be used to help you find a best options out of a lot of treatments in experimentation.</li>\n      <li>Unlike A/B tests, MAB tries to maximizes a metric (reward) during the course of the test. It usually has a lot of treatments to select from. The trade-off is that you can draw causal inference through traditional A/B testing, but it’s hard to analyze each treatment through MAB; however, because it’s dynamic, it might be faster to select the best treatment than A/B testing.</li>\n    </ul>\n<p>Recommendation engines</p>\n<ul>\n      <li>While traditional matrix factorization works well for recommendation engines, using reinforcement learning can help you maximize metrics like customer engagement and metrics that measure downstream impact.</li>\n      <li>For example, social media can use RL to maximize ‘time spent’ or ‘review score’ when recommending content; so this way, instead of just recommending similar content, you might also help customers discover new content or other popular content they like.</li>\n    </ul>\n<p>Portfolio Management</p>\n<ul>\n      <li>RL has been used in finance recently as well. Data scientist can train the agent to interact with a trading environment to maximize the return of the portfolio. For example, if the agent selects an allocation of 70% stock, 10% Cash, and 20% bond, the agent gets a positive or negative reward for this allocation. Through iteration, the agent finds out the best allocation.</li>\n      <li>Robo-advisers can also use RL to learn investors risk tolerance.</li>\n      <li>Of course, self-driving cars, gaming, robotics use RL heavily, but I’ve seen data scientists from industries mentioned above (retail, social media, finance) start to use more RL in their day-to-day work.</li>\n    </ul>",
      "contentMarkdown": "*   Reinforcement learning is NOT just used in gaming and self-driving cars, here are three common use cases you should know in 2022:\n\n1.  Multi-arm bandit testing (MAB)\n    \n    *   A little bit about reinforcement learning (RL): you train an agent to interact with the environment and figure out the optimum policy which maximizes the reward (a metric you select).\n    *   MAB is a classic reinforcement learning problem that can be used to help you find a best options out of a lot of treatments in experimentation.\n    *   Unlike A/B tests, MAB tries to maximizes a metric (reward) during the course of the test. It usually has a lot of treatments to select from. The trade-off is that you can draw causal inference through traditional A/B testing, but it’s hard to analyze each treatment through MAB; however, because it’s dynamic, it might be faster to select the best treatment than A/B testing.\n2.  Recommendation engines\n    \n    *   While traditional matrix factorization works well for recommendation engines, using reinforcement learning can help you maximize metrics like customer engagement and metrics that measure downstream impact.\n    *   For example, social media can use RL to maximize ‘time spent’ or ‘review score’ when recommending content; so this way, instead of just recommending similar content, you might also help customers discover new content or other popular content they like.\n3.  Portfolio Management\n    \n    *   RL has been used in finance recently as well. Data scientist can train the agent to interact with a trading environment to maximize the return of the portfolio. For example, if the agent selects an allocation of 70% stock, 10% Cash, and 20% bond, the agent gets a positive or negative reward for this allocation. Through iteration, the agent finds out the best allocation.\n    *   Robo-advisers can also use RL to learn investors risk tolerance.\n    *   Of course, self-driving cars, gaming, robotics use RL heavily, but I’ve seen data scientists from industries mentioned above (retail, social media, finance) start to use more RL in their day-to-day work.\n\nMulti-arm bandit testing (MAB)\n\n*   A little bit about reinforcement learning (RL): you train an agent to interact with the environment and figure out the optimum policy which maximizes the reward (a metric you select).\n*   MAB is a classic reinforcement learning problem that can be used to help you find a best options out of a lot of treatments in experimentation.\n*   Unlike A/B tests, MAB tries to maximizes a metric (reward) during the course of the test. It usually has a lot of treatments to select from. The trade-off is that you can draw causal inference through traditional A/B testing, but it’s hard to analyze each treatment through MAB; however, because it’s dynamic, it might be faster to select the best treatment than A/B testing.\n\nRecommendation engines\n\n*   While traditional matrix factorization works well for recommendation engines, using reinforcement learning can help you maximize metrics like customer engagement and metrics that measure downstream impact.\n*   For example, social media can use RL to maximize ‘time spent’ or ‘review score’ when recommending content; so this way, instead of just recommending similar content, you might also help customers discover new content or other popular content they like.\n\nPortfolio Management\n\n*   RL has been used in finance recently as well. Data scientist can train the agent to interact with a trading environment to maximize the return of the portfolio. For example, if the agent selects an allocation of 70% stock, 10% Cash, and 20% bond, the agent gets a positive or negative reward for this allocation. Through iteration, the agent finds out the best allocation.\n*   Robo-advisers can also use RL to learn investors risk tolerance.\n*   Of course, self-driving cars, gaming, robotics use RL heavily, but I’ve seen data scientists from industries mentioned above (retail, social media, finance) start to use more RL in their day-to-day work.",
      "order": 39,
      "orderInChapter": 39,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "reinforcement learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 640,
        "contentLength": 4366
      },
      "nextCards": [
        "ai-interview-you-are-using-a-deep-neural-network-for-a-predicti-40",
        "ai-interview-explain-the-linear-regression-model-and-discuss-it-41"
      ],
      "relatedCards": [
        "ai-reinforcement-learning-model-free-reinforcement-learning-13",
        "ai-reinforcement-learning-on-policy-vs-off-policy-reinforcement-learning-14",
        "ai-reinforcement-learning-reward-function-design-41",
        "ai-reinforcement-learning-what-are-the-differences-between-the-value-return--42",
        "ai-agents-implementation-details-for-responsible-agents-66"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-applications-of-rl-beyond-gaming-and-self-driving-cars?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-you-are-using-a-deep-neural-network-for-a-predicti-40",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "You are Using a Deep Neural Network for a Prediction Task. After Training Your Model, You Notice That It is Strongly Overfitting the Training Set and That the Performance on the Test Isn’t Good. What Can You Do to Reduce Overfitting?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>To reduce overfitting in a deep neural network changes can be made in three places/stages: The input data to the network, the network architecture, and the training process:\n    <ol>\n      <li>The input data to the network:</li>\n    </ol>\n    <ul>\n      <li>Check if all the features are available and reliable</li>\n      <li>Check if the training sample distribution is the same as the validation and test set distribution. Because if there is a difference in validation set distribution then it is hard for the model to predict as these complex patterns are unknown to the model.</li>\n      <li>Check for train / valid data contamination (or leakage)</li>\n      <li>The dataset size is enough, if not try data augmentation to increase the data size</li>\n      <li>The dataset is balanced\n        <ol>\n          <li>Network architecture:</li>\n        </ol>\n      </li>\n      <li>Overfitting could be due to model complexity. Question each component:\n        <ul>\n          <li>can fully connect layers be replaced with convolutional + pooling layers?</li>\n          <li>what is the justification for the number of layers and number of neurons chosen? Given how hard it is to tune these, can a pre-trained model be used?</li>\n        </ul>\n      </li>\n      <li>Add regularization - ridge (l1), lasso (l2), elastic net (both)</li>\n      <li>Add dropouts</li>\n      <li>Add batch normalization\n        <ol>\n          <li>The training process:</li>\n        </ol>\n      </li>\n      <li>Improvements in validation losses should decide when to stop training. Use callbacks for early stopping when there are no significant changes in the validation loss and restore_best_weights.</li>\n    </ul>\n  </li>\n</ul>\n<ol>\n      <li>The input data to the network:</li>\n    </ol>\n<ul>\n      <li>Check if all the features are available and reliable</li>\n      <li>Check if the training sample distribution is the same as the validation and test set distribution. Because if there is a difference in validation set distribution then it is hard for the model to predict as these complex patterns are unknown to the model.</li>\n      <li>Check for train / valid data contamination (or leakage)</li>\n      <li>The dataset size is enough, if not try data augmentation to increase the data size</li>\n      <li>The dataset is balanced\n        <ol>\n          <li>Network architecture:</li>\n        </ol>\n      </li>\n      <li>Overfitting could be due to model complexity. Question each component:\n        <ul>\n          <li>can fully connect layers be replaced with convolutional + pooling layers?</li>\n          <li>what is the justification for the number of layers and number of neurons chosen? Given how hard it is to tune these, can a pre-trained model be used?</li>\n        </ul>\n      </li>\n      <li>Add regularization - ridge (l1), lasso (l2), elastic net (both)</li>\n      <li>Add dropouts</li>\n      <li>Add batch normalization\n        <ol>\n          <li>The training process:</li>\n        </ol>\n      </li>\n      <li>Improvements in validation losses should decide when to stop training. Use callbacks for early stopping when there are no significant changes in the validation loss and restore_best_weights.</li>\n    </ul>\n<ol>\n          <li>Network architecture:</li>\n        </ol>\n<ul>\n          <li>can fully connect layers be replaced with convolutional + pooling layers?</li>\n          <li>what is the justification for the number of layers and number of neurons chosen? Given how hard it is to tune these, can a pre-trained model be used?</li>\n        </ul>\n<ol>\n          <li>The training process:</li>\n        </ol>",
      "contentMarkdown": "*   To reduce overfitting in a deep neural network changes can be made in three places/stages: The input data to the network, the network architecture, and the training process:\n    \n    1.  The input data to the network:\n    \n    *   Check if all the features are available and reliable\n    *   Check if the training sample distribution is the same as the validation and test set distribution. Because if there is a difference in validation set distribution then it is hard for the model to predict as these complex patterns are unknown to the model.\n    *   Check for train / valid data contamination (or leakage)\n    *   The dataset size is enough, if not try data augmentation to increase the data size\n    *   The dataset is balanced\n        1.  Network architecture:\n    *   Overfitting could be due to model complexity. Question each component:\n        *   can fully connect layers be replaced with convolutional + pooling layers?\n        *   what is the justification for the number of layers and number of neurons chosen? Given how hard it is to tune these, can a pre-trained model be used?\n    *   Add regularization - ridge (l1), lasso (l2), elastic net (both)\n    *   Add dropouts\n    *   Add batch normalization\n        1.  The training process:\n    *   Improvements in validation losses should decide when to stop training. Use callbacks for early stopping when there are no significant changes in the validation loss and restore\\_best\\_weights.\n\n1.  The input data to the network:\n\n*   Check if all the features are available and reliable\n*   Check if the training sample distribution is the same as the validation and test set distribution. Because if there is a difference in validation set distribution then it is hard for the model to predict as these complex patterns are unknown to the model.\n*   Check for train / valid data contamination (or leakage)\n*   The dataset size is enough, if not try data augmentation to increase the data size\n*   The dataset is balanced\n    1.  Network architecture:\n*   Overfitting could be due to model complexity. Question each component:\n    *   can fully connect layers be replaced with convolutional + pooling layers?\n    *   what is the justification for the number of layers and number of neurons chosen? Given how hard it is to tune these, can a pre-trained model be used?\n*   Add regularization - ridge (l1), lasso (l2), elastic net (both)\n*   Add dropouts\n*   Add batch normalization\n    1.  The training process:\n*   Improvements in validation losses should decide when to stop training. Use callbacks for early stopping when there are no significant changes in the validation loss and restore\\_best\\_weights.\n\n1.  Network architecture:\n\n*   can fully connect layers be replaced with convolutional + pooling layers?\n*   what is the justification for the number of layers and number of neurons chosen? Given how hard it is to tune these, can a pre-trained model be used?\n\n1.  The training process:",
      "order": 40,
      "orderInChapter": 40,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "neural network",
        "convolution",
        "regularization",
        "dropout",
        "batch normalization",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 473,
        "contentLength": 3621
      },
      "nextCards": [
        "ai-interview-explain-the-linear-regression-model-and-discuss-it-41",
        "ai-interview-explain-briefly-the-k-means-clustering-and-how-can-42"
      ],
      "relatedCards": [
        "ai-bias-variance-tradeoff-overfitting-and-underfitting-common-challenges-in--13",
        "ai-decision-trees-and-ensemble-methods-what-are-the-biggest-advantages-of-using-gbdts-com-22",
        "ai-top-30-papers-deep-speech-2-end-to-end-speech-recognition-in-eng-21",
        "ai-dropout-use-a-larger-network-3",
        "ai-bias-variance-tradeoff-techniques-to-prevent-overfitting-10"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#you-are-using-a-deep-neural-network-for-a-prediction-task.-after-training-your-model,-you-notice-that-it-is-strongly-overfitting-the-training-set-and-that-the-performance-on-the-test-isn’t-good.-what-can-you-do-to-reduce-overfitting?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-linear-regression-model-and-discuss-it-41",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain the Linear Regression Model and Discuss Its Assumption?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Linear regression is a supervised statistical model to predict dependent variable quantity based on independent variables.</li>\n  <li>Linear regression is a parametric model and the objective of linear regression is that it has to learn coefficients using the training data and predict the target value given only independent values.</li>\n  <li>Some of the linear regression assumptions and how to validate them:\n    <ol>\n      <li>Linear relationship between independent and dependent variables</li>\n      <li>Independent residuals and the constant residuals at every <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-42-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-432\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-433\"><span class=\"mi\" id=\"MathJax-Span-434\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-42\">x</script>: We can check for 1 and 2 by plotting the residuals(error terms) against the fitted values (upper left graph). Generally, we should look for a lack of patterns and a consistent variance across the horizontal line.</li>\n      <li>Normally distributed residuals: We can check for this using a couple of methods:\n -Q-Q-plot(upper right graph): If data is normally distributed, points should roughly align with the 45-degree line.\n -Boxplot: it also helps visualize outliers\n -Shapiro–Wilk test: If the p-value is lower than the chosen threshold, then the null hypothesis (Data is normally distributed) is rejected.</li>\n      <li>Low multicollinearity\n        <ul>\n          <li>You can calculate the VIF (Variable Inflation Factors) using your favorite statistical tool. If the value for each covariate is lower than 10 (some say 5), you’re good to go.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>The figure below summarizes these assumptions.</li>\n</ul>\n<ol>\n      <li>Linear relationship between independent and dependent variables</li>\n      <li>Independent residuals and the constant residuals at every <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-42-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-432\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-433\"><span class=\"mi\" id=\"MathJax-Span-434\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-42\">x</script>: We can check for 1 and 2 by plotting the residuals(error terms) against the fitted values (upper left graph). Generally, we should look for a lack of patterns and a consistent variance across the horizontal line.</li>\n      <li>Normally distributed residuals: We can check for this using a couple of methods:\n -Q-Q-plot(upper right graph): If data is normally distributed, points should roughly align with the 45-degree line.\n -Boxplot: it also helps visualize outliers\n -Shapiro–Wilk test: If the p-value is lower than the chosen threshold, then the null hypothesis (Data is normally distributed) is rejected.</li>\n      <li>Low multicollinearity\n        <ul>\n          <li>You can calculate the VIF (Variable Inflation Factors) using your favorite statistical tool. If the value for each covariate is lower than 10 (some say 5), you’re good to go.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>You can calculate the VIF (Variable Inflation Factors) using your favorite statistical tool. If the value for each covariate is lower than 10 (some say 5), you’re good to go.</li>\n        </ul>\n<p><img src=\"/primers/ai/assets/interview/lr.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Linear regression is a supervised statistical model to predict dependent variable quantity based on independent variables.\n*   Linear regression is a parametric model and the objective of linear regression is that it has to learn coefficients using the training data and predict the target value given only independent values.\n*   Some of the linear regression assumptions and how to validate them:\n    1.  Linear relationship between independent and dependent variables\n    2.  Independent residuals and the constant residuals at every xxx: We can check for 1 and 2 by plotting the residuals(error terms) against the fitted values (upper left graph). Generally, we should look for a lack of patterns and a consistent variance across the horizontal line.\n    3.  Normally distributed residuals: We can check for this using a couple of methods: -Q-Q-plot(upper right graph): If data is normally distributed, points should roughly align with the 45-degree line. -Boxplot: it also helps visualize outliers -Shapiro–Wilk test: If the p-value is lower than the chosen threshold, then the null hypothesis (Data is normally distributed) is rejected.\n    4.  Low multicollinearity\n        *   You can calculate the VIF (Variable Inflation Factors) using your favorite statistical tool. If the value for each covariate is lower than 10 (some say 5), you’re good to go.\n*   The figure below summarizes these assumptions.\n\n1.  Linear relationship between independent and dependent variables\n2.  Independent residuals and the constant residuals at every xxx: We can check for 1 and 2 by plotting the residuals(error terms) against the fitted values (upper left graph). Generally, we should look for a lack of patterns and a consistent variance across the horizontal line.\n3.  Normally distributed residuals: We can check for this using a couple of methods: -Q-Q-plot(upper right graph): If data is normally distributed, points should roughly align with the 45-degree line. -Boxplot: it also helps visualize outliers -Shapiro–Wilk test: If the p-value is lower than the chosen threshold, then the null hypothesis (Data is normally distributed) is rejected.\n4.  Low multicollinearity\n    *   You can calculate the VIF (Variable Inflation Factors) using your favorite statistical tool. If the value for each covariate is lower than 10 (some say 5), you’re good to go.\n\n*   You can calculate the VIF (Variable Inflation Factors) using your favorite statistical tool. If the value for each covariate is lower than 10 (some say 5), you’re good to go.\n\n![](/primers/ai/assets/interview/lr.jpeg)",
      "order": 41,
      "orderInChapter": 41,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 391,
        "contentLength": 5405
      },
      "nextCards": [
        "ai-interview-explain-briefly-the-k-means-clustering-and-how-can-42",
        "ai-interview-given-an-integer-array-return-the-maximum-product--43"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-linear-regression-model-and-discuss-its-assumption?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-briefly-the-k-means-clustering-and-how-can-42",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Briefly the K-Means Clustering and How Can We Find the Best Value of K?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>K-Means is a well-known clustering algorithm. K-Means clustering is often used because it is easy to interpret and implement. It starts by partitioning a set of data into <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-43-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-435\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-436\"><span class=\"mi\" id=\"MathJax-Span-437\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-43\">K</script> distinct clusters and then arbitrary selects centroids of each of these clusters. It iteratively updates partitions by first assigning the points to the closet cluster and then updating the centroid and then repeating this process until convergence. The process essentially minimizes the total inter-cluster variation across all clusters.</li>\n  <li>The elbow method is a well-known method to find the best value of <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-44-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-438\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-439\"><span class=\"mi\" id=\"MathJax-Span-440\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-44\">K</script> in K-means clustering. The intuition behind this technique is that the first few clusters will explain a lot of the variation in the data, but past a certain point, the amount of information added is diminishing. Looking at the graph below of the explained variation (on the y-axis) versus the number of cluster <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-45-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-441\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-442\"><span class=\"mi\" id=\"MathJax-Span-443\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-45\">K</script> (on the x-axis), there should be a sharp change in the y-axis at some level of <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-46-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-444\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-445\"><span class=\"mi\" id=\"MathJax-Span-446\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-46\">K</script>. For example in the graph below the drop-off is at <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-47-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>=</mo><mn>3</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-447\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.14em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-448\"><span class=\"mi\" id=\"MathJax-Span-449\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-450\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-451\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">3</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi><mo>=</mo><mn>3</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-47\">k=3</script>.</li>\n  <li>The explained variation is quantified by the within-cluster sum of squared errors. To calculate this error notice, we look for each cluster at the total sum of squared errors using Euclidean distance.</li>\n  <li>Another popular alternative method to find the value of <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-48-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-452\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-453\"><span class=\"mi\" id=\"MathJax-Span-454\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-48\">K</script> is to apply the silhouette method, which aims to measure how similar points are in its cluster compared to other clusters. It can be calculated with this equation: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-49-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>&amp;#x2212;</mo><mi>y</mi><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-455\" style=\"width: 8.284em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 6.878em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1006.83em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-456\"><span class=\"mo\" id=\"MathJax-Span-457\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-458\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-459\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-460\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">y</span><span class=\"mo\" id=\"MathJax-Span-461\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"texatom\" id=\"MathJax-Span-462\"><span class=\"mrow\" id=\"MathJax-Span-463\"><span class=\"mo\" id=\"MathJax-Span-464\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mi\" id=\"MathJax-Span-465\" style=\"font-family: STIXGeneral-Italic;\">m</span><span class=\"mi\" id=\"MathJax-Span-466\" style=\"font-family: STIXGeneral-Italic;\">a</span><span class=\"mi\" id=\"MathJax-Span-467\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-468\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-469\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-470\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-471\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">y</span><span class=\"mo\" id=\"MathJax-Span-472\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-49\">(x-y)/max(x,y)</script>, where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-50-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-473\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-474\"><span class=\"mi\" id=\"MathJax-Span-475\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-50\">x</script> is the mean distance to the examples of the nearest cluster, and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-51-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-476\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-477\"><span class=\"mi\" id=\"MathJax-Span-478\" style=\"font-family: STIXGeneral-Italic;\">y</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-51\">y</script> is the mean distance to other examples in the same cluster. The coefficient varies between -1 and 1 for any given point. A value of 1 implies that the point is in the right cluster and the value of -1 implies that it is in the wrong cluster. By plotting the silhouette coefficient on the y-axis versus each <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-52-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-479\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-480\"><span class=\"mi\" id=\"MathJax-Span-481\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-52\">K</script> we can get an idea of the optimal number of clusters. However, it is worthy to note that this method is more computationally expensive than the previous one.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/kmc.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   K-Means is a well-known clustering algorithm. K-Means clustering is often used because it is easy to interpret and implement. It starts by partitioning a set of data into KKK distinct clusters and then arbitrary selects centroids of each of these clusters. It iteratively updates partitions by first assigning the points to the closet cluster and then updating the centroid and then repeating this process until convergence. The process essentially minimizes the total inter-cluster variation across all clusters.\n*   The elbow method is a well-known method to find the best value of KKK in K-means clustering. The intuition behind this technique is that the first few clusters will explain a lot of the variation in the data, but past a certain point, the amount of information added is diminishing. Looking at the graph below of the explained variation (on the y-axis) versus the number of cluster KKK (on the x-axis), there should be a sharp change in the y-axis at some level of KKK. For example in the graph below the drop-off is at k\\=3k\\=3k=3.\n*   The explained variation is quantified by the within-cluster sum of squared errors. To calculate this error notice, we look for each cluster at the total sum of squared errors using Euclidean distance.\n*   Another popular alternative method to find the value of KKK is to apply the silhouette method, which aims to measure how similar points are in its cluster compared to other clusters. It can be calculated with this equation: (x−y)/max(x,y)(x−y)/max(x,y)(x-y)/max(x,y), where xxx is the mean distance to the examples of the nearest cluster, and yyy is the mean distance to other examples in the same cluster. The coefficient varies between -1 and 1 for any given point. A value of 1 implies that the point is in the right cluster and the value of -1 implies that it is in the wrong cluster. By plotting the silhouette coefficient on the y-axis versus each KKK we can get an idea of the optimal number of clusters. However, it is worthy to note that this method is more computationally expensive than the previous one.\n\n![](/primers/ai/assets/interview/kmc.jpeg)",
      "order": 42,
      "orderInChapter": 42,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 351,
        "contentLength": 17018
      },
      "nextCards": [
        "ai-interview-given-an-integer-array-return-the-maximum-product--43",
        "ai-interview-what-are-joins-in-sql-and-discuss-its-types-44"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-briefly-the-k-means-clustering-and-how-can-we-find-the-best-value-of-k?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-given-an-integer-array-return-the-maximum-product--43",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Given an Integer Array, Return the Maximum Product of Any Three Numbers in the Array.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>For example:</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code12\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code12\">A = [1, 5, 3, 4] it should return 60\nB = [-2, -4, 5, 3] it should return 40\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code12\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code12\">A = [1, 5, 3, 4] it should return 60\nB = [-2, -4, 5, 3] it should return 40\n</code></pre>\n<ul>\n  <li>If all the numbers are positive, then the solution will be finding the max 3 numbers, if they have negative numbers then it will be the result of multiplying the smallest two negative numbers with the maximum positive number.</li>\n  <li>We can use the <code class=\"language-plaintext highlighter-rouge\">heapq</code> library to sort and find the maximum numbers in one step. As shown in the image below.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/maxprod.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   For example:\n\n![](https://aman.ai/images/copy.png)\n\n`A = [1, 5, 3, 4] it should return 60 B = [-2, -4, 5, 3] it should return 40`\n\n![](https://aman.ai/images/copy.png)\n\n`A = [1, 5, 3, 4] it should return 60 B = [-2, -4, 5, 3] it should return 40`\n\n*   If all the numbers are positive, then the solution will be finding the max 3 numbers, if they have negative numbers then it will be the result of multiplying the smallest two negative numbers with the maximum positive number.\n*   We can use the `heapq` library to sort and find the maximum numbers in one step. As shown in the image below.\n\n![](/primers/ai/assets/interview/maxprod.jpeg)",
      "order": 43,
      "orderInChapter": 43,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 109,
        "contentLength": 1342
      },
      "nextCards": [
        "ai-interview-what-are-joins-in-sql-and-discuss-its-types-44",
        "ai-interview-why-should-we-use-batch-normalization-45"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#given-an-integer-array,-return-the-maximum-product-of-any-three-numbers-in-the-array.",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-joins-in-sql-and-discuss-its-types-44",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Joins in SQL and Discuss Its Types?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>A JOIN clause is used to combine rows from two or more tables, based on a related column between them. It is used to merge two tables or retrieve data from there. There are 4 types of joins: inner join left join, right join, and full join.</li>\n  <li>Inner join: Inner Join in SQL is the most common type of join. It is used to return all the rows from multiple tables where the join condition is satisfied.</li>\n  <li>Left Join:  Left Join in SQL is used to return all the rows from the left table but only the matching rows from the right table where the join condition is fulfilled.</li>\n  <li>Right Join: Right Join in SQL is used to return all the rows from the right table but only the matching rows from the left table where the join condition is fulfilled.</li>\n  <li>Full Join: Full join returns all the records when there is a match in any of the tables. Therefore, it returns all the rows from the left-hand side table and all the rows from the right-hand side table.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/sql_join.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   A JOIN clause is used to combine rows from two or more tables, based on a related column between them. It is used to merge two tables or retrieve data from there. There are 4 types of joins: inner join left join, right join, and full join.\n*   Inner join: Inner Join in SQL is the most common type of join. It is used to return all the rows from multiple tables where the join condition is satisfied.\n*   Left Join: Left Join in SQL is used to return all the rows from the left table but only the matching rows from the right table where the join condition is fulfilled.\n*   Right Join: Right Join in SQL is used to return all the rows from the right table but only the matching rows from the left table where the join condition is fulfilled.\n*   Full Join: Full join returns all the records when there is a match in any of the tables. Therefore, it returns all the rows from the left-hand side table and all the rows from the right-hand side table.\n\n![](/primers/ai/assets/interview/sql_join.jpeg)",
      "order": 44,
      "orderInChapter": 44,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 185,
        "contentLength": 1069
      },
      "nextCards": [
        "ai-interview-why-should-we-use-batch-normalization-45",
        "ai-interview-what-is-weak-supervision-46"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-joins-in-sql-and-discuss-its-types?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-should-we-use-batch-normalization-45",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Should We Use Batch Normalization?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Batch normalization is a technique for training very deep neural networks that standardizes the inputs to a layer for each mini-batch.</li>\n  <li>Usually, a dataset is fed into the network in the form of batches where the distribution of the data differs for every batch size. By doing this, there might be chances of vanishing gradient or exploding gradient when it tries to backpropagate. In order to combat these issues, we can use BN (with irreducible error) layer mostly on the inputs to the layer before the activation function in the previous layer and after fully connected layers.</li>\n  <li>Batch Normalisation has the following effects on the Neural Network:\n    <ul>\n      <li>Robust Training of the deeper layers of the network.</li>\n      <li>Better covariate-shift proof NN Architecture.</li>\n      <li>Has a slight regularization effect.</li>\n      <li>Centered and controlled values of Activation.</li>\n      <li>Tries to prevent exploding/vanishing gradient.</li>\n      <li>Faster training/convergence.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Robust Training of the deeper layers of the network.</li>\n      <li>Better covariate-shift proof NN Architecture.</li>\n      <li>Has a slight regularization effect.</li>\n      <li>Centered and controlled values of Activation.</li>\n      <li>Tries to prevent exploding/vanishing gradient.</li>\n      <li>Faster training/convergence.</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/bn.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Batch normalization is a technique for training very deep neural networks that standardizes the inputs to a layer for each mini-batch.\n*   Usually, a dataset is fed into the network in the form of batches where the distribution of the data differs for every batch size. By doing this, there might be chances of vanishing gradient or exploding gradient when it tries to backpropagate. In order to combat these issues, we can use BN (with irreducible error) layer mostly on the inputs to the layer before the activation function in the previous layer and after fully connected layers.\n*   Batch Normalisation has the following effects on the Neural Network:\n    *   Robust Training of the deeper layers of the network.\n    *   Better covariate-shift proof NN Architecture.\n    *   Has a slight regularization effect.\n    *   Centered and controlled values of Activation.\n    *   Tries to prevent exploding/vanishing gradient.\n    *   Faster training/convergence.\n\n*   Robust Training of the deeper layers of the network.\n*   Better covariate-shift proof NN Architecture.\n*   Has a slight regularization effect.\n*   Centered and controlled values of Activation.\n*   Tries to prevent exploding/vanishing gradient.\n*   Faster training/convergence.\n\n![](/primers/ai/assets/interview/bn.jpeg)",
      "order": 45,
      "orderInChapter": 45,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "activation",
        "regularization",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 187,
        "contentLength": 1485
      },
      "nextCards": [
        "ai-interview-what-is-weak-supervision-46",
        "ai-interview-what-is-active-learning-47"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-definition-and-taxonomy-59",
        "ai-model-compression-how-far-can-quantization-be-pushed-20",
        "ai-top-30-papers-stanfords-cs231n-convolutional-neural-networks-for-26",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-reinforcement-learning-deep-actorcritic-methods-18"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-should-we-use-batch-normalization?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-weak-supervision-46",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Weak Supervision?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Weak Supervision (which most people know as the Snorkel algorithm) is an approach designed to help annotate data at scale, and it’s a pretty clever one too.</li>\n  <li>Imagine that you have to build a content moderation system that can flag LinkedIn posts that are offensive. Before you can build a model, you’ll first have to get some data. So you’ll scrape posts. A lot of them, because content moderation is particularly data-greedy. Say, you collect 10M of them. That’s when trouble begins: you need to annotate each and every one of them - and you know that’s gonna cost you a lot of time and a lot of money!</li>\n  <li>So you want to use autolabeling (basically, you want to apply a pre-trained model) to generate ground truth. The problem is that such a model doesn’t just lie around, as this isn’t your vanilla object detection for autonomous driving use case, and you can’t just use YOLO v5.</li>\n  <li>Rather than seek the budget to annotate all that data, you reach out to subject matter experts you know on LinkedIn, and you ask them to give you a list of rules of what constitutes, according to each one of them, an offensive post.</li>\n</ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code13\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code13\">Person 1's rules:\n- The post is in all caps\n- There is a mention of Politics\n\nPerson 2's rules:\n- The post is in all caps\n- It uses slang\n- The topic is not professional\n\n...\n\nPerson 20's rules:\n- The post is about religion\n- The post mentions death\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code13\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code13\">Person 1's rules:\n- The post is in all caps\n- There is a mention of Politics\n\nPerson 2's rules:\n- The post is in all caps\n- It uses slang\n- The topic is not professional\n\n...\n\nPerson 20's rules:\n- The post is about religion\n- The post mentions death\n</code></pre>\n<ul>\n  <li>You then combine all rules into a mega processing engine that functions as a voting system: if a comment is flagged as offensive by at least X% of those 20 rule sets, then you label it as offensive. You apply the same logic to all 10M records and are able to annotate then in minutes, at almost no costs.</li>\n  <li>You just used a weakly supervised algorithm to annotate your data.</li>\n  <li>You can of course replace people’s inputs by embeddings, or some other automatically generated information, which comes handy in cases when no clear rules can be defined (for example, try coming up with rules to flag a cat in a picture).</li>\n</ul>",
      "contentMarkdown": "*   Weak Supervision (which most people know as the Snorkel algorithm) is an approach designed to help annotate data at scale, and it’s a pretty clever one too.\n*   Imagine that you have to build a content moderation system that can flag LinkedIn posts that are offensive. Before you can build a model, you’ll first have to get some data. So you’ll scrape posts. A lot of them, because content moderation is particularly data-greedy. Say, you collect 10M of them. That’s when trouble begins: you need to annotate each and every one of them - and you know that’s gonna cost you a lot of time and a lot of money!\n*   So you want to use autolabeling (basically, you want to apply a pre-trained model) to generate ground truth. The problem is that such a model doesn’t just lie around, as this isn’t your vanilla object detection for autonomous driving use case, and you can’t just use YOLO v5.\n*   Rather than seek the budget to annotate all that data, you reach out to subject matter experts you know on LinkedIn, and you ask them to give you a list of rules of what constitutes, according to each one of them, an offensive post.\n\n![](https://aman.ai/images/copy.png)\n\n`Person 1's rules: - The post is in all caps - There is a mention of Politics  Person 2's rules: - The post is in all caps - It uses slang - The topic is not professional  ...  Person 20's rules: - The post is about religion - The post mentions death`\n\n![](https://aman.ai/images/copy.png)\n\n`Person 1's rules: - The post is in all caps - There is a mention of Politics  Person 2's rules: - The post is in all caps - It uses slang - The topic is not professional  ...  Person 20's rules: - The post is about religion - The post mentions death`\n\n*   You then combine all rules into a mega processing engine that functions as a voting system: if a comment is flagged as offensive by at least X% of those 20 rule sets, then you label it as offensive. You apply the same logic to all 10M records and are able to annotate then in minutes, at almost no costs.\n*   You just used a weakly supervised algorithm to annotate your data.\n*   You can of course replace people’s inputs by embeddings, or some other automatically generated information, which comes handy in cases when no clear rules can be defined (for example, try coming up with rules to flag a cat in a picture).",
      "order": 46,
      "orderInChapter": 46,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "embedding"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 425,
        "contentLength": 2983
      },
      "nextCards": [
        "ai-interview-what-is-active-learning-47",
        "ai-interview-what-are-the-types-of-active-learning-48"
      ],
      "relatedCards": [
        "ai-diffusion-models-key-papers-introducing-external-classifiers-for-te-27",
        "ai-diffusion-models-prompting-text-to-video-models-31",
        "ai-diffusion-models-imagen-video-high-definition-video-generation-with-61",
        "ai-gnn-edge-features-in-gnn-based-link-prediction-17",
        "ai-gnn-general-update-with-edge-embeddings-18"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-weak-supervision?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-active-learning-47",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Active Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>When you don’t have enough labeled data and it’s expensive and/or time consuming to label new data, active learning is the solution. Active learning is a semi-supervised ML training paradigm which, like all semi-supervised learning techniques, relies on the usage of partially labeled data. Active Learning helps to select unlabeled samples to label that will be most beneficial for the model, when retrained with the new sample.</li>\n  <li>Active Learning consists of dynamically selecting the most relevant data by sequentially:\n    <ul>\n      <li>selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy)</li>\n      <li>getting the selected data annotated</li>\n      <li>training the model with that sample of annotated training data</li>\n      <li>running inference on the remaining (unannotated) data.</li>\n    </ul>\n  </li>\n  <li>That last step is used to evaluate which records should be then selected for the next iteration (called a loop). However, since there is no ground truth for the data used in the inference step, one cannot simply decide to feed the data where the model failed to make the correct prediction, and has instead to use metadata (such as the confidence level of the prediction) to make that decision.</li>\n  <li>The easiest and most common querying strategy used for selecting the next batch of useful data consists of picking the records with the lowest confidence level; this is called the least-confidence querying strategy, which is one of many possible querying strategies. (Technically, those querying strategies are usually brute-force, arbitrary algorithms which can be replaced by actual ML models trained on metadata generated during the training and inference phases for more sophistication).</li>\n  <li>Thus, the most important criterion is selecting samples with maximum prediction uncertainty. You can use the model’s prediction confidence to ascertain uncertain samples. Entropy is another way to measure such uncertainty. Another criterion could be diversity of the new sample with respect to exiting training data. You could also select samples close to labeled samples in the training data with poor performance. Another option could be selecting samples from regions of the feature space where better performance is desired. You could combine all the strategies in your active learning decision making process.</li>\n  <li>The training is an iterative process. With active learning you select new sample to label, label it and retrain the model. Adding one labeled sample at a time and retraining the model could be expensive. There are techniques to select a batch of samples to label. For deep learning the most popular active learning technique is entropy with is Monte Carlo dropout for prediction probability.</li>\n  <li>The process of deciding the samples to label could also be implemented with Multi Arm Bandit. The reward function could be defined in terms of prediction uncertainty, diversity, etc.</li>\n  <li>Let’s go deeper and explain why the vanilla form of Active Learning, “uncertainty-based”/”least-confidence” Active Learning, actually perform poorly via real-life datasets:\n    <ul>\n      <li>Let’s take the example of a binary classification model identifying toxic content in tweets, and let’s say we have 100,000 tweets as our dataset.</li>\n      <li>Here is how uncertainty-based AL would work:\n        <ol>\n          <li>We pick 1,000 (or another number, depending on how we tune the process) records - at that stage, randomly.</li>\n          <li>We annotate that data as toxic / not-toxic.</li>\n          <li>We train our model with it and get a (not-so-good) model.</li>\n          <li>We use the model to infer the remaining 99,000 (unlabeled) records.</li>\n          <li>We don’t have ground truth for those 99,000, so we can’t select which records are incorrectly predicted, but we can use metadata, such as the confidence level, as a proxy to detect bad predictions. With least confidence Active Learning, we would pick the 1,000 records predicted with the lowest confidence level as our next batch.</li>\n          <li>Go to (2) and repeat the same steps, until we’re happy with the model.</li>\n        </ol>\n      </li>\n      <li>What we did here, is assume that confidence was a good proxy for usefulness, because it is assumed that low confidence records are the hardest for the model to learn, and hence that the model needs to see them to learn more efficiently.</li>\n      <li>Let’s consider a scenario where it is not. Assume now that this training data is not clean, and 5% of the data is actually in Spanish. If the model (and the majority of the data) was meant to be for English, then chances are, the Spanish tweets will be inferred with a low confidence: you will actually pollute the dataset with data that doesn’t belong there. In other words, low confidence can happen for a variety of different reasons. That’s what happens when you do active learning with messy data.\n        <ul>\n          <li>To resolve this, one solution is to stop using confidence level alone: confidence levels are just one meta-feature to evaluate usefulness.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>In a nutshell, active learning is an incremental semi-supervised learning paradigm where training data is selected incrementally and the model is sequentially retrained (loop after loop), until either the model reaches a specific performance or labeling budget is exhausted.</li>\n</ul>\n<ul>\n      <li>selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy)</li>\n      <li>getting the selected data annotated</li>\n      <li>training the model with that sample of annotated training data</li>\n      <li>running inference on the remaining (unannotated) data.</li>\n    </ul>\n<ul>\n      <li>Let’s take the example of a binary classification model identifying toxic content in tweets, and let’s say we have 100,000 tweets as our dataset.</li>\n      <li>Here is how uncertainty-based AL would work:\n        <ol>\n          <li>We pick 1,000 (or another number, depending on how we tune the process) records - at that stage, randomly.</li>\n          <li>We annotate that data as toxic / not-toxic.</li>\n          <li>We train our model with it and get a (not-so-good) model.</li>\n          <li>We use the model to infer the remaining 99,000 (unlabeled) records.</li>\n          <li>We don’t have ground truth for those 99,000, so we can’t select which records are incorrectly predicted, but we can use metadata, such as the confidence level, as a proxy to detect bad predictions. With least confidence Active Learning, we would pick the 1,000 records predicted with the lowest confidence level as our next batch.</li>\n          <li>Go to (2) and repeat the same steps, until we’re happy with the model.</li>\n        </ol>\n      </li>\n      <li>What we did here, is assume that confidence was a good proxy for usefulness, because it is assumed that low confidence records are the hardest for the model to learn, and hence that the model needs to see them to learn more efficiently.</li>\n      <li>Let’s consider a scenario where it is not. Assume now that this training data is not clean, and 5% of the data is actually in Spanish. If the model (and the majority of the data) was meant to be for English, then chances are, the Spanish tweets will be inferred with a low confidence: you will actually pollute the dataset with data that doesn’t belong there. In other words, low confidence can happen for a variety of different reasons. That’s what happens when you do active learning with messy data.\n        <ul>\n          <li>To resolve this, one solution is to stop using confidence level alone: confidence levels are just one meta-feature to evaluate usefulness.</li>\n        </ul>\n      </li>\n    </ul>\n<ol>\n          <li>We pick 1,000 (or another number, depending on how we tune the process) records - at that stage, randomly.</li>\n          <li>We annotate that data as toxic / not-toxic.</li>\n          <li>We train our model with it and get a (not-so-good) model.</li>\n          <li>We use the model to infer the remaining 99,000 (unlabeled) records.</li>\n          <li>We don’t have ground truth for those 99,000, so we can’t select which records are incorrectly predicted, but we can use metadata, such as the confidence level, as a proxy to detect bad predictions. With least confidence Active Learning, we would pick the 1,000 records predicted with the lowest confidence level as our next batch.</li>\n          <li>Go to (2) and repeat the same steps, until we’re happy with the model.</li>\n        </ol>\n<ul>\n          <li>To resolve this, one solution is to stop using confidence level alone: confidence levels are just one meta-feature to evaluate usefulness.</li>\n        </ul>\n<p><img src=\"/primers/ai/assets/interview/al1.jpeg\" alt=\"\"></p>\n<p><img src=\"/primers/ai/assets/interview/al2.jpeg\" alt=\"\"></p>\n<p><img src=\"/primers/ai/assets/interview/al4.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   When you don’t have enough labeled data and it’s expensive and/or time consuming to label new data, active learning is the solution. Active learning is a semi-supervised ML training paradigm which, like all semi-supervised learning techniques, relies on the usage of partially labeled data. Active Learning helps to select unlabeled samples to label that will be most beneficial for the model, when retrained with the new sample.\n*   Active Learning consists of dynamically selecting the most relevant data by sequentially:\n    *   selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy)\n    *   getting the selected data annotated\n    *   training the model with that sample of annotated training data\n    *   running inference on the remaining (unannotated) data.\n*   That last step is used to evaluate which records should be then selected for the next iteration (called a loop). However, since there is no ground truth for the data used in the inference step, one cannot simply decide to feed the data where the model failed to make the correct prediction, and has instead to use metadata (such as the confidence level of the prediction) to make that decision.\n*   The easiest and most common querying strategy used for selecting the next batch of useful data consists of picking the records with the lowest confidence level; this is called the least-confidence querying strategy, which is one of many possible querying strategies. (Technically, those querying strategies are usually brute-force, arbitrary algorithms which can be replaced by actual ML models trained on metadata generated during the training and inference phases for more sophistication).\n*   Thus, the most important criterion is selecting samples with maximum prediction uncertainty. You can use the model’s prediction confidence to ascertain uncertain samples. Entropy is another way to measure such uncertainty. Another criterion could be diversity of the new sample with respect to exiting training data. You could also select samples close to labeled samples in the training data with poor performance. Another option could be selecting samples from regions of the feature space where better performance is desired. You could combine all the strategies in your active learning decision making process.\n*   The training is an iterative process. With active learning you select new sample to label, label it and retrain the model. Adding one labeled sample at a time and retraining the model could be expensive. There are techniques to select a batch of samples to label. For deep learning the most popular active learning technique is entropy with is Monte Carlo dropout for prediction probability.\n*   The process of deciding the samples to label could also be implemented with Multi Arm Bandit. The reward function could be defined in terms of prediction uncertainty, diversity, etc.\n*   Let’s go deeper and explain why the vanilla form of Active Learning, “uncertainty-based”/”least-confidence” Active Learning, actually perform poorly via real-life datasets:\n    *   Let’s take the example of a binary classification model identifying toxic content in tweets, and let’s say we have 100,000 tweets as our dataset.\n    *   Here is how uncertainty-based AL would work:\n        1.  We pick 1,000 (or another number, depending on how we tune the process) records - at that stage, randomly.\n        2.  We annotate that data as toxic / not-toxic.\n        3.  We train our model with it and get a (not-so-good) model.\n        4.  We use the model to infer the remaining 99,000 (unlabeled) records.\n        5.  We don’t have ground truth for those 99,000, so we can’t select which records are incorrectly predicted, but we can use metadata, such as the confidence level, as a proxy to detect bad predictions. With least confidence Active Learning, we would pick the 1,000 records predicted with the lowest confidence level as our next batch.\n        6.  Go to (2) and repeat the same steps, until we’re happy with the model.\n    *   What we did here, is assume that confidence was a good proxy for usefulness, because it is assumed that low confidence records are the hardest for the model to learn, and hence that the model needs to see them to learn more efficiently.\n    *   Let’s consider a scenario where it is not. Assume now that this training data is not clean, and 5% of the data is actually in Spanish. If the model (and the majority of the data) was meant to be for English, then chances are, the Spanish tweets will be inferred with a low confidence: you will actually pollute the dataset with data that doesn’t belong there. In other words, low confidence can happen for a variety of different reasons. That’s what happens when you do active learning with messy data.\n        *   To resolve this, one solution is to stop using confidence level alone: confidence levels are just one meta-feature to evaluate usefulness.\n*   In a nutshell, active learning is an incremental semi-supervised learning paradigm where training data is selected incrementally and the model is sequentially retrained (loop after loop), until either the model reaches a specific performance or labeling budget is exhausted.\n\n*   selecting a sample of the raw (unannotated) dataset (the algorithm used for that selection step is called a querying strategy)\n*   getting the selected data annotated\n*   training the model with that sample of annotated training data\n*   running inference on the remaining (unannotated) data.\n\n*   Let’s take the example of a binary classification model identifying toxic content in tweets, and let’s say we have 100,000 tweets as our dataset.\n*   Here is how uncertainty-based AL would work:\n    1.  We pick 1,000 (or another number, depending on how we tune the process) records - at that stage, randomly.\n    2.  We annotate that data as toxic / not-toxic.\n    3.  We train our model with it and get a (not-so-good) model.\n    4.  We use the model to infer the remaining 99,000 (unlabeled) records.\n    5.  We don’t have ground truth for those 99,000, so we can’t select which records are incorrectly predicted, but we can use metadata, such as the confidence level, as a proxy to detect bad predictions. With least confidence Active Learning, we would pick the 1,000 records predicted with the lowest confidence level as our next batch.\n    6.  Go to (2) and repeat the same steps, until we’re happy with the model.\n*   What we did here, is assume that confidence was a good proxy for usefulness, because it is assumed that low confidence records are the hardest for the model to learn, and hence that the model needs to see them to learn more efficiently.\n*   Let’s consider a scenario where it is not. Assume now that this training data is not clean, and 5% of the data is actually in Spanish. If the model (and the majority of the data) was meant to be for English, then chances are, the Spanish tweets will be inferred with a low confidence: you will actually pollute the dataset with data that doesn’t belong there. In other words, low confidence can happen for a variety of different reasons. That’s what happens when you do active learning with messy data.\n    *   To resolve this, one solution is to stop using confidence level alone: confidence levels are just one meta-feature to evaluate usefulness.\n\n1.  We pick 1,000 (or another number, depending on how we tune the process) records - at that stage, randomly.\n2.  We annotate that data as toxic / not-toxic.\n3.  We train our model with it and get a (not-so-good) model.\n4.  We use the model to infer the remaining 99,000 (unlabeled) records.\n5.  We don’t have ground truth for those 99,000, so we can’t select which records are incorrectly predicted, but we can use metadata, such as the confidence level, as a proxy to detect bad predictions. With least confidence Active Learning, we would pick the 1,000 records predicted with the lowest confidence level as our next batch.\n6.  Go to (2) and repeat the same steps, until we’re happy with the model.\n\n*   To resolve this, one solution is to stop using confidence level alone: confidence levels are just one meta-feature to evaluate usefulness.\n\n![](/primers/ai/assets/interview/al1.jpeg)\n\n![](/primers/ai/assets/interview/al2.jpeg)\n\n![](/primers/ai/assets/interview/al4.jpeg)",
      "order": 47,
      "orderInChapter": 47,
      "difficulty": 4,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "deep learning",
        "supervised learning",
        "dropout"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 1344,
        "contentLength": 9111
      },
      "nextCards": [
        "ai-interview-what-are-the-types-of-active-learning-48",
        "ai-interview-what-is-the-difference-between-online-learning-and-49"
      ],
      "relatedCards": [
        "ai-gnn-survey-papers-on-gnns-22",
        "ai-dropout-books-7",
        "ai-decision-trees-and-ensemble-methods-what-are-the-biggest-advantages-of-using-gbdts-com-22",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-ml-comp-naive-bayes-classifier-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-active-learning?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-types-of-active-learning-48",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Types of Active Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>There are many different “flavors” of active learning, but did you know that active learning could be broken down into two main categories, “streaming active learning”, and “pooling (batch) active learning”?</li>\n  <li>Pooling Active Learning, is when all records available for training data have to be evaluated before a decision can be made about the ones to keep. For example, if your querying strategy is least-confidence, you goal is to select the N records that were predicted with the lowest confidence level in the previous loop, which means all records have to be ranked accordingly to their confidence level. Pooling Active Learning hence requires more compute resources for inference (the entire remainder of the dataset, at each loop, needs to be inferred), but provides a better control of loop sizes and the process as a whole.</li>\n  <li>Streaming Active Learning, is when a decision is made “on the fly”, record by record. If your selection strategy was to select all records predicted with a confidence level lower than X% for the previous loop, you’d be doing Streaming AL. This technique obviously requires less compute, and can be used in combination with Online Learning, but it comes with a huge risk: there is no guarantee regarding the amount of data that will be selected. Set the threshold too low, and you won’t select any data for the next loop. Set the threshold too high, and all the remaining data gets selected, and you lose the benefit of AL.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/al3.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   There are many different “flavors” of active learning, but did you know that active learning could be broken down into two main categories, “streaming active learning”, and “pooling (batch) active learning”?\n*   Pooling Active Learning, is when all records available for training data have to be evaluated before a decision can be made about the ones to keep. For example, if your querying strategy is least-confidence, you goal is to select the N records that were predicted with the lowest confidence level in the previous loop, which means all records have to be ranked accordingly to their confidence level. Pooling Active Learning hence requires more compute resources for inference (the entire remainder of the dataset, at each loop, needs to be inferred), but provides a better control of loop sizes and the process as a whole.\n*   Streaming Active Learning, is when a decision is made “on the fly”, record by record. If your selection strategy was to select all records predicted with a confidence level lower than X% for the previous loop, you’d be doing Streaming AL. This technique obviously requires less compute, and can be used in combination with Online Learning, but it comes with a huge risk: there is no guarantee regarding the amount of data that will be selected. Set the threshold too low, and you won’t select any data for the next loop. Set the threshold too high, and all the remaining data gets selected, and you lose the benefit of AL.\n\n![](/primers/ai/assets/interview/al3.jpeg)",
      "order": 48,
      "orderInChapter": 48,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 249,
        "contentLength": 1561
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-online-learning-and-49",
        "ai-interview-why-is-active-learning-not-frequently-used-with-de-50"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-types-of-active-learning?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-online-learning-and-49",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Online Learning and Active Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Online learning is essentially the concept of training a machine learning model on streaming data. In that case, data arrives little-by-little, sequentially, and the model is updated as opposed to be trained entirely from scratch.</li>\n  <li>Active learning also consists in training a model sequentially, but the difference is that the training dataset is already fully available. Active learning simply selects small samples of data incrementally; the model is either retrained with the totality of selected records at a given point in time, or updated with the newly selected data.</li>\n  <li>Online learning is required when models are to be trained at the point of collection (e.g, on the edge of a device), but active learning, just like supervised learning, usually involves the model being trained offline.</li>\n</ul>",
      "contentMarkdown": "*   Online learning is essentially the concept of training a machine learning model on streaming data. In that case, data arrives little-by-little, sequentially, and the model is updated as opposed to be trained entirely from scratch.\n*   Active learning also consists in training a model sequentially, but the difference is that the training dataset is already fully available. Active learning simply selects small samples of data incrementally; the model is either retrained with the totality of selected records at a given point in time, or updated with the newly selected data.\n*   Online learning is required when models are to be trained at the point of collection (e.g, on the edge of a device), but active learning, just like supervised learning, usually involves the model being trained offline.",
      "order": 49,
      "orderInChapter": 49,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning",
        "supervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 128,
        "contentLength": 836
      },
      "nextCards": [
        "ai-interview-why-is-active-learning-not-frequently-used-with-de-50",
        "ai-interview-what-does-active-learning-have-to-do-with-explore--51"
      ],
      "relatedCards": [
        "ai-top-30-papers-neural-message-passing-for-quantum-chemistry-12",
        "ai-ml-comp-model-ensembles-7",
        "ai-loss-cross-entropy-loss-function-1",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-support-vector-machines-conceptual-overview-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-online-learning-and-active-learning?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-is-active-learning-not-frequently-used-with-de-50",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why is Active Learning Not Frequently Used with Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Active Learning was relatively popular among ML scientists during the pre-Deep Learning era, and somehow fell out of favor afterwards.</p>\n  </li>\n  <li>\n    <p>The reason why is actually relatively simple: Active Learning usually doesn’t work as well with Deep Learning Models (at least the most common querying strategies don’t). So people gave up on Deep Active Learning pretty quickly. The two most important reasons are the following:</p>\n  </li>\n</ul>\n<p>Active Learning was relatively popular among ML scientists during the pre-Deep Learning era, and somehow fell out of favor afterwards.</p>\n<p>The reason why is actually relatively simple: Active Learning usually doesn’t work as well with Deep Learning Models (at least the most common querying strategies don’t). So people gave up on Deep Active Learning pretty quickly. The two most important reasons are the following:</p>\n<ol>\n  <li>\n    <p>The least-confidence, by far the most popular querying strategy, requires the computation of a confidence score. However, the softmax technique which most ML scientists rely on, is relatively unreliable (see this article for details to learn about a better way to compute confidence: https://arxiv.org/pdf/1706.04599.pdf)</p>\n  </li>\n  <li>\n    <p>Active learning, as a process, is actually meant to “grow” a better dataset dynamically. At each loop, more records are selected, which means the same model is retrained with incrementally larger data. However, many hyperparameters in neural nets are very sensitive to the amount of data used. For example, a certain number of epochs might lead to overfitting with early loops and underfitting later on. The proper way of doing Deep Active Learning would be to do hyperparameter tuning dynamically, which is rarely done.</p>\n  </li>\n</ol>\n<p>The least-confidence, by far the most popular querying strategy, requires the computation of a confidence score. However, the softmax technique which most ML scientists rely on, is relatively unreliable (see this article for details to learn about a better way to compute confidence: https://arxiv.org/pdf/1706.04599.pdf)</p>\n<p>Active learning, as a process, is actually meant to “grow” a better dataset dynamically. At each loop, more records are selected, which means the same model is retrained with incrementally larger data. However, many hyperparameters in neural nets are very sensitive to the amount of data used. For example, a certain number of epochs might lead to overfitting with early loops and underfitting later on. The proper way of doing Deep Active Learning would be to do hyperparameter tuning dynamically, which is rarely done.</p>",
      "contentMarkdown": "*   Active Learning was relatively popular among ML scientists during the pre-Deep Learning era, and somehow fell out of favor afterwards.\n    \n*   The reason why is actually relatively simple: Active Learning usually doesn’t work as well with Deep Learning Models (at least the most common querying strategies don’t). So people gave up on Deep Active Learning pretty quickly. The two most important reasons are the following:\n    \n\nActive Learning was relatively popular among ML scientists during the pre-Deep Learning era, and somehow fell out of favor afterwards.\n\nThe reason why is actually relatively simple: Active Learning usually doesn’t work as well with Deep Learning Models (at least the most common querying strategies don’t). So people gave up on Deep Active Learning pretty quickly. The two most important reasons are the following:\n\n1.  The least-confidence, by far the most popular querying strategy, requires the computation of a confidence score. However, the softmax technique which most ML scientists rely on, is relatively unreliable (see this article for details to learn about a better way to compute confidence: https://arxiv.org/pdf/1706.04599.pdf)\n    \n2.  Active learning, as a process, is actually meant to “grow” a better dataset dynamically. At each loop, more records are selected, which means the same model is retrained with incrementally larger data. However, many hyperparameters in neural nets are very sensitive to the amount of data used. For example, a certain number of epochs might lead to overfitting with early loops and underfitting later on. The proper way of doing Deep Active Learning would be to do hyperparameter tuning dynamically, which is rarely done.\n    \n\nThe least-confidence, by far the most popular querying strategy, requires the computation of a confidence score. However, the softmax technique which most ML scientists rely on, is relatively unreliable (see this article for details to learn about a better way to compute confidence: https://arxiv.org/pdf/1706.04599.pdf)\n\nActive learning, as a process, is actually meant to “grow” a better dataset dynamically. At each loop, more records are selected, which means the same model is retrained with incrementally larger data. However, many hyperparameters in neural nets are very sensitive to the amount of data used. For example, a certain number of epochs might lead to overfitting with early loops and underfitting later on. The proper way of doing Deep Active Learning would be to do hyperparameter tuning dynamically, which is rarely done.",
      "order": 50,
      "orderInChapter": 50,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "deep learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 388,
        "contentLength": 2667
      },
      "nextCards": [
        "ai-interview-what-does-active-learning-have-to-do-with-explore--51",
        "ai-interview-what-are-the-differences-between-a-model-that-mini-52"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-concept-16",
        "ai-distributed-training-parallelism-conclusion-22",
        "ai-distributed-training-parallelism-concept-24",
        "ai-distributed-training-parallelism-conclusion-30",
        "ai-distributed-training-parallelism-summary-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-is-active-learning-not-frequently-used-with-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-does-active-learning-have-to-do-with-explore--51",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What Does Active Learning Have to Do with Explore-exploit?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Using the “uncertainty-based”/”least/lowest-confidence” querying strategy as a selection criteria in an active learning process could cause issues when working with a real-life (messy) dataset, as indicated above.</li>\n  <li>Uncertainty-based active learning aims at selecting records based on how “certain” (or confident) the model already is about what it knows. Assuming the model can be trusted to self-evaluate properly, then:\n    <ul>\n      <li>Selecting low confidence records is about picking what the model seems not to know yet; it is a pure exploration process.</li>\n      <li>Selecting high confidence records is about picking what the model seems to already know, and that would be about reinforcing that knowledge; it is a pure exploitation process.</li>\n    </ul>\n  </li>\n  <li>While the “uncertainty-based”/”least/lowest-confidence” querying strategy strategy is the most common using active learning, it might be better to balance exploration and exploitation, and that active learning can and should, in fact, be formulated as a reinforcement learning problem.</li>\n</ul>\n<ul>\n      <li>Selecting low confidence records is about picking what the model seems not to know yet; it is a pure exploration process.</li>\n      <li>Selecting high confidence records is about picking what the model seems to already know, and that would be about reinforcing that knowledge; it is a pure exploitation process.</li>\n    </ul>",
      "contentMarkdown": "*   Using the “uncertainty-based”/”least/lowest-confidence” querying strategy as a selection criteria in an active learning process could cause issues when working with a real-life (messy) dataset, as indicated above.\n*   Uncertainty-based active learning aims at selecting records based on how “certain” (or confident) the model already is about what it knows. Assuming the model can be trusted to self-evaluate properly, then:\n    *   Selecting low confidence records is about picking what the model seems not to know yet; it is a pure exploration process.\n    *   Selecting high confidence records is about picking what the model seems to already know, and that would be about reinforcing that knowledge; it is a pure exploitation process.\n*   While the “uncertainty-based”/”least/lowest-confidence” querying strategy strategy is the most common using active learning, it might be better to balance exploration and exploitation, and that active learning can and should, in fact, be formulated as a reinforcement learning problem.\n\n*   Selecting low confidence records is about picking what the model seems not to know yet; it is a pure exploration process.\n*   Selecting high confidence records is about picking what the model seems to already know, and that would be about reinforcing that knowledge; it is a pure exploitation process.",
      "order": 51,
      "orderInChapter": 51,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "reinforcement learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 201,
        "contentLength": 1443
      },
      "nextCards": [
        "ai-interview-what-are-the-differences-between-a-model-that-mini-52",
        "ai-interview-define-tuples-and-lists-in-python-what-are-the-maj-53"
      ],
      "relatedCards": [
        "ai-reinforcement-learning-model-free-reinforcement-learning-13",
        "ai-reinforcement-learning-on-policy-vs-off-policy-reinforcement-learning-14",
        "ai-reinforcement-learning-reward-function-design-41",
        "ai-reinforcement-learning-what-are-the-differences-between-the-value-return--42",
        "ai-agents-implementation-details-for-responsible-agents-66"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-does-active-learning-have-to-do-with-explore-exploit?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-differences-between-a-model-that-mini-52",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Differences Between a Model That Minimizes Squared Error and the One That Minimizes the Absolute Error? and in Which Cases Each Error Metric Would be More Appropriate?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Both mean square error (MSE) and mean absolute error (MAE) measures the distances between vectors and express average model prediction in units of the target variable. Both can range from 0 to infinity, the lower they are the better the model.</li>\n  <li>The main difference between them is that in MSE the errors are squared before being averaged while in MAE they are not. This means that a large weight will be given to large errors. MSE is useful when large errors in the model are trying to be avoided. This means that outliers affect MSE more than MAE (because large errors have a greater influence than small errors), that is why MAE is more robust to outliers.</li>\n  <li>Computation-wise MSE is easier to use as the gradient calculation will be more straightforward than MAE, since MAE requires linear programming to calculate it.</li>\n</ul>",
      "contentMarkdown": "*   Both mean square error (MSE) and mean absolute error (MAE) measures the distances between vectors and express average model prediction in units of the target variable. Both can range from 0 to infinity, the lower they are the better the model.\n*   The main difference between them is that in MSE the errors are squared before being averaged while in MAE they are not. This means that a large weight will be given to large errors. MSE is useful when large errors in the model are trying to be avoided. This means that outliers affect MSE more than MAE (because large errors have a greater influence than small errors), that is why MAE is more robust to outliers.\n*   Computation-wise MSE is easier to use as the gradient calculation will be more straightforward than MAE, since MAE requires linear programming to calculate it.",
      "order": 52,
      "orderInChapter": 52,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 144,
        "contentLength": 861
      },
      "nextCards": [
        "ai-interview-define-tuples-and-lists-in-python-what-are-the-maj-53",
        "ai-interview-given-a-left-skewed-distribution-that-has-a-median-54"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-differences-between-a-model-that-minimizes-squared-error-and-the-one-that-minimizes-the-absolute-error?-and-in-which-cases-each-error-metric-would-be-more-appropriate?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-define-tuples-and-lists-in-python-what-are-the-maj-53",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Define Tuples and Lists in Python What are the Major Differences Between Them?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Lists:\n    <ul>\n      <li>In Python, a list is created by placing elements inside square brackets <code class=\"language-plaintext highlighter-rouge\">[]</code>, separated by commas. A list can have any number of items and they may be of different types (integer, float, string, etc.). A list can also have another list as an item. This is called a nested list.\n        <ol>\n          <li>Lists are mutable (we can change, add, delete and modify stuff).</li>\n          <li>Lists are better for performing operations, such as insertion and deletion.</li>\n          <li>Lists consume more memory.</li>\n          <li>Lists have several built-in methods.</li>\n        </ol>\n      </li>\n    </ul>\n  </li>\n  <li>Tuples:\n    <ul>\n      <li>A tuple is a collection of objects which ordered and immutable. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\n        <ol>\n          <li>Tuples are immutable (we cannot change, add, delete and modify stuff).</li>\n          <li>Tuple data type is appropriate for accessing the elements.</li>\n          <li>Tuples consume less memory as compared to the list.</li>\n          <li>Tuple does not have many built-in methods.</li>\n        </ol>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>In Python, a list is created by placing elements inside square brackets <code class=\"language-plaintext highlighter-rouge\">[]</code>, separated by commas. A list can have any number of items and they may be of different types (integer, float, string, etc.). A list can also have another list as an item. This is called a nested list.\n        <ol>\n          <li>Lists are mutable (we can change, add, delete and modify stuff).</li>\n          <li>Lists are better for performing operations, such as insertion and deletion.</li>\n          <li>Lists consume more memory.</li>\n          <li>Lists have several built-in methods.</li>\n        </ol>\n      </li>\n    </ul>\n<ol>\n          <li>Lists are mutable (we can change, add, delete and modify stuff).</li>\n          <li>Lists are better for performing operations, such as insertion and deletion.</li>\n          <li>Lists consume more memory.</li>\n          <li>Lists have several built-in methods.</li>\n        </ol>\n<ul>\n      <li>A tuple is a collection of objects which ordered and immutable. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\n        <ol>\n          <li>Tuples are immutable (we cannot change, add, delete and modify stuff).</li>\n          <li>Tuple data type is appropriate for accessing the elements.</li>\n          <li>Tuples consume less memory as compared to the list.</li>\n          <li>Tuple does not have many built-in methods.</li>\n        </ol>\n      </li>\n    </ul>\n<ol>\n          <li>Tuples are immutable (we cannot change, add, delete and modify stuff).</li>\n          <li>Tuple data type is appropriate for accessing the elements.</li>\n          <li>Tuples consume less memory as compared to the list.</li>\n          <li>Tuple does not have many built-in methods.</li>\n        </ol>",
      "contentMarkdown": "*   Lists:\n    *   In Python, a list is created by placing elements inside square brackets `[]`, separated by commas. A list can have any number of items and they may be of different types (integer, float, string, etc.). A list can also have another list as an item. This is called a nested list.\n        1.  Lists are mutable (we can change, add, delete and modify stuff).\n        2.  Lists are better for performing operations, such as insertion and deletion.\n        3.  Lists consume more memory.\n        4.  Lists have several built-in methods.\n*   Tuples:\n    *   A tuple is a collection of objects which ordered and immutable. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\n        1.  Tuples are immutable (we cannot change, add, delete and modify stuff).\n        2.  Tuple data type is appropriate for accessing the elements.\n        3.  Tuples consume less memory as compared to the list.\n        4.  Tuple does not have many built-in methods.\n\n*   In Python, a list is created by placing elements inside square brackets `[]`, separated by commas. A list can have any number of items and they may be of different types (integer, float, string, etc.). A list can also have another list as an item. This is called a nested list.\n    1.  Lists are mutable (we can change, add, delete and modify stuff).\n    2.  Lists are better for performing operations, such as insertion and deletion.\n    3.  Lists consume more memory.\n    4.  Lists have several built-in methods.\n\n1.  Lists are mutable (we can change, add, delete and modify stuff).\n2.  Lists are better for performing operations, such as insertion and deletion.\n3.  Lists consume more memory.\n4.  Lists have several built-in methods.\n\n*   A tuple is a collection of objects which ordered and immutable. Tuples are sequences, just like lists. The differences between tuples and lists are, the tuples cannot be changed unlike lists and tuples use parentheses, whereas lists use square brackets.\n    1.  Tuples are immutable (we cannot change, add, delete and modify stuff).\n    2.  Tuple data type is appropriate for accessing the elements.\n    3.  Tuples consume less memory as compared to the list.\n    4.  Tuple does not have many built-in methods.\n\n1.  Tuples are immutable (we cannot change, add, delete and modify stuff).\n2.  Tuple data type is appropriate for accessing the elements.\n3.  Tuples consume less memory as compared to the list.\n4.  Tuple does not have many built-in methods.",
      "order": 53,
      "orderInChapter": 53,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 415,
        "contentLength": 3277
      },
      "nextCards": [
        "ai-interview-given-a-left-skewed-distribution-that-has-a-median-54",
        "ai-interview-explain-the-kernel-trick-in-svm-and-why-we-use-it--55"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#define-tuples-and-lists-in-python-what-are-the-major-differences-between-them?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-given-a-left-skewed-distribution-that-has-a-median-54",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Given a Left-skewed Distribution That Has a Median of 60, What Conclusions Can We Draw about the Mean and the Mode of the Data?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Left skewed distribution means the tail of the distribution is to the left and the tip is to the right. So the mean which tends to be near outliers (very large or small values) will be shifted towards the left or in other words, towards the tail.</li>\n  <li>While the mode (which represents the most repeated value) will be near the tip and the median is the middle element independent of the distribution skewness, therefore it will be smaller than the mode and more than the mean.</li>\n  <li>Thus,\n    <ul>\n      <li>Mean &lt; 60</li>\n      <li>Mode &gt; 60</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Mean &lt; 60</li>\n      <li>Mode &gt; 60</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/skewdist.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Left skewed distribution means the tail of the distribution is to the left and the tip is to the right. So the mean which tends to be near outliers (very large or small values) will be shifted towards the left or in other words, towards the tail.\n*   While the mode (which represents the most repeated value) will be near the tip and the median is the middle element independent of the distribution skewness, therefore it will be smaller than the mode and more than the mean.\n*   Thus,\n    *   Mean < 60\n    *   Mode > 60\n\n*   Mean < 60\n*   Mode > 60\n\n![](/primers/ai/assets/interview/skewdist.jpeg)",
      "order": 54,
      "orderInChapter": 54,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 107,
        "contentLength": 739
      },
      "nextCards": [
        "ai-interview-explain-the-kernel-trick-in-svm-and-why-we-use-it--55",
        "ai-interview-can-you-explain-the-parameter-sharing-concept-in-d-56"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#given-a-left-skewed-distribution-that-has-a-median-of-60,-what-conclusions-can-we-draw-about-the-mean-and-the-mode-of-the-data?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-kernel-trick-in-svm-and-why-we-use-it--55",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain the Kernel Trick in SVM and Why We Use It and How to Choose What Kernel to Use?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Kernels are used in SVM to map the original input data into a particular higher dimensional space where it will be easier to find patterns in the data and train the model with better performance.\n    <ul>\n      <li>For e.g.: If we have binary class data which form a ring-like pattern (inner and outer rings representing two different class instances) when plotted in 2D space, a linear SVM kernel will not be able to differentiate the two classes well when compared to a RBF (radial basis function) kernel, mapping the data into a particular higher dimensional space where the two classes are clearly separable.</li>\n    </ul>\n  </li>\n  <li>Typically without the kernel trick, in order to calculate support vectors and support vector classifiers, we need first to transform data points one by one to the higher dimensional space, and do the calculations based on SVM equations in the higher dimensional space, then return the results. The ‘trick’ in the kernel trick is that we design the kernels based on some conditions as mathematical functions that are equivalent to a dot product in the higher dimensional space without even having to transform data points to the higher dimensional space. i.e we can calculate support vectors and support vector classifiers in the same space where the data is provided which saves a lot of time and calculations.</li>\n  <li>Having domain knowledge can be very helpful in choosing the optimal kernel for your problem, however in the absence of such knowledge following this default rule can be helpful:\nFor linear problems, we can try linear or logistic kernels and for nonlinear problems, we can use RBF or Gaussian kernels.</li>\n</ul>\n<ul>\n      <li>For e.g.: If we have binary class data which form a ring-like pattern (inner and outer rings representing two different class instances) when plotted in 2D space, a linear SVM kernel will not be able to differentiate the two classes well when compared to a RBF (radial basis function) kernel, mapping the data into a particular higher dimensional space where the two classes are clearly separable.</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/svmkt.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Kernels are used in SVM to map the original input data into a particular higher dimensional space where it will be easier to find patterns in the data and train the model with better performance.\n    *   For e.g.: If we have binary class data which form a ring-like pattern (inner and outer rings representing two different class instances) when plotted in 2D space, a linear SVM kernel will not be able to differentiate the two classes well when compared to a RBF (radial basis function) kernel, mapping the data into a particular higher dimensional space where the two classes are clearly separable.\n*   Typically without the kernel trick, in order to calculate support vectors and support vector classifiers, we need first to transform data points one by one to the higher dimensional space, and do the calculations based on SVM equations in the higher dimensional space, then return the results. The ‘trick’ in the kernel trick is that we design the kernels based on some conditions as mathematical functions that are equivalent to a dot product in the higher dimensional space without even having to transform data points to the higher dimensional space. i.e we can calculate support vectors and support vector classifiers in the same space where the data is provided which saves a lot of time and calculations.\n*   Having domain knowledge can be very helpful in choosing the optimal kernel for your problem, however in the absence of such knowledge following this default rule can be helpful: For linear problems, we can try linear or logistic kernels and for nonlinear problems, we can use RBF or Gaussian kernels.\n\n*   For e.g.: If we have binary class data which form a ring-like pattern (inner and outer rings representing two different class instances) when plotted in 2D space, a linear SVM kernel will not be able to differentiate the two classes well when compared to a RBF (radial basis function) kernel, mapping the data into a particular higher dimensional space where the two classes are clearly separable.\n\n![](/primers/ai/assets/interview/svmkt.jpeg)",
      "order": 55,
      "orderInChapter": 55,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 340,
        "contentLength": 2180
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-parameter-sharing-concept-in-d-56",
        "ai-interview-what-is-the-difference-between-between-and-in-oper-57"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-kernel-trick-in-svm-and-why-we-use-it-and-how-to-choose-what-kernel-to-use?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-parameter-sharing-concept-in-d-56",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Explain the Parameter Sharing Concept in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Parameter sharing is the method of sharing weights by all neurons in a particular feature map. Therefore helps to reduce the number of parameters in the whole system, making it computationally cheap. It basically means that the same parameters will be used to represent different transformations in the system. This basically means the same matrix elements may be updated multiple times during backpropagation from varied gradients. The same set of elements will facilitate transformations at more than one layer instead of those from a single layer as conventional. This is usually done in architectures like Siamese that tend to have parallel trunks trained simultaneously. In that case, using shared weights in a few layers (usually the bottom layers) helps the model converge better. This behavior, as observed, can be attributed to more diverse feature representations learned by the system. Since neurons corresponding to the same features are triggered in varied scenarios. Helps to model to generalize better.</li>\n  <li>Note that sometimes the parameter sharing assumption may not make sense. This is especially the case when the input images to a ConvNet have some specific centered structure, where we should expect, for example, that completely different features should be learned on one side of the image than another.</li>\n  <li>One practical example is when the input is faces that have been centered in the image. You might expect that different eye-specific or hair-specific features could (and should) be learned in different spatial locations. In that case, it is common to relax the parameter sharing scheme, and instead, simply call the layer a Locally-Connected Layer.</li>\n</ul>",
      "contentMarkdown": "*   Parameter sharing is the method of sharing weights by all neurons in a particular feature map. Therefore helps to reduce the number of parameters in the whole system, making it computationally cheap. It basically means that the same parameters will be used to represent different transformations in the system. This basically means the same matrix elements may be updated multiple times during backpropagation from varied gradients. The same set of elements will facilitate transformations at more than one layer instead of those from a single layer as conventional. This is usually done in architectures like Siamese that tend to have parallel trunks trained simultaneously. In that case, using shared weights in a few layers (usually the bottom layers) helps the model converge better. This behavior, as observed, can be attributed to more diverse feature representations learned by the system. Since neurons corresponding to the same features are triggered in varied scenarios. Helps to model to generalize better.\n*   Note that sometimes the parameter sharing assumption may not make sense. This is especially the case when the input images to a ConvNet have some specific centered structure, where we should expect, for example, that completely different features should be learned on one side of the image than another.\n*   One practical example is when the input is faces that have been centered in the image. You might expect that different eye-specific or hair-specific features could (and should) be learned in different spatial locations. In that case, it is common to relax the parameter sharing scheme, and instead, simply call the layer a Locally-Connected Layer.",
      "order": 56,
      "orderInChapter": 56,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "backpropagation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 264,
        "contentLength": 1713
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-between-and-in-oper-57",
        "ai-interview-what-is-the-meaning-of-selection-bias-and-how-to-a-58"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-benefits-limitations-and-open-questions-57",
        "ai-agentic-RL-monte-carlo-tree-search-mcts-in-rl-based-agents-37",
        "ai-reasoning-in-LLMs-monte-carlo-tree-search-mcts-based-reasoning-16",
        "ai-mixture-of-experts-architectural-alternatives-27",
        "ai-agentic-RL-practical-engineering-for-stable-multi-turn-tir-62"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-parameter-sharing-concept-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-between-and-in-oper-57",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between BETWEEN and in Operators in SQL?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">BETWEEN</code> –&gt; range between two elements including themselves); <code class=\"language-plaintext highlighter-rouge\">IN</code> –&gt; elements in a set(list)</li>\n  <li>As an simple example:</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/between_in.png\" alt=\"\"></p>",
      "contentMarkdown": "*   `BETWEEN` –> range between two elements including themselves); `IN` –> elements in a set(list)\n*   As an simple example:\n\n![](/primers/ai/assets/interview/between_in.png)",
      "order": 57,
      "orderInChapter": 57,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 21,
        "contentLength": 337
      },
      "nextCards": [
        "ai-interview-what-is-the-meaning-of-selection-bias-and-how-to-a-58",
        "ai-interview-given-two-python-series-write-a-function-to-comput-59"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-between-and-in-operators-in-sql?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-meaning-of-selection-bias-and-how-to-a-58",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Meaning of Selection Bias and How to Avoid It?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Sampling bias is the phenomenon that occurs when a research study design fails to collect a representative sample of a target population. This typically occurs because the selection criteria for respondents failed to capture a wide enough sampling frame to represent all viewpoints.</p>\n  </li>\n  <li>The cause of sampling bias almost always owes to one of two conditions.\n    <ol>\n      <li>Poor methodology: In most cases, non-representative samples pop up when researchers set improper parameters for survey research. The most accurate and repeatable sampling method is simple random sampling where a large number of respondents are chosen at random. When researchers stray from random sampling (also called probability sampling), they risk injecting their own selection bias into recruiting respondents.</li>\n      <li>Poor execution: Sometimes data researchers craft scientifically sound sampling methods, but their work is undermined when field workers cut corners. By reverting to convenience sampling (where the only people studied are those who are easy to reach) or giving up on reaching non-responders, a field worker can jeopardize the careful methodology set up by data scientists.</li>\n    </ol>\n  </li>\n  <li>The best way to avoid sampling bias is to stick to probability-based sampling methods. These include simple random sampling, systematic sampling, cluster sampling, and stratified sampling. In these methodologies, respondents are only chosen through processes of random selection—even if they are sometimes sorted into demographic groups along the way.</li>\n</ul>\n<p>Sampling bias is the phenomenon that occurs when a research study design fails to collect a representative sample of a target population. This typically occurs because the selection criteria for respondents failed to capture a wide enough sampling frame to represent all viewpoints.</p>\n<ol>\n      <li>Poor methodology: In most cases, non-representative samples pop up when researchers set improper parameters for survey research. The most accurate and repeatable sampling method is simple random sampling where a large number of respondents are chosen at random. When researchers stray from random sampling (also called probability sampling), they risk injecting their own selection bias into recruiting respondents.</li>\n      <li>Poor execution: Sometimes data researchers craft scientifically sound sampling methods, but their work is undermined when field workers cut corners. By reverting to convenience sampling (where the only people studied are those who are easy to reach) or giving up on reaching non-responders, a field worker can jeopardize the careful methodology set up by data scientists.</li>\n    </ol>\n<p><img src=\"/primers/ai/assets/interview/sel_bias.jpg\" alt=\"\"></p>",
      "contentMarkdown": "*   Sampling bias is the phenomenon that occurs when a research study design fails to collect a representative sample of a target population. This typically occurs because the selection criteria for respondents failed to capture a wide enough sampling frame to represent all viewpoints.\n    \n*   The cause of sampling bias almost always owes to one of two conditions.\n    1.  Poor methodology: In most cases, non-representative samples pop up when researchers set improper parameters for survey research. The most accurate and repeatable sampling method is simple random sampling where a large number of respondents are chosen at random. When researchers stray from random sampling (also called probability sampling), they risk injecting their own selection bias into recruiting respondents.\n    2.  Poor execution: Sometimes data researchers craft scientifically sound sampling methods, but their work is undermined when field workers cut corners. By reverting to convenience sampling (where the only people studied are those who are easy to reach) or giving up on reaching non-responders, a field worker can jeopardize the careful methodology set up by data scientists.\n*   The best way to avoid sampling bias is to stick to probability-based sampling methods. These include simple random sampling, systematic sampling, cluster sampling, and stratified sampling. In these methodologies, respondents are only chosen through processes of random selection—even if they are sometimes sorted into demographic groups along the way.\n\nSampling bias is the phenomenon that occurs when a research study design fails to collect a representative sample of a target population. This typically occurs because the selection criteria for respondents failed to capture a wide enough sampling frame to represent all viewpoints.\n\n1.  Poor methodology: In most cases, non-representative samples pop up when researchers set improper parameters for survey research. The most accurate and repeatable sampling method is simple random sampling where a large number of respondents are chosen at random. When researchers stray from random sampling (also called probability sampling), they risk injecting their own selection bias into recruiting respondents.\n2.  Poor execution: Sometimes data researchers craft scientifically sound sampling methods, but their work is undermined when field workers cut corners. By reverting to convenience sampling (where the only people studied are those who are easy to reach) or giving up on reaching non-responders, a field worker can jeopardize the careful methodology set up by data scientists.\n\n![](/primers/ai/assets/interview/sel_bias.jpg)",
      "order": 58,
      "orderInChapter": 58,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 384,
        "contentLength": 2796
      },
      "nextCards": [
        "ai-interview-given-two-python-series-write-a-function-to-comput-59",
        "ai-interview-define-the-cross-validation-process-and-the-motiva-60"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-meaning-of-selection-bias-and-how-to-avoid-it?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-given-two-python-series-write-a-function-to-comput-59",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Given Two Python Series, Write a Function to Compute the Euclidean Distance Between Them?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>There are different ways to solve this question. The notebook snippet below shows various ways (along with credits to the respetive individual authors) and also shows the computation time for each method. Furthermore, the computation time for each method is calculated depending on whether the input was a NumPy array vs. Python Series and as shown using a NumPy array decreases the computation time.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/euclid.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   There are different ways to solve this question. The notebook snippet below shows various ways (along with credits to the respetive individual authors) and also shows the computation time for each method. Furthermore, the computation time for each method is calculated depending on whether the input was a NumPy array vs. Python Series and as shown using a NumPy array decreases the computation time.\n\n![](/primers/ai/assets/interview/euclid.jpeg)",
      "order": 59,
      "orderInChapter": 59,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 66,
        "contentLength": 489
      },
      "nextCards": [
        "ai-interview-define-the-cross-validation-process-and-the-motiva-60",
        "ai-interview-what-is-the-difference-between-the-bernoulli-and-b-61"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#given-two-python-series,-write-a-function-to-compute-the-euclidean-distance-between-them?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-define-the-cross-validation-process-and-the-motiva-60",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Define the Cross-validation Process and the Motivation Behind Using It?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Cross-validation is a technique used to assess the performance of a learning model in several subsamples of training data. In general, we split the data into train and test sets where we use the training data to train our model and the test data to evaluate the performance of the model on unseen data and validation set for choosing the best hyperparameters. Now, a random split in most cases (for large datasets) is fine. But for smaller datasets, it is susceptible to loss of important information present in the data in which it was not trained. Hence, cross-validation though computationally bit expensive combats this issue.</p>\n  </li>\n  <li>\n    <p>The process of cross-validation is as the following:</p>\n\n    <ol>\n      <li>Define <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-53-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-482\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-483\"><span class=\"mi\" id=\"MathJax-Span-484\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-53\">k</script> or the number of folds.</li>\n      <li>Randomly shuffle the data into <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-54-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-485\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-486\"><span class=\"mi\" id=\"MathJax-Span-487\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-54\">k</script> equally-sized blocks (folds).</li>\n      <li>For each <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-55-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-488\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-489\"><span class=\"mi\" id=\"MathJax-Span-490\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-55\">i</script> in fold (1 to <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-56-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-491\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-492\"><span class=\"mi\" id=\"MathJax-Span-493\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-56\">k</script>), train the data using all the folds except for fold <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-57-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-494\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-495\"><span class=\"mi\" id=\"MathJax-Span-496\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-57\">i</script> and test on the fold <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-58-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-497\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-498\"><span class=\"mi\" id=\"MathJax-Span-499\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-58\">i</script>.</li>\n      <li>Average the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-59-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-500\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-501\"><span class=\"mi\" id=\"MathJax-Span-502\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-59\">k</script> validation/test error from the previous step to get an estimate of the error.</li>\n    </ol>\n  </li>\n  <li>This process aims to accomplish the following:\n    <ul>\n      <li>Prevent overfitting during training by avoiding training and testing on the same subset of the data points</li>\n      <li>Avoid information loss by using a certain subset of the data for validation only. This is important for small datasets.</li>\n    </ul>\n  </li>\n  <li>Cross-validation is always good to be used for small datasets, and if used for large datasets the computational complexity will increase depending on the number of folds.</li>\n</ul>\n<p>Cross-validation is a technique used to assess the performance of a learning model in several subsamples of training data. In general, we split the data into train and test sets where we use the training data to train our model and the test data to evaluate the performance of the model on unseen data and validation set for choosing the best hyperparameters. Now, a random split in most cases (for large datasets) is fine. But for smaller datasets, it is susceptible to loss of important information present in the data in which it was not trained. Hence, cross-validation though computationally bit expensive combats this issue.</p>\n<p>The process of cross-validation is as the following:</p>\n<ol>\n      <li>Define <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-53-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-482\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-483\"><span class=\"mi\" id=\"MathJax-Span-484\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-53\">k</script> or the number of folds.</li>\n      <li>Randomly shuffle the data into <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-54-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-485\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-486\"><span class=\"mi\" id=\"MathJax-Span-487\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-54\">k</script> equally-sized blocks (folds).</li>\n      <li>For each <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-55-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-488\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-489\"><span class=\"mi\" id=\"MathJax-Span-490\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-55\">i</script> in fold (1 to <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-56-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-491\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-492\"><span class=\"mi\" id=\"MathJax-Span-493\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-56\">k</script>), train the data using all the folds except for fold <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-57-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-494\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-495\"><span class=\"mi\" id=\"MathJax-Span-496\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-57\">i</script> and test on the fold <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-58-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-497\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-498\"><span class=\"mi\" id=\"MathJax-Span-499\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-58\">i</script>.</li>\n      <li>Average the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-59-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-500\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-501\"><span class=\"mi\" id=\"MathJax-Span-502\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-59\">k</script> validation/test error from the previous step to get an estimate of the error.</li>\n    </ol>\n<ul>\n      <li>Prevent overfitting during training by avoiding training and testing on the same subset of the data points</li>\n      <li>Avoid information loss by using a certain subset of the data for validation only. This is important for small datasets.</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/cv.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Cross-validation is a technique used to assess the performance of a learning model in several subsamples of training data. In general, we split the data into train and test sets where we use the training data to train our model and the test data to evaluate the performance of the model on unseen data and validation set for choosing the best hyperparameters. Now, a random split in most cases (for large datasets) is fine. But for smaller datasets, it is susceptible to loss of important information present in the data in which it was not trained. Hence, cross-validation though computationally bit expensive combats this issue.\n    \n*   The process of cross-validation is as the following:\n    \n    1.  Define kkk or the number of folds.\n    2.  Randomly shuffle the data into kkk equally-sized blocks (folds).\n    3.  For each iii in fold (1 to kkk), train the data using all the folds except for fold iii and test on the fold iii.\n    4.  Average the kkk validation/test error from the previous step to get an estimate of the error.\n*   This process aims to accomplish the following:\n    *   Prevent overfitting during training by avoiding training and testing on the same subset of the data points\n    *   Avoid information loss by using a certain subset of the data for validation only. This is important for small datasets.\n*   Cross-validation is always good to be used for small datasets, and if used for large datasets the computational complexity will increase depending on the number of folds.\n\nCross-validation is a technique used to assess the performance of a learning model in several subsamples of training data. In general, we split the data into train and test sets where we use the training data to train our model and the test data to evaluate the performance of the model on unseen data and validation set for choosing the best hyperparameters. Now, a random split in most cases (for large datasets) is fine. But for smaller datasets, it is susceptible to loss of important information present in the data in which it was not trained. Hence, cross-validation though computationally bit expensive combats this issue.\n\nThe process of cross-validation is as the following:\n\n1.  Define kkk or the number of folds.\n2.  Randomly shuffle the data into kkk equally-sized blocks (folds).\n3.  For each iii in fold (1 to kkk), train the data using all the folds except for fold iii and test on the fold iii.\n4.  Average the kkk validation/test error from the previous step to get an estimate of the error.\n\n*   Prevent overfitting during training by avoiding training and testing on the same subset of the data points\n*   Avoid information loss by using a certain subset of the data for validation only. This is important for small datasets.\n\n![](/primers/ai/assets/interview/cv.jpeg)",
      "order": 60,
      "orderInChapter": 60,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "cross-validation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 465,
        "contentLength": 20261
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-the-bernoulli-and-b-61",
        "ai-interview-given-an-integer-nnn-and-an-integer-kkk-output-a-l-62"
      ],
      "relatedCards": [
        "ai-model-debugging-hyper-parameter-optimization-hpo-17",
        "ai-k-nearest-neighbors-parameters-4",
        "ai-ml-comp-support-vector-machines-5",
        "ai-model-debugging-overfitting-8",
        "ai-k-nearest-neighbors-faq-what-are-some-methods-that-do-not-require-a-pr-9"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#define-the-cross-validation-process-and-the-motivation-behind-using-it?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-the-bernoulli-and-b-61",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between the Bernoulli and Binomial Distribution?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Bernoulli and Binomial are both types of probability distributions.</li>\n  <li>\n    <p>The function of Bernoulli is given by</p>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-60-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><msup><mi>p</mi><mi>x</mi></msup><mo>&amp;#x2217;</mo><msup><mi>q</mi><mo stretchy=&quot;false&quot;>(</mo></msup><mn>1</mn><mo>&amp;#x2212;</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>,</mo><mi>x</mi><mo>=</mo><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>]</mo></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-503\" style=\"width: 14.846em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 12.346em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1012.24em, 2.607em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-504\"><span class=\"mi\" id=\"MathJax-Span-505\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-506\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-507\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-508\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-509\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"msubsup\" id=\"MathJax-Span-510\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-511\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-512\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-513\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"msubsup\" id=\"MathJax-Span-514\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-515\" style=\"font-family: STIXGeneral-Italic;\">q</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 0.523em;\"><span class=\"mo\" id=\"MathJax-Span-516\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">(</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mn\" id=\"MathJax-Span-517\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-518\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-519\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-520\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-521\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-522\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-523\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-524\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">[</span><span class=\"mn\" id=\"MathJax-Span-525\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-526\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-527\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">1</span><span class=\"mo\" id=\"MathJax-Span-528\" style=\"font-family: STIXGeneral-Regular;\">]</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.441em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>p</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>p</mi><mi>x</mi></msup><mo>∗</mo><msup><mi>q</mi><mo stretchy=\"false\">(</mo></msup><mn>1</mn><mo>−</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>,</mo><mi>x</mi><mo>=</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-60\">p(x) =p^x * q^(1-x), x=[0,1]</script>\n\n    <ul>\n      <li>where,\n        <ul>\n          <li>Mean is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-61-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-529\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-530\"><span class=\"mi\" id=\"MathJax-Span-531\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-61\">p</script>.</li>\n          <li>Variance <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-62-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-532\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1004.27em, 2.607em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-533\"><span class=\"mi\" id=\"MathJax-Span-534\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-535\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-536\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-537\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-538\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-539\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span><span class=\"mo\" id=\"MathJax-Span-540\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-62\">p*(1-p)</script>.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <p>The function Binomial is given by:</p>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-63-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>n</mi><mi>C</mi><mi>x</mi><msup><mi>p</mi><mi>x</mi></msup><msup><mi>q</mi><mo stretchy=&quot;false&quot;>(</mo></msup><mi>n</mi><mo>&amp;#x2212;</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mi>x</mi><mo>=</mo><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2...</mn><mi>n</mi><mo stretchy=&quot;false&quot;>]</mo></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-541\" style=\"width: 17.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 14.742em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.148em, 1014.64em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-542\"><span class=\"mi\" id=\"MathJax-Span-543\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-544\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-545\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-546\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-547\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-548\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">n</span><span class=\"mi\" id=\"MathJax-Span-549\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-550\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"msubsup\" id=\"MathJax-Span-551\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-552\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-553\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-554\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-555\" style=\"font-family: STIXGeneral-Italic;\">q</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 0.523em;\"><span class=\"mo\" id=\"MathJax-Span-556\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">(</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-557\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mo\" id=\"MathJax-Span-558\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-559\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-560\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mi\" id=\"MathJax-Span-561\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-562\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-563\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">[</span><span class=\"mn\" id=\"MathJax-Span-564\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-565\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-566\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">1</span><span class=\"mo\" id=\"MathJax-Span-567\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-568\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">2...</span><span class=\"mi\" id=\"MathJax-Span-569\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mo\" id=\"MathJax-Span-570\" style=\"font-family: STIXGeneral-Regular;\">]</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.441em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>p</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>n</mi><mi>C</mi><mi>x</mi><msup><mi>p</mi><mi>x</mi></msup><msup><mi>q</mi><mo stretchy=\"false\">(</mo></msup><mi>n</mi><mo>−</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>x</mi><mo>=</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2...</mn><mi>n</mi><mo stretchy=\"false\">]</mo></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-63\">p(x) = nCx p^x q^(n-x) x=[0,1,2...n]</script>\n\n    <ul>\n      <li>where,\n        <ul>\n          <li>Mean: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-64-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-571\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.94em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-572\"><span class=\"mi\" id=\"MathJax-Span-573\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-574\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-64\">np</script>.</li>\n          <li>Variance: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-65-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mi>p</mi><mi>q</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-575\" style=\"width: 1.826em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.51em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-576\"><span class=\"mi\" id=\"MathJax-Span-577\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-578\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-579\" style=\"font-family: STIXGeneral-Italic;\">q</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mi>p</mi><mi>q</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-65\">npq</script>.\nWhere p and q are the probability of success and probability of failure respectively, n is the number of independent trials and x is the number of successes.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>As we can see sample space (<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-66-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-580\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-581\"><span class=\"mi\" id=\"MathJax-Span-582\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-66\">x</script>) for Bernoulli distribution is Binary (2 outcomes), and just a single trial.</li>\n  <li>For e.g., a loan sanction for a person can be either a success or a failure, with no other possibility. (Hence single trial).\n    <ul>\n      <li>Whereas for Binomial the sample space (<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-67-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-583\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-584\"><span class=\"mi\" id=\"MathJax-Span-585\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-67\">x</script>) ranges from <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-68-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn><mo>&amp;#x2212;</mo><mi>n</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-586\" style=\"width: 2.503em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-587\"><span class=\"mn\" id=\"MathJax-Span-588\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-589\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-590\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">n</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>0</mn><mo>−</mo><mi>n</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-68\">0-n</script>.</li>\n    </ul>\n  </li>\n  <li>As an example, tossing a coin 6 times, what is the probability of getting 2 or a few heads?</li>\n  <li>Here sample space is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-69-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi><mo>=</mo><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy=&quot;false&quot;>]</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-591\" style=\"width: 5.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.794em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.69em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-592\"><span class=\"mi\" id=\"MathJax-Span-593\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-594\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-595\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">[</span><span class=\"mn\" id=\"MathJax-Span-596\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-597\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-598\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">1</span><span class=\"mo\" id=\"MathJax-Span-599\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-600\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">2</span><span class=\"mo\" id=\"MathJax-Span-601\" style=\"font-family: STIXGeneral-Regular;\">]</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi><mo>=</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy=\"false\">]</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-69\">x=[0,1,2]</script> and more than 1 trial and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-70-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>6</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-602\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.14em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-603\"><span class=\"mi\" id=\"MathJax-Span-604\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mo\" id=\"MathJax-Span-605\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-606\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">6</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mo>=</mo><mn>6</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-70\">n=6</script> (finite).</li>\n  <li>In short, Bernoulli Distribution is a single trial version of Binomial Distribution.</li>\n</ul>\n<p>The function of Bernoulli is given by</p>\n<ul>\n      <li>where,\n        <ul>\n          <li>Mean is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-61-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-529\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-530\"><span class=\"mi\" id=\"MathJax-Span-531\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-61\">p</script>.</li>\n          <li>Variance <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-62-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-532\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1004.27em, 2.607em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-533\"><span class=\"mi\" id=\"MathJax-Span-534\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-535\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-536\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-537\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-538\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-539\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span><span class=\"mo\" id=\"MathJax-Span-540\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-62\">p*(1-p)</script>.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Mean is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-61-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-529\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-530\"><span class=\"mi\" id=\"MathJax-Span-531\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-61\">p</script>.</li>\n          <li>Variance <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-62-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mo>&amp;#x2217;</mo><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-532\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1004.27em, 2.607em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-533\"><span class=\"mi\" id=\"MathJax-Span-534\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mo\" id=\"MathJax-Span-535\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mo\" id=\"MathJax-Span-536\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">(</span><span class=\"mn\" id=\"MathJax-Span-537\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-538\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-539\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span><span class=\"mo\" id=\"MathJax-Span-540\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-62\">p*(1-p)</script>.</li>\n        </ul>\n<p>The function Binomial is given by:</p>\n<ul>\n      <li>where,\n        <ul>\n          <li>Mean: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-64-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-571\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.94em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-572\"><span class=\"mi\" id=\"MathJax-Span-573\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-574\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-64\">np</script>.</li>\n          <li>Variance: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-65-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mi>p</mi><mi>q</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-575\" style=\"width: 1.826em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.51em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-576\"><span class=\"mi\" id=\"MathJax-Span-577\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-578\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-579\" style=\"font-family: STIXGeneral-Italic;\">q</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mi>p</mi><mi>q</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-65\">npq</script>.\nWhere p and q are the probability of success and probability of failure respectively, n is the number of independent trials and x is the number of successes.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Mean: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-64-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-571\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.94em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-572\"><span class=\"mi\" id=\"MathJax-Span-573\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-574\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-64\">np</script>.</li>\n          <li>Variance: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-65-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mi>p</mi><mi>q</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-575\" style=\"width: 1.826em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.51em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-576\"><span class=\"mi\" id=\"MathJax-Span-577\" style=\"font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-578\" style=\"font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-579\" style=\"font-family: STIXGeneral-Italic;\">q</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>n</mi><mi>p</mi><mi>q</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-65\">npq</script>.\nWhere p and q are the probability of success and probability of failure respectively, n is the number of independent trials and x is the number of successes.</li>\n        </ul>\n<ul>\n      <li>Whereas for Binomial the sample space (<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-67-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-583\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-584\"><span class=\"mi\" id=\"MathJax-Span-585\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>x</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-67\">x</script>) ranges from <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-68-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn><mo>&amp;#x2212;</mo><mi>n</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-586\" style=\"width: 2.503em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-587\"><span class=\"mn\" id=\"MathJax-Span-588\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-589\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-590\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">n</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>0</mn><mo>−</mo><mi>n</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-68\">0-n</script>.</li>\n    </ul>",
      "contentMarkdown": "*   Bernoulli and Binomial are both types of probability distributions.\n*   The function of Bernoulli is given by\n    \n    p(x)\\=px∗q(1−x),x\\=\\[0,1\\]p(x)\\=px∗q(1−x),x\\=\\[0,1\\]\n    \n    p(x) =p^x \\* q^(1-x), x=\\[0,1\\]\n    *   where,\n        *   Mean is ppp.\n        *   Variance p∗(1−p)p∗(1−p)p\\*(1-p).\n*   The function Binomial is given by:\n    \n    p(x)\\=nCxpxq(n−x)x\\=\\[0,1,2...n\\]p(x)\\=nCxpxq(n−x)x\\=\\[0,1,2...n\\]\n    \n    p(x) = nCx p^x q^(n-x) x=\\[0,1,2...n\\]\n    *   where,\n        *   Mean: npnpnp.\n        *   Variance: npqnpqnpq. Where p and q are the probability of success and probability of failure respectively, n is the number of independent trials and x is the number of successes.\n*   As we can see sample space (xxx) for Bernoulli distribution is Binary (2 outcomes), and just a single trial.\n*   For e.g., a loan sanction for a person can be either a success or a failure, with no other possibility. (Hence single trial).\n    *   Whereas for Binomial the sample space (xxx) ranges from 0−n0−n0-n.\n*   As an example, tossing a coin 6 times, what is the probability of getting 2 or a few heads?\n*   Here sample space is x\\=\\[0,1,2\\]x\\=\\[0,1,2\\]x=\\[0,1,2\\] and more than 1 trial and n\\=6n\\=6n=6 (finite).\n*   In short, Bernoulli Distribution is a single trial version of Binomial Distribution.\n\nThe function of Bernoulli is given by\n\n*   where,\n    *   Mean is ppp.\n    *   Variance p∗(1−p)p∗(1−p)p\\*(1-p).\n\n*   Mean is ppp.\n*   Variance p∗(1−p)p∗(1−p)p\\*(1-p).\n\nThe function Binomial is given by:\n\n*   where,\n    *   Mean: npnpnp.\n    *   Variance: npqnpqnpq. Where p and q are the probability of success and probability of failure respectively, n is the number of independent trials and x is the number of successes.\n\n*   Mean: npnpnp.\n*   Variance: npqnpqnpq. Where p and q are the probability of success and probability of failure respectively, n is the number of independent trials and x is the number of successes.\n\n*   Whereas for Binomial the sample space (xxx) ranges from 0−n0−n0-n.",
      "order": 61,
      "orderInChapter": 61,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 295,
        "contentLength": 42133
      },
      "nextCards": [
        "ai-interview-given-an-integer-nnn-and-an-integer-kkk-output-a-l-62",
        "ai-interview-explain-the-long-tailed-distribution-and-provide-t-63"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-the-bernoulli-and-binomial-distribution?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-given-an-integer-nnn-and-an-integer-kkk-output-a-l-62",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Given an Integer nnn and an Integer KKK, Output a List of All of the Combinations of kkk Numbers Chosen from 1 to nnn. for Example, If n=3n=3n=3 and k=2k=2k=2, Return [1,2],[1,3],[2,3][1,2],[1,3],[2,3][1,2],[1,3],[2,3].",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>There are different solutions one of them is the one below, there are other solutions in the comments of the original post and also the benchmarking between them thanks to Behnam Hedayat</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code14\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code14\"><span class=\"kn\">from</span> <span class=\"nn\">itertools</span> <span class=\"kn\">import</span> <span class=\"n\">combinations</span> \n<span class=\"k\">def</span> <span class=\"nf\">find_combintaion</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">):</span>\n\t<span class=\"n\">list_num</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\t<span class=\"n\">comb</span> <span class=\"o\">=</span> <span class=\"n\">combinations</span><span class=\"p\">([</span><span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)],</span> <span class=\"n\">k</span><span class=\"p\">)</span> \n\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">comb</span><span class=\"p\">:</span> \n\t\t<span class=\"n\">list_num</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> \n\t\t\n\t<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"(k: {}, n: {}):\"</span><span class=\"p\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">))</span>\n\t<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">list_num</span><span class=\"p\">,</span> <span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code14\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code14\"><span class=\"kn\">from</span> <span class=\"nn\">itertools</span> <span class=\"kn\">import</span> <span class=\"n\">combinations</span> \n<span class=\"k\">def</span> <span class=\"nf\">find_combintaion</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">):</span>\n\t<span class=\"n\">list_num</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\t<span class=\"n\">comb</span> <span class=\"o\">=</span> <span class=\"n\">combinations</span><span class=\"p\">([</span><span class=\"n\">k</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)],</span> <span class=\"n\">k</span><span class=\"p\">)</span> \n\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">comb</span><span class=\"p\">:</span> \n\t\t<span class=\"n\">list_num</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> \n\t\t\n\t<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s\">\"(k: {}, n: {}):\"</span><span class=\"p\">.</span><span class=\"nb\">format</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">))</span>\n\t<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">list_num</span><span class=\"p\">,</span> <span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n</code></pre>",
      "contentMarkdown": "*   There are different solutions one of them is the one below, there are other solutions in the comments of the original post and also the benchmarking between them thanks to Behnam Hedayat\n\n![](https://aman.ai/images/copy.png)\n\n`from itertools import combinations  def find_combintaion(k, n): \tlist_num = [] \tcomb = combinations([k for x in range (1, n+1)], k)  \tfor i in comb:  \t\tlist_num.append(i)  \t\t \tprint(\"(k: {}, n: {}):\".format(k, n)) \tprint(list_num, \"\\n\")`\n\n![](https://aman.ai/images/copy.png)\n\n`from itertools import combinations  def find_combintaion(k, n): \tlist_num = [] \tcomb = combinations([k for x in range (1, n+1)], k)  \tfor i in comb:  \t\tlist_num.append(i)  \t\t \tprint(\"(k: {}, n: {}):\".format(k, n)) \tprint(list_num, \"\\n\")`",
      "order": 62,
      "orderInChapter": 62,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 99,
        "contentLength": 4170
      },
      "nextCards": [
        "ai-interview-explain-the-long-tailed-distribution-and-provide-t-63",
        "ai-interview-you-are-building-a-binary-classifier-and-found-tha-64"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#given-an-integer-nnn-and-an-integer-kkk,-output-a-list-of-all-of-the-combinations-of-kkk-numbers-chosen-from-1-to-nnn.-for-example,-if-n=3n=3n=3-and-k=2k=2k=2,-return-[1,2],[1,3],[2,3][1,2],[1,3],[2,3][1,2],[1,3],[2,3].",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-long-tailed-distribution-and-provide-t-63",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain the Long-tailed Distribution and Provide Three Examples of Relevant Phenomena That Have Long Tails. Why are They Important in Classification and Regression Problems?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>A long-tailed distribution is a type of heavy-tailed distribution that has a tail (or tails) that drop off gradually and asymptotically.</li>\n  <li>Three examples of relevant phenomena that have long tails:\n    <ol>\n      <li>Frequencies of languages spoken</li>\n      <li>Population of cities</li>\n      <li>Pageviews of articles</li>\n    </ol>\n  </li>\n  <li>All of these follow something close to the 80-20 rule: 80% of outcomes (or outputs) result from 20% of all causes (or inputs) for any given event. This 20% forms the long tail in the distribution.</li>\n  <li>It’s important to be mindful of long-tailed distributions in classification and regression problems because the least frequently occurring values make up the majority of the population. This can ultimately change the way that you deal with outliers, and it also conflicts with some machine learning techniques with the assumption that the data is normally distributed.</li>\n</ul>\n<ol>\n      <li>Frequencies of languages spoken</li>\n      <li>Population of cities</li>\n      <li>Pageviews of articles</li>\n    </ol>\n<p><img src=\"/primers/ai/assets/interview/long-tail.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   A long-tailed distribution is a type of heavy-tailed distribution that has a tail (or tails) that drop off gradually and asymptotically.\n*   Three examples of relevant phenomena that have long tails:\n    1.  Frequencies of languages spoken\n    2.  Population of cities\n    3.  Pageviews of articles\n*   All of these follow something close to the 80-20 rule: 80% of outcomes (or outputs) result from 20% of all causes (or inputs) for any given event. This 20% forms the long tail in the distribution.\n*   It’s important to be mindful of long-tailed distributions in classification and regression problems because the least frequently occurring values make up the majority of the population. This can ultimately change the way that you deal with outliers, and it also conflicts with some machine learning techniques with the assumption that the data is normally distributed.\n\n1.  Frequencies of languages spoken\n2.  Population of cities\n3.  Pageviews of articles\n\n![](/primers/ai/assets/interview/long-tail.jpeg)",
      "order": 63,
      "orderInChapter": 63,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 152,
        "contentLength": 1163
      },
      "nextCards": [
        "ai-interview-you-are-building-a-binary-classifier-and-found-tha-64",
        "ai-interview-if-there-are-30-people-in-a-room-what-is-the-proba-65"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-long-tailed-distribution-and-provide-three-examples-of-relevant-phenomena-that-have-long-tails.-why-are-they-important-in-classification-and-regression-problems?",
      "scrapedAt": "2025-12-28T11:58:12.837Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-you-are-building-a-binary-classifier-and-found-tha-64",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "You are Building a Binary Classifier and Found That the Data is Imbalanced, What Should You Do to Handle This Situation?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>If there is a data imbalance there are several measures we can take to train a fairer binary classifier:\n    <ol>\n      <li>Pre-Processing:\n        <ul>\n          <li>Check whether you can get more data or not.</li>\n          <li>Use sampling techniques (Up-sample minority class, downsample majority class, can take the hybrid approach as well). We can also use data augmentation to add more data points for the minority class but with little deviations/changes leading to new data points which are similar to the ones they are derived from. The most common/popular technique is SMOTE (Synthetic Minority Oversampling technique)</li>\n          <li>Suppression: Though not recommended, we can drop off some features directly responsible for the imbalance.</li>\n          <li>Learning Fair Representation: Projecting the training examples to a subspace or plane minimizes the data imbalance.</li>\n          <li>Re-Weighting: We can assign some weights to each training example to reduce the imbalance in the data.</li>\n        </ul>\n      </li>\n      <li>In-Processing:\n        <ul>\n          <li>Regularizaion: We can add score terms that measure the data imbalance in the loss function and therefore minimizing the loss function will also minimize the degree of imbalance with respect to the score chosen which also indirectly minimizes other metrics which measure the degree of data imbalance.</li>\n          <li>Adversarial Debiasing: Here we use the adversarial notion to train the model where the discriminator tries to detect if there are signs of data imbalance in the predicted data by the generator and hence the generator learns to generate data that is less prone to imbalance.</li>\n        </ul>\n      </li>\n      <li>Post-Processing:\n        <ul>\n          <li>Odds-Equalization: Here we try to equalize the odds for the classes w.r.t. the data is imbalanced for correct imbalance in the trained model. Usually, the F1 score is a good choice, if both precision and recall scores are important</li>\n          <li>Choose appropriate performance metrics. For example, accuracy is not a correct metric to use when classes are imbalanced. Instead, use precision, recall, F1 score, and ROC curve.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n</ul>\n<ol>\n      <li>Pre-Processing:\n        <ul>\n          <li>Check whether you can get more data or not.</li>\n          <li>Use sampling techniques (Up-sample minority class, downsample majority class, can take the hybrid approach as well). We can also use data augmentation to add more data points for the minority class but with little deviations/changes leading to new data points which are similar to the ones they are derived from. The most common/popular technique is SMOTE (Synthetic Minority Oversampling technique)</li>\n          <li>Suppression: Though not recommended, we can drop off some features directly responsible for the imbalance.</li>\n          <li>Learning Fair Representation: Projecting the training examples to a subspace or plane minimizes the data imbalance.</li>\n          <li>Re-Weighting: We can assign some weights to each training example to reduce the imbalance in the data.</li>\n        </ul>\n      </li>\n      <li>In-Processing:\n        <ul>\n          <li>Regularizaion: We can add score terms that measure the data imbalance in the loss function and therefore minimizing the loss function will also minimize the degree of imbalance with respect to the score chosen which also indirectly minimizes other metrics which measure the degree of data imbalance.</li>\n          <li>Adversarial Debiasing: Here we use the adversarial notion to train the model where the discriminator tries to detect if there are signs of data imbalance in the predicted data by the generator and hence the generator learns to generate data that is less prone to imbalance.</li>\n        </ul>\n      </li>\n      <li>Post-Processing:\n        <ul>\n          <li>Odds-Equalization: Here we try to equalize the odds for the classes w.r.t. the data is imbalanced for correct imbalance in the trained model. Usually, the F1 score is a good choice, if both precision and recall scores are important</li>\n          <li>Choose appropriate performance metrics. For example, accuracy is not a correct metric to use when classes are imbalanced. Instead, use precision, recall, F1 score, and ROC curve.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Check whether you can get more data or not.</li>\n          <li>Use sampling techniques (Up-sample minority class, downsample majority class, can take the hybrid approach as well). We can also use data augmentation to add more data points for the minority class but with little deviations/changes leading to new data points which are similar to the ones they are derived from. The most common/popular technique is SMOTE (Synthetic Minority Oversampling technique)</li>\n          <li>Suppression: Though not recommended, we can drop off some features directly responsible for the imbalance.</li>\n          <li>Learning Fair Representation: Projecting the training examples to a subspace or plane minimizes the data imbalance.</li>\n          <li>Re-Weighting: We can assign some weights to each training example to reduce the imbalance in the data.</li>\n        </ul>\n<ul>\n          <li>Regularizaion: We can add score terms that measure the data imbalance in the loss function and therefore minimizing the loss function will also minimize the degree of imbalance with respect to the score chosen which also indirectly minimizes other metrics which measure the degree of data imbalance.</li>\n          <li>Adversarial Debiasing: Here we use the adversarial notion to train the model where the discriminator tries to detect if there are signs of data imbalance in the predicted data by the generator and hence the generator learns to generate data that is less prone to imbalance.</li>\n        </ul>\n<ul>\n          <li>Odds-Equalization: Here we try to equalize the odds for the classes w.r.t. the data is imbalanced for correct imbalance in the trained model. Usually, the F1 score is a good choice, if both precision and recall scores are important</li>\n          <li>Choose appropriate performance metrics. For example, accuracy is not a correct metric to use when classes are imbalanced. Instead, use precision, recall, F1 score, and ROC curve.</li>\n        </ul>\n<p><img src=\"/primers/ai/assets/interview/os.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   If there is a data imbalance there are several measures we can take to train a fairer binary classifier:\n    1.  Pre-Processing:\n        *   Check whether you can get more data or not.\n        *   Use sampling techniques (Up-sample minority class, downsample majority class, can take the hybrid approach as well). We can also use data augmentation to add more data points for the minority class but with little deviations/changes leading to new data points which are similar to the ones they are derived from. The most common/popular technique is SMOTE (Synthetic Minority Oversampling technique)\n        *   Suppression: Though not recommended, we can drop off some features directly responsible for the imbalance.\n        *   Learning Fair Representation: Projecting the training examples to a subspace or plane minimizes the data imbalance.\n        *   Re-Weighting: We can assign some weights to each training example to reduce the imbalance in the data.\n    2.  In-Processing:\n        *   Regularizaion: We can add score terms that measure the data imbalance in the loss function and therefore minimizing the loss function will also minimize the degree of imbalance with respect to the score chosen which also indirectly minimizes other metrics which measure the degree of data imbalance.\n        *   Adversarial Debiasing: Here we use the adversarial notion to train the model where the discriminator tries to detect if there are signs of data imbalance in the predicted data by the generator and hence the generator learns to generate data that is less prone to imbalance.\n    3.  Post-Processing:\n        *   Odds-Equalization: Here we try to equalize the odds for the classes w.r.t. the data is imbalanced for correct imbalance in the trained model. Usually, the F1 score is a good choice, if both precision and recall scores are important\n        *   Choose appropriate performance metrics. For example, accuracy is not a correct metric to use when classes are imbalanced. Instead, use precision, recall, F1 score, and ROC curve.\n\n1.  Pre-Processing:\n    *   Check whether you can get more data or not.\n    *   Use sampling techniques (Up-sample minority class, downsample majority class, can take the hybrid approach as well). We can also use data augmentation to add more data points for the minority class but with little deviations/changes leading to new data points which are similar to the ones they are derived from. The most common/popular technique is SMOTE (Synthetic Minority Oversampling technique)\n    *   Suppression: Though not recommended, we can drop off some features directly responsible for the imbalance.\n    *   Learning Fair Representation: Projecting the training examples to a subspace or plane minimizes the data imbalance.\n    *   Re-Weighting: We can assign some weights to each training example to reduce the imbalance in the data.\n2.  In-Processing:\n    *   Regularizaion: We can add score terms that measure the data imbalance in the loss function and therefore minimizing the loss function will also minimize the degree of imbalance with respect to the score chosen which also indirectly minimizes other metrics which measure the degree of data imbalance.\n    *   Adversarial Debiasing: Here we use the adversarial notion to train the model where the discriminator tries to detect if there are signs of data imbalance in the predicted data by the generator and hence the generator learns to generate data that is less prone to imbalance.\n3.  Post-Processing:\n    *   Odds-Equalization: Here we try to equalize the odds for the classes w.r.t. the data is imbalanced for correct imbalance in the trained model. Usually, the F1 score is a good choice, if both precision and recall scores are important\n    *   Choose appropriate performance metrics. For example, accuracy is not a correct metric to use when classes are imbalanced. Instead, use precision, recall, F1 score, and ROC curve.\n\n*   Check whether you can get more data or not.\n*   Use sampling techniques (Up-sample minority class, downsample majority class, can take the hybrid approach as well). We can also use data augmentation to add more data points for the minority class but with little deviations/changes leading to new data points which are similar to the ones they are derived from. The most common/popular technique is SMOTE (Synthetic Minority Oversampling technique)\n*   Suppression: Though not recommended, we can drop off some features directly responsible for the imbalance.\n*   Learning Fair Representation: Projecting the training examples to a subspace or plane minimizes the data imbalance.\n*   Re-Weighting: We can assign some weights to each training example to reduce the imbalance in the data.\n\n*   Regularizaion: We can add score terms that measure the data imbalance in the loss function and therefore minimizing the loss function will also minimize the degree of imbalance with respect to the score chosen which also indirectly minimizes other metrics which measure the degree of data imbalance.\n*   Adversarial Debiasing: Here we use the adversarial notion to train the model where the discriminator tries to detect if there are signs of data imbalance in the predicted data by the generator and hence the generator learns to generate data that is less prone to imbalance.\n\n*   Odds-Equalization: Here we try to equalize the odds for the classes w.r.t. the data is imbalanced for correct imbalance in the trained model. Usually, the F1 score is a good choice, if both precision and recall scores are important\n*   Choose appropriate performance metrics. For example, accuracy is not a correct metric to use when classes are imbalanced. Instead, use precision, recall, F1 score, and ROC curve.\n\n![](/primers/ai/assets/interview/os.jpeg)",
      "order": 64,
      "orderInChapter": 64,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "loss function",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 888,
        "contentLength": 6451
      },
      "nextCards": [
        "ai-interview-if-there-are-30-people-in-a-room-what-is-the-proba-65",
        "ai-interview-what-is-the-vanishing-gradient-problem-and-how-do--66"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-decision-trees-and-ensemble-methods-how-do-ensemble-methods-help-with-class-imbalance-26",
        "ai-gan-wasserstein-loss-9",
        "ai-diffusion-models-reverse-process-and-l1t1l1t1l1-t-1-15"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#you-are-building-a-binary-classifier-and-found-that-the-data-is-imbalanced,-what-should-you-do-to-handle-this-situation?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-if-there-are-30-people-in-a-room-what-is-the-proba-65",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "If There are 30 People in a Room, What is the Probability That Everyone Has Different Birthdays?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The sample space is 365^30 and the number of events is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-78-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><merror><mtext>365_p_30</mtext></merror></math>\" role=\"presentation\" style=\"position: relative;\"><span class=\"math\" id=\"MathJax-Span-648\" aria-hidden=\"true\" style=\"\"><span class=\"noError\" id=\"MathJax-Span-649\" style=\"display: inline-block;\">365_p_30</span></span><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><merror><mtext>365_p_30</mtext></merror></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-78\">365_p_30</script> because we need to choose persons without replacement to get everyone to have a unique birthday therefore the Prob = <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-79-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><merror><mtext>365_p_30</mtext></merror></math>\" role=\"presentation\" style=\"position: relative;\"><span class=\"math\" id=\"MathJax-Span-650\" aria-hidden=\"true\" style=\"\"><span class=\"noError\" id=\"MathJax-Span-651\" style=\"display: inline-block;\">365_p_30</span></span><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><merror><mtext>365_p_30</mtext></merror></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-79\">365_p_30</script> / 365^30 = 0.2936</li>\n  <li>Interesting facts provided by <a href=\"https://www.linkedin.com/in/ACoAADK3RF4BHc-MCOOX59iUj_OGF79XMSFhZ1o?lipi=urn%3Ali%3Apage%3Ad_flagship3_detail_base%3BjMQQrs5NRSSacWULXDUBHg%3D%3D\">Rishi Dey Chowdhury</a>:\n    <ol>\n      <li>With just 23 people there is over 50% chance of a birthday match and with 57 people the match probability exceeds 99%. One intuition to think of why with such a low number of people the probability of a match is so high. It’s because for a match we require a pair of people and 23 choose 2 is 23*11 = 253 which is a relatively big number and ya 50% sounds like a decent probability of a match for this case.</li>\n      <li>Another interesting fact is if the assumption of equal probability of birthday of a person on any day out of 365 is violated and there is a non-equal probability of birthday of a person among days of the year then, it is even more likely to have a birthday match.</li>\n    </ol>\n  </li>\n  <li>A theoretical explanation is provided in the figure below thanks to Fazil Mohammed.</li>\n</ul>\n<ol>\n      <li>With just 23 people there is over 50% chance of a birthday match and with 57 people the match probability exceeds 99%. One intuition to think of why with such a low number of people the probability of a match is so high. It’s because for a match we require a pair of people and 23 choose 2 is 23*11 = 253 which is a relatively big number and ya 50% sounds like a decent probability of a match for this case.</li>\n      <li>Another interesting fact is if the assumption of equal probability of birthday of a person on any day out of 365 is violated and there is a non-equal probability of birthday of a person among days of the year then, it is even more likely to have a birthday match.</li>\n    </ol>\n<p><img src=\"/primers/ai/assets/interview/diff_bday.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   The sample space is 365^30 and the number of events is 365\\_p\\_30365\\_p\\_30365\\_p\\_30 because we need to choose persons without replacement to get everyone to have a unique birthday therefore the Prob = 365\\_p\\_30365\\_p\\_30365\\_p\\_30 / 365^30 = 0.2936\n*   Interesting facts provided by [Rishi Dey Chowdhury](https://www.linkedin.com/in/ACoAADK3RF4BHc-MCOOX59iUj_OGF79XMSFhZ1o?lipi=urn%3Ali%3Apage%3Ad_flagship3_detail_base%3BjMQQrs5NRSSacWULXDUBHg%3D%3D):\n    1.  With just 23 people there is over 50% chance of a birthday match and with 57 people the match probability exceeds 99%. One intuition to think of why with such a low number of people the probability of a match is so high. It’s because for a match we require a pair of people and 23 choose 2 is 23\\*11 = 253 which is a relatively big number and ya 50% sounds like a decent probability of a match for this case.\n    2.  Another interesting fact is if the assumption of equal probability of birthday of a person on any day out of 365 is violated and there is a non-equal probability of birthday of a person among days of the year then, it is even more likely to have a birthday match.\n*   A theoretical explanation is provided in the figure below thanks to Fazil Mohammed.\n\n1.  With just 23 people there is over 50% chance of a birthday match and with 57 people the match probability exceeds 99%. One intuition to think of why with such a low number of people the probability of a match is so high. It’s because for a match we require a pair of people and 23 choose 2 is 23\\*11 = 253 which is a relatively big number and ya 50% sounds like a decent probability of a match for this case.\n2.  Another interesting fact is if the assumption of equal probability of birthday of a person on any day out of 365 is violated and there is a non-equal probability of birthday of a person among days of the year then, it is even more likely to have a birthday match.\n\n![](/primers/ai/assets/interview/diff_bday.jpeg)",
      "order": 65,
      "orderInChapter": 65,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 329,
        "contentLength": 3453
      },
      "nextCards": [
        "ai-interview-what-is-the-vanishing-gradient-problem-and-how-do--66",
        "ai-interview-what-are-residual-networks-how-do-they-help-with-v-67"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#if-there-are-30-people-in-a-room,-what-is-the-probability-that-everyone-has-different-birthdays?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-vanishing-gradient-problem-and-how-do--66",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Vanishing Gradient Problem and How Do You Fix It?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The vanishing gradient problem is encountered in artificial neural networks with gradient-based learning methods and backpropagation. In these learning methods, each of the weights of the neural network receives an update proportional to the partial derivative of the error function with respect to the current weight in each iteration of training. Sometimes when gradients become vanishingly small, this prevents the weight to change value.</li>\n  <li>When the neural network has many hidden layers, the gradients in the earlier layers will become very low as we multiply the derivatives of each layer. As a result, learning in the earlier layers becomes very slow. This can cause the network to stop learning. This problem of vanishing gradients happens when training neural networks with many layers because the gradient diminishes dramatically as it propagates backward through the network.</li>\n  <li>Some ways to fix it are:\n    <ol>\n      <li>Use skip/residual connections.</li>\n      <li>Using ReLU or Leaky ReLU over sigmoid and tanh activation functions.</li>\n      <li>Use models that help propagate gradients to earlier time steps such as GRUs and LSTMs.</li>\n    </ol>\n  </li>\n</ul>\n<ol>\n      <li>Use skip/residual connections.</li>\n      <li>Using ReLU or Leaky ReLU over sigmoid and tanh activation functions.</li>\n      <li>Use models that help propagate gradients to earlier time steps such as GRUs and LSTMs.</li>\n    </ol>",
      "contentMarkdown": "*   The vanishing gradient problem is encountered in artificial neural networks with gradient-based learning methods and backpropagation. In these learning methods, each of the weights of the neural network receives an update proportional to the partial derivative of the error function with respect to the current weight in each iteration of training. Sometimes when gradients become vanishingly small, this prevents the weight to change value.\n*   When the neural network has many hidden layers, the gradients in the earlier layers will become very low as we multiply the derivatives of each layer. As a result, learning in the earlier layers becomes very slow. This can cause the network to stop learning. This problem of vanishing gradients happens when training neural networks with many layers because the gradient diminishes dramatically as it propagates backward through the network.\n*   Some ways to fix it are:\n    1.  Use skip/residual connections.\n    2.  Using ReLU or Leaky ReLU over sigmoid and tanh activation functions.\n    3.  Use models that help propagate gradients to earlier time steps such as GRUs and LSTMs.\n\n1.  Use skip/residual connections.\n2.  Using ReLU or Leaky ReLU over sigmoid and tanh activation functions.\n3.  Use models that help propagate gradients to earlier time steps such as GRUs and LSTMs.",
      "order": 66,
      "orderInChapter": 66,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "lstm",
        "gru",
        "backpropagation",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 207,
        "contentLength": 1453
      },
      "nextCards": [
        "ai-interview-what-are-residual-networks-how-do-they-help-with-v-67",
        "ai-interview-how-does-resnet-50-solve-the-vanishing-gradients-p-68"
      ],
      "relatedCards": [
        "ai-architectures-how-does-a-gru-work-internally-10",
        "ai-gnn-how-do-various-gnn-architectures-gcns-graphsage-ga-12",
        "ai-architectures-vanishing-gradients-27",
        "ai-architectures-encoder-29",
        "ai-padding-and-packing-motivation-the-problem-with-padding-6"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-vanishing-gradient-problem-and-how-do-you-fix-it?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-residual-networks-how-do-they-help-with-v-67",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Residual Networks? How Do They Help with Vanishing Gradients?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Here is a concept that you should know whether you are trying to get a job in AI or you want to improve your knowledge of AI: residual networks.</li>\n  <li>Skip connections or residual networks feed the output of a layer to the input of the subsequent layers, skipping intermediate operations.</li>\n  <li>They appear in the Transformer architecture, which is the base of GPT4 and other language models, and in most computer vision networks.</li>\n  <li>Residual connections have several advantages:\n    <ol>\n      <li>They reduce the vanishing gradient since the gradient value is transferred through the network.</li>\n      <li>They allow later layers to learn from features generated in the initial layers. Without the skip connection, that initial info would be lost.</li>\n      <li>They help to maintain the gradient surface smooth and without too many saddle points.</li>\n    </ol>\n  </li>\n  <li>This keeps gradient descent to get stuck in local minima, in other words, the optimization process is more robust and then we can use deeper networks.</li>\n  <li>ResNet paper was published at the end of 2015 and was very influential because, for the first time, a network with 152 layers surpassed the human performance in image classification.</li>\n  <li>Deep learning is based on two competing forces: the more layers, the higher the generalization power of the network, however, the more layers, the more difficult is to optimize.</li>\n  <li>In other words, the deeper the network, the better it models the real world in theory, however, it is very difficult to train in practice.</li>\n  <li>ResNet was a very important step to solve this problem.</li>\n</ul>\n<ol>\n      <li>They reduce the vanishing gradient since the gradient value is transferred through the network.</li>\n      <li>They allow later layers to learn from features generated in the initial layers. Without the skip connection, that initial info would be lost.</li>\n      <li>They help to maintain the gradient surface smooth and without too many saddle points.</li>\n    </ol>\n<p><img src=\"/primers/ai/assets/interview/resnet.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Here is a concept that you should know whether you are trying to get a job in AI or you want to improve your knowledge of AI: residual networks.\n*   Skip connections or residual networks feed the output of a layer to the input of the subsequent layers, skipping intermediate operations.\n*   They appear in the Transformer architecture, which is the base of GPT4 and other language models, and in most computer vision networks.\n*   Residual connections have several advantages:\n    1.  They reduce the vanishing gradient since the gradient value is transferred through the network.\n    2.  They allow later layers to learn from features generated in the initial layers. Without the skip connection, that initial info would be lost.\n    3.  They help to maintain the gradient surface smooth and without too many saddle points.\n*   This keeps gradient descent to get stuck in local minima, in other words, the optimization process is more robust and then we can use deeper networks.\n*   ResNet paper was published at the end of 2015 and was very influential because, for the first time, a network with 152 layers surpassed the human performance in image classification.\n*   Deep learning is based on two competing forces: the more layers, the higher the generalization power of the network, however, the more layers, the more difficult is to optimize.\n*   In other words, the deeper the network, the better it models the real world in theory, however, it is very difficult to train in practice.\n*   ResNet was a very important step to solve this problem.\n\n1.  They reduce the vanishing gradient since the gradient value is transferred through the network.\n2.  They allow later layers to learn from features generated in the initial layers. Without the skip connection, that initial info would be lost.\n3.  They help to maintain the gradient surface smooth and without too many saddle points.\n\n![](/primers/ai/assets/interview/resnet.jpeg)",
      "order": 67,
      "orderInChapter": 67,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "deep learning",
        "transformer",
        "gpt",
        "computer vision",
        "optimization",
        "gradient descent"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 315,
        "contentLength": 2123
      },
      "nextCards": [
        "ai-interview-how-does-resnet-50-solve-the-vanishing-gradients-p-68",
        "ai-interview-how-do-you-run-a-deep-learning-model-efficiently-o-69"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-from-sparse-to-soft-mixtures-of-experts-77",
        "ai-gpt4o-native-image-generation-diffusion-as-the-bridge-for-continuous-generation-45",
        "ai-model-compression-background-matrix-multiplication-in-gpus-2",
        "ai-transformers-speeding-up-the-gpt---kv-cache-51",
        "ai-gemma-3n-training-strategy-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-residual-networks?-how-do-they-help-with-vanishing-gradients?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-resnet-50-solve-the-vanishing-gradients-p-68",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Does ResNet-50 Solve the Vanishing Gradients Problem of VGG-16?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>During the ImageNet Large Scale Visual Recognition Challenge (ILSVRC) that with the increase in the number of layers the deep learning models will perform better because of more parameters. However, because of more number of layers, there was a problem with vanishing gradients. In fact, the authors of ResNet, in the original paper, noticed that neural networks without residual connections don’t learn as well as ResNets, although they are using batch normalization, which, in theory, ensures that gradients should not vanish.</li>\n  <li>Enter ResNet that utilize skip connections under-the-hood.</li>\n  <li>The skip connections allow information to skip layers, so, in the forward pass, information from layer l can directly be fed into layer $l+t$ (i.e., the activations of layer $l$ are added to the activations of layer $l+t$, for $t &gt;= 2$ and, during the forward pass, the gradients can also flow unchanged from layer $l+t$ to layer $l$. This prevents the vanishing gradient problem (VGP). Let’s explain how.</li>\n  <li>The VGP occurs when the elements of the gradient (the partial derivatives with respect to the parameters of the network) become exponentially small, so that the update of the parameters with the gradient becomes almost insignificant (i.e., if you add a very small number $0 &lt; \\epsilon «&nbsp;1$ to another number $d$, $d+\\epsilon$ is almost the same as d and, consequently, the network learns very slowly or not at all (considering also numerical errors).</li>\n  <li>Given that these partial derivatives are computed with the chain rule, this can easily occur, because you keep on multiplying small (finite-precision) numbers.</li>\n  <li>The deeper the network, the more likely the VGP can occur. This should be quite intuitive if you are familiar with the chain rule and the back-propagation algorithm (i.e. the chain rule).</li>\n  <li>By allowing information to skip layers, layer l+t receives information from both layer $l+t−1$ and layer $l$ (unchanged, i.e., you do not perform multiplications).</li>\n  <li>From the <a href=\"https://arxiv.org/abs/1605.06431\">paper</a>: “Our results reveal one of the key characteristics that seem to enable the training of very deep networks: Residual networks avoid the vanishing gradient problem by introducing short paths which can carry gradient throughout the extent of very deep networks.”</li>\n</ul>",
      "contentMarkdown": "*   During the ImageNet Large Scale Visual Recognition Challenge (ILSVRC) that with the increase in the number of layers the deep learning models will perform better because of more parameters. However, because of more number of layers, there was a problem with vanishing gradients. In fact, the authors of ResNet, in the original paper, noticed that neural networks without residual connections don’t learn as well as ResNets, although they are using batch normalization, which, in theory, ensures that gradients should not vanish.\n*   Enter ResNet that utilize skip connections under-the-hood.\n*   The skip connections allow information to skip layers, so, in the forward pass, information from layer l can directly be fed into layer $l+t$ (i.e., the activations of layer $l$ are added to the activations of layer $l+t$, for $t >= 2$ and, during the forward pass, the gradients can also flow unchanged from layer $l+t$ to layer $l$. This prevents the vanishing gradient problem (VGP). Let’s explain how.\n*   The VGP occurs when the elements of the gradient (the partial derivatives with respect to the parameters of the network) become exponentially small, so that the update of the parameters with the gradient becomes almost insignificant (i.e., if you add a very small number $0 < \\\\epsilon « 1$ to another number $d$, $d+\\\\epsilon$ is almost the same as d and, consequently, the network learns very slowly or not at all (considering also numerical errors).\n*   Given that these partial derivatives are computed with the chain rule, this can easily occur, because you keep on multiplying small (finite-precision) numbers.\n*   The deeper the network, the more likely the VGP can occur. This should be quite intuitive if you are familiar with the chain rule and the back-propagation algorithm (i.e. the chain rule).\n*   By allowing information to skip layers, layer l+t receives information from both layer $l+t−1$ and layer $l$ (unchanged, i.e., you do not perform multiplications).\n*   From the [paper](https://arxiv.org/abs/1605.06431): “Our results reveal one of the key characteristics that seem to enable the training of very deep networks: Residual networks avoid the vanishing gradient problem by introducing short paths which can carry gradient throughout the extent of very deep networks.”",
      "order": 68,
      "orderInChapter": 68,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "activation",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 362,
        "contentLength": 2389
      },
      "nextCards": [
        "ai-interview-how-do-you-run-a-deep-learning-model-efficiently-o-69",
        "ai-interview-when-are-tress-not-useful-70"
      ],
      "relatedCards": [
        "ai-model-compression-definition-3",
        "ai-batchnorm-does-batchnorm-lead-to-a-standard-normal-distribut-10",
        "ai-model-compression-background-precision-1",
        "ai-gpu-architecture-operator-dispatch-and-kernel-mapping-14",
        "ai-batchnorm-related-does-layernorm-seek-to-obtain-a-normal-dis-11"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-resnet-50-solve-the-vanishing-gradients-problem-of-vgg-16?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-run-a-deep-learning-model-efficiently-o-69",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Run a Deep Learning Model Efficiently On-device?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Let’s take the example of LLaMA, a ChatGPT-like LLM by Meta.</li>\n  <li>You can run one of the latest LLMs if you have a computer with 4Gb of RAM.</li>\n  <li>The model is implemented in C++ (with Python wrappers) and uses several optimization techniques:\n    <ol>\n      <li>Quantization\n        <ul>\n          <li>Quantization represents the weights of the model in a low-precision data type like 4-bit integer (INT4) instead of the usual 32-bit floating precision (FP32).</li>\n          <li>For example, the smallest LLaMA model has 7B parameters.</li>\n          <li>The original model uses 13GB of RAM, while the optimized model uses 3.9GB.</li>\n        </ul>\n      </li>\n      <li>Faster weight loading\n        <ul>\n          <li>Another optimization is to load the model weights using <code class=\"language-plaintext highlighter-rouge\">mmap()</code> instead of standard C++ I/O.</li>\n          <li>That enabled to load LLaMA 100x faster using half as much memory.</li>\n          <li><code class=\"language-plaintext highlighter-rouge\">mmap()</code> maps the read-only weights using <code class=\"language-plaintext highlighter-rouge\">MAP_SHARED</code>, which is the same technique that’s traditionally used for loading executable software.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n</ul>\n<ol>\n      <li>Quantization\n        <ul>\n          <li>Quantization represents the weights of the model in a low-precision data type like 4-bit integer (INT4) instead of the usual 32-bit floating precision (FP32).</li>\n          <li>For example, the smallest LLaMA model has 7B parameters.</li>\n          <li>The original model uses 13GB of RAM, while the optimized model uses 3.9GB.</li>\n        </ul>\n      </li>\n      <li>Faster weight loading\n        <ul>\n          <li>Another optimization is to load the model weights using <code class=\"language-plaintext highlighter-rouge\">mmap()</code> instead of standard C++ I/O.</li>\n          <li>That enabled to load LLaMA 100x faster using half as much memory.</li>\n          <li><code class=\"language-plaintext highlighter-rouge\">mmap()</code> maps the read-only weights using <code class=\"language-plaintext highlighter-rouge\">MAP_SHARED</code>, which is the same technique that’s traditionally used for loading executable software.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Quantization represents the weights of the model in a low-precision data type like 4-bit integer (INT4) instead of the usual 32-bit floating precision (FP32).</li>\n          <li>For example, the smallest LLaMA model has 7B parameters.</li>\n          <li>The original model uses 13GB of RAM, while the optimized model uses 3.9GB.</li>\n        </ul>\n<ul>\n          <li>Another optimization is to load the model weights using <code class=\"language-plaintext highlighter-rouge\">mmap()</code> instead of standard C++ I/O.</li>\n          <li>That enabled to load LLaMA 100x faster using half as much memory.</li>\n          <li><code class=\"language-plaintext highlighter-rouge\">mmap()</code> maps the read-only weights using <code class=\"language-plaintext highlighter-rouge\">MAP_SHARED</code>, which is the same technique that’s traditionally used for loading executable software.</li>\n        </ul>",
      "contentMarkdown": "*   Let’s take the example of LLaMA, a ChatGPT-like LLM by Meta.\n*   You can run one of the latest LLMs if you have a computer with 4Gb of RAM.\n*   The model is implemented in C++ (with Python wrappers) and uses several optimization techniques:\n    1.  Quantization\n        *   Quantization represents the weights of the model in a low-precision data type like 4-bit integer (INT4) instead of the usual 32-bit floating precision (FP32).\n        *   For example, the smallest LLaMA model has 7B parameters.\n        *   The original model uses 13GB of RAM, while the optimized model uses 3.9GB.\n    2.  Faster weight loading\n        *   Another optimization is to load the model weights using `mmap()` instead of standard C++ I/O.\n        *   That enabled to load LLaMA 100x faster using half as much memory.\n        *   `mmap()` maps the read-only weights using `MAP_SHARED`, which is the same technique that’s traditionally used for loading executable software.\n\n1.  Quantization\n    *   Quantization represents the weights of the model in a low-precision data type like 4-bit integer (INT4) instead of the usual 32-bit floating precision (FP32).\n    *   For example, the smallest LLaMA model has 7B parameters.\n    *   The original model uses 13GB of RAM, while the optimized model uses 3.9GB.\n2.  Faster weight loading\n    *   Another optimization is to load the model weights using `mmap()` instead of standard C++ I/O.\n    *   That enabled to load LLaMA 100x faster using half as much memory.\n    *   `mmap()` maps the read-only weights using `MAP_SHARED`, which is the same technique that’s traditionally used for loading executable software.\n\n*   Quantization represents the weights of the model in a low-precision data type like 4-bit integer (INT4) instead of the usual 32-bit floating precision (FP32).\n*   For example, the smallest LLaMA model has 7B parameters.\n*   The original model uses 13GB of RAM, while the optimized model uses 3.9GB.\n\n*   Another optimization is to load the model weights using `mmap()` instead of standard C++ I/O.\n*   That enabled to load LLaMA 100x faster using half as much memory.\n*   `mmap()` maps the read-only weights using `MAP_SHARED`, which is the same technique that’s traditionally used for loading executable software.",
      "order": 69,
      "orderInChapter": 69,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "gpt",
        "llm",
        "optimization"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 351,
        "contentLength": 3245
      },
      "nextCards": [
        "ai-interview-when-are-tress-not-useful-70",
        "ai-interview-gradient-descent-local-minimum-vs-global-minimum-71"
      ],
      "relatedCards": [
        "ai-agents-octotools-an-agentic-framework-with-extensible-too-72",
        "ai-reasoning-in-LLMs-webgpt-19",
        "ai-reasoning-in-LLMs-deepseek-r1-20",
        "ai-reasoning-in-LLMs-tool-learning-with-foundation-models-23",
        "ai-gpt4o-native-image-generation-combined-loss-function-15"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-run-a-deep-learning-model-efficiently-on-device?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-when-are-tress-not-useful-70",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "When are Tress Not Useful?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Use tree ensembles (random forest/gradient boosted trees) unless you have a reason not to.</li>\n  <li>Here are some of the only reasons not to use tree ensembles for your supervised machine learning problem:\n    <ul>\n      <li>You are working with unstructured data (text, image, audio, video)</li>\n      <li>You are doing statistical inference on a parametric model to draw conclusions (for example, causal inference)</li>\n      <li>You have strict interpretability requirements from a legal perspective</li>\n      <li>You are trying to model a phenomenon with a known relationship in order to extrapolate the relationship (for example, logistic curves to model population growth scenarios)</li>\n      <li>You have very restrictive latency and/or memory requirements (sparse linear models and SVMs are superior here)</li>\n    </ul>\n  </li>\n  <li>Ignoring these, tree ensembles are <em>typically</em> more adaptable and performant. Spend less time trying to beat them, and more time iterating on data quality, feature engineering, and MLOps best practices.</li>\n</ul>\n<ul>\n      <li>You are working with unstructured data (text, image, audio, video)</li>\n      <li>You are doing statistical inference on a parametric model to draw conclusions (for example, causal inference)</li>\n      <li>You have strict interpretability requirements from a legal perspective</li>\n      <li>You are trying to model a phenomenon with a known relationship in order to extrapolate the relationship (for example, logistic curves to model population growth scenarios)</li>\n      <li>You have very restrictive latency and/or memory requirements (sparse linear models and SVMs are superior here)</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/trees.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Use tree ensembles (random forest/gradient boosted trees) unless you have a reason not to.\n*   Here are some of the only reasons not to use tree ensembles for your supervised machine learning problem:\n    *   You are working with unstructured data (text, image, audio, video)\n    *   You are doing statistical inference on a parametric model to draw conclusions (for example, causal inference)\n    *   You have strict interpretability requirements from a legal perspective\n    *   You are trying to model a phenomenon with a known relationship in order to extrapolate the relationship (for example, logistic curves to model population growth scenarios)\n    *   You have very restrictive latency and/or memory requirements (sparse linear models and SVMs are superior here)\n*   Ignoring these, tree ensembles are _typically_ more adaptable and performant. Spend less time trying to beat them, and more time iterating on data quality, feature engineering, and MLOps best practices.\n\n*   You are working with unstructured data (text, image, audio, video)\n*   You are doing statistical inference on a parametric model to draw conclusions (for example, causal inference)\n*   You have strict interpretability requirements from a legal perspective\n*   You are trying to model a phenomenon with a known relationship in order to extrapolate the relationship (for example, logistic curves to model population growth scenarios)\n*   You have very restrictive latency and/or memory requirements (sparse linear models and SVMs are superior here)\n\n![](/primers/ai/assets/interview/trees.jpeg)",
      "order": 70,
      "orderInChapter": 70,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 230,
        "contentLength": 1765
      },
      "nextCards": [
        "ai-interview-gradient-descent-local-minimum-vs-global-minimum-71",
        "ai-interview-why-cant-the-mean-squared-error-be-used-for-classi-72"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#when-are-tress-not-useful?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-gradient-descent-local-minimum-vs-global-minimum-71",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Gradient Descent: Local Minimum vs. Global Minimum",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Gradient descent moves in the direction of the steepest descent of the objective function.</li>\n  <li>Without any constraints, the iterative process would lead towards a local minimum by always trying to reduce the objective function value. The critical point here is “local minimum”. Gradient descent, especially in complex functions or when constraints are introduced, doesn’t guarantee finding a global minimum. However, it does guarantee convergence to a local minimum under suitable conditions.</li>\n</ul>",
      "contentMarkdown": "*   Gradient descent moves in the direction of the steepest descent of the objective function.\n*   Without any constraints, the iterative process would lead towards a local minimum by always trying to reduce the objective function value. The critical point here is “local minimum”. Gradient descent, especially in complex functions or when constraints are introduced, doesn’t guarantee finding a global minimum. However, it does guarantee convergence to a local minimum under suitable conditions.",
      "order": 71,
      "orderInChapter": 71,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "gradient descent"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 73,
        "contentLength": 521
      },
      "nextCards": [
        "ai-interview-why-cant-the-mean-squared-error-be-used-for-classi-72",
        "ai-interview-what-is-overfitting-what-are-some-ways-to-mitigate-73"
      ],
      "relatedCards": [
        "ai-differential-privacy-dpsgd-core-idea-9",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7",
        "ai-diffusion-models-general-overview-4",
        "ai-agentic-RL-neural-guided-search-policy-priors-and-value-model-38",
        "ai-gradient-descent-and-backprop-forward-propagation-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#gradient-descent:-local-minimum-vs.-global-minimum",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-cant-the-mean-squared-error-be-used-for-classi-72",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Can’t the Mean Squared Error be Used for Classification?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>First, using MSE means that we assume that the underlying data has been generated from a normal distribution (a bell-shaped curve). In Bayesian terms, this means we assume a <a href=\"https://en.wikipedia.org/wiki/Conjugate_prior\">Gaussian prior</a>. While in reality, a dataset that can be classified into two categories (i.e., binary) is usually not from a normal distribution but a <a href=\"https://en.wikipedia.org/wiki/Bernoulli_distribution\">Bernoulli distribution</a>.</li>\n  <li>Secondly, the MSE function is non-convex for binary classification.\n    <ul>\n      <li>As a reminder, a function is non-convex if the function is not a convex function. Non-convex functions are those functions that have many minimum points, in the form of local and global minimum points. The following figure <a href=\"https://www.quora.com/Why-is-nonconvex-optimization-so-difficult-compared-to-convex-optimization\">(source)</a> shows the difference between convex and non-convex functions.</li>\n    </ul>\n\n    <p><img src=\"../assets/loss/convex.webp\" alt=\"\"></p>\n\n    <ul>\n      <li>Note that the loss functions that are applied in the context of machine learning models are convex functions, while those applied in the context of neural networks are non-convex functions.</li>\n      <li>Put simply, if a binary classification model is trained with the MSE cost function, it is not guaranteed to minimize the cost function. This is because MSE function expects real-valued inputs in range <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-80-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mi mathvariant=&quot;normal&quot;>&amp;#x221E;</mi><mo>,</mo><mi mathvariant=&quot;normal&quot;>&amp;#x221E;</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-652\" style=\"width: 3.753em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.128em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.08em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-653\"><span class=\"mo\" id=\"MathJax-Span-654\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mo\" id=\"MathJax-Span-655\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"mi\" id=\"MathJax-Span-656\" style=\"font-family: STIXGeneral-Regular;\">∞</span><span class=\"mo\" id=\"MathJax-Span-657\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-658\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">∞</span><span class=\"mo\" id=\"MathJax-Span-659\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo>,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-80\">(-\\infty, \\infty)</script>, while binary classification models outputs discrete probabilities in range <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-81-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-660\" style=\"width: 2.607em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-661\"><span class=\"mo\" id=\"MathJax-Span-662\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-663\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-664\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-665\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">1</span><span class=\"mo\" id=\"MathJax-Span-666\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-81\">(0,1)</script> through the sigmoid/logistic function.</li>\n    </ul>\n  </li>\n  <li><a href=\"https://towardsdatascience.com/why-using-mean-squared-error-mse-cost-function-for-binary-classification-is-a-bad-idea-933089e90df7\">Why Using Mean Squared Error (MSE) Cost Function for Binary Classification is a Bad Idea?</a> offers a great overview of this topic.</li>\n</ul>\n<ul>\n      <li>As a reminder, a function is non-convex if the function is not a convex function. Non-convex functions are those functions that have many minimum points, in the form of local and global minimum points. The following figure <a href=\"https://www.quora.com/Why-is-nonconvex-optimization-so-difficult-compared-to-convex-optimization\">(source)</a> shows the difference between convex and non-convex functions.</li>\n    </ul>\n<p><img src=\"../assets/loss/convex.webp\" alt=\"\"></p>\n<ul>\n      <li>Note that the loss functions that are applied in the context of machine learning models are convex functions, while those applied in the context of neural networks are non-convex functions.</li>\n      <li>Put simply, if a binary classification model is trained with the MSE cost function, it is not guaranteed to minimize the cost function. This is because MSE function expects real-valued inputs in range <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-80-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mi mathvariant=&quot;normal&quot;>&amp;#x221E;</mi><mo>,</mo><mi mathvariant=&quot;normal&quot;>&amp;#x221E;</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-652\" style=\"width: 3.753em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.128em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.08em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-653\"><span class=\"mo\" id=\"MathJax-Span-654\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mo\" id=\"MathJax-Span-655\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"mi\" id=\"MathJax-Span-656\" style=\"font-family: STIXGeneral-Regular;\">∞</span><span class=\"mo\" id=\"MathJax-Span-657\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-658\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">∞</span><span class=\"mo\" id=\"MathJax-Span-659\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mo>−</mo><mi mathvariant=\"normal\">∞</mi><mo>,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-80\">(-\\infty, \\infty)</script>, while binary classification models outputs discrete probabilities in range <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-81-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-660\" style=\"width: 2.607em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-661\"><span class=\"mo\" id=\"MathJax-Span-662\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-663\" style=\"font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-664\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mn\" id=\"MathJax-Span-665\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">1</span><span class=\"mo\" id=\"MathJax-Span-666\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-81\">(0,1)</script> through the sigmoid/logistic function.</li>\n    </ul>",
      "contentMarkdown": "*   First, using MSE means that we assume that the underlying data has been generated from a normal distribution (a bell-shaped curve). In Bayesian terms, this means we assume a [Gaussian prior](https://en.wikipedia.org/wiki/Conjugate_prior). While in reality, a dataset that can be classified into two categories (i.e., binary) is usually not from a normal distribution but a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution).\n*   Secondly, the MSE function is non-convex for binary classification.\n    \n    *   As a reminder, a function is non-convex if the function is not a convex function. Non-convex functions are those functions that have many minimum points, in the form of local and global minimum points. The following figure [(source)](https://www.quora.com/Why-is-nonconvex-optimization-so-difficult-compared-to-convex-optimization) shows the difference between convex and non-convex functions.\n    \n    ![](../assets/loss/convex.webp)\n    \n    *   Note that the loss functions that are applied in the context of machine learning models are convex functions, while those applied in the context of neural networks are non-convex functions.\n    *   Put simply, if a binary classification model is trained with the MSE cost function, it is not guaranteed to minimize the cost function. This is because MSE function expects real-valued inputs in range (−∞,∞)(−∞,∞)(-\\\\infty, \\\\infty), while binary classification models outputs discrete probabilities in range (0,1)(0,1)(0,1) through the sigmoid/logistic function.\n*   [Why Using Mean Squared Error (MSE) Cost Function for Binary Classification is a Bad Idea?](https://towardsdatascience.com/why-using-mean-squared-error-mse-cost-function-for-binary-classification-is-a-bad-idea-933089e90df7) offers a great overview of this topic.\n\n*   As a reminder, a function is non-convex if the function is not a convex function. Non-convex functions are those functions that have many minimum points, in the form of local and global minimum points. The following figure [(source)](https://www.quora.com/Why-is-nonconvex-optimization-so-difficult-compared-to-convex-optimization) shows the difference between convex and non-convex functions.\n\n![](../assets/loss/convex.webp)\n\n*   Note that the loss functions that are applied in the context of machine learning models are convex functions, while those applied in the context of neural networks are non-convex functions.\n*   Put simply, if a binary classification model is trained with the MSE cost function, it is not guaranteed to minimize the cost function. This is because MSE function expects real-valued inputs in range (−∞,∞)(−∞,∞)(-\\\\infty, \\\\infty), while binary classification models outputs discrete probabilities in range (0,1)(0,1)(0,1) through the sigmoid/logistic function.",
      "order": 72,
      "orderInChapter": 72,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "machine learning",
        "optimization",
        "loss function"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 348,
        "contentLength": 10399
      },
      "nextCards": [
        "ai-interview-what-is-overfitting-what-are-some-ways-to-mitigate-73",
        "ai-interview-how-do-you-mitigate-data-imbalance-during-model-tr-74"
      ],
      "relatedCards": [
        "ai-loss-mean-squared-error-mse-l2-loss-10",
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32",
        "ai-loss-pairwise-ranking-loss-19",
        "ai-decision-trees-and-ensemble-methods-can-decision-trees-be-fine-tuned-ie-do-they-have-i-18",
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-can’t-the-mean-squared-error-be-used-for-classification?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-overfitting-what-are-some-ways-to-mitigate-73",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Overfitting? What are Some Ways to Mitigate It?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Overfitting refers to a modeling error that occurs when a machine learning model is too closely tailored to the specificities of the training data, resulting in poor performance on unseen or new data. Essentially, an overfitted model has learned the training data, including its noise and outliers, so well that it lacks generalization capability to new, unseen data.</li>\n  <li>Here’s an analogy: Imagine a student who memorizes specific questions and answers for an exam rather than understanding the underlying concepts. If the exam has the exact questions the student memorized, they will perform well. However, if the exam has different questions that test the same concepts, the student might perform poorly because they only memorized specific answers rather than understanding the topic as a whole.</li>\n  <li>Ways to mitigate overfitting include:\n    <ul>\n      <li><strong>Early stopping:</strong> In iterative algorithms, like neural networks, training can be stopped when performance on a validation set starts to degrade, rather than continuing until training error is minimized.</li>\n      <li><strong>Regularization:</strong> Techniques such as L1 (Lasso) and L2 (Ridge) regularization add a penalty term for complexity to the loss function, discouraging overly complex models. Another regularization technique is dropout, especially used in neural networks, where randomly selected neurons are ignored during training.</li>\n      <li><strong>Reduce model complexity:</strong> Choose simpler models or reduce the number of parameters in the model. For instance, using a linear regression instead of a high-degree polynomial regression, or using a shallower neural network instead of a very deep one.</li>\n      <li><strong>Ensemble methods:</strong> Techniques like bagging and boosting, which combine multiple models, can reduce overfitting. For instance, Random Forests use multiple decision trees (an ensemble) and average their predictions, which can help in generalizing better than a single decision tree.</li>\n      <li><strong>Gathering more data:</strong> If feasible, increasing the amount of training data can help the model generalize better.</li>\n      <li><strong>Data augmentation:</strong> In areas like image processing, the training data can be augmented by creating new data points through transformations such as rotations, scaling, and cropping. This helps in increasing the effective size of the training dataset.</li>\n      <li><strong>Noise injection:</strong> Adding a small amount of noise to the training data or even within the model (like in weights of a neural network) can sometimes prevent overfitting, as it encourages the model to learn the underlying patterns rather than the specific noise in the training data.</li>\n      <li><strong>Using Bayesian approaches:</strong> Bayesian methods, like Bayesian Neural Networks, provide a probabilistic approach to training and can inherently avoid overfitting by considering a distribution over parameters.</li>\n    </ul>\n  </li>\n  <li>Regularly monitoring and evaluating model performance on a held-out validation set can help in early detection and mitigation of overfitting.</li>\n</ul>\n<ul>\n      <li><strong>Early stopping:</strong> In iterative algorithms, like neural networks, training can be stopped when performance on a validation set starts to degrade, rather than continuing until training error is minimized.</li>\n      <li><strong>Regularization:</strong> Techniques such as L1 (Lasso) and L2 (Ridge) regularization add a penalty term for complexity to the loss function, discouraging overly complex models. Another regularization technique is dropout, especially used in neural networks, where randomly selected neurons are ignored during training.</li>\n      <li><strong>Reduce model complexity:</strong> Choose simpler models or reduce the number of parameters in the model. For instance, using a linear regression instead of a high-degree polynomial regression, or using a shallower neural network instead of a very deep one.</li>\n      <li><strong>Ensemble methods:</strong> Techniques like bagging and boosting, which combine multiple models, can reduce overfitting. For instance, Random Forests use multiple decision trees (an ensemble) and average their predictions, which can help in generalizing better than a single decision tree.</li>\n      <li><strong>Gathering more data:</strong> If feasible, increasing the amount of training data can help the model generalize better.</li>\n      <li><strong>Data augmentation:</strong> In areas like image processing, the training data can be augmented by creating new data points through transformations such as rotations, scaling, and cropping. This helps in increasing the effective size of the training dataset.</li>\n      <li><strong>Noise injection:</strong> Adding a small amount of noise to the training data or even within the model (like in weights of a neural network) can sometimes prevent overfitting, as it encourages the model to learn the underlying patterns rather than the specific noise in the training data.</li>\n      <li><strong>Using Bayesian approaches:</strong> Bayesian methods, like Bayesian Neural Networks, provide a probabilistic approach to training and can inherently avoid overfitting by considering a distribution over parameters.</li>\n    </ul>",
      "contentMarkdown": "*   Overfitting refers to a modeling error that occurs when a machine learning model is too closely tailored to the specificities of the training data, resulting in poor performance on unseen or new data. Essentially, an overfitted model has learned the training data, including its noise and outliers, so well that it lacks generalization capability to new, unseen data.\n*   Here’s an analogy: Imagine a student who memorizes specific questions and answers for an exam rather than understanding the underlying concepts. If the exam has the exact questions the student memorized, they will perform well. However, if the exam has different questions that test the same concepts, the student might perform poorly because they only memorized specific answers rather than understanding the topic as a whole.\n*   Ways to mitigate overfitting include:\n    *   **Early stopping:** In iterative algorithms, like neural networks, training can be stopped when performance on a validation set starts to degrade, rather than continuing until training error is minimized.\n    *   **Regularization:** Techniques such as L1 (Lasso) and L2 (Ridge) regularization add a penalty term for complexity to the loss function, discouraging overly complex models. Another regularization technique is dropout, especially used in neural networks, where randomly selected neurons are ignored during training.\n    *   **Reduce model complexity:** Choose simpler models or reduce the number of parameters in the model. For instance, using a linear regression instead of a high-degree polynomial regression, or using a shallower neural network instead of a very deep one.\n    *   **Ensemble methods:** Techniques like bagging and boosting, which combine multiple models, can reduce overfitting. For instance, Random Forests use multiple decision trees (an ensemble) and average their predictions, which can help in generalizing better than a single decision tree.\n    *   **Gathering more data:** If feasible, increasing the amount of training data can help the model generalize better.\n    *   **Data augmentation:** In areas like image processing, the training data can be augmented by creating new data points through transformations such as rotations, scaling, and cropping. This helps in increasing the effective size of the training dataset.\n    *   **Noise injection:** Adding a small amount of noise to the training data or even within the model (like in weights of a neural network) can sometimes prevent overfitting, as it encourages the model to learn the underlying patterns rather than the specific noise in the training data.\n    *   **Using Bayesian approaches:** Bayesian methods, like Bayesian Neural Networks, provide a probabilistic approach to training and can inherently avoid overfitting by considering a distribution over parameters.\n*   Regularly monitoring and evaluating model performance on a held-out validation set can help in early detection and mitigation of overfitting.\n\n*   **Early stopping:** In iterative algorithms, like neural networks, training can be stopped when performance on a validation set starts to degrade, rather than continuing until training error is minimized.\n*   **Regularization:** Techniques such as L1 (Lasso) and L2 (Ridge) regularization add a penalty term for complexity to the loss function, discouraging overly complex models. Another regularization technique is dropout, especially used in neural networks, where randomly selected neurons are ignored during training.\n*   **Reduce model complexity:** Choose simpler models or reduce the number of parameters in the model. For instance, using a linear regression instead of a high-degree polynomial regression, or using a shallower neural network instead of a very deep one.\n*   **Ensemble methods:** Techniques like bagging and boosting, which combine multiple models, can reduce overfitting. For instance, Random Forests use multiple decision trees (an ensemble) and average their predictions, which can help in generalizing better than a single decision tree.\n*   **Gathering more data:** If feasible, increasing the amount of training data can help the model generalize better.\n*   **Data augmentation:** In areas like image processing, the training data can be augmented by creating new data points through transformations such as rotations, scaling, and cropping. This helps in increasing the effective size of the training dataset.\n*   **Noise injection:** Adding a small amount of noise to the training data or even within the model (like in weights of a neural network) can sometimes prevent overfitting, as it encourages the model to learn the underlying patterns rather than the specific noise in the training data.\n*   **Using Bayesian approaches:** Bayesian methods, like Bayesian Neural Networks, provide a probabilistic approach to training and can inherently avoid overfitting by considering a distribution over parameters.",
      "order": 73,
      "orderInChapter": 73,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "neural network",
        "machine learning",
        "loss function",
        "regularization",
        "dropout",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 721,
        "contentLength": 5347
      },
      "nextCards": [
        "ai-interview-how-do-you-mitigate-data-imbalance-during-model-tr-74",
        "ai-interview-which-ensembling-methods-work-well-for-class-imbal-75"
      ],
      "relatedCards": [
        "ai-bias-variance-tradeoff-overfitting-and-underfitting-common-challenges-in--13",
        "ai-decision-trees-and-ensemble-methods-what-are-the-biggest-advantages-of-using-gbdts-com-22",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-dropout-use-a-larger-network-3",
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-overfitting?-what-are-some-ways-to-mitigate-it?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-mitigate-data-imbalance-during-model-tr-74",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Mitigate Data Imbalance During Model Training?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Data imbalance refers to situations where some classes in a classification task have significantly fewer samples than others. This can lead models to favor the majority class (or classes) and perform poorly on the minority class. Here are several methods to mitigate the effects of data imbalance during model training:\n    <ol>\n      <li>Resampling Techniques:\n        <ul>\n          <li>Oversampling: Increase the number of instances in the minority class by replicating them or generating synthetic samples.\n            <ul>\n              <li>Random oversampling: Duplicate random samples from the minority class.</li>\n              <li>SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.</li>\n              <li>ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.</li>\n            </ul>\n          </li>\n          <li>Undersampling: Reduce the number of instances in the majority class. This can lead to a loss of information unless carefully done.\n            <ul>\n              <li>Random undersampling: Remove random samples from the majority class.</li>\n              <li>Tomek links: Remove majority samples that are close to minority samples.</li>\n              <li>Cluster centroids: Replace a cluster of majority samples with the cluster centroid.</li>\n              <li>NearMiss: Selects majority samples based on their distances to minority class samples.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Use Different Evaluation Metrics: Accuracy is not a good metric for imbalanced datasets. Instead, consider using:\n        <ul>\n          <li>Precision, Recall, F1-score</li>\n          <li>Area Under the Receiver Operating Characteristic Curve (ROC-AUC)</li>\n          <li>Area Under the Precision-Recall Curve (PR-AUC)</li>\n          <li>Matthews Correlation Coefficient (MCC)</li>\n          <li>Balanced accuracy</li>\n        </ul>\n      </li>\n      <li>Algorithm-level Approaches:\n        <ul>\n          <li>Cost-sensitive training: Introduce different misclassification costs for different classes.\n            <ul>\n              <li>Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.</li>\n              <li>The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.</li>\n            </ul>\n          </li>\n          <li>Anomaly (or outlier) detection: Treat the minority class as an anomaly detection problem, by modeling the minority class as a rare event.</li>\n          <li>Using tree-based algorithms: Some algorithms like Decision Trees or Random Forests can be less sensitive to data imbalance.</li>\n        </ul>\n      </li>\n      <li>Ensemble Methods:\n        <ul>\n          <li>Bagging with balanced datasets: Bootstrap samples from each class and train ensemble members like Random Forests.</li>\n          <li>Boosting: Algorithms like AdaBoost increase the weight of misclassified instances, which can help in focusing on the minority class.</li>\n          <li>Balanced Random Forest: Random Forest variant where each tree is grown on a balanced bootstrap sample.</li>\n          <li>RUSBoost: A boosting method which combines the principles of boosting with random undersampling.</li>\n        </ul>\n      </li>\n      <li>Synthetic Data Generation: Use techniques like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs) to generate synthetic samples for the minority class.</li>\n    </ol>\n  </li>\n</ul>\n<ol>\n      <li>Resampling Techniques:\n        <ul>\n          <li>Oversampling: Increase the number of instances in the minority class by replicating them or generating synthetic samples.\n            <ul>\n              <li>Random oversampling: Duplicate random samples from the minority class.</li>\n              <li>SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.</li>\n              <li>ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.</li>\n            </ul>\n          </li>\n          <li>Undersampling: Reduce the number of instances in the majority class. This can lead to a loss of information unless carefully done.\n            <ul>\n              <li>Random undersampling: Remove random samples from the majority class.</li>\n              <li>Tomek links: Remove majority samples that are close to minority samples.</li>\n              <li>Cluster centroids: Replace a cluster of majority samples with the cluster centroid.</li>\n              <li>NearMiss: Selects majority samples based on their distances to minority class samples.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Use Different Evaluation Metrics: Accuracy is not a good metric for imbalanced datasets. Instead, consider using:\n        <ul>\n          <li>Precision, Recall, F1-score</li>\n          <li>Area Under the Receiver Operating Characteristic Curve (ROC-AUC)</li>\n          <li>Area Under the Precision-Recall Curve (PR-AUC)</li>\n          <li>Matthews Correlation Coefficient (MCC)</li>\n          <li>Balanced accuracy</li>\n        </ul>\n      </li>\n      <li>Algorithm-level Approaches:\n        <ul>\n          <li>Cost-sensitive training: Introduce different misclassification costs for different classes.\n            <ul>\n              <li>Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.</li>\n              <li>The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.</li>\n            </ul>\n          </li>\n          <li>Anomaly (or outlier) detection: Treat the minority class as an anomaly detection problem, by modeling the minority class as a rare event.</li>\n          <li>Using tree-based algorithms: Some algorithms like Decision Trees or Random Forests can be less sensitive to data imbalance.</li>\n        </ul>\n      </li>\n      <li>Ensemble Methods:\n        <ul>\n          <li>Bagging with balanced datasets: Bootstrap samples from each class and train ensemble members like Random Forests.</li>\n          <li>Boosting: Algorithms like AdaBoost increase the weight of misclassified instances, which can help in focusing on the minority class.</li>\n          <li>Balanced Random Forest: Random Forest variant where each tree is grown on a balanced bootstrap sample.</li>\n          <li>RUSBoost: A boosting method which combines the principles of boosting with random undersampling.</li>\n        </ul>\n      </li>\n      <li>Synthetic Data Generation: Use techniques like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs) to generate synthetic samples for the minority class.</li>\n    </ol>\n<ul>\n          <li>Oversampling: Increase the number of instances in the minority class by replicating them or generating synthetic samples.\n            <ul>\n              <li>Random oversampling: Duplicate random samples from the minority class.</li>\n              <li>SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.</li>\n              <li>ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.</li>\n            </ul>\n          </li>\n          <li>Undersampling: Reduce the number of instances in the majority class. This can lead to a loss of information unless carefully done.\n            <ul>\n              <li>Random undersampling: Remove random samples from the majority class.</li>\n              <li>Tomek links: Remove majority samples that are close to minority samples.</li>\n              <li>Cluster centroids: Replace a cluster of majority samples with the cluster centroid.</li>\n              <li>NearMiss: Selects majority samples based on their distances to minority class samples.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>Random oversampling: Duplicate random samples from the minority class.</li>\n              <li>SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.</li>\n              <li>ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.</li>\n            </ul>\n<ul>\n              <li>Random undersampling: Remove random samples from the majority class.</li>\n              <li>Tomek links: Remove majority samples that are close to minority samples.</li>\n              <li>Cluster centroids: Replace a cluster of majority samples with the cluster centroid.</li>\n              <li>NearMiss: Selects majority samples based on their distances to minority class samples.</li>\n            </ul>\n<ul>\n          <li>Precision, Recall, F1-score</li>\n          <li>Area Under the Receiver Operating Characteristic Curve (ROC-AUC)</li>\n          <li>Area Under the Precision-Recall Curve (PR-AUC)</li>\n          <li>Matthews Correlation Coefficient (MCC)</li>\n          <li>Balanced accuracy</li>\n        </ul>\n<ul>\n          <li>Cost-sensitive training: Introduce different misclassification costs for different classes.\n            <ul>\n              <li>Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.</li>\n              <li>The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.</li>\n            </ul>\n          </li>\n          <li>Anomaly (or outlier) detection: Treat the minority class as an anomaly detection problem, by modeling the minority class as a rare event.</li>\n          <li>Using tree-based algorithms: Some algorithms like Decision Trees or Random Forests can be less sensitive to data imbalance.</li>\n        </ul>\n<ul>\n              <li>Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.</li>\n              <li>The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.</li>\n            </ul>\n<ul>\n          <li>Bagging with balanced datasets: Bootstrap samples from each class and train ensemble members like Random Forests.</li>\n          <li>Boosting: Algorithms like AdaBoost increase the weight of misclassified instances, which can help in focusing on the minority class.</li>\n          <li>Balanced Random Forest: Random Forest variant where each tree is grown on a balanced bootstrap sample.</li>\n          <li>RUSBoost: A boosting method which combines the principles of boosting with random undersampling.</li>\n        </ul>\n<h4 id=\"related-what-are-some-common-approaches-to-improve-performance-on-a-long-tailed-data-distribution\">Related: What are Some Common Approaches to Improve Performance on a Long Tailed Data Distribution?</h4>\n<ul>\n  <li>A long-tail distribution, often observed in real-world datasets, is characterized by a majority of data points belonging to a few “head” categories, while a vast number of categories have very few data points, forming the “tail”. In the context of machine learning, this can lead to challenges, as the model may not perform well on the underrepresented categories in the tail due to the lack of sufficient training examples. Here are some common approaches to improve performance on datasets with long-tail distributions:\n    <ol>\n      <li><strong>Resampling Techniques:</strong>\n        <ul>\n          <li>Oversampling the tail: This involves creating copies or synthesizing new examples for underrepresented categories. Techniques such as SMOTE or ADASYN can be used for this.</li>\n          <li>Undersampling the head: This reduces the number of samples in the overrepresented categories. This approach can be detrimental if done carelessly, as it may throw away potentially useful information.</li>\n        </ul>\n      </li>\n      <li><strong>Cost-sensitive Learning:</strong>\n        <ul>\n          <li>Assign higher misclassification costs to the tail classes. This way, the algorithm is penalized more for making mistakes on the tail categories, prompting it to pay more attention to them.</li>\n        </ul>\n      </li>\n      <li><strong>Class Decomposition:</strong>\n        <ul>\n          <li>Decompose multi-class classification into several binary or multi-class tasks, thereby allowing the model to focus on fewer classes at a time.</li>\n        </ul>\n      </li>\n      <li><strong>Transfer Learning:</strong>\n        <ul>\n          <li>Train a model on a related but balanced dataset and then fine-tune it on the imbalanced, long-tail dataset. The initial training helps the model capture general features, which can aid in recognizing tail classes during fine-tuning.</li>\n        </ul>\n      </li>\n      <li><strong>Data Augmentation:</strong>\n        <ul>\n          <li>Particularly useful for image data. Augment data in the tail classes by applying transformations such as rotations, translations, zooming, or color jittering to artificially increase the dataset’s size.</li>\n        </ul>\n      </li>\n      <li><strong>Tail-class Focused Augmentation:</strong>\n        <ul>\n          <li>Apply more aggressive or more frequent augmentations to the tail classes than the head classes, ensuring the model gets a diverse set of examples from the tail classes.</li>\n        </ul>\n      </li>\n      <li><strong>Hard Example Mining:</strong>\n        <ul>\n          <li>For tasks like object detection, focus on training examples that the model finds challenging, which often belong to the tail classes.</li>\n        </ul>\n      </li>\n      <li><strong>Meta-learning:</strong>\n        <ul>\n          <li>Techniques like Model-Agnostic Meta-Learning (MAML) can be adapted to long-tail scenarios, enabling the model to learn from few-shot examples, which can be beneficial for tail classes.</li>\n        </ul>\n      </li>\n      <li><strong>Ensemble Models:</strong>\n        <ul>\n          <li>Combine predictions from several models, potentially giving more weight to models or predictions that focus on tail classes.\n  10.** Hybrid Models with Memory:**</li>\n          <li>Use models that have a memory component, such as Memory Networks or models with a Neural Turing Machine architecture, to remember rare examples from tail classes.\n  11.** Curriculum Learning:**</li>\n          <li>Start training with the head categories and then gradually introduce the tail classes as training progresses.\n  12.** Binning or Bucketing:**</li>\n          <li>Group tail classes into meta-classes or bins and train the model to predict these bins. Once a bin is predicted, a second model can be used to predict the exact class within that bin.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>When dealing with long-tail distributions, it’s crucial to measure performance using appropriate metrics. Accuracy might not be informative, as high accuracy can be achieved by merely focusing on the head classes. Metrics like weighted F1-score, macro-average precision, and recall, or area under the precision-recall curve (PR-AUC) may provide a better indication of performance across all classes.</li>\n</ul>\n<ol>\n      <li><strong>Resampling Techniques:</strong>\n        <ul>\n          <li>Oversampling the tail: This involves creating copies or synthesizing new examples for underrepresented categories. Techniques such as SMOTE or ADASYN can be used for this.</li>\n          <li>Undersampling the head: This reduces the number of samples in the overrepresented categories. This approach can be detrimental if done carelessly, as it may throw away potentially useful information.</li>\n        </ul>\n      </li>\n      <li><strong>Cost-sensitive Learning:</strong>\n        <ul>\n          <li>Assign higher misclassification costs to the tail classes. This way, the algorithm is penalized more for making mistakes on the tail categories, prompting it to pay more attention to them.</li>\n        </ul>\n      </li>\n      <li><strong>Class Decomposition:</strong>\n        <ul>\n          <li>Decompose multi-class classification into several binary or multi-class tasks, thereby allowing the model to focus on fewer classes at a time.</li>\n        </ul>\n      </li>\n      <li><strong>Transfer Learning:</strong>\n        <ul>\n          <li>Train a model on a related but balanced dataset and then fine-tune it on the imbalanced, long-tail dataset. The initial training helps the model capture general features, which can aid in recognizing tail classes during fine-tuning.</li>\n        </ul>\n      </li>\n      <li><strong>Data Augmentation:</strong>\n        <ul>\n          <li>Particularly useful for image data. Augment data in the tail classes by applying transformations such as rotations, translations, zooming, or color jittering to artificially increase the dataset’s size.</li>\n        </ul>\n      </li>\n      <li><strong>Tail-class Focused Augmentation:</strong>\n        <ul>\n          <li>Apply more aggressive or more frequent augmentations to the tail classes than the head classes, ensuring the model gets a diverse set of examples from the tail classes.</li>\n        </ul>\n      </li>\n      <li><strong>Hard Example Mining:</strong>\n        <ul>\n          <li>For tasks like object detection, focus on training examples that the model finds challenging, which often belong to the tail classes.</li>\n        </ul>\n      </li>\n      <li><strong>Meta-learning:</strong>\n        <ul>\n          <li>Techniques like Model-Agnostic Meta-Learning (MAML) can be adapted to long-tail scenarios, enabling the model to learn from few-shot examples, which can be beneficial for tail classes.</li>\n        </ul>\n      </li>\n      <li><strong>Ensemble Models:</strong>\n        <ul>\n          <li>Combine predictions from several models, potentially giving more weight to models or predictions that focus on tail classes.\n  10.** Hybrid Models with Memory:**</li>\n          <li>Use models that have a memory component, such as Memory Networks or models with a Neural Turing Machine architecture, to remember rare examples from tail classes.\n  11.** Curriculum Learning:**</li>\n          <li>Start training with the head categories and then gradually introduce the tail classes as training progresses.\n  12.** Binning or Bucketing:**</li>\n          <li>Group tail classes into meta-classes or bins and train the model to predict these bins. Once a bin is predicted, a second model can be used to predict the exact class within that bin.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Oversampling the tail: This involves creating copies or synthesizing new examples for underrepresented categories. Techniques such as SMOTE or ADASYN can be used for this.</li>\n          <li>Undersampling the head: This reduces the number of samples in the overrepresented categories. This approach can be detrimental if done carelessly, as it may throw away potentially useful information.</li>\n        </ul>\n<ul>\n          <li>Assign higher misclassification costs to the tail classes. This way, the algorithm is penalized more for making mistakes on the tail categories, prompting it to pay more attention to them.</li>\n        </ul>\n<ul>\n          <li>Decompose multi-class classification into several binary or multi-class tasks, thereby allowing the model to focus on fewer classes at a time.</li>\n        </ul>\n<ul>\n          <li>Train a model on a related but balanced dataset and then fine-tune it on the imbalanced, long-tail dataset. The initial training helps the model capture general features, which can aid in recognizing tail classes during fine-tuning.</li>\n        </ul>\n<ul>\n          <li>Particularly useful for image data. Augment data in the tail classes by applying transformations such as rotations, translations, zooming, or color jittering to artificially increase the dataset’s size.</li>\n        </ul>\n<ul>\n          <li>Apply more aggressive or more frequent augmentations to the tail classes than the head classes, ensuring the model gets a diverse set of examples from the tail classes.</li>\n        </ul>\n<ul>\n          <li>For tasks like object detection, focus on training examples that the model finds challenging, which often belong to the tail classes.</li>\n        </ul>\n<ul>\n          <li>Techniques like Model-Agnostic Meta-Learning (MAML) can be adapted to long-tail scenarios, enabling the model to learn from few-shot examples, which can be beneficial for tail classes.</li>\n        </ul>\n<ul>\n          <li>Combine predictions from several models, potentially giving more weight to models or predictions that focus on tail classes.\n  10.** Hybrid Models with Memory:**</li>\n          <li>Use models that have a memory component, such as Memory Networks or models with a Neural Turing Machine architecture, to remember rare examples from tail classes.\n  11.** Curriculum Learning:**</li>\n          <li>Start training with the head categories and then gradually introduce the tail classes as training progresses.\n  12.** Binning or Bucketing:**</li>\n          <li>Group tail classes into meta-classes or bins and train the model to predict these bins. Once a bin is predicted, a second model can be used to predict the exact class within that bin.</li>\n        </ul>",
      "contentMarkdown": "*   Data imbalance refers to situations where some classes in a classification task have significantly fewer samples than others. This can lead models to favor the majority class (or classes) and perform poorly on the minority class. Here are several methods to mitigate the effects of data imbalance during model training:\n    1.  Resampling Techniques:\n        *   Oversampling: Increase the number of instances in the minority class by replicating them or generating synthetic samples.\n            *   Random oversampling: Duplicate random samples from the minority class.\n            *   SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.\n            *   ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.\n        *   Undersampling: Reduce the number of instances in the majority class. This can lead to a loss of information unless carefully done.\n            *   Random undersampling: Remove random samples from the majority class.\n            *   Tomek links: Remove majority samples that are close to minority samples.\n            *   Cluster centroids: Replace a cluster of majority samples with the cluster centroid.\n            *   NearMiss: Selects majority samples based on their distances to minority class samples.\n    2.  Use Different Evaluation Metrics: Accuracy is not a good metric for imbalanced datasets. Instead, consider using:\n        *   Precision, Recall, F1-score\n        *   Area Under the Receiver Operating Characteristic Curve (ROC-AUC)\n        *   Area Under the Precision-Recall Curve (PR-AUC)\n        *   Matthews Correlation Coefficient (MCC)\n        *   Balanced accuracy\n    3.  Algorithm-level Approaches:\n        *   Cost-sensitive training: Introduce different misclassification costs for different classes.\n            *   Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.\n            *   The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.\n        *   Anomaly (or outlier) detection: Treat the minority class as an anomaly detection problem, by modeling the minority class as a rare event.\n        *   Using tree-based algorithms: Some algorithms like Decision Trees or Random Forests can be less sensitive to data imbalance.\n    4.  Ensemble Methods:\n        *   Bagging with balanced datasets: Bootstrap samples from each class and train ensemble members like Random Forests.\n        *   Boosting: Algorithms like AdaBoost increase the weight of misclassified instances, which can help in focusing on the minority class.\n        *   Balanced Random Forest: Random Forest variant where each tree is grown on a balanced bootstrap sample.\n        *   RUSBoost: A boosting method which combines the principles of boosting with random undersampling.\n    5.  Synthetic Data Generation: Use techniques like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs) to generate synthetic samples for the minority class.\n\n1.  Resampling Techniques:\n    *   Oversampling: Increase the number of instances in the minority class by replicating them or generating synthetic samples.\n        *   Random oversampling: Duplicate random samples from the minority class.\n        *   SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.\n        *   ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.\n    *   Undersampling: Reduce the number of instances in the majority class. This can lead to a loss of information unless carefully done.\n        *   Random undersampling: Remove random samples from the majority class.\n        *   Tomek links: Remove majority samples that are close to minority samples.\n        *   Cluster centroids: Replace a cluster of majority samples with the cluster centroid.\n        *   NearMiss: Selects majority samples based on their distances to minority class samples.\n2.  Use Different Evaluation Metrics: Accuracy is not a good metric for imbalanced datasets. Instead, consider using:\n    *   Precision, Recall, F1-score\n    *   Area Under the Receiver Operating Characteristic Curve (ROC-AUC)\n    *   Area Under the Precision-Recall Curve (PR-AUC)\n    *   Matthews Correlation Coefficient (MCC)\n    *   Balanced accuracy\n3.  Algorithm-level Approaches:\n    *   Cost-sensitive training: Introduce different misclassification costs for different classes.\n        *   Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.\n        *   The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.\n    *   Anomaly (or outlier) detection: Treat the minority class as an anomaly detection problem, by modeling the minority class as a rare event.\n    *   Using tree-based algorithms: Some algorithms like Decision Trees or Random Forests can be less sensitive to data imbalance.\n4.  Ensemble Methods:\n    *   Bagging with balanced datasets: Bootstrap samples from each class and train ensemble members like Random Forests.\n    *   Boosting: Algorithms like AdaBoost increase the weight of misclassified instances, which can help in focusing on the minority class.\n    *   Balanced Random Forest: Random Forest variant where each tree is grown on a balanced bootstrap sample.\n    *   RUSBoost: A boosting method which combines the principles of boosting with random undersampling.\n5.  Synthetic Data Generation: Use techniques like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs) to generate synthetic samples for the minority class.\n\n*   Oversampling: Increase the number of instances in the minority class by replicating them or generating synthetic samples.\n    *   Random oversampling: Duplicate random samples from the minority class.\n    *   SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.\n    *   ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.\n*   Undersampling: Reduce the number of instances in the majority class. This can lead to a loss of information unless carefully done.\n    *   Random undersampling: Remove random samples from the majority class.\n    *   Tomek links: Remove majority samples that are close to minority samples.\n    *   Cluster centroids: Replace a cluster of majority samples with the cluster centroid.\n    *   NearMiss: Selects majority samples based on their distances to minority class samples.\n\n*   Random oversampling: Duplicate random samples from the minority class.\n*   SMOTE (Synthetic Minority Over-sampling Technique): Create synthetic examples in the feature space.\n*   ADASYN: Similar to SMOTE but places an emphasis on those instances which are difficult to classify.\n\n*   Random undersampling: Remove random samples from the majority class.\n*   Tomek links: Remove majority samples that are close to minority samples.\n*   Cluster centroids: Replace a cluster of majority samples with the cluster centroid.\n*   NearMiss: Selects majority samples based on their distances to minority class samples.\n\n*   Precision, Recall, F1-score\n*   Area Under the Receiver Operating Characteristic Curve (ROC-AUC)\n*   Area Under the Precision-Recall Curve (PR-AUC)\n*   Matthews Correlation Coefficient (MCC)\n*   Balanced accuracy\n\n*   Cost-sensitive training: Introduce different misclassification costs for different classes.\n    *   Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.\n    *   The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.\n*   Anomaly (or outlier) detection: Treat the minority class as an anomaly detection problem, by modeling the minority class as a rare event.\n*   Using tree-based algorithms: Some algorithms like Decision Trees or Random Forests can be less sensitive to data imbalance.\n\n*   Focal Loss is an alternative to the standard cross-entropy loss for classification, specifically designed to address the issue of class imbalance in deep learning models. It was introduced by Tsung-Yi Lin et al. in the paper “Focal Loss for Dense Object Detection” in the context of object detection, but the principle can be applied to any classification problem.\n*   The main idea behind focal loss is to reduce the loss contribution from easy-to-classify examples and focus on the hard-to-classify ones. In an imbalanced dataset, the majority of examples are easy-to-classify (i.e., they belong to the majority class), which can overshadow the minority class during training.\n\n*   Bagging with balanced datasets: Bootstrap samples from each class and train ensemble members like Random Forests.\n*   Boosting: Algorithms like AdaBoost increase the weight of misclassified instances, which can help in focusing on the minority class.\n*   Balanced Random Forest: Random Forest variant where each tree is grown on a balanced bootstrap sample.\n*   RUSBoost: A boosting method which combines the principles of boosting with random undersampling.\n\n#### Related: What are Some Common Approaches to Improve Performance on a Long Tailed Data Distribution?\n\n*   A long-tail distribution, often observed in real-world datasets, is characterized by a majority of data points belonging to a few “head” categories, while a vast number of categories have very few data points, forming the “tail”. In the context of machine learning, this can lead to challenges, as the model may not perform well on the underrepresented categories in the tail due to the lack of sufficient training examples. Here are some common approaches to improve performance on datasets with long-tail distributions:\n    1.  **Resampling Techniques:**\n        *   Oversampling the tail: This involves creating copies or synthesizing new examples for underrepresented categories. Techniques such as SMOTE or ADASYN can be used for this.\n        *   Undersampling the head: This reduces the number of samples in the overrepresented categories. This approach can be detrimental if done carelessly, as it may throw away potentially useful information.\n    2.  **Cost-sensitive Learning:**\n        *   Assign higher misclassification costs to the tail classes. This way, the algorithm is penalized more for making mistakes on the tail categories, prompting it to pay more attention to them.\n    3.  **Class Decomposition:**\n        *   Decompose multi-class classification into several binary or multi-class tasks, thereby allowing the model to focus on fewer classes at a time.\n    4.  **Transfer Learning:**\n        *   Train a model on a related but balanced dataset and then fine-tune it on the imbalanced, long-tail dataset. The initial training helps the model capture general features, which can aid in recognizing tail classes during fine-tuning.\n    5.  **Data Augmentation:**\n        *   Particularly useful for image data. Augment data in the tail classes by applying transformations such as rotations, translations, zooming, or color jittering to artificially increase the dataset’s size.\n    6.  **Tail-class Focused Augmentation:**\n        *   Apply more aggressive or more frequent augmentations to the tail classes than the head classes, ensuring the model gets a diverse set of examples from the tail classes.\n    7.  **Hard Example Mining:**\n        *   For tasks like object detection, focus on training examples that the model finds challenging, which often belong to the tail classes.\n    8.  **Meta-learning:**\n        *   Techniques like Model-Agnostic Meta-Learning (MAML) can be adapted to long-tail scenarios, enabling the model to learn from few-shot examples, which can be beneficial for tail classes.\n    9.  **Ensemble Models:**\n        *   Combine predictions from several models, potentially giving more weight to models or predictions that focus on tail classes. 10.\\*\\* Hybrid Models with Memory:\\*\\*\n        *   Use models that have a memory component, such as Memory Networks or models with a Neural Turing Machine architecture, to remember rare examples from tail classes. 11.\\*\\* Curriculum Learning:\\*\\*\n        *   Start training with the head categories and then gradually introduce the tail classes as training progresses. 12.\\*\\* Binning or Bucketing:\\*\\*\n        *   Group tail classes into meta-classes or bins and train the model to predict these bins. Once a bin is predicted, a second model can be used to predict the exact class within that bin.\n*   When dealing with long-tail distributions, it’s crucial to measure performance using appropriate metrics. Accuracy might not be informative, as high accuracy can be achieved by merely focusing on the head classes. Metrics like weighted F1-score, macro-average precision, and recall, or area under the precision-recall curve (PR-AUC) may provide a better indication of performance across all classes.\n\n1.  **Resampling Techniques:**\n    *   Oversampling the tail: This involves creating copies or synthesizing new examples for underrepresented categories. Techniques such as SMOTE or ADASYN can be used for this.\n    *   Undersampling the head: This reduces the number of samples in the overrepresented categories. This approach can be detrimental if done carelessly, as it may throw away potentially useful information.\n2.  **Cost-sensitive Learning:**\n    *   Assign higher misclassification costs to the tail classes. This way, the algorithm is penalized more for making mistakes on the tail categories, prompting it to pay more attention to them.\n3.  **Class Decomposition:**\n    *   Decompose multi-class classification into several binary or multi-class tasks, thereby allowing the model to focus on fewer classes at a time.\n4.  **Transfer Learning:**\n    *   Train a model on a related but balanced dataset and then fine-tune it on the imbalanced, long-tail dataset. The initial training helps the model capture general features, which can aid in recognizing tail classes during fine-tuning.\n5.  **Data Augmentation:**\n    *   Particularly useful for image data. Augment data in the tail classes by applying transformations such as rotations, translations, zooming, or color jittering to artificially increase the dataset’s size.\n6.  **Tail-class Focused Augmentation:**\n    *   Apply more aggressive or more frequent augmentations to the tail classes than the head classes, ensuring the model gets a diverse set of examples from the tail classes.\n7.  **Hard Example Mining:**\n    *   For tasks like object detection, focus on training examples that the model finds challenging, which often belong to the tail classes.\n8.  **Meta-learning:**\n    *   Techniques like Model-Agnostic Meta-Learning (MAML) can be adapted to long-tail scenarios, enabling the model to learn from few-shot examples, which can be beneficial for tail classes.\n9.  **Ensemble Models:**\n    *   Combine predictions from several models, potentially giving more weight to models or predictions that focus on tail classes. 10.\\*\\* Hybrid Models with Memory:\\*\\*\n    *   Use models that have a memory component, such as Memory Networks or models with a Neural Turing Machine architecture, to remember rare examples from tail classes. 11.\\*\\* Curriculum Learning:\\*\\*\n    *   Start training with the head categories and then gradually introduce the tail classes as training progresses. 12.\\*\\* Binning or Bucketing:\\*\\*\n    *   Group tail classes into meta-classes or bins and train the model to predict these bins. Once a bin is predicted, a second model can be used to predict the exact class within that bin.\n\n*   Oversampling the tail: This involves creating copies or synthesizing new examples for underrepresented categories. Techniques such as SMOTE or ADASYN can be used for this.\n*   Undersampling the head: This reduces the number of samples in the overrepresented categories. This approach can be detrimental if done carelessly, as it may throw away potentially useful information.\n\n*   Assign higher misclassification costs to the tail classes. This way, the algorithm is penalized more for making mistakes on the tail categories, prompting it to pay more attention to them.\n\n*   Decompose multi-class classification into several binary or multi-class tasks, thereby allowing the model to focus on fewer classes at a time.\n\n*   Train a model on a related but balanced dataset and then fine-tune it on the imbalanced, long-tail dataset. The initial training helps the model capture general features, which can aid in recognizing tail classes during fine-tuning.\n\n*   Particularly useful for image data. Augment data in the tail classes by applying transformations such as rotations, translations, zooming, or color jittering to artificially increase the dataset’s size.\n\n*   Apply more aggressive or more frequent augmentations to the tail classes than the head classes, ensuring the model gets a diverse set of examples from the tail classes.\n\n*   For tasks like object detection, focus on training examples that the model finds challenging, which often belong to the tail classes.\n\n*   Techniques like Model-Agnostic Meta-Learning (MAML) can be adapted to long-tail scenarios, enabling the model to learn from few-shot examples, which can be beneficial for tail classes.\n\n*   Combine predictions from several models, potentially giving more weight to models or predictions that focus on tail classes. 10.\\*\\* Hybrid Models with Memory:\\*\\*\n*   Use models that have a memory component, such as Memory Networks or models with a Neural Turing Machine architecture, to remember rare examples from tail classes. 11.\\*\\* Curriculum Learning:\\*\\*\n*   Start training with the head categories and then gradually introduce the tail classes as training progresses. 12.\\*\\* Binning or Bucketing:\\*\\*\n*   Group tail classes into meta-classes or bins and train the model to predict these bins. Once a bin is predicted, a second model can be used to predict the exact class within that bin.",
      "order": 74,
      "orderInChapter": 74,
      "difficulty": 4,
      "estimatedMinutes": 14,
      "tags": [
        "practice",
        "deep learning",
        "machine learning",
        "attention",
        "fine-tuning",
        "transfer learning",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 2790,
        "contentLength": 23110
      },
      "nextCards": [
        "ai-interview-which-ensembling-methods-work-well-for-class-imbal-75",
        "ai-interview-what-is-focal-loss-how-does-it-help-mitigate-class-76"
      ],
      "relatedCards": [
        "ai-context-length-extension-yarn-efficient-context-window-extension-of-large-l-7",
        "ai-federated-learning-privacy-21",
        "ai-fine-tune-and-eval-BERT-add-padding-9",
        "ai-parameter-efficient-fine-tuning-reparameterization-4",
        "ai-nlp-tasks-future-directions-39"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-mitigate-data-imbalance-during-model-training?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-which-ensembling-methods-work-well-for-class-imbal-75",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Which Ensembling Methods Work Well for Class Imbalance/long Tail Scenarios?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Ensemble methods are strategies that combine multiple models to achieve better performance than any single model alone. For dealing with long-tail distributions, especially in unlabeled data scenarios, certain ensemble techniques can be particularly beneficial:\n    <ul>\n      <li><strong>Bagging:</strong>\n        <ul>\n          <li>Bootstrap Sampling: This involves taking random subsamples (with replacement) from your dataset to train multiple models. Some of these subsamples might have a higher representation of the tail classes, which can help in capturing their characteristics.</li>\n          <li>Random Subspaces: Instead of subsampling data points, random subsets of features are selected for training multiple models. This diversifies the ensemble and can help in capturing nuances of the tail distribution.</li>\n        </ul>\n      </li>\n      <li><strong>Boosting:</strong>\n        <ul>\n          <li>Boosting algorithms focus on examples that are hard to predict. For long-tail distributions, the tail classes often represent harder examples. Algorithms like AdaBoost or Gradient Boosting can adaptively focus more on these examples in subsequent iterations.</li>\n        </ul>\n      </li>\n      <li><strong>Stacking:</strong>\n        <ul>\n          <li>Train models with different architectures or algorithms and use their predictions as input features for a meta-model. This can be beneficial since different models might capture different aspects of the tail data.</li>\n        </ul>\n      </li>\n      <li><strong>Bald Boosting:</strong>\n        <ul>\n          <li>A variant of boosting, where, along with data weights, instance-specific costs are introduced. This allows the algorithm to focus more on tail instances by assigning higher misclassification costs to them.</li>\n        </ul>\n      </li>\n      <li><strong>Diversity-Aware Ensembles:</strong>\n        <ul>\n          <li>Train multiple models where each model is encouraged to be diverse from others. This can be achieved by using different architectures, different training subsets, different feature subsets, or regularization terms that promote diversity. The goal is to ensure that at least some models in the ensemble are good at capturing the tail data.</li>\n        </ul>\n      </li>\n      <li><strong>Hierarchical Ensembles:</strong>\n        <ul>\n          <li>Construct ensembles in a hierarchical fashion, where the first level of models might focus on broad patterns (including distinguishing head from tail) and subsequent levels delve deeper into specifics.</li>\n        </ul>\n      </li>\n      <li><strong>Weighted Ensemble:</strong>\n        <ul>\n          <li>Assign higher weights to models that perform better on tail data when combining their predictions. This gives more importance to models that capture the nuances of the tail distribution.</li>\n        </ul>\n      </li>\n      <li><strong>Hybrid Ensembles:</strong>\n        <ul>\n          <li>Combine models trained with supervised methods (if some labeled data is available) with models trained on unsupervised methods, thereby leveraging strengths from both supervised and unsupervised paradigms.</li>\n        </ul>\n      </li>\n      <li><strong>Dynamic Ensemble Selection:</strong>\n        <ul>\n          <li>Rather than combining predictions from all models, dynamically select a subset of models based on the instance to be predicted. Models that are more competent for tail instances can be chosen when predicting such instances.</li>\n        </ul>\n      </li>\n      <li><strong>Cluster-based Ensembles:</strong>\n        <ul>\n          <li>First, cluster the data, ensuring that tail data is adequately represented in some clusters. Then, for each cluster, train a dedicated model. During prediction, route data points to appropriate models based on their cluster membership or similarity.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Remember, when working with long-tail distributions, the evaluation metric is crucial. Ensure that you’re not only looking at overall accuracy but also metrics that can capture performance on the tail classes or instances, such as F1-score, macro-average precision/recall, or other suitable metrics.</li>\n</ul>\n<ul>\n      <li><strong>Bagging:</strong>\n        <ul>\n          <li>Bootstrap Sampling: This involves taking random subsamples (with replacement) from your dataset to train multiple models. Some of these subsamples might have a higher representation of the tail classes, which can help in capturing their characteristics.</li>\n          <li>Random Subspaces: Instead of subsampling data points, random subsets of features are selected for training multiple models. This diversifies the ensemble and can help in capturing nuances of the tail distribution.</li>\n        </ul>\n      </li>\n      <li><strong>Boosting:</strong>\n        <ul>\n          <li>Boosting algorithms focus on examples that are hard to predict. For long-tail distributions, the tail classes often represent harder examples. Algorithms like AdaBoost or Gradient Boosting can adaptively focus more on these examples in subsequent iterations.</li>\n        </ul>\n      </li>\n      <li><strong>Stacking:</strong>\n        <ul>\n          <li>Train models with different architectures or algorithms and use their predictions as input features for a meta-model. This can be beneficial since different models might capture different aspects of the tail data.</li>\n        </ul>\n      </li>\n      <li><strong>Bald Boosting:</strong>\n        <ul>\n          <li>A variant of boosting, where, along with data weights, instance-specific costs are introduced. This allows the algorithm to focus more on tail instances by assigning higher misclassification costs to them.</li>\n        </ul>\n      </li>\n      <li><strong>Diversity-Aware Ensembles:</strong>\n        <ul>\n          <li>Train multiple models where each model is encouraged to be diverse from others. This can be achieved by using different architectures, different training subsets, different feature subsets, or regularization terms that promote diversity. The goal is to ensure that at least some models in the ensemble are good at capturing the tail data.</li>\n        </ul>\n      </li>\n      <li><strong>Hierarchical Ensembles:</strong>\n        <ul>\n          <li>Construct ensembles in a hierarchical fashion, where the first level of models might focus on broad patterns (including distinguishing head from tail) and subsequent levels delve deeper into specifics.</li>\n        </ul>\n      </li>\n      <li><strong>Weighted Ensemble:</strong>\n        <ul>\n          <li>Assign higher weights to models that perform better on tail data when combining their predictions. This gives more importance to models that capture the nuances of the tail distribution.</li>\n        </ul>\n      </li>\n      <li><strong>Hybrid Ensembles:</strong>\n        <ul>\n          <li>Combine models trained with supervised methods (if some labeled data is available) with models trained on unsupervised methods, thereby leveraging strengths from both supervised and unsupervised paradigms.</li>\n        </ul>\n      </li>\n      <li><strong>Dynamic Ensemble Selection:</strong>\n        <ul>\n          <li>Rather than combining predictions from all models, dynamically select a subset of models based on the instance to be predicted. Models that are more competent for tail instances can be chosen when predicting such instances.</li>\n        </ul>\n      </li>\n      <li><strong>Cluster-based Ensembles:</strong>\n        <ul>\n          <li>First, cluster the data, ensuring that tail data is adequately represented in some clusters. Then, for each cluster, train a dedicated model. During prediction, route data points to appropriate models based on their cluster membership or similarity.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Bootstrap Sampling: This involves taking random subsamples (with replacement) from your dataset to train multiple models. Some of these subsamples might have a higher representation of the tail classes, which can help in capturing their characteristics.</li>\n          <li>Random Subspaces: Instead of subsampling data points, random subsets of features are selected for training multiple models. This diversifies the ensemble and can help in capturing nuances of the tail distribution.</li>\n        </ul>\n<ul>\n          <li>Boosting algorithms focus on examples that are hard to predict. For long-tail distributions, the tail classes often represent harder examples. Algorithms like AdaBoost or Gradient Boosting can adaptively focus more on these examples in subsequent iterations.</li>\n        </ul>\n<ul>\n          <li>Train models with different architectures or algorithms and use their predictions as input features for a meta-model. This can be beneficial since different models might capture different aspects of the tail data.</li>\n        </ul>\n<ul>\n          <li>A variant of boosting, where, along with data weights, instance-specific costs are introduced. This allows the algorithm to focus more on tail instances by assigning higher misclassification costs to them.</li>\n        </ul>\n<ul>\n          <li>Train multiple models where each model is encouraged to be diverse from others. This can be achieved by using different architectures, different training subsets, different feature subsets, or regularization terms that promote diversity. The goal is to ensure that at least some models in the ensemble are good at capturing the tail data.</li>\n        </ul>\n<ul>\n          <li>Construct ensembles in a hierarchical fashion, where the first level of models might focus on broad patterns (including distinguishing head from tail) and subsequent levels delve deeper into specifics.</li>\n        </ul>\n<ul>\n          <li>Assign higher weights to models that perform better on tail data when combining their predictions. This gives more importance to models that capture the nuances of the tail distribution.</li>\n        </ul>\n<ul>\n          <li>Combine models trained with supervised methods (if some labeled data is available) with models trained on unsupervised methods, thereby leveraging strengths from both supervised and unsupervised paradigms.</li>\n        </ul>\n<ul>\n          <li>Rather than combining predictions from all models, dynamically select a subset of models based on the instance to be predicted. Models that are more competent for tail instances can be chosen when predicting such instances.</li>\n        </ul>\n<ul>\n          <li>First, cluster the data, ensuring that tail data is adequately represented in some clusters. Then, for each cluster, train a dedicated model. During prediction, route data points to appropriate models based on their cluster membership or similarity.</li>\n        </ul>",
      "contentMarkdown": "*   Ensemble methods are strategies that combine multiple models to achieve better performance than any single model alone. For dealing with long-tail distributions, especially in unlabeled data scenarios, certain ensemble techniques can be particularly beneficial:\n    *   **Bagging:**\n        *   Bootstrap Sampling: This involves taking random subsamples (with replacement) from your dataset to train multiple models. Some of these subsamples might have a higher representation of the tail classes, which can help in capturing their characteristics.\n        *   Random Subspaces: Instead of subsampling data points, random subsets of features are selected for training multiple models. This diversifies the ensemble and can help in capturing nuances of the tail distribution.\n    *   **Boosting:**\n        *   Boosting algorithms focus on examples that are hard to predict. For long-tail distributions, the tail classes often represent harder examples. Algorithms like AdaBoost or Gradient Boosting can adaptively focus more on these examples in subsequent iterations.\n    *   **Stacking:**\n        *   Train models with different architectures or algorithms and use their predictions as input features for a meta-model. This can be beneficial since different models might capture different aspects of the tail data.\n    *   **Bald Boosting:**\n        *   A variant of boosting, where, along with data weights, instance-specific costs are introduced. This allows the algorithm to focus more on tail instances by assigning higher misclassification costs to them.\n    *   **Diversity-Aware Ensembles:**\n        *   Train multiple models where each model is encouraged to be diverse from others. This can be achieved by using different architectures, different training subsets, different feature subsets, or regularization terms that promote diversity. The goal is to ensure that at least some models in the ensemble are good at capturing the tail data.\n    *   **Hierarchical Ensembles:**\n        *   Construct ensembles in a hierarchical fashion, where the first level of models might focus on broad patterns (including distinguishing head from tail) and subsequent levels delve deeper into specifics.\n    *   **Weighted Ensemble:**\n        *   Assign higher weights to models that perform better on tail data when combining their predictions. This gives more importance to models that capture the nuances of the tail distribution.\n    *   **Hybrid Ensembles:**\n        *   Combine models trained with supervised methods (if some labeled data is available) with models trained on unsupervised methods, thereby leveraging strengths from both supervised and unsupervised paradigms.\n    *   **Dynamic Ensemble Selection:**\n        *   Rather than combining predictions from all models, dynamically select a subset of models based on the instance to be predicted. Models that are more competent for tail instances can be chosen when predicting such instances.\n    *   **Cluster-based Ensembles:**\n        *   First, cluster the data, ensuring that tail data is adequately represented in some clusters. Then, for each cluster, train a dedicated model. During prediction, route data points to appropriate models based on their cluster membership or similarity.\n*   Remember, when working with long-tail distributions, the evaluation metric is crucial. Ensure that you’re not only looking at overall accuracy but also metrics that can capture performance on the tail classes or instances, such as F1-score, macro-average precision/recall, or other suitable metrics.\n\n*   **Bagging:**\n    *   Bootstrap Sampling: This involves taking random subsamples (with replacement) from your dataset to train multiple models. Some of these subsamples might have a higher representation of the tail classes, which can help in capturing their characteristics.\n    *   Random Subspaces: Instead of subsampling data points, random subsets of features are selected for training multiple models. This diversifies the ensemble and can help in capturing nuances of the tail distribution.\n*   **Boosting:**\n    *   Boosting algorithms focus on examples that are hard to predict. For long-tail distributions, the tail classes often represent harder examples. Algorithms like AdaBoost or Gradient Boosting can adaptively focus more on these examples in subsequent iterations.\n*   **Stacking:**\n    *   Train models with different architectures or algorithms and use their predictions as input features for a meta-model. This can be beneficial since different models might capture different aspects of the tail data.\n*   **Bald Boosting:**\n    *   A variant of boosting, where, along with data weights, instance-specific costs are introduced. This allows the algorithm to focus more on tail instances by assigning higher misclassification costs to them.\n*   **Diversity-Aware Ensembles:**\n    *   Train multiple models where each model is encouraged to be diverse from others. This can be achieved by using different architectures, different training subsets, different feature subsets, or regularization terms that promote diversity. The goal is to ensure that at least some models in the ensemble are good at capturing the tail data.\n*   **Hierarchical Ensembles:**\n    *   Construct ensembles in a hierarchical fashion, where the first level of models might focus on broad patterns (including distinguishing head from tail) and subsequent levels delve deeper into specifics.\n*   **Weighted Ensemble:**\n    *   Assign higher weights to models that perform better on tail data when combining their predictions. This gives more importance to models that capture the nuances of the tail distribution.\n*   **Hybrid Ensembles:**\n    *   Combine models trained with supervised methods (if some labeled data is available) with models trained on unsupervised methods, thereby leveraging strengths from both supervised and unsupervised paradigms.\n*   **Dynamic Ensemble Selection:**\n    *   Rather than combining predictions from all models, dynamically select a subset of models based on the instance to be predicted. Models that are more competent for tail instances can be chosen when predicting such instances.\n*   **Cluster-based Ensembles:**\n    *   First, cluster the data, ensuring that tail data is adequately represented in some clusters. Then, for each cluster, train a dedicated model. During prediction, route data points to appropriate models based on their cluster membership or similarity.\n\n*   Bootstrap Sampling: This involves taking random subsamples (with replacement) from your dataset to train multiple models. Some of these subsamples might have a higher representation of the tail classes, which can help in capturing their characteristics.\n*   Random Subspaces: Instead of subsampling data points, random subsets of features are selected for training multiple models. This diversifies the ensemble and can help in capturing nuances of the tail distribution.\n\n*   Boosting algorithms focus on examples that are hard to predict. For long-tail distributions, the tail classes often represent harder examples. Algorithms like AdaBoost or Gradient Boosting can adaptively focus more on these examples in subsequent iterations.\n\n*   Train models with different architectures or algorithms and use their predictions as input features for a meta-model. This can be beneficial since different models might capture different aspects of the tail data.\n\n*   A variant of boosting, where, along with data weights, instance-specific costs are introduced. This allows the algorithm to focus more on tail instances by assigning higher misclassification costs to them.\n\n*   Train multiple models where each model is encouraged to be diverse from others. This can be achieved by using different architectures, different training subsets, different feature subsets, or regularization terms that promote diversity. The goal is to ensure that at least some models in the ensemble are good at capturing the tail data.\n\n*   Construct ensembles in a hierarchical fashion, where the first level of models might focus on broad patterns (including distinguishing head from tail) and subsequent levels delve deeper into specifics.\n\n*   Assign higher weights to models that perform better on tail data when combining their predictions. This gives more importance to models that capture the nuances of the tail distribution.\n\n*   Combine models trained with supervised methods (if some labeled data is available) with models trained on unsupervised methods, thereby leveraging strengths from both supervised and unsupervised paradigms.\n\n*   Rather than combining predictions from all models, dynamically select a subset of models based on the instance to be predicted. Models that are more competent for tail instances can be chosen when predicting such instances.\n\n*   First, cluster the data, ensuring that tail data is adequately represented in some clusters. Then, for each cluster, train a dedicated model. During prediction, route data points to appropriate models based on their cluster membership or similarity.",
      "order": 75,
      "orderInChapter": 75,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1292,
        "contentLength": 10803
      },
      "nextCards": [
        "ai-interview-what-is-focal-loss-how-does-it-help-mitigate-class-76",
        "ai-interview-how-do-you-define-uncertainty-with-regression-prob-77"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-is-an-occasional-side-effect-of-boosting-an-increa-28",
        "ai-diffusion-models-what-does-the-stable-in-stable-diffusion-refer-to-48",
        "ai-diffusion-models-integration-with-mse-46",
        "ai-diffusion-models-high-resolution-image-synthesis-with-latent-diffus-54",
        "ai-mixture-of-experts-overview-19"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#which-ensembling-methods-work-well-for-class-imbalance/long-tail-scenarios?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-focal-loss-how-does-it-help-mitigate-class-76",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Focal Loss? How Does It Help Mitigate Class Imbalance?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Focal loss is a modified version of the standard cross-entropy loss used in classification tasks, particularly designed to address class imbalance by focusing more on hard-to-classify examples. It was introduced by Lin et al. in the context of object detection tasks, but it can be applied to any classification problem.</li>\n  <li>The formula for focal loss is as follows:\n    <ul>\n      <li><strong>Binary Classification:</strong>\n        <ul>\n          <li>\n            <p>For a binary classification task, the focal loss is defined as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-82-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-667\" style=\"width: 14.378em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.982em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1011.93em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-668\"><span class=\"mi\" id=\"MathJax-Span-669\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-670\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-671\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-672\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-673\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-674\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-675\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-676\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-677\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-678\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-679\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-680\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-681\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-682\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-683\"><span class=\"mo\" id=\"MathJax-Span-684\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-685\"><span class=\"mn\" id=\"MathJax-Span-686\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-687\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-688\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-689\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-690\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-691\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-692\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-693\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-694\"></span><span class=\"mrow\" id=\"MathJax-Span-695\"><span class=\"mo\" id=\"MathJax-Span-696\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-697\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-698\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-699\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-700\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><msub><mi>α</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-82\">F L\\left(p_t\\right)=-\\alpha_t\\left(1-p_t\\right)^\\gamma \\log \\left(p_t\\right)</script></p>\n          </li>\n          <li>\n            <p>Where:</p>\n            <ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-83-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-701\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-702\"><span class=\"msubsup\" id=\"MathJax-Span-703\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-704\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-705\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-83\">p_t</script> is the model’s estimated probability for the class with label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-84-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-706\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-707\"><span class=\"mi\" id=\"MathJax-Span-708\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-709\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-710\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-84\">y=1</script>. Specifically, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-85-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-711\" style=\"width: 3.023em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.503em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.45em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-712\"><span class=\"msubsup\" id=\"MathJax-Span-713\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-714\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-715\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-716\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-717\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-85\">p_t=p</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-86-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-718\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-719\"><span class=\"mi\" id=\"MathJax-Span-720\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-721\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-722\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-86\">y=1</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-87-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-723\" style=\"width: 4.898em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.065em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.01em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-724\"><span class=\"msubsup\" id=\"MathJax-Span-725\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-726\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-727\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-728\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-729\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-730\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-731\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-87\">p_t=1-p</script> otherwise, with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-88-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-732\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-733\"><span class=\"mi\" id=\"MathJax-Span-734\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-88\">p</script> being the model’s estimated probability for the class label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-89-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-735\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-736\"><span class=\"mi\" id=\"MathJax-Span-737\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-738\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-739\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-89\">y=1</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-90-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-740\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-741\"><span class=\"msubsup\" id=\"MathJax-Span-742\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-743\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-744\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-90\">\\alpha_t</script> is a weighting factor for the class (usually set to address class imbalance), with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-91-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-745\" style=\"width: 3.232em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.659em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.66em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-746\"><span class=\"msubsup\" id=\"MathJax-Span-747\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-748\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-749\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-750\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-751\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-91\">\\alpha_t=\\alpha</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-92-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-752\" style=\"width: 1.669em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.3em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-753\"><span class=\"mi\" id=\"MathJax-Span-754\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-755\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-92\">y=</script> 1 and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-93-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-756\" style=\"width: 5.107em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.221em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.22em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-757\"><span class=\"msubsup\" id=\"MathJax-Span-758\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-759\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-760\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-761\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-762\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-763\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-764\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-93\">\\alpha_t=1-\\alpha</script> otherwise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-94-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-765\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-766\"><span class=\"mi\" id=\"MathJax-Span-767\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-94\">\\gamma</script> is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-95-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi><mo>=</mo><mn>0</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-768\" style=\"width: 2.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.242em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-769\"><span class=\"mi\" id=\"MathJax-Span-770\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-771\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-772\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi><mo>=</mo><mn>0</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-95\">\\gamma=0</script>, focal loss is equivalent to cross-entropy loss.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Multiclass Classification:</strong>\n        <ul>\n          <li>\n            <p>For a multiclass classification problem with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-96-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-773\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-774\"><span class=\"mi\" id=\"MathJax-Span-775\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-96\">C</script> classes, the focal loss can be extended as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-97-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-776\" style=\"width: 19.482em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 16.201em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.826em, 1016.04em, 3.44em, -999.997em); top: -2.914em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-777\"><span class=\"mi\" id=\"MathJax-Span-778\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-779\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-780\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-781\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-782\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-783\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-784\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-785\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-786\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-787\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"munderover\" id=\"MathJax-Span-788\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-789\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.58em, 4.169em, -999.997em); top: -4.477em; left: 0.94em;\"><span class=\"mi\" id=\"MathJax-Span-790\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1001.25em, 4.169em, -999.997em); top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-791\"><span class=\"mrow\" id=\"MathJax-Span-792\"><span class=\"mi\" id=\"MathJax-Span-793\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span class=\"mo\" id=\"MathJax-Span-794\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">=</span><span class=\"mn\" id=\"MathJax-Span-795\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-796\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-797\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-798\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-799\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px;\"><span style=\"position: absolute; clip: rect(2.971em, 1003.8em, 4.534em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-800\"><span class=\"mo\" id=\"MathJax-Span-801\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-802\"><span class=\"mn\" id=\"MathJax-Span-803\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-804\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-805\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-806\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-807\"><span class=\"mrow\" id=\"MathJax-Span-808\"><span class=\"mi\" id=\"MathJax-Span-809\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-810\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-811\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-812\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.581em; left: 3.909em;\"><span class=\"mi\" id=\"MathJax-Span-813\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-814\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-815\"></span><span class=\"mrow\" id=\"MathJax-Span-816\"><span class=\"mo\" id=\"MathJax-Span-817\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-818\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-819\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-820\"><span class=\"mrow\" id=\"MathJax-Span-821\"><span class=\"mi\" id=\"MathJax-Span-822\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-823\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-824\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-825\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.919em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.497em; border-left: 0px solid; width: 0px; height: 1.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>α</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-97\">F L\\left(p_t\\right)=-\\sum_{c=1}^C \\alpha_c\\left(1-p_{t, c}\\right)^\\gamma \\log \\left(p_{t, c}\\right)</script></p>\n          </li>\n          <li>\n            <p>Where:</p>\n            <ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-98-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-826\" style=\"width: 1.565em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.3em, 2.555em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-827\"><span class=\"msubsup\" id=\"MathJax-Span-828\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-829\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-830\"><span class=\"mrow\" id=\"MathJax-Span-831\"><span class=\"mi\" id=\"MathJax-Span-832\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-833\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-834\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-98\">p_{t, c}</script> is the predicted probability of the true class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-99-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-835\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-836\"><span class=\"mi\" id=\"MathJax-Span-837\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-99\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-100-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-838\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.94em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-839\"><span class=\"msubsup\" id=\"MathJax-Span-840\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-841\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-842\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>c</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-100\">\\alpha_c</script> is the weighting factor for class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-101-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-843\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-844\"><span class=\"mi\" id=\"MathJax-Span-845\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-101\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-102-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-846\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-847\"><span class=\"mi\" id=\"MathJax-Span-848\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-102\">\\gamma</script> is the focusing parameter, as in the binary case.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Intuition Behind Focal Loss:</strong>\n        <ul>\n          <li>Handling Class Imbalance: The factor <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-103-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-849\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-850\"><span class=\"msubsup\" id=\"MathJax-Span-851\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-852\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-853\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-103\">\\alpha_t</script> helps in handling class imbalance by giving more weight to the rare class.</li>\n          <li>Focusing on Hard Examples: The term <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-104-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-854\" style=\"width: 4.273em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1003.54em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-855\"><span class=\"msubsup\" id=\"MathJax-Span-856\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-857\"><span class=\"mo\" id=\"MathJax-Span-858\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-859\"><span class=\"mn\" id=\"MathJax-Span-860\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-861\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-862\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-863\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-864\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-865\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-866\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-104\">\\left(1-p_t\\right)^\\gamma</script> reduces the loss contribution from easy examples (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-105-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-867\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-868\"><span class=\"msubsup\" id=\"MathJax-Span-869\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-870\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-871\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-105\">p_t</script> is large) and increases the contribution from hard examples (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-106-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-872\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-873\"><span class=\"msubsup\" id=\"MathJax-Span-874\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-875\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-876\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-106\">p_t</script> is small). This focusing parameter <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-107-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-877\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-878\"><span class=\"mi\" id=\"MathJax-Span-879\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-107\">\\gamma</script> modulates the effect; the higher the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-108-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-880\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-881\"><span class=\"mi\" id=\"MathJax-Span-882\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-108\">\\gamma</script>, the more the model focuses on hard examples.</li>\n          <li>Reduction in Dominance of Easy Examples: In imbalanced datasets, the majority class comprises mostly easy examples that can dominate the loss and gradients. Focal loss ensures that the loss is mainly influenced by incorrectly classified examples.</li>\n        </ul>\n      </li>\n      <li>Focal loss has shown significant improvements in performance for tasks with highly imbalanced datasets, especially in scenarios like object detection, where the background class (negative examples) can significantly outnumber the object classes (positive examples).</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Binary Classification:</strong>\n        <ul>\n          <li>\n            <p>For a binary classification task, the focal loss is defined as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-82-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-667\" style=\"width: 14.378em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.982em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1011.93em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-668\"><span class=\"mi\" id=\"MathJax-Span-669\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-670\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-671\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-672\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-673\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-674\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-675\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-676\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-677\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-678\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-679\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-680\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-681\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-682\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-683\"><span class=\"mo\" id=\"MathJax-Span-684\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-685\"><span class=\"mn\" id=\"MathJax-Span-686\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-687\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-688\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-689\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-690\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-691\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-692\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-693\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-694\"></span><span class=\"mrow\" id=\"MathJax-Span-695\"><span class=\"mo\" id=\"MathJax-Span-696\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-697\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-698\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-699\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-700\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><msub><mi>α</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-82\">F L\\left(p_t\\right)=-\\alpha_t\\left(1-p_t\\right)^\\gamma \\log \\left(p_t\\right)</script></p>\n          </li>\n          <li>\n            <p>Where:</p>\n            <ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-83-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-701\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-702\"><span class=\"msubsup\" id=\"MathJax-Span-703\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-704\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-705\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-83\">p_t</script> is the model’s estimated probability for the class with label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-84-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-706\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-707\"><span class=\"mi\" id=\"MathJax-Span-708\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-709\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-710\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-84\">y=1</script>. Specifically, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-85-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-711\" style=\"width: 3.023em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.503em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.45em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-712\"><span class=\"msubsup\" id=\"MathJax-Span-713\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-714\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-715\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-716\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-717\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-85\">p_t=p</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-86-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-718\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-719\"><span class=\"mi\" id=\"MathJax-Span-720\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-721\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-722\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-86\">y=1</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-87-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-723\" style=\"width: 4.898em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.065em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.01em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-724\"><span class=\"msubsup\" id=\"MathJax-Span-725\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-726\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-727\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-728\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-729\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-730\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-731\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-87\">p_t=1-p</script> otherwise, with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-88-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-732\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-733\"><span class=\"mi\" id=\"MathJax-Span-734\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-88\">p</script> being the model’s estimated probability for the class label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-89-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-735\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-736\"><span class=\"mi\" id=\"MathJax-Span-737\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-738\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-739\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-89\">y=1</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-90-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-740\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-741\"><span class=\"msubsup\" id=\"MathJax-Span-742\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-743\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-744\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-90\">\\alpha_t</script> is a weighting factor for the class (usually set to address class imbalance), with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-91-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-745\" style=\"width: 3.232em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.659em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.66em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-746\"><span class=\"msubsup\" id=\"MathJax-Span-747\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-748\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-749\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-750\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-751\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-91\">\\alpha_t=\\alpha</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-92-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-752\" style=\"width: 1.669em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.3em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-753\"><span class=\"mi\" id=\"MathJax-Span-754\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-755\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-92\">y=</script> 1 and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-93-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-756\" style=\"width: 5.107em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.221em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.22em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-757\"><span class=\"msubsup\" id=\"MathJax-Span-758\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-759\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-760\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-761\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-762\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-763\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-764\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-93\">\\alpha_t=1-\\alpha</script> otherwise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-94-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-765\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-766\"><span class=\"mi\" id=\"MathJax-Span-767\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-94\">\\gamma</script> is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-95-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi><mo>=</mo><mn>0</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-768\" style=\"width: 2.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.242em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-769\"><span class=\"mi\" id=\"MathJax-Span-770\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-771\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-772\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi><mo>=</mo><mn>0</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-95\">\\gamma=0</script>, focal loss is equivalent to cross-entropy loss.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Multiclass Classification:</strong>\n        <ul>\n          <li>\n            <p>For a multiclass classification problem with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-96-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-773\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-774\"><span class=\"mi\" id=\"MathJax-Span-775\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-96\">C</script> classes, the focal loss can be extended as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-97-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-776\" style=\"width: 19.482em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 16.201em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.826em, 1016.04em, 3.44em, -999.997em); top: -2.914em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-777\"><span class=\"mi\" id=\"MathJax-Span-778\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-779\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-780\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-781\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-782\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-783\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-784\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-785\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-786\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-787\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"munderover\" id=\"MathJax-Span-788\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-789\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.58em, 4.169em, -999.997em); top: -4.477em; left: 0.94em;\"><span class=\"mi\" id=\"MathJax-Span-790\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1001.25em, 4.169em, -999.997em); top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-791\"><span class=\"mrow\" id=\"MathJax-Span-792\"><span class=\"mi\" id=\"MathJax-Span-793\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span class=\"mo\" id=\"MathJax-Span-794\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">=</span><span class=\"mn\" id=\"MathJax-Span-795\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-796\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-797\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-798\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-799\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px;\"><span style=\"position: absolute; clip: rect(2.971em, 1003.8em, 4.534em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-800\"><span class=\"mo\" id=\"MathJax-Span-801\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-802\"><span class=\"mn\" id=\"MathJax-Span-803\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-804\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-805\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-806\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-807\"><span class=\"mrow\" id=\"MathJax-Span-808\"><span class=\"mi\" id=\"MathJax-Span-809\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-810\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-811\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-812\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.581em; left: 3.909em;\"><span class=\"mi\" id=\"MathJax-Span-813\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-814\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-815\"></span><span class=\"mrow\" id=\"MathJax-Span-816\"><span class=\"mo\" id=\"MathJax-Span-817\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-818\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-819\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-820\"><span class=\"mrow\" id=\"MathJax-Span-821\"><span class=\"mi\" id=\"MathJax-Span-822\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-823\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-824\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-825\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.919em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.497em; border-left: 0px solid; width: 0px; height: 1.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>α</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-97\">F L\\left(p_t\\right)=-\\sum_{c=1}^C \\alpha_c\\left(1-p_{t, c}\\right)^\\gamma \\log \\left(p_{t, c}\\right)</script></p>\n          </li>\n          <li>\n            <p>Where:</p>\n            <ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-98-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-826\" style=\"width: 1.565em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.3em, 2.555em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-827\"><span class=\"msubsup\" id=\"MathJax-Span-828\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-829\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-830\"><span class=\"mrow\" id=\"MathJax-Span-831\"><span class=\"mi\" id=\"MathJax-Span-832\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-833\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-834\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-98\">p_{t, c}</script> is the predicted probability of the true class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-99-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-835\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-836\"><span class=\"mi\" id=\"MathJax-Span-837\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-99\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-100-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-838\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.94em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-839\"><span class=\"msubsup\" id=\"MathJax-Span-840\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-841\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-842\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>c</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-100\">\\alpha_c</script> is the weighting factor for class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-101-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-843\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-844\"><span class=\"mi\" id=\"MathJax-Span-845\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-101\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-102-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-846\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-847\"><span class=\"mi\" id=\"MathJax-Span-848\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-102\">\\gamma</script> is the focusing parameter, as in the binary case.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Intuition Behind Focal Loss:</strong>\n        <ul>\n          <li>Handling Class Imbalance: The factor <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-103-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-849\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-850\"><span class=\"msubsup\" id=\"MathJax-Span-851\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-852\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-853\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-103\">\\alpha_t</script> helps in handling class imbalance by giving more weight to the rare class.</li>\n          <li>Focusing on Hard Examples: The term <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-104-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-854\" style=\"width: 4.273em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1003.54em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-855\"><span class=\"msubsup\" id=\"MathJax-Span-856\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-857\"><span class=\"mo\" id=\"MathJax-Span-858\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-859\"><span class=\"mn\" id=\"MathJax-Span-860\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-861\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-862\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-863\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-864\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-865\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-866\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-104\">\\left(1-p_t\\right)^\\gamma</script> reduces the loss contribution from easy examples (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-105-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-867\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-868\"><span class=\"msubsup\" id=\"MathJax-Span-869\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-870\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-871\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-105\">p_t</script> is large) and increases the contribution from hard examples (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-106-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-872\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-873\"><span class=\"msubsup\" id=\"MathJax-Span-874\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-875\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-876\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-106\">p_t</script> is small). This focusing parameter <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-107-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-877\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-878\"><span class=\"mi\" id=\"MathJax-Span-879\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-107\">\\gamma</script> modulates the effect; the higher the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-108-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-880\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-881\"><span class=\"mi\" id=\"MathJax-Span-882\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-108\">\\gamma</script>, the more the model focuses on hard examples.</li>\n          <li>Reduction in Dominance of Easy Examples: In imbalanced datasets, the majority class comprises mostly easy examples that can dominate the loss and gradients. Focal loss ensures that the loss is mainly influenced by incorrectly classified examples.</li>\n        </ul>\n      </li>\n      <li>Focal loss has shown significant improvements in performance for tasks with highly imbalanced datasets, especially in scenarios like object detection, where the background class (negative examples) can significantly outnumber the object classes (positive examples).</li>\n    </ul>\n<ul>\n          <li>\n            <p>For a binary classification task, the focal loss is defined as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-82-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-667\" style=\"width: 14.378em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.982em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1011.93em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-668\"><span class=\"mi\" id=\"MathJax-Span-669\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-670\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-671\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-672\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-673\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-674\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-675\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-676\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-677\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-678\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-679\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-680\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-681\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-682\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-683\"><span class=\"mo\" id=\"MathJax-Span-684\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-685\"><span class=\"mn\" id=\"MathJax-Span-686\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-687\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-688\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-689\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-690\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-691\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-692\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-693\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-694\"></span><span class=\"mrow\" id=\"MathJax-Span-695\"><span class=\"mo\" id=\"MathJax-Span-696\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-697\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-698\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-699\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-700\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><msub><mi>α</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-82\">F L\\left(p_t\\right)=-\\alpha_t\\left(1-p_t\\right)^\\gamma \\log \\left(p_t\\right)</script></p>\n          </li>\n          <li>\n            <p>Where:</p>\n            <ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-83-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-701\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-702\"><span class=\"msubsup\" id=\"MathJax-Span-703\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-704\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-705\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-83\">p_t</script> is the model’s estimated probability for the class with label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-84-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-706\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-707\"><span class=\"mi\" id=\"MathJax-Span-708\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-709\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-710\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-84\">y=1</script>. Specifically, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-85-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-711\" style=\"width: 3.023em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.503em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.45em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-712\"><span class=\"msubsup\" id=\"MathJax-Span-713\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-714\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-715\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-716\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-717\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-85\">p_t=p</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-86-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-718\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-719\"><span class=\"mi\" id=\"MathJax-Span-720\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-721\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-722\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-86\">y=1</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-87-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-723\" style=\"width: 4.898em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.065em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.01em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-724\"><span class=\"msubsup\" id=\"MathJax-Span-725\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-726\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-727\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-728\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-729\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-730\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-731\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-87\">p_t=1-p</script> otherwise, with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-88-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-732\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-733\"><span class=\"mi\" id=\"MathJax-Span-734\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-88\">p</script> being the model’s estimated probability for the class label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-89-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-735\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-736\"><span class=\"mi\" id=\"MathJax-Span-737\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-738\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-739\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-89\">y=1</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-90-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-740\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-741\"><span class=\"msubsup\" id=\"MathJax-Span-742\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-743\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-744\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-90\">\\alpha_t</script> is a weighting factor for the class (usually set to address class imbalance), with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-91-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-745\" style=\"width: 3.232em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.659em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.66em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-746\"><span class=\"msubsup\" id=\"MathJax-Span-747\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-748\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-749\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-750\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-751\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-91\">\\alpha_t=\\alpha</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-92-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-752\" style=\"width: 1.669em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.3em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-753\"><span class=\"mi\" id=\"MathJax-Span-754\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-755\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-92\">y=</script> 1 and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-93-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-756\" style=\"width: 5.107em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.221em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.22em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-757\"><span class=\"msubsup\" id=\"MathJax-Span-758\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-759\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-760\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-761\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-762\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-763\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-764\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-93\">\\alpha_t=1-\\alpha</script> otherwise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-94-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-765\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-766\"><span class=\"mi\" id=\"MathJax-Span-767\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-94\">\\gamma</script> is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-95-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi><mo>=</mo><mn>0</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-768\" style=\"width: 2.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.242em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-769\"><span class=\"mi\" id=\"MathJax-Span-770\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-771\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-772\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi><mo>=</mo><mn>0</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-95\">\\gamma=0</script>, focal loss is equivalent to cross-entropy loss.</li>\n            </ul>\n          </li>\n        </ul>\n<p>For a binary classification task, the focal loss is defined as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-82-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-667\" style=\"width: 14.378em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.982em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1011.93em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-668\"><span class=\"mi\" id=\"MathJax-Span-669\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-670\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-671\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-672\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-673\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-674\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-675\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-676\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-677\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-678\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-679\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-680\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-681\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-682\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-683\"><span class=\"mo\" id=\"MathJax-Span-684\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-685\"><span class=\"mn\" id=\"MathJax-Span-686\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-687\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-688\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-689\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-690\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-691\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-692\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-693\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-694\"></span><span class=\"mrow\" id=\"MathJax-Span-695\"><span class=\"mo\" id=\"MathJax-Span-696\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-697\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-698\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-699\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-700\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><msub><mi>α</mi><mi>t</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-82\">F L\\left(p_t\\right)=-\\alpha_t\\left(1-p_t\\right)^\\gamma \\log \\left(p_t\\right)</script></p>\n<p>Where:</p>\n<ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-83-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-701\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-702\"><span class=\"msubsup\" id=\"MathJax-Span-703\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-704\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-705\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-83\">p_t</script> is the model’s estimated probability for the class with label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-84-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-706\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-707\"><span class=\"mi\" id=\"MathJax-Span-708\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-709\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-710\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-84\">y=1</script>. Specifically, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-85-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-711\" style=\"width: 3.023em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.503em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.45em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-712\"><span class=\"msubsup\" id=\"MathJax-Span-713\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-714\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-715\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-716\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-717\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-85\">p_t=p</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-86-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-718\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-719\"><span class=\"mi\" id=\"MathJax-Span-720\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-721\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-722\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-86\">y=1</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-87-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-723\" style=\"width: 4.898em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.065em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.01em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-724\"><span class=\"msubsup\" id=\"MathJax-Span-725\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-726\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-727\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-728\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-729\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-730\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-731\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-87\">p_t=1-p</script> otherwise, with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-88-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-732\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-733\"><span class=\"mi\" id=\"MathJax-Span-734\" style=\"font-family: STIXGeneral-Italic;\">p</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>p</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-88\">p</script> being the model’s estimated probability for the class label <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-89-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-735\" style=\"width: 2.659em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.09em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-736\"><span class=\"mi\" id=\"MathJax-Span-737\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-738\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-739\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-89\">y=1</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-90-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-740\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-741\"><span class=\"msubsup\" id=\"MathJax-Span-742\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-743\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-744\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-90\">\\alpha_t</script> is a weighting factor for the class (usually set to address class imbalance), with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-91-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-745\" style=\"width: 3.232em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.659em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1002.66em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-746\"><span class=\"msubsup\" id=\"MathJax-Span-747\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-748\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-749\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-750\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-751\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-91\">\\alpha_t=\\alpha</script> if <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-92-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-752\" style=\"width: 1.669em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1001.3em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-753\"><span class=\"mi\" id=\"MathJax-Span-754\" style=\"font-family: STIXGeneral-Italic;\">y</span><span class=\"mo\" id=\"MathJax-Span-755\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>y</mi><mo>=</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-92\">y=</script> 1 and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-93-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mi>&amp;#x03B1;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-756\" style=\"width: 5.107em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.221em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.22em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-757\"><span class=\"msubsup\" id=\"MathJax-Span-758\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-759\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-760\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-761\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-762\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">1</span><span class=\"mo\" id=\"MathJax-Span-763\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mi\" id=\"MathJax-Span-764\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">α</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><mi>α</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-93\">\\alpha_t=1-\\alpha</script> otherwise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-94-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-765\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-766\"><span class=\"mi\" id=\"MathJax-Span-767\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-94\">\\gamma</script> is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-95-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi><mo>=</mo><mn>0</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-768\" style=\"width: 2.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.242em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-769\"><span class=\"mi\" id=\"MathJax-Span-770\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-771\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-772\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi><mo>=</mo><mn>0</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-95\">\\gamma=0</script>, focal loss is equivalent to cross-entropy loss.</li>\n            </ul>\n<ul>\n          <li>\n            <p>For a multiclass classification problem with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-96-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-773\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-774\"><span class=\"mi\" id=\"MathJax-Span-775\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-96\">C</script> classes, the focal loss can be extended as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-97-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-776\" style=\"width: 19.482em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 16.201em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.826em, 1016.04em, 3.44em, -999.997em); top: -2.914em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-777\"><span class=\"mi\" id=\"MathJax-Span-778\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-779\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-780\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-781\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-782\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-783\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-784\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-785\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-786\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-787\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"munderover\" id=\"MathJax-Span-788\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-789\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.58em, 4.169em, -999.997em); top: -4.477em; left: 0.94em;\"><span class=\"mi\" id=\"MathJax-Span-790\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1001.25em, 4.169em, -999.997em); top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-791\"><span class=\"mrow\" id=\"MathJax-Span-792\"><span class=\"mi\" id=\"MathJax-Span-793\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span class=\"mo\" id=\"MathJax-Span-794\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">=</span><span class=\"mn\" id=\"MathJax-Span-795\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-796\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-797\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-798\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-799\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px;\"><span style=\"position: absolute; clip: rect(2.971em, 1003.8em, 4.534em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-800\"><span class=\"mo\" id=\"MathJax-Span-801\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-802\"><span class=\"mn\" id=\"MathJax-Span-803\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-804\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-805\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-806\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-807\"><span class=\"mrow\" id=\"MathJax-Span-808\"><span class=\"mi\" id=\"MathJax-Span-809\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-810\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-811\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-812\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.581em; left: 3.909em;\"><span class=\"mi\" id=\"MathJax-Span-813\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-814\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-815\"></span><span class=\"mrow\" id=\"MathJax-Span-816\"><span class=\"mo\" id=\"MathJax-Span-817\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-818\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-819\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-820\"><span class=\"mrow\" id=\"MathJax-Span-821\"><span class=\"mi\" id=\"MathJax-Span-822\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-823\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-824\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-825\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.919em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.497em; border-left: 0px solid; width: 0px; height: 1.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>α</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-97\">F L\\left(p_t\\right)=-\\sum_{c=1}^C \\alpha_c\\left(1-p_{t, c}\\right)^\\gamma \\log \\left(p_{t, c}\\right)</script></p>\n          </li>\n          <li>\n            <p>Where:</p>\n            <ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-98-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-826\" style=\"width: 1.565em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.3em, 2.555em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-827\"><span class=\"msubsup\" id=\"MathJax-Span-828\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-829\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-830\"><span class=\"mrow\" id=\"MathJax-Span-831\"><span class=\"mi\" id=\"MathJax-Span-832\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-833\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-834\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-98\">p_{t, c}</script> is the predicted probability of the true class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-99-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-835\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-836\"><span class=\"mi\" id=\"MathJax-Span-837\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-99\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-100-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-838\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.94em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-839\"><span class=\"msubsup\" id=\"MathJax-Span-840\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-841\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-842\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>c</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-100\">\\alpha_c</script> is the weighting factor for class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-101-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-843\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-844\"><span class=\"mi\" id=\"MathJax-Span-845\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-101\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-102-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-846\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-847\"><span class=\"mi\" id=\"MathJax-Span-848\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-102\">\\gamma</script> is the focusing parameter, as in the binary case.</li>\n            </ul>\n          </li>\n        </ul>\n<p>For a multiclass classification problem with <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-96-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-773\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-774\"><span class=\"mi\" id=\"MathJax-Span-775\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-96\">C</script> classes, the focal loss can be extended as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-97-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>&amp;#x2212;</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup><mi>log</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-776\" style=\"width: 19.482em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 16.201em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.826em, 1016.04em, 3.44em, -999.997em); top: -2.914em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-777\"><span class=\"mi\" id=\"MathJax-Span-778\" style=\"font-family: STIXGeneral-Italic;\">F<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-779\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mrow\" id=\"MathJax-Span-780\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-781\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-782\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-783\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-784\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-785\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-786\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-787\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"munderover\" id=\"MathJax-Span-788\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-789\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.58em, 4.169em, -999.997em); top: -4.477em; left: 0.94em;\"><span class=\"mi\" id=\"MathJax-Span-790\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1001.25em, 4.169em, -999.997em); top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-791\"><span class=\"mrow\" id=\"MathJax-Span-792\"><span class=\"mi\" id=\"MathJax-Span-793\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span class=\"mo\" id=\"MathJax-Span-794\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">=</span><span class=\"mn\" id=\"MathJax-Span-795\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-796\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-797\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-798\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-799\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px;\"><span style=\"position: absolute; clip: rect(2.971em, 1003.8em, 4.534em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-800\"><span class=\"mo\" id=\"MathJax-Span-801\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-802\"><span class=\"mn\" id=\"MathJax-Span-803\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-804\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-805\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-806\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-807\"><span class=\"mrow\" id=\"MathJax-Span-808\"><span class=\"mi\" id=\"MathJax-Span-809\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-810\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-811\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-812\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.581em; left: 3.909em;\"><span class=\"mi\" id=\"MathJax-Span-813\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-814\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-815\"></span><span class=\"mrow\" id=\"MathJax-Span-816\"><span class=\"mo\" id=\"MathJax-Span-817\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">(</span></span><span class=\"msubsup\" id=\"MathJax-Span-818\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-819\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-820\"><span class=\"mrow\" id=\"MathJax-Span-821\"><span class=\"mi\" id=\"MathJax-Span-822\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-823\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-824\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-825\" style=\"vertical-align: -0.206em;\"><span style=\"font-family: STIXSizeOneSym;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.919em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.497em; border-left: 0px solid; width: 0px; height: 1.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>F</mi><mi>L</mi><mrow><mo>(</mo><msub><mi>p</mi><mi>t</mi></msub><mo>)</mo></mrow><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>c</mi><mo>=</mo><mn>1</mn></mrow><mi>C</mi></munderover><msub><mi>α</mi><mi>c</mi></msub><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup><mi>log</mi><mo>⁡</mo><mrow><mo>(</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-97\">F L\\left(p_t\\right)=-\\sum_{c=1}^C \\alpha_c\\left(1-p_{t, c}\\right)^\\gamma \\log \\left(p_{t, c}\\right)</script></p>\n<p>Where:</p>\n<ul>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-98-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-826\" style=\"width: 1.565em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.3em, 2.555em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-827\"><span class=\"msubsup\" id=\"MathJax-Span-828\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-829\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-830\"><span class=\"mrow\" id=\"MathJax-Span-831\"><span class=\"mi\" id=\"MathJax-Span-832\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-833\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-834\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>,</mo><mi>c</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-98\">p_{t, c}</script> is the predicted probability of the true class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-99-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-835\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-836\"><span class=\"mi\" id=\"MathJax-Span-837\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-99\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-100-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>c</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-838\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.94em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-839\"><span class=\"msubsup\" id=\"MathJax-Span-840\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-841\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-842\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">c</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>c</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-100\">\\alpha_c</script> is the weighting factor for class <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-101-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-843\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-844\"><span class=\"mi\" id=\"MathJax-Span-845\" style=\"font-family: STIXGeneral-Italic;\">c</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>c</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-101\">c</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-102-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-846\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-847\"><span class=\"mi\" id=\"MathJax-Span-848\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-102\">\\gamma</script> is the focusing parameter, as in the binary case.</li>\n            </ul>\n<ul>\n          <li>Handling Class Imbalance: The factor <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-103-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B1;</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-849\" style=\"width: 1.044em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.84em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-850\"><span class=\"msubsup\" id=\"MathJax-Span-851\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-852\" style=\"font-family: STIXGeneral-Italic;\">α</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mi\" id=\"MathJax-Span-853\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>α</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-103\">\\alpha_t</script> helps in handling class imbalance by giving more weight to the rare class.</li>\n          <li>Focusing on Hard Examples: The term <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-104-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>&amp;#x2212;</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>&amp;#x03B3;</mi></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-854\" style=\"width: 4.273em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1003.54em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-855\"><span class=\"msubsup\" id=\"MathJax-Span-856\"><span style=\"display: inline-block; position: relative; width: 3.544em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1003.13em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-857\"><span class=\"mo\" id=\"MathJax-Span-858\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-859\"><span class=\"mn\" id=\"MathJax-Span-860\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-861\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-862\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-863\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-864\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-865\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.424em; left: 3.18em;\"><span class=\"mi\" id=\"MathJax-Span-866\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mrow><mo>(</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><mo>)</mo></mrow><mi>γ</mi></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-104\">\\left(1-p_t\\right)^\\gamma</script> reduces the loss contribution from easy examples (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-105-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-867\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-868\"><span class=\"msubsup\" id=\"MathJax-Span-869\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-870\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-871\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-105\">p_t</script> is large) and increases the contribution from hard examples (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-106-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-872\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-873\"><span class=\"msubsup\" id=\"MathJax-Span-874\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-875\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-876\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-106\">p_t</script> is small). This focusing parameter <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-107-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-877\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-878\"><span class=\"mi\" id=\"MathJax-Span-879\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-107\">\\gamma</script> modulates the effect; the higher the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-108-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-880\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.58em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-881\"><span class=\"mi\" id=\"MathJax-Span-882\" style=\"font-family: STIXGeneral-Italic;\">γ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>γ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-108\">\\gamma</script>, the more the model focuses on hard examples.</li>\n          <li>Reduction in Dominance of Easy Examples: In imbalanced datasets, the majority class comprises mostly easy examples that can dominate the loss and gradients. Focal loss ensures that the loss is mainly influenced by incorrectly classified examples.</li>\n        </ul>",
      "contentMarkdown": "*   Focal loss is a modified version of the standard cross-entropy loss used in classification tasks, particularly designed to address class imbalance by focusing more on hard-to-classify examples. It was introduced by Lin et al. in the context of object detection tasks, but it can be applied to any classification problem.\n*   The formula for focal loss is as follows:\n    *   **Binary Classification:**\n        *   For a binary classification task, the focal loss is defined as: FL(pt)\\=−αt(1−pt)γlog(pt)FL(pt)\\=−αt(1−pt)γlog⁡(pt)F L\\\\left(p\\_t\\\\right)=-\\\\alpha\\_t\\\\left(1-p\\_t\\\\right)^\\\\gamma \\\\log \\\\left(p\\_t\\\\right)\n            \n        *   Where:\n            \n            *   ptptp\\_t is the model’s estimated probability for the class with label y\\=1y\\=1y=1. Specifically, pt\\=ppt\\=pp\\_t=p if y\\=1y\\=1y=1 and pt\\=1−ppt\\=1−pp\\_t=1-p otherwise, with ppp being the model’s estimated probability for the class label y\\=1y\\=1y=1.\n            *   αtαt\\\\alpha\\_t is a weighting factor for the class (usually set to address class imbalance), with αt\\=ααt\\=α\\\\alpha\\_t=\\\\alpha if y\\=y\\=y= 1 and αt\\=1−ααt\\=1−α\\\\alpha\\_t=1-\\\\alpha otherwise.\n            *   γγ\\\\gamma is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When γ\\=0γ\\=0\\\\gamma=0, focal loss is equivalent to cross-entropy loss.\n    *   **Multiclass Classification:**\n        *   For a multiclass classification problem with CCC classes, the focal loss can be extended as: FL(pt)\\=−∑Cc\\=1αc(1−pt,c)γlog(pt,c)FL(pt)\\=−∑c\\=1Cαc(1−pt,c)γlog⁡(pt,c)F L\\\\left(p\\_t\\\\right)=-\\\\sum\\_{c=1}^C \\\\alpha\\_c\\\\left(1-p\\_{t, c}\\\\right)^\\\\gamma \\\\log \\\\left(p\\_{t, c}\\\\right)\n            \n        *   Where:\n            \n            *   pt,cpt,cp\\_{t, c} is the predicted probability of the true class ccc.\n            *   αcαc\\\\alpha\\_c is the weighting factor for class ccc.\n            *   γγ\\\\gamma is the focusing parameter, as in the binary case.\n    *   **Intuition Behind Focal Loss:**\n        *   Handling Class Imbalance: The factor αtαt\\\\alpha\\_t helps in handling class imbalance by giving more weight to the rare class.\n        *   Focusing on Hard Examples: The term (1−pt)γ(1−pt)γ\\\\left(1-p\\_t\\\\right)^\\\\gamma reduces the loss contribution from easy examples (where ptptp\\_t is large) and increases the contribution from hard examples (where ptptp\\_t is small). This focusing parameter γγ\\\\gamma modulates the effect; the higher the γγ\\\\gamma, the more the model focuses on hard examples.\n        *   Reduction in Dominance of Easy Examples: In imbalanced datasets, the majority class comprises mostly easy examples that can dominate the loss and gradients. Focal loss ensures that the loss is mainly influenced by incorrectly classified examples.\n    *   Focal loss has shown significant improvements in performance for tasks with highly imbalanced datasets, especially in scenarios like object detection, where the background class (negative examples) can significantly outnumber the object classes (positive examples).\n\n*   **Binary Classification:**\n    *   For a binary classification task, the focal loss is defined as: FL(pt)\\=−αt(1−pt)γlog(pt)FL(pt)\\=−αt(1−pt)γlog⁡(pt)F L\\\\left(p\\_t\\\\right)=-\\\\alpha\\_t\\\\left(1-p\\_t\\\\right)^\\\\gamma \\\\log \\\\left(p\\_t\\\\right)\n        \n    *   Where:\n        \n        *   ptptp\\_t is the model’s estimated probability for the class with label y\\=1y\\=1y=1. Specifically, pt\\=ppt\\=pp\\_t=p if y\\=1y\\=1y=1 and pt\\=1−ppt\\=1−pp\\_t=1-p otherwise, with ppp being the model’s estimated probability for the class label y\\=1y\\=1y=1.\n        *   αtαt\\\\alpha\\_t is a weighting factor for the class (usually set to address class imbalance), with αt\\=ααt\\=α\\\\alpha\\_t=\\\\alpha if y\\=y\\=y= 1 and αt\\=1−ααt\\=1−α\\\\alpha\\_t=1-\\\\alpha otherwise.\n        *   γγ\\\\gamma is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When γ\\=0γ\\=0\\\\gamma=0, focal loss is equivalent to cross-entropy loss.\n*   **Multiclass Classification:**\n    *   For a multiclass classification problem with CCC classes, the focal loss can be extended as: FL(pt)\\=−∑Cc\\=1αc(1−pt,c)γlog(pt,c)FL(pt)\\=−∑c\\=1Cαc(1−pt,c)γlog⁡(pt,c)F L\\\\left(p\\_t\\\\right)=-\\\\sum\\_{c=1}^C \\\\alpha\\_c\\\\left(1-p\\_{t, c}\\\\right)^\\\\gamma \\\\log \\\\left(p\\_{t, c}\\\\right)\n        \n    *   Where:\n        \n        *   pt,cpt,cp\\_{t, c} is the predicted probability of the true class ccc.\n        *   αcαc\\\\alpha\\_c is the weighting factor for class ccc.\n        *   γγ\\\\gamma is the focusing parameter, as in the binary case.\n*   **Intuition Behind Focal Loss:**\n    *   Handling Class Imbalance: The factor αtαt\\\\alpha\\_t helps in handling class imbalance by giving more weight to the rare class.\n    *   Focusing on Hard Examples: The term (1−pt)γ(1−pt)γ\\\\left(1-p\\_t\\\\right)^\\\\gamma reduces the loss contribution from easy examples (where ptptp\\_t is large) and increases the contribution from hard examples (where ptptp\\_t is small). This focusing parameter γγ\\\\gamma modulates the effect; the higher the γγ\\\\gamma, the more the model focuses on hard examples.\n    *   Reduction in Dominance of Easy Examples: In imbalanced datasets, the majority class comprises mostly easy examples that can dominate the loss and gradients. Focal loss ensures that the loss is mainly influenced by incorrectly classified examples.\n*   Focal loss has shown significant improvements in performance for tasks with highly imbalanced datasets, especially in scenarios like object detection, where the background class (negative examples) can significantly outnumber the object classes (positive examples).\n\n*   For a binary classification task, the focal loss is defined as: FL(pt)\\=−αt(1−pt)γlog(pt)FL(pt)\\=−αt(1−pt)γlog⁡(pt)F L\\\\left(p\\_t\\\\right)=-\\\\alpha\\_t\\\\left(1-p\\_t\\\\right)^\\\\gamma \\\\log \\\\left(p\\_t\\\\right)\n    \n*   Where:\n    \n    *   ptptp\\_t is the model’s estimated probability for the class with label y\\=1y\\=1y=1. Specifically, pt\\=ppt\\=pp\\_t=p if y\\=1y\\=1y=1 and pt\\=1−ppt\\=1−pp\\_t=1-p otherwise, with ppp being the model’s estimated probability for the class label y\\=1y\\=1y=1.\n    *   αtαt\\\\alpha\\_t is a weighting factor for the class (usually set to address class imbalance), with αt\\=ααt\\=α\\\\alpha\\_t=\\\\alpha if y\\=y\\=y= 1 and αt\\=1−ααt\\=1−α\\\\alpha\\_t=1-\\\\alpha otherwise.\n    *   γγ\\\\gamma is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When γ\\=0γ\\=0\\\\gamma=0, focal loss is equivalent to cross-entropy loss.\n\nFor a binary classification task, the focal loss is defined as: FL(pt)\\=−αt(1−pt)γlog(pt)FL(pt)\\=−αt(1−pt)γlog⁡(pt)F L\\\\left(p\\_t\\\\right)=-\\\\alpha\\_t\\\\left(1-p\\_t\\\\right)^\\\\gamma \\\\log \\\\left(p\\_t\\\\right)\n\nWhere:\n\n*   ptptp\\_t is the model’s estimated probability for the class with label y\\=1y\\=1y=1. Specifically, pt\\=ppt\\=pp\\_t=p if y\\=1y\\=1y=1 and pt\\=1−ppt\\=1−pp\\_t=1-p otherwise, with ppp being the model’s estimated probability for the class label y\\=1y\\=1y=1.\n*   αtαt\\\\alpha\\_t is a weighting factor for the class (usually set to address class imbalance), with αt\\=ααt\\=α\\\\alpha\\_t=\\\\alpha if y\\=y\\=y= 1 and αt\\=1−ααt\\=1−α\\\\alpha\\_t=1-\\\\alpha otherwise.\n*   γγ\\\\gamma is the focusing parameter that smoothly adjusts the rate at which easy examples are downweighted. When γ\\=0γ\\=0\\\\gamma=0, focal loss is equivalent to cross-entropy loss.\n\n*   For a multiclass classification problem with CCC classes, the focal loss can be extended as: FL(pt)\\=−∑Cc\\=1αc(1−pt,c)γlog(pt,c)FL(pt)\\=−∑c\\=1Cαc(1−pt,c)γlog⁡(pt,c)F L\\\\left(p\\_t\\\\right)=-\\\\sum\\_{c=1}^C \\\\alpha\\_c\\\\left(1-p\\_{t, c}\\\\right)^\\\\gamma \\\\log \\\\left(p\\_{t, c}\\\\right)\n    \n*   Where:\n    \n    *   pt,cpt,cp\\_{t, c} is the predicted probability of the true class ccc.\n    *   αcαc\\\\alpha\\_c is the weighting factor for class ccc.\n    *   γγ\\\\gamma is the focusing parameter, as in the binary case.\n\nFor a multiclass classification problem with CCC classes, the focal loss can be extended as: FL(pt)\\=−∑Cc\\=1αc(1−pt,c)γlog(pt,c)FL(pt)\\=−∑c\\=1Cαc(1−pt,c)γlog⁡(pt,c)F L\\\\left(p\\_t\\\\right)=-\\\\sum\\_{c=1}^C \\\\alpha\\_c\\\\left(1-p\\_{t, c}\\\\right)^\\\\gamma \\\\log \\\\left(p\\_{t, c}\\\\right)\n\nWhere:\n\n*   pt,cpt,cp\\_{t, c} is the predicted probability of the true class ccc.\n*   αcαc\\\\alpha\\_c is the weighting factor for class ccc.\n*   γγ\\\\gamma is the focusing parameter, as in the binary case.\n\n*   Handling Class Imbalance: The factor αtαt\\\\alpha\\_t helps in handling class imbalance by giving more weight to the rare class.\n*   Focusing on Hard Examples: The term (1−pt)γ(1−pt)γ\\\\left(1-p\\_t\\\\right)^\\\\gamma reduces the loss contribution from easy examples (where ptptp\\_t is large) and increases the contribution from hard examples (where ptptp\\_t is small). This focusing parameter γγ\\\\gamma modulates the effect; the higher the γγ\\\\gamma, the more the model focuses on hard examples.\n*   Reduction in Dominance of Easy Examples: In imbalanced datasets, the majority class comprises mostly easy examples that can dominate the loss and gradients. Focal loss ensures that the loss is mainly influenced by incorrectly classified examples.",
      "order": 76,
      "orderInChapter": 76,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 1090,
        "contentLength": 241952
      },
      "nextCards": [
        "ai-interview-how-do-you-define-uncertainty-with-regression-prob-77",
        "ai-interview-how-do-we-fix-distribution-shift-in-machine-learni-78"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-focal-loss?-how-does-it-help-mitigate-class-imbalance?",
      "scrapedAt": "2025-12-28T11:58:12.838Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-define-uncertainty-with-regression-prob-77",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Define Uncertainty with Regression Problems?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Uncertainty in regression problems refers to the degree of confidence associated with the model’s predictions. It provides a measure of the model’s “sureness” about its predicted outputs. In the context of regression, uncertainty quantification can be critical for many applications, such as medical or financial predictions, where understanding the reliability of predictions can have significant consequences.</li>\n  <li>There are two main types of uncertainties:\n    <ul>\n      <li><strong>Aleatoric Uncertainty (Data Uncertainty):</strong>\n        <ul>\n          <li>This is inherent variability in the data and cannot be reduced, no matter how much more data you collect.</li>\n          <li>It arises due to noise in the observations or inherent variability in the processes being modeled.</li>\n          <li>For regression, this can be modeled by predicting a distribution (e.g., Gaussian) for each data point, with the model outputting not just the mean of this distribution but also its variance.\n      2. <strong>Epistemic Uncertainty (Model Uncertainty):</strong></li>\n          <li>This uncertainty stems from the model itself. It represents what the model doesn’t know due to lack of data.</li>\n          <li>With more data, especially in the underrepresented regions, epistemic uncertainty can be reduced.</li>\n          <li>This uncertainty is often captured using techniques like Bayesian neural networks or dropout as a Bayesian approximation.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>To quantify and incorporate uncertainty in regression problems, here are some approaches:\n    <ul>\n      <li><strong>Prediction Intervals:</strong> Generate prediction intervals around the predicted value, which provide a range within which the actual value is likely to fall. Wider intervals indicate greater uncertainty.</li>\n      <li><strong>Bayesian Linear Regression:</strong> Instead of estimating fixed values for regression coefficients as in standard linear regression, Bayesian linear regression estimates a distribution over possible coefficient values. In other words, Bayesian regression models provide a distribution over the possible values of the regression coefficients, thereby offering a measure of uncertainty.</li>\n      <li><strong>Bayesian Neural Networks:</strong> Similar to Bayesian Linear Regression, but applied to neural network weights.\n        <ul>\n          <li><strong>Principle:</strong> BNNs model uncertainty by placing a probability distribution over the network’s weights (as opposed to fixed weights in standard neural networks).</li>\n          <li><strong>Application:</strong> By sampling from these distributions, you can obtain a distribution of predictions for a given input, which reflects the model’s uncertainty.</li>\n          <li><strong>Challenge:</strong> BNNs can be computationally expensive and complex to implement.</li>\n        </ul>\n      </li>\n      <li><strong>Monte Carlo (MC) Dropout as a Bayesian Approximation:</strong> Using dropout in a neural network not just during training but also during inference can act as an approximation to Bayesian neural networks. Running the model with dropout multiple times for a single input provides a distribution of outputs, capturing the model’s uncertainty.\n        <ul>\n          <li><strong>Principle:</strong> Use dropout not just during training but also during inference. By running multiple forward passes with dropout, you obtain a distribution of predictions.</li>\n          <li><strong>Application:</strong> The variance in these predictions can be interpreted as a measure of model uncertainty.</li>\n          <li><strong>Advantage:</strong> Easier to implement than BNNs, as it can be applied to any standard neural network with dropout layers.</li>\n        </ul>\n      </li>\n      <li><strong>Confidence Calibration:</strong>\n        <ul>\n          <li><strong>Principle:</strong> If the model’s confidence scores are not well-calibrated, apply post-hoc calibration methods.</li>\n          <li><strong>Techniques:</strong> Methods like Platt scaling, isotonic regression, or temperature scaling can adjust the confidence scores to better reflect true probabilities.</li>\n        </ul>\n      </li>\n      <li><strong>Test-Time Augmentation:</strong>\n        <ul>\n          <li>Principle: Apply various augmentations to the input data at test time.</li>\n          <li>Application: Variability in predictions across augmentations can indicate uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Quantile Regression:</strong> Instead of predicting a single value, the model is trained to predict quantiles (e.g., 10th percentile, 50th percentile, and 90th percentile). This provides a range of predictions, capturing inherent data uncertainty. In other words, predict different quantiles of the conditional distribution of the response variable, giving an idea of the spread of the possible outcomes.\n        <ul>\n          <li><strong>Principle:</strong> Instead of predicting a single value, predict a range (quantiles) for the output.</li>\n          <li><strong>Application:</strong> The range between lower and upper quantiles (e.g., 5th and 95th) can represent the prediction uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Gaussian Processes:</strong> Gaussian Processes (GPs) are a non-parametric method that provides a probabilistic measure of uncertainty with the predictions. The output of a GP is a distribution over functions, from which you can derive mean predictions and variances.\n        <ul>\n          <li><strong>Principle:</strong> GPs are a Bayesian approach suitable for small to medium-sized datasets.</li>\n          <li><strong>Application:</strong> They naturally provide a measure of uncertainty (variance) along with predictions.</li>\n        </ul>\n      </li>\n      <li><strong>Ensemble Methods:</strong> Using an ensemble of models (e.g., bagging or bootstrapped ensembles) can provide multiple predictions for each input. The variance or spread of these predictions can be used as a measure of uncertainty. Pu simply, use an ensemble of models and measure the variance in their predictions. A higher variance indicates higher uncertainty.\n        <ul>\n          <li><strong>Principle:</strong> Train multiple models independently and use the variance in their predictions to estimate uncertainty.</li>\n          <li><strong>Application:</strong> A higher variance in predictions indicates greater uncertainty.</li>\n          <li><strong>Types:</strong> Bagging, boosting, or stacking different models or the same model with different initializations.</li>\n        </ul>\n      </li>\n      <li><strong>Likelihood Methods:</strong>\n        <ul>\n          <li><strong>Principle:</strong> Model the output distribution of your predictions (e.g., a Gaussian distribution with mean and variance).</li>\n          <li><strong>Application:</strong> The variance can be used as a measure of uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Adversarial Training:</strong>\n        <ul>\n          <li><strong>Principle:</strong> Train the model with adversarial examples.</li>\n          <li><strong>Application:</strong> This can make the model more robust and its uncertainty estimates more reliable.</li>\n        </ul>\n      </li>\n      <li><strong>Out-of-Distribution (OOD) Detection</strong>\n        <ul>\n          <li><strong>Principle:</strong> Train the model to recognize when inputs are significantly different from the training data.</li>\n          <li><strong>Application:</strong> OOD inputs often result in higher uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Residual Analysis:</strong> Analyze the residuals of the model (the differences between the predicted and actual values). Patterns or high variability in residuals can indicate areas where the model is less certain.</li>\n      <li><strong>Homoscedastic &amp; Heteroscedastic Uncertainty:</strong> Homoscedastic refers to models where the aleatoric uncertainty is assumed to be constant across all inputs. Heteroscedastic models allow this uncertainty to vary with input data. For regression problems, modeling heteroscedastic uncertainty can be crucial, especially when the noise or variability in the data is input-dependent.</li>\n    </ul>\n  </li>\n  <li>Addressing Miscalibration:\n    <ul>\n      <li><strong>Model Calibration Techniques:</strong> Implement calibration methods to ensure that the predicted uncertainties align with the actual errors. For example, in probabilistic models, ensuring that the predicted probability distribution matches the observed distribution of the target variable. For miscalibrated models, post-hoc calibration techniques (like Platt scaling or isotonic regression) can be used to adjust the predicted values to better reflect the true likelihoods.\n        <ol>\n          <li><strong>Improving Model Fit:</strong> If the model is miscalibrated, it might be necessary to revisit model selection, feature engineering, or even the data itself to improve the fit.</li>\n        </ol>\n      </li>\n    </ul>\n  </li>\n  <li>Choosing the Right Method:\n    <ul>\n      <li>The choice of method depends on various factors like the size of the dataset, the model complexity, the type of task (regression/classification), and computational resources. In practice, a combination of these methods might be employed to gain a more comprehensive understanding of the model’s uncertainty.</li>\n    </ul>\n  </li>\n  <li>Understanding and quantifying uncertainty in regression is crucial for making informed decisions based on model predictions, particularly in fields like finance, healthcare, and engineering, where decisions based on model predictions can have significant consequences.</li>\n</ul>\n<ul>\n      <li><strong>Aleatoric Uncertainty (Data Uncertainty):</strong>\n        <ul>\n          <li>This is inherent variability in the data and cannot be reduced, no matter how much more data you collect.</li>\n          <li>It arises due to noise in the observations or inherent variability in the processes being modeled.</li>\n          <li>For regression, this can be modeled by predicting a distribution (e.g., Gaussian) for each data point, with the model outputting not just the mean of this distribution but also its variance.\n      2. <strong>Epistemic Uncertainty (Model Uncertainty):</strong></li>\n          <li>This uncertainty stems from the model itself. It represents what the model doesn’t know due to lack of data.</li>\n          <li>With more data, especially in the underrepresented regions, epistemic uncertainty can be reduced.</li>\n          <li>This uncertainty is often captured using techniques like Bayesian neural networks or dropout as a Bayesian approximation.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>This is inherent variability in the data and cannot be reduced, no matter how much more data you collect.</li>\n          <li>It arises due to noise in the observations or inherent variability in the processes being modeled.</li>\n          <li>For regression, this can be modeled by predicting a distribution (e.g., Gaussian) for each data point, with the model outputting not just the mean of this distribution but also its variance.\n      2. <strong>Epistemic Uncertainty (Model Uncertainty):</strong></li>\n          <li>This uncertainty stems from the model itself. It represents what the model doesn’t know due to lack of data.</li>\n          <li>With more data, especially in the underrepresented regions, epistemic uncertainty can be reduced.</li>\n          <li>This uncertainty is often captured using techniques like Bayesian neural networks or dropout as a Bayesian approximation.</li>\n        </ul>\n<ul>\n      <li><strong>Prediction Intervals:</strong> Generate prediction intervals around the predicted value, which provide a range within which the actual value is likely to fall. Wider intervals indicate greater uncertainty.</li>\n      <li><strong>Bayesian Linear Regression:</strong> Instead of estimating fixed values for regression coefficients as in standard linear regression, Bayesian linear regression estimates a distribution over possible coefficient values. In other words, Bayesian regression models provide a distribution over the possible values of the regression coefficients, thereby offering a measure of uncertainty.</li>\n      <li><strong>Bayesian Neural Networks:</strong> Similar to Bayesian Linear Regression, but applied to neural network weights.\n        <ul>\n          <li><strong>Principle:</strong> BNNs model uncertainty by placing a probability distribution over the network’s weights (as opposed to fixed weights in standard neural networks).</li>\n          <li><strong>Application:</strong> By sampling from these distributions, you can obtain a distribution of predictions for a given input, which reflects the model’s uncertainty.</li>\n          <li><strong>Challenge:</strong> BNNs can be computationally expensive and complex to implement.</li>\n        </ul>\n      </li>\n      <li><strong>Monte Carlo (MC) Dropout as a Bayesian Approximation:</strong> Using dropout in a neural network not just during training but also during inference can act as an approximation to Bayesian neural networks. Running the model with dropout multiple times for a single input provides a distribution of outputs, capturing the model’s uncertainty.\n        <ul>\n          <li><strong>Principle:</strong> Use dropout not just during training but also during inference. By running multiple forward passes with dropout, you obtain a distribution of predictions.</li>\n          <li><strong>Application:</strong> The variance in these predictions can be interpreted as a measure of model uncertainty.</li>\n          <li><strong>Advantage:</strong> Easier to implement than BNNs, as it can be applied to any standard neural network with dropout layers.</li>\n        </ul>\n      </li>\n      <li><strong>Confidence Calibration:</strong>\n        <ul>\n          <li><strong>Principle:</strong> If the model’s confidence scores are not well-calibrated, apply post-hoc calibration methods.</li>\n          <li><strong>Techniques:</strong> Methods like Platt scaling, isotonic regression, or temperature scaling can adjust the confidence scores to better reflect true probabilities.</li>\n        </ul>\n      </li>\n      <li><strong>Test-Time Augmentation:</strong>\n        <ul>\n          <li>Principle: Apply various augmentations to the input data at test time.</li>\n          <li>Application: Variability in predictions across augmentations can indicate uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Quantile Regression:</strong> Instead of predicting a single value, the model is trained to predict quantiles (e.g., 10th percentile, 50th percentile, and 90th percentile). This provides a range of predictions, capturing inherent data uncertainty. In other words, predict different quantiles of the conditional distribution of the response variable, giving an idea of the spread of the possible outcomes.\n        <ul>\n          <li><strong>Principle:</strong> Instead of predicting a single value, predict a range (quantiles) for the output.</li>\n          <li><strong>Application:</strong> The range between lower and upper quantiles (e.g., 5th and 95th) can represent the prediction uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Gaussian Processes:</strong> Gaussian Processes (GPs) are a non-parametric method that provides a probabilistic measure of uncertainty with the predictions. The output of a GP is a distribution over functions, from which you can derive mean predictions and variances.\n        <ul>\n          <li><strong>Principle:</strong> GPs are a Bayesian approach suitable for small to medium-sized datasets.</li>\n          <li><strong>Application:</strong> They naturally provide a measure of uncertainty (variance) along with predictions.</li>\n        </ul>\n      </li>\n      <li><strong>Ensemble Methods:</strong> Using an ensemble of models (e.g., bagging or bootstrapped ensembles) can provide multiple predictions for each input. The variance or spread of these predictions can be used as a measure of uncertainty. Pu simply, use an ensemble of models and measure the variance in their predictions. A higher variance indicates higher uncertainty.\n        <ul>\n          <li><strong>Principle:</strong> Train multiple models independently and use the variance in their predictions to estimate uncertainty.</li>\n          <li><strong>Application:</strong> A higher variance in predictions indicates greater uncertainty.</li>\n          <li><strong>Types:</strong> Bagging, boosting, or stacking different models or the same model with different initializations.</li>\n        </ul>\n      </li>\n      <li><strong>Likelihood Methods:</strong>\n        <ul>\n          <li><strong>Principle:</strong> Model the output distribution of your predictions (e.g., a Gaussian distribution with mean and variance).</li>\n          <li><strong>Application:</strong> The variance can be used as a measure of uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Adversarial Training:</strong>\n        <ul>\n          <li><strong>Principle:</strong> Train the model with adversarial examples.</li>\n          <li><strong>Application:</strong> This can make the model more robust and its uncertainty estimates more reliable.</li>\n        </ul>\n      </li>\n      <li><strong>Out-of-Distribution (OOD) Detection</strong>\n        <ul>\n          <li><strong>Principle:</strong> Train the model to recognize when inputs are significantly different from the training data.</li>\n          <li><strong>Application:</strong> OOD inputs often result in higher uncertainty.</li>\n        </ul>\n      </li>\n      <li><strong>Residual Analysis:</strong> Analyze the residuals of the model (the differences between the predicted and actual values). Patterns or high variability in residuals can indicate areas where the model is less certain.</li>\n      <li><strong>Homoscedastic &amp; Heteroscedastic Uncertainty:</strong> Homoscedastic refers to models where the aleatoric uncertainty is assumed to be constant across all inputs. Heteroscedastic models allow this uncertainty to vary with input data. For regression problems, modeling heteroscedastic uncertainty can be crucial, especially when the noise or variability in the data is input-dependent.</li>\n    </ul>\n<ul>\n          <li><strong>Principle:</strong> BNNs model uncertainty by placing a probability distribution over the network’s weights (as opposed to fixed weights in standard neural networks).</li>\n          <li><strong>Application:</strong> By sampling from these distributions, you can obtain a distribution of predictions for a given input, which reflects the model’s uncertainty.</li>\n          <li><strong>Challenge:</strong> BNNs can be computationally expensive and complex to implement.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> Use dropout not just during training but also during inference. By running multiple forward passes with dropout, you obtain a distribution of predictions.</li>\n          <li><strong>Application:</strong> The variance in these predictions can be interpreted as a measure of model uncertainty.</li>\n          <li><strong>Advantage:</strong> Easier to implement than BNNs, as it can be applied to any standard neural network with dropout layers.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> If the model’s confidence scores are not well-calibrated, apply post-hoc calibration methods.</li>\n          <li><strong>Techniques:</strong> Methods like Platt scaling, isotonic regression, or temperature scaling can adjust the confidence scores to better reflect true probabilities.</li>\n        </ul>\n<ul>\n          <li>Principle: Apply various augmentations to the input data at test time.</li>\n          <li>Application: Variability in predictions across augmentations can indicate uncertainty.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> Instead of predicting a single value, predict a range (quantiles) for the output.</li>\n          <li><strong>Application:</strong> The range between lower and upper quantiles (e.g., 5th and 95th) can represent the prediction uncertainty.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> GPs are a Bayesian approach suitable for small to medium-sized datasets.</li>\n          <li><strong>Application:</strong> They naturally provide a measure of uncertainty (variance) along with predictions.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> Train multiple models independently and use the variance in their predictions to estimate uncertainty.</li>\n          <li><strong>Application:</strong> A higher variance in predictions indicates greater uncertainty.</li>\n          <li><strong>Types:</strong> Bagging, boosting, or stacking different models or the same model with different initializations.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> Model the output distribution of your predictions (e.g., a Gaussian distribution with mean and variance).</li>\n          <li><strong>Application:</strong> The variance can be used as a measure of uncertainty.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> Train the model with adversarial examples.</li>\n          <li><strong>Application:</strong> This can make the model more robust and its uncertainty estimates more reliable.</li>\n        </ul>\n<ul>\n          <li><strong>Principle:</strong> Train the model to recognize when inputs are significantly different from the training data.</li>\n          <li><strong>Application:</strong> OOD inputs often result in higher uncertainty.</li>\n        </ul>\n<ul>\n      <li><strong>Model Calibration Techniques:</strong> Implement calibration methods to ensure that the predicted uncertainties align with the actual errors. For example, in probabilistic models, ensuring that the predicted probability distribution matches the observed distribution of the target variable. For miscalibrated models, post-hoc calibration techniques (like Platt scaling or isotonic regression) can be used to adjust the predicted values to better reflect the true likelihoods.\n        <ol>\n          <li><strong>Improving Model Fit:</strong> If the model is miscalibrated, it might be necessary to revisit model selection, feature engineering, or even the data itself to improve the fit.</li>\n        </ol>\n      </li>\n    </ul>\n<ol>\n          <li><strong>Improving Model Fit:</strong> If the model is miscalibrated, it might be necessary to revisit model selection, feature engineering, or even the data itself to improve the fit.</li>\n        </ol>\n<ul>\n      <li>The choice of method depends on various factors like the size of the dataset, the model complexity, the type of task (regression/classification), and computational resources. In practice, a combination of these methods might be employed to gain a more comprehensive understanding of the model’s uncertainty.</li>\n    </ul>",
      "contentMarkdown": "*   Uncertainty in regression problems refers to the degree of confidence associated with the model’s predictions. It provides a measure of the model’s “sureness” about its predicted outputs. In the context of regression, uncertainty quantification can be critical for many applications, such as medical or financial predictions, where understanding the reliability of predictions can have significant consequences.\n*   There are two main types of uncertainties:\n    *   **Aleatoric Uncertainty (Data Uncertainty):**\n        *   This is inherent variability in the data and cannot be reduced, no matter how much more data you collect.\n        *   It arises due to noise in the observations or inherent variability in the processes being modeled.\n        *   For regression, this can be modeled by predicting a distribution (e.g., Gaussian) for each data point, with the model outputting not just the mean of this distribution but also its variance. 2. **Epistemic Uncertainty (Model Uncertainty):**\n        *   This uncertainty stems from the model itself. It represents what the model doesn’t know due to lack of data.\n        *   With more data, especially in the underrepresented regions, epistemic uncertainty can be reduced.\n        *   This uncertainty is often captured using techniques like Bayesian neural networks or dropout as a Bayesian approximation.\n*   To quantify and incorporate uncertainty in regression problems, here are some approaches:\n    *   **Prediction Intervals:** Generate prediction intervals around the predicted value, which provide a range within which the actual value is likely to fall. Wider intervals indicate greater uncertainty.\n    *   **Bayesian Linear Regression:** Instead of estimating fixed values for regression coefficients as in standard linear regression, Bayesian linear regression estimates a distribution over possible coefficient values. In other words, Bayesian regression models provide a distribution over the possible values of the regression coefficients, thereby offering a measure of uncertainty.\n    *   **Bayesian Neural Networks:** Similar to Bayesian Linear Regression, but applied to neural network weights.\n        *   **Principle:** BNNs model uncertainty by placing a probability distribution over the network’s weights (as opposed to fixed weights in standard neural networks).\n        *   **Application:** By sampling from these distributions, you can obtain a distribution of predictions for a given input, which reflects the model’s uncertainty.\n        *   **Challenge:** BNNs can be computationally expensive and complex to implement.\n    *   **Monte Carlo (MC) Dropout as a Bayesian Approximation:** Using dropout in a neural network not just during training but also during inference can act as an approximation to Bayesian neural networks. Running the model with dropout multiple times for a single input provides a distribution of outputs, capturing the model’s uncertainty.\n        *   **Principle:** Use dropout not just during training but also during inference. By running multiple forward passes with dropout, you obtain a distribution of predictions.\n        *   **Application:** The variance in these predictions can be interpreted as a measure of model uncertainty.\n        *   **Advantage:** Easier to implement than BNNs, as it can be applied to any standard neural network with dropout layers.\n    *   **Confidence Calibration:**\n        *   **Principle:** If the model’s confidence scores are not well-calibrated, apply post-hoc calibration methods.\n        *   **Techniques:** Methods like Platt scaling, isotonic regression, or temperature scaling can adjust the confidence scores to better reflect true probabilities.\n    *   **Test-Time Augmentation:**\n        *   Principle: Apply various augmentations to the input data at test time.\n        *   Application: Variability in predictions across augmentations can indicate uncertainty.\n    *   **Quantile Regression:** Instead of predicting a single value, the model is trained to predict quantiles (e.g., 10th percentile, 50th percentile, and 90th percentile). This provides a range of predictions, capturing inherent data uncertainty. In other words, predict different quantiles of the conditional distribution of the response variable, giving an idea of the spread of the possible outcomes.\n        *   **Principle:** Instead of predicting a single value, predict a range (quantiles) for the output.\n        *   **Application:** The range between lower and upper quantiles (e.g., 5th and 95th) can represent the prediction uncertainty.\n    *   **Gaussian Processes:** Gaussian Processes (GPs) are a non-parametric method that provides a probabilistic measure of uncertainty with the predictions. The output of a GP is a distribution over functions, from which you can derive mean predictions and variances.\n        *   **Principle:** GPs are a Bayesian approach suitable for small to medium-sized datasets.\n        *   **Application:** They naturally provide a measure of uncertainty (variance) along with predictions.\n    *   **Ensemble Methods:** Using an ensemble of models (e.g., bagging or bootstrapped ensembles) can provide multiple predictions for each input. The variance or spread of these predictions can be used as a measure of uncertainty. Pu simply, use an ensemble of models and measure the variance in their predictions. A higher variance indicates higher uncertainty.\n        *   **Principle:** Train multiple models independently and use the variance in their predictions to estimate uncertainty.\n        *   **Application:** A higher variance in predictions indicates greater uncertainty.\n        *   **Types:** Bagging, boosting, or stacking different models or the same model with different initializations.\n    *   **Likelihood Methods:**\n        *   **Principle:** Model the output distribution of your predictions (e.g., a Gaussian distribution with mean and variance).\n        *   **Application:** The variance can be used as a measure of uncertainty.\n    *   **Adversarial Training:**\n        *   **Principle:** Train the model with adversarial examples.\n        *   **Application:** This can make the model more robust and its uncertainty estimates more reliable.\n    *   **Out-of-Distribution (OOD) Detection**\n        *   **Principle:** Train the model to recognize when inputs are significantly different from the training data.\n        *   **Application:** OOD inputs often result in higher uncertainty.\n    *   **Residual Analysis:** Analyze the residuals of the model (the differences between the predicted and actual values). Patterns or high variability in residuals can indicate areas where the model is less certain.\n    *   **Homoscedastic & Heteroscedastic Uncertainty:** Homoscedastic refers to models where the aleatoric uncertainty is assumed to be constant across all inputs. Heteroscedastic models allow this uncertainty to vary with input data. For regression problems, modeling heteroscedastic uncertainty can be crucial, especially when the noise or variability in the data is input-dependent.\n*   Addressing Miscalibration:\n    *   **Model Calibration Techniques:** Implement calibration methods to ensure that the predicted uncertainties align with the actual errors. For example, in probabilistic models, ensuring that the predicted probability distribution matches the observed distribution of the target variable. For miscalibrated models, post-hoc calibration techniques (like Platt scaling or isotonic regression) can be used to adjust the predicted values to better reflect the true likelihoods.\n        1.  **Improving Model Fit:** If the model is miscalibrated, it might be necessary to revisit model selection, feature engineering, or even the data itself to improve the fit.\n*   Choosing the Right Method:\n    *   The choice of method depends on various factors like the size of the dataset, the model complexity, the type of task (regression/classification), and computational resources. In practice, a combination of these methods might be employed to gain a more comprehensive understanding of the model’s uncertainty.\n*   Understanding and quantifying uncertainty in regression is crucial for making informed decisions based on model predictions, particularly in fields like finance, healthcare, and engineering, where decisions based on model predictions can have significant consequences.\n\n*   **Aleatoric Uncertainty (Data Uncertainty):**\n    *   This is inherent variability in the data and cannot be reduced, no matter how much more data you collect.\n    *   It arises due to noise in the observations or inherent variability in the processes being modeled.\n    *   For regression, this can be modeled by predicting a distribution (e.g., Gaussian) for each data point, with the model outputting not just the mean of this distribution but also its variance. 2. **Epistemic Uncertainty (Model Uncertainty):**\n    *   This uncertainty stems from the model itself. It represents what the model doesn’t know due to lack of data.\n    *   With more data, especially in the underrepresented regions, epistemic uncertainty can be reduced.\n    *   This uncertainty is often captured using techniques like Bayesian neural networks or dropout as a Bayesian approximation.\n\n*   This is inherent variability in the data and cannot be reduced, no matter how much more data you collect.\n*   It arises due to noise in the observations or inherent variability in the processes being modeled.\n*   For regression, this can be modeled by predicting a distribution (e.g., Gaussian) for each data point, with the model outputting not just the mean of this distribution but also its variance. 2. **Epistemic Uncertainty (Model Uncertainty):**\n*   This uncertainty stems from the model itself. It represents what the model doesn’t know due to lack of data.\n*   With more data, especially in the underrepresented regions, epistemic uncertainty can be reduced.\n*   This uncertainty is often captured using techniques like Bayesian neural networks or dropout as a Bayesian approximation.\n\n*   **Prediction Intervals:** Generate prediction intervals around the predicted value, which provide a range within which the actual value is likely to fall. Wider intervals indicate greater uncertainty.\n*   **Bayesian Linear Regression:** Instead of estimating fixed values for regression coefficients as in standard linear regression, Bayesian linear regression estimates a distribution over possible coefficient values. In other words, Bayesian regression models provide a distribution over the possible values of the regression coefficients, thereby offering a measure of uncertainty.\n*   **Bayesian Neural Networks:** Similar to Bayesian Linear Regression, but applied to neural network weights.\n    *   **Principle:** BNNs model uncertainty by placing a probability distribution over the network’s weights (as opposed to fixed weights in standard neural networks).\n    *   **Application:** By sampling from these distributions, you can obtain a distribution of predictions for a given input, which reflects the model’s uncertainty.\n    *   **Challenge:** BNNs can be computationally expensive and complex to implement.\n*   **Monte Carlo (MC) Dropout as a Bayesian Approximation:** Using dropout in a neural network not just during training but also during inference can act as an approximation to Bayesian neural networks. Running the model with dropout multiple times for a single input provides a distribution of outputs, capturing the model’s uncertainty.\n    *   **Principle:** Use dropout not just during training but also during inference. By running multiple forward passes with dropout, you obtain a distribution of predictions.\n    *   **Application:** The variance in these predictions can be interpreted as a measure of model uncertainty.\n    *   **Advantage:** Easier to implement than BNNs, as it can be applied to any standard neural network with dropout layers.\n*   **Confidence Calibration:**\n    *   **Principle:** If the model’s confidence scores are not well-calibrated, apply post-hoc calibration methods.\n    *   **Techniques:** Methods like Platt scaling, isotonic regression, or temperature scaling can adjust the confidence scores to better reflect true probabilities.\n*   **Test-Time Augmentation:**\n    *   Principle: Apply various augmentations to the input data at test time.\n    *   Application: Variability in predictions across augmentations can indicate uncertainty.\n*   **Quantile Regression:** Instead of predicting a single value, the model is trained to predict quantiles (e.g., 10th percentile, 50th percentile, and 90th percentile). This provides a range of predictions, capturing inherent data uncertainty. In other words, predict different quantiles of the conditional distribution of the response variable, giving an idea of the spread of the possible outcomes.\n    *   **Principle:** Instead of predicting a single value, predict a range (quantiles) for the output.\n    *   **Application:** The range between lower and upper quantiles (e.g., 5th and 95th) can represent the prediction uncertainty.\n*   **Gaussian Processes:** Gaussian Processes (GPs) are a non-parametric method that provides a probabilistic measure of uncertainty with the predictions. The output of a GP is a distribution over functions, from which you can derive mean predictions and variances.\n    *   **Principle:** GPs are a Bayesian approach suitable for small to medium-sized datasets.\n    *   **Application:** They naturally provide a measure of uncertainty (variance) along with predictions.\n*   **Ensemble Methods:** Using an ensemble of models (e.g., bagging or bootstrapped ensembles) can provide multiple predictions for each input. The variance or spread of these predictions can be used as a measure of uncertainty. Pu simply, use an ensemble of models and measure the variance in their predictions. A higher variance indicates higher uncertainty.\n    *   **Principle:** Train multiple models independently and use the variance in their predictions to estimate uncertainty.\n    *   **Application:** A higher variance in predictions indicates greater uncertainty.\n    *   **Types:** Bagging, boosting, or stacking different models or the same model with different initializations.\n*   **Likelihood Methods:**\n    *   **Principle:** Model the output distribution of your predictions (e.g., a Gaussian distribution with mean and variance).\n    *   **Application:** The variance can be used as a measure of uncertainty.\n*   **Adversarial Training:**\n    *   **Principle:** Train the model with adversarial examples.\n    *   **Application:** This can make the model more robust and its uncertainty estimates more reliable.\n*   **Out-of-Distribution (OOD) Detection**\n    *   **Principle:** Train the model to recognize when inputs are significantly different from the training data.\n    *   **Application:** OOD inputs often result in higher uncertainty.\n*   **Residual Analysis:** Analyze the residuals of the model (the differences between the predicted and actual values). Patterns or high variability in residuals can indicate areas where the model is less certain.\n*   **Homoscedastic & Heteroscedastic Uncertainty:** Homoscedastic refers to models where the aleatoric uncertainty is assumed to be constant across all inputs. Heteroscedastic models allow this uncertainty to vary with input data. For regression problems, modeling heteroscedastic uncertainty can be crucial, especially when the noise or variability in the data is input-dependent.\n\n*   **Principle:** BNNs model uncertainty by placing a probability distribution over the network’s weights (as opposed to fixed weights in standard neural networks).\n*   **Application:** By sampling from these distributions, you can obtain a distribution of predictions for a given input, which reflects the model’s uncertainty.\n*   **Challenge:** BNNs can be computationally expensive and complex to implement.\n\n*   **Principle:** Use dropout not just during training but also during inference. By running multiple forward passes with dropout, you obtain a distribution of predictions.\n*   **Application:** The variance in these predictions can be interpreted as a measure of model uncertainty.\n*   **Advantage:** Easier to implement than BNNs, as it can be applied to any standard neural network with dropout layers.\n\n*   **Principle:** If the model’s confidence scores are not well-calibrated, apply post-hoc calibration methods.\n*   **Techniques:** Methods like Platt scaling, isotonic regression, or temperature scaling can adjust the confidence scores to better reflect true probabilities.\n\n*   Principle: Apply various augmentations to the input data at test time.\n*   Application: Variability in predictions across augmentations can indicate uncertainty.\n\n*   **Principle:** Instead of predicting a single value, predict a range (quantiles) for the output.\n*   **Application:** The range between lower and upper quantiles (e.g., 5th and 95th) can represent the prediction uncertainty.\n\n*   **Principle:** GPs are a Bayesian approach suitable for small to medium-sized datasets.\n*   **Application:** They naturally provide a measure of uncertainty (variance) along with predictions.\n\n*   **Principle:** Train multiple models independently and use the variance in their predictions to estimate uncertainty.\n*   **Application:** A higher variance in predictions indicates greater uncertainty.\n*   **Types:** Bagging, boosting, or stacking different models or the same model with different initializations.\n\n*   **Principle:** Model the output distribution of your predictions (e.g., a Gaussian distribution with mean and variance).\n*   **Application:** The variance can be used as a measure of uncertainty.\n\n*   **Principle:** Train the model with adversarial examples.\n*   **Application:** This can make the model more robust and its uncertainty estimates more reliable.\n\n*   **Principle:** Train the model to recognize when inputs are significantly different from the training data.\n*   **Application:** OOD inputs often result in higher uncertainty.\n\n*   **Model Calibration Techniques:** Implement calibration methods to ensure that the predicted uncertainties align with the actual errors. For example, in probabilistic models, ensuring that the predicted probability distribution matches the observed distribution of the target variable. For miscalibrated models, post-hoc calibration techniques (like Platt scaling or isotonic regression) can be used to adjust the predicted values to better reflect the true likelihoods.\n    1.  **Improving Model Fit:** If the model is miscalibrated, it might be necessary to revisit model selection, feature engineering, or even the data itself to improve the fit.\n\n1.  **Improving Model Fit:** If the model is miscalibrated, it might be necessary to revisit model selection, feature engineering, or even the data itself to improve the fit.\n\n*   The choice of method depends on various factors like the size of the dataset, the model complexity, the type of task (regression/classification), and computational resources. In practice, a combination of these methods might be employed to gain a more comprehensive understanding of the model’s uncertainty.",
      "order": 77,
      "orderInChapter": 77,
      "difficulty": 4,
      "estimatedMinutes": 14,
      "tags": [
        "practice",
        "neural network",
        "dropout"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 2659,
        "contentLength": 23120
      },
      "nextCards": [
        "ai-interview-how-do-we-fix-distribution-shift-in-machine-learni-78",
        "ai-interview-what-is-self-attention-79"
      ],
      "relatedCards": [
        "ai-dropout-use-a-larger-network-3",
        "ai-dropout-use-a-weight-constraint-5",
        "ai-on-device-transformers-encoder-compute-bound-nature-1",
        "ai-bias-variance-tradeoff-overfitting-and-underfitting-common-challenges-in--13",
        "ai-support-vector-machines-linear-vs-non-linear-separability-6"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-define-uncertainty-with-regression-problems?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-we-fix-distribution-shift-in-machine-learni-78",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do We Fix Distribution Shift in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Distribution shift refers to situations where the distribution of the data your model was trained on (source distribution or training distribution) differs from the distribution of the data your model is applied to (target distribution or test distribution). Addressing distribution shift is crucial for ensuring that machine learning models are robust and maintain their performance in real-world scenarios.</li>\n  <li>Here are some strategies and techniques to address distribution shift:\n    <ul>\n      <li><strong>Retraining/Transfer Learning:</strong> Regularly retrain your model with recent data or fine-tune on a small labeled subset of the target domain data to adapt to the new distribution.</li>\n      <li><strong>Model Ensembles and Stacking:</strong> Use an ensemble of models trained on different subsets of the data or under different conditions. This can make the ensemble more robust against distribution shifts.</li>\n      <li><strong>Data Augmentation:</strong> Expand the training dataset using data augmentation techniques that mimic possible changes in the data distribution.</li>\n      <li><strong>Domain Adaptation:</strong> This involves adapting a model trained on one domain (source) to work well on a different but related domain (target). Techniques include:\n        <ul>\n          <li>Feature-level adaptation: Transform source and target feature distributions to be similar using methods like Maximum Mean Discrepancy (MMD) or adversarial training.</li>\n          <li>Instance weighting: Assign weights to training instances according to their importance for the target domain.</li>\n        </ul>\n      </li>\n      <li><strong>Domain-Adversarial Neural Networks:</strong> Use a neural network architecture with two objectives: one for the primary task and another adversarial objective that tries to make the feature representations from the source and target domains indistinguishable.</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td><strong>Covariate Shift Adaptation:</strong> If the shift is due to changes in the input distribution (P(X)), but the conditional distribution P(Y</td>\n              <td>X) remains the same, then re-weighting the training samples to minimize the distribution difference can help.</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li><strong>Concept Drift Detection:</strong> Continuously monitor model predictions for signs of declining performance, indicating a possible distribution shift. If detected, the model can be updated.</li>\n      <li>Active Learning: Actively query labels for instances in the target domain where the model is uncertain. This can help adapt the model more effectively with fewer labeled examples.</li>\n      <li><strong>Neural Architecture Search (NAS):</strong> Employ NAS to search for architectures that are robust against distribution shifts.</li>\n      <li><strong>Out-of-Distribution (OOD) Detection:</strong> Train models to detect OOD samples and handle them separately, either by seeking human intervention or using specialized models.\n        <ul>\n          <li><strong>Feedback Loops:</strong> Implement systems where users can provide feedback on incorrect predictions. This feedback can be used to continuously update and correct the model.</li>\n          <li><strong>Anomaly Detection:</strong> If the distribution shift leads to anomalous data points, using anomaly detection techniques can help in identifying and handling these anomalies.</li>\n          <li><strong>Test-Time Augmentation:</strong> Apply various augmentations to each test instance and make predictions on each augmented version. Aggregate these predictions to produce the final prediction.</li>\n          <li><strong>Calibration Techniques:</strong> Calibrate your model’s predictions to adjust for distribution shifts and ensure that the prediction confidence aligns with the true accuracy.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>When addressing distribution shift, the first step is often to identify and understand its nature. Techniques like visualization, two-sample tests, or measuring divergence metrics can help diagnose the type and magnitude of the shift. Depending on the situation, a combination of the aforementioned strategies might be needed to effectively handle the distribution shift.</li>\n</ul>\n<ul>\n      <li><strong>Retraining/Transfer Learning:</strong> Regularly retrain your model with recent data or fine-tune on a small labeled subset of the target domain data to adapt to the new distribution.</li>\n      <li><strong>Model Ensembles and Stacking:</strong> Use an ensemble of models trained on different subsets of the data or under different conditions. This can make the ensemble more robust against distribution shifts.</li>\n      <li><strong>Data Augmentation:</strong> Expand the training dataset using data augmentation techniques that mimic possible changes in the data distribution.</li>\n      <li><strong>Domain Adaptation:</strong> This involves adapting a model trained on one domain (source) to work well on a different but related domain (target). Techniques include:\n        <ul>\n          <li>Feature-level adaptation: Transform source and target feature distributions to be similar using methods like Maximum Mean Discrepancy (MMD) or adversarial training.</li>\n          <li>Instance weighting: Assign weights to training instances according to their importance for the target domain.</li>\n        </ul>\n      </li>\n      <li><strong>Domain-Adversarial Neural Networks:</strong> Use a neural network architecture with two objectives: one for the primary task and another adversarial objective that tries to make the feature representations from the source and target domains indistinguishable.</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td><strong>Covariate Shift Adaptation:</strong> If the shift is due to changes in the input distribution (P(X)), but the conditional distribution P(Y</td>\n              <td>X) remains the same, then re-weighting the training samples to minimize the distribution difference can help.</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li><strong>Concept Drift Detection:</strong> Continuously monitor model predictions for signs of declining performance, indicating a possible distribution shift. If detected, the model can be updated.</li>\n      <li>Active Learning: Actively query labels for instances in the target domain where the model is uncertain. This can help adapt the model more effectively with fewer labeled examples.</li>\n      <li><strong>Neural Architecture Search (NAS):</strong> Employ NAS to search for architectures that are robust against distribution shifts.</li>\n      <li><strong>Out-of-Distribution (OOD) Detection:</strong> Train models to detect OOD samples and handle them separately, either by seeking human intervention or using specialized models.\n        <ul>\n          <li><strong>Feedback Loops:</strong> Implement systems where users can provide feedback on incorrect predictions. This feedback can be used to continuously update and correct the model.</li>\n          <li><strong>Anomaly Detection:</strong> If the distribution shift leads to anomalous data points, using anomaly detection techniques can help in identifying and handling these anomalies.</li>\n          <li><strong>Test-Time Augmentation:</strong> Apply various augmentations to each test instance and make predictions on each augmented version. Aggregate these predictions to produce the final prediction.</li>\n          <li><strong>Calibration Techniques:</strong> Calibrate your model’s predictions to adjust for distribution shifts and ensure that the prediction confidence aligns with the true accuracy.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Feature-level adaptation: Transform source and target feature distributions to be similar using methods like Maximum Mean Discrepancy (MMD) or adversarial training.</li>\n          <li>Instance weighting: Assign weights to training instances according to their importance for the target domain.</li>\n        </ul>\n<table>\n          <tbody>\n            <tr>\n              <td><strong>Covariate Shift Adaptation:</strong> If the shift is due to changes in the input distribution (P(X)), but the conditional distribution P(Y</td>\n              <td>X) remains the same, then re-weighting the training samples to minimize the distribution difference can help.</td>\n            </tr>\n          </tbody>\n        </table>\n<ul>\n          <li><strong>Feedback Loops:</strong> Implement systems where users can provide feedback on incorrect predictions. This feedback can be used to continuously update and correct the model.</li>\n          <li><strong>Anomaly Detection:</strong> If the distribution shift leads to anomalous data points, using anomaly detection techniques can help in identifying and handling these anomalies.</li>\n          <li><strong>Test-Time Augmentation:</strong> Apply various augmentations to each test instance and make predictions on each augmented version. Aggregate these predictions to produce the final prediction.</li>\n          <li><strong>Calibration Techniques:</strong> Calibrate your model’s predictions to adjust for distribution shifts and ensure that the prediction confidence aligns with the true accuracy.</li>\n        </ul>",
      "contentMarkdown": "*   Distribution shift refers to situations where the distribution of the data your model was trained on (source distribution or training distribution) differs from the distribution of the data your model is applied to (target distribution or test distribution). Addressing distribution shift is crucial for ensuring that machine learning models are robust and maintain their performance in real-world scenarios.\n*   Here are some strategies and techniques to address distribution shift:\n    *   **Retraining/Transfer Learning:** Regularly retrain your model with recent data or fine-tune on a small labeled subset of the target domain data to adapt to the new distribution.\n    *   **Model Ensembles and Stacking:** Use an ensemble of models trained on different subsets of the data or under different conditions. This can make the ensemble more robust against distribution shifts.\n    *   **Data Augmentation:** Expand the training dataset using data augmentation techniques that mimic possible changes in the data distribution.\n    *   **Domain Adaptation:** This involves adapting a model trained on one domain (source) to work well on a different but related domain (target). Techniques include:\n        *   Feature-level adaptation: Transform source and target feature distributions to be similar using methods like Maximum Mean Discrepancy (MMD) or adversarial training.\n        *   Instance weighting: Assign weights to training instances according to their importance for the target domain.\n    *   **Domain-Adversarial Neural Networks:** Use a neural network architecture with two objectives: one for the primary task and another adversarial objective that tries to make the feature representations from the source and target domains indistinguishable.\n    *   **Covariate Shift Adaptation:** If the shift is due to changes in the input distribution (P(X)), but the conditional distribution P(Y\n        \n        X) remains the same, then re-weighting the training samples to minimize the distribution difference can help.\n        \n    *   **Concept Drift Detection:** Continuously monitor model predictions for signs of declining performance, indicating a possible distribution shift. If detected, the model can be updated.\n    *   Active Learning: Actively query labels for instances in the target domain where the model is uncertain. This can help adapt the model more effectively with fewer labeled examples.\n    *   **Neural Architecture Search (NAS):** Employ NAS to search for architectures that are robust against distribution shifts.\n    *   **Out-of-Distribution (OOD) Detection:** Train models to detect OOD samples and handle them separately, either by seeking human intervention or using specialized models.\n        *   **Feedback Loops:** Implement systems where users can provide feedback on incorrect predictions. This feedback can be used to continuously update and correct the model.\n        *   **Anomaly Detection:** If the distribution shift leads to anomalous data points, using anomaly detection techniques can help in identifying and handling these anomalies.\n        *   **Test-Time Augmentation:** Apply various augmentations to each test instance and make predictions on each augmented version. Aggregate these predictions to produce the final prediction.\n        *   **Calibration Techniques:** Calibrate your model’s predictions to adjust for distribution shifts and ensure that the prediction confidence aligns with the true accuracy.\n*   When addressing distribution shift, the first step is often to identify and understand its nature. Techniques like visualization, two-sample tests, or measuring divergence metrics can help diagnose the type and magnitude of the shift. Depending on the situation, a combination of the aforementioned strategies might be needed to effectively handle the distribution shift.\n\n*   **Retraining/Transfer Learning:** Regularly retrain your model with recent data or fine-tune on a small labeled subset of the target domain data to adapt to the new distribution.\n*   **Model Ensembles and Stacking:** Use an ensemble of models trained on different subsets of the data or under different conditions. This can make the ensemble more robust against distribution shifts.\n*   **Data Augmentation:** Expand the training dataset using data augmentation techniques that mimic possible changes in the data distribution.\n*   **Domain Adaptation:** This involves adapting a model trained on one domain (source) to work well on a different but related domain (target). Techniques include:\n    *   Feature-level adaptation: Transform source and target feature distributions to be similar using methods like Maximum Mean Discrepancy (MMD) or adversarial training.\n    *   Instance weighting: Assign weights to training instances according to their importance for the target domain.\n*   **Domain-Adversarial Neural Networks:** Use a neural network architecture with two objectives: one for the primary task and another adversarial objective that tries to make the feature representations from the source and target domains indistinguishable.\n*   **Covariate Shift Adaptation:** If the shift is due to changes in the input distribution (P(X)), but the conditional distribution P(Y\n    \n    X) remains the same, then re-weighting the training samples to minimize the distribution difference can help.\n    \n*   **Concept Drift Detection:** Continuously monitor model predictions for signs of declining performance, indicating a possible distribution shift. If detected, the model can be updated.\n*   Active Learning: Actively query labels for instances in the target domain where the model is uncertain. This can help adapt the model more effectively with fewer labeled examples.\n*   **Neural Architecture Search (NAS):** Employ NAS to search for architectures that are robust against distribution shifts.\n*   **Out-of-Distribution (OOD) Detection:** Train models to detect OOD samples and handle them separately, either by seeking human intervention or using specialized models.\n    *   **Feedback Loops:** Implement systems where users can provide feedback on incorrect predictions. This feedback can be used to continuously update and correct the model.\n    *   **Anomaly Detection:** If the distribution shift leads to anomalous data points, using anomaly detection techniques can help in identifying and handling these anomalies.\n    *   **Test-Time Augmentation:** Apply various augmentations to each test instance and make predictions on each augmented version. Aggregate these predictions to produce the final prediction.\n    *   **Calibration Techniques:** Calibrate your model’s predictions to adjust for distribution shifts and ensure that the prediction confidence aligns with the true accuracy.\n\n*   Feature-level adaptation: Transform source and target feature distributions to be similar using methods like Maximum Mean Discrepancy (MMD) or adversarial training.\n*   Instance weighting: Assign weights to training instances according to their importance for the target domain.\n\n**Covariate Shift Adaptation:** If the shift is due to changes in the input distribution (P(X)), but the conditional distribution P(Y\n\nX) remains the same, then re-weighting the training samples to minimize the distribution difference can help.\n\n*   **Feedback Loops:** Implement systems where users can provide feedback on incorrect predictions. This feedback can be used to continuously update and correct the model.\n*   **Anomaly Detection:** If the distribution shift leads to anomalous data points, using anomaly detection techniques can help in identifying and handling these anomalies.\n*   **Test-Time Augmentation:** Apply various augmentations to each test instance and make predictions on each augmented version. Aggregate these predictions to produce the final prediction.\n*   **Calibration Techniques:** Calibrate your model’s predictions to adjust for distribution shifts and ensure that the prediction confidence aligns with the true accuracy.",
      "order": 78,
      "orderInChapter": 78,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "machine learning",
        "transfer learning",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1103,
        "contentLength": 9443
      },
      "nextCards": [
        "ai-interview-what-is-self-attention-79",
        "ai-interview-why-do-we-need-q-k-and-v-in-self-attention-80"
      ],
      "relatedCards": [
        "ai-speech-processing-frequency-domain-26",
        "ai-decision-trees-and-ensemble-methods-stacking-stacked-generalization-10",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-model-compression-overview-42",
        "ai-top-30-papers-neural-message-passing-for-quantum-chemistry-12"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-we-fix-distribution-shift-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-self-attention-79",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Self-attention?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Self-attention, a key component of the Transformer architecture, has revolutionized the field of natural language processing due to its effectiveness in modeling complex patterns in sequences. Here’s a breakdown of self-attention:</li>\n  <li>Overview:\n    <ul>\n      <li>Self-attention allows a sequence (e.g., a sentence) to focus on different parts of itself to produce a representation of the sequence. In essence, it lets the model weigh the importance of different words or tokens in relation to a specific word.</li>\n    </ul>\n  </li>\n  <li>Mechanism:\n    <ul>\n      <li>Given an input sequence, the self-attention mechanism calculates attention scores for every word against every other word in the sequence. These scores determine how much focus each word in the sequence should have on every other word.</li>\n    </ul>\n\n    <ol>\n      <li><strong>Query, Key, Value Vectors:</strong>\n        <ul>\n          <li>For each word/token, we derive three vectors:\n            <ul>\n              <li>Query vector: Represents the word we’re focusing on.</li>\n              <li>Key vector: Represents the words we’re comparing against.</li>\n              <li>Value vector: Provides the information from each word which we’ll use in our final output.</li>\n            </ul>\n          </li>\n          <li>These vectors are derived by multiplying the embedding of each word with three weight matrices (which are learned during training).</li>\n        </ul>\n      </li>\n      <li><strong>Attention Score Calculation:</strong> For a given word’s Query vector, we calculate its dot product with the Key vector of every other word. This gives us the attention scores.</li>\n      <li><strong>Softmax:</strong> The attention scores are then passed through a softmax function, which converts them to probabilities. This ensures that the scores are normalized and sum up to 1.</li>\n      <li><strong>Weighted Sum:</strong> The softmax scores for each word are multiplied with their respective Value vectors. The results are summed up to produce the final self-attended representation of the word.</li>\n      <li><strong>Multi-Head Attention:</strong> Instead of doing this process once, the Transformer architecture does it multiple times in parallel, with each set using different weight matrices. These parallel executions are the “heads” in multi-head attention. The results from each head are concatenated and linearly transformed to produce the final output.</li>\n    </ol>\n  </li>\n  <li>Advantages of Self-Attention:\n  <strong>Long-range Dependencies:</strong> Self-attention can capture relationships between words or tokens regardless of their distance in the sequence, unlike RNNs or LSTMs which might struggle with long-range dependencies.\n  <strong>Parallelization:</strong> Since the attention scores for all word pairs are calculated simultaneously, the process can be parallelized easily, leading to faster training times.\n  <strong>Flexibility:</strong> The self-attention mechanism is versatile and has been successfully used not just in NLP tasks but also in computer vision and other domains.</li>\n  <li><strong>Challenges:</strong>\n  <strong>Quadratic Complexity:</strong> For a sequence of length N, self-attention computes N^2 attention scores. This quadratic complexity can be a bottleneck for very long sequences.\n  <strong>Overhead:</strong> Despite its parallelizable nature, the sheer number of operations in self-attention can be computationally intensive, especially for tasks that might not need such a complex mechanism.</li>\n  <li>The self-attention mechanism, especially within the Transformer architecture, has been the foundation for models like BERT, GPT, T5, and many others that have set state-of-the-art benchmarks in a wide array of NLP tasks.</li>\n</ul>\n<ul>\n      <li>Self-attention allows a sequence (e.g., a sentence) to focus on different parts of itself to produce a representation of the sequence. In essence, it lets the model weigh the importance of different words or tokens in relation to a specific word.</li>\n    </ul>\n<ul>\n      <li>Given an input sequence, the self-attention mechanism calculates attention scores for every word against every other word in the sequence. These scores determine how much focus each word in the sequence should have on every other word.</li>\n    </ul>\n<ol>\n      <li><strong>Query, Key, Value Vectors:</strong>\n        <ul>\n          <li>For each word/token, we derive three vectors:\n            <ul>\n              <li>Query vector: Represents the word we’re focusing on.</li>\n              <li>Key vector: Represents the words we’re comparing against.</li>\n              <li>Value vector: Provides the information from each word which we’ll use in our final output.</li>\n            </ul>\n          </li>\n          <li>These vectors are derived by multiplying the embedding of each word with three weight matrices (which are learned during training).</li>\n        </ul>\n      </li>\n      <li><strong>Attention Score Calculation:</strong> For a given word’s Query vector, we calculate its dot product with the Key vector of every other word. This gives us the attention scores.</li>\n      <li><strong>Softmax:</strong> The attention scores are then passed through a softmax function, which converts them to probabilities. This ensures that the scores are normalized and sum up to 1.</li>\n      <li><strong>Weighted Sum:</strong> The softmax scores for each word are multiplied with their respective Value vectors. The results are summed up to produce the final self-attended representation of the word.</li>\n      <li><strong>Multi-Head Attention:</strong> Instead of doing this process once, the Transformer architecture does it multiple times in parallel, with each set using different weight matrices. These parallel executions are the “heads” in multi-head attention. The results from each head are concatenated and linearly transformed to produce the final output.</li>\n    </ol>\n<ul>\n          <li>For each word/token, we derive three vectors:\n            <ul>\n              <li>Query vector: Represents the word we’re focusing on.</li>\n              <li>Key vector: Represents the words we’re comparing against.</li>\n              <li>Value vector: Provides the information from each word which we’ll use in our final output.</li>\n            </ul>\n          </li>\n          <li>These vectors are derived by multiplying the embedding of each word with three weight matrices (which are learned during training).</li>\n        </ul>\n<ul>\n              <li>Query vector: Represents the word we’re focusing on.</li>\n              <li>Key vector: Represents the words we’re comparing against.</li>\n              <li>Value vector: Provides the information from each word which we’ll use in our final output.</li>\n            </ul>",
      "contentMarkdown": "*   Self-attention, a key component of the Transformer architecture, has revolutionized the field of natural language processing due to its effectiveness in modeling complex patterns in sequences. Here’s a breakdown of self-attention:\n*   Overview:\n    *   Self-attention allows a sequence (e.g., a sentence) to focus on different parts of itself to produce a representation of the sequence. In essence, it lets the model weigh the importance of different words or tokens in relation to a specific word.\n*   Mechanism:\n    \n    *   Given an input sequence, the self-attention mechanism calculates attention scores for every word against every other word in the sequence. These scores determine how much focus each word in the sequence should have on every other word.\n    \n    1.  **Query, Key, Value Vectors:**\n        *   For each word/token, we derive three vectors:\n            *   Query vector: Represents the word we’re focusing on.\n            *   Key vector: Represents the words we’re comparing against.\n            *   Value vector: Provides the information from each word which we’ll use in our final output.\n        *   These vectors are derived by multiplying the embedding of each word with three weight matrices (which are learned during training).\n    2.  **Attention Score Calculation:** For a given word’s Query vector, we calculate its dot product with the Key vector of every other word. This gives us the attention scores.\n    3.  **Softmax:** The attention scores are then passed through a softmax function, which converts them to probabilities. This ensures that the scores are normalized and sum up to 1.\n    4.  **Weighted Sum:** The softmax scores for each word are multiplied with their respective Value vectors. The results are summed up to produce the final self-attended representation of the word.\n    5.  **Multi-Head Attention:** Instead of doing this process once, the Transformer architecture does it multiple times in parallel, with each set using different weight matrices. These parallel executions are the “heads” in multi-head attention. The results from each head are concatenated and linearly transformed to produce the final output.\n*   Advantages of Self-Attention: **Long-range Dependencies:** Self-attention can capture relationships between words or tokens regardless of their distance in the sequence, unlike RNNs or LSTMs which might struggle with long-range dependencies. **Parallelization:** Since the attention scores for all word pairs are calculated simultaneously, the process can be parallelized easily, leading to faster training times. **Flexibility:** The self-attention mechanism is versatile and has been successfully used not just in NLP tasks but also in computer vision and other domains.\n*   **Challenges:** **Quadratic Complexity:** For a sequence of length N, self-attention computes N^2 attention scores. This quadratic complexity can be a bottleneck for very long sequences. **Overhead:** Despite its parallelizable nature, the sheer number of operations in self-attention can be computationally intensive, especially for tasks that might not need such a complex mechanism.\n*   The self-attention mechanism, especially within the Transformer architecture, has been the foundation for models like BERT, GPT, T5, and many others that have set state-of-the-art benchmarks in a wide array of NLP tasks.\n\n*   Self-attention allows a sequence (e.g., a sentence) to focus on different parts of itself to produce a representation of the sequence. In essence, it lets the model weigh the importance of different words or tokens in relation to a specific word.\n\n*   Given an input sequence, the self-attention mechanism calculates attention scores for every word against every other word in the sequence. These scores determine how much focus each word in the sequence should have on every other word.\n\n1.  **Query, Key, Value Vectors:**\n    *   For each word/token, we derive three vectors:\n        *   Query vector: Represents the word we’re focusing on.\n        *   Key vector: Represents the words we’re comparing against.\n        *   Value vector: Provides the information from each word which we’ll use in our final output.\n    *   These vectors are derived by multiplying the embedding of each word with three weight matrices (which are learned during training).\n2.  **Attention Score Calculation:** For a given word’s Query vector, we calculate its dot product with the Key vector of every other word. This gives us the attention scores.\n3.  **Softmax:** The attention scores are then passed through a softmax function, which converts them to probabilities. This ensures that the scores are normalized and sum up to 1.\n4.  **Weighted Sum:** The softmax scores for each word are multiplied with their respective Value vectors. The results are summed up to produce the final self-attended representation of the word.\n5.  **Multi-Head Attention:** Instead of doing this process once, the Transformer architecture does it multiple times in parallel, with each set using different weight matrices. These parallel executions are the “heads” in multi-head attention. The results from each head are concatenated and linearly transformed to produce the final output.\n\n*   For each word/token, we derive three vectors:\n    *   Query vector: Represents the word we’re focusing on.\n    *   Key vector: Represents the words we’re comparing against.\n    *   Value vector: Provides the information from each word which we’ll use in our final output.\n*   These vectors are derived by multiplying the embedding of each word with three weight matrices (which are learned during training).\n\n*   Query vector: Represents the word we’re focusing on.\n*   Key vector: Represents the words we’re comparing against.\n*   Value vector: Provides the information from each word which we’ll use in our final output.",
      "order": 79,
      "orderInChapter": 79,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "embedding",
        "rnn",
        "lstm",
        "bert",
        "gpt"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 868,
        "contentLength": 6813
      },
      "nextCards": [
        "ai-interview-why-do-we-need-q-k-and-v-in-self-attention-80",
        "ai-interview-what-is-the-difference-between-ddpm-and-ddim-model-81"
      ],
      "relatedCards": [
        "ai-word-vectors-contextualized-embeddings-and-the-post-word2vec-er-38",
        "ai-encoder-vs-decoder-models-summary-10",
        "ai-diffusion-models-how-do-you-condition-a-diffusion-model-to-the-text-49",
        "ai-transformers-what-is-the-fraction-of-attention-weights-relative-60",
        "ai-word-vectors-word2vec-11"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-self-attention?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-do-we-need-q-k-and-v-in-self-attention-80",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Do We Need Q, K and V in Self Attention?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The concepts of Query (Q), Key (K), and Value (V) in self-attention arise from the need to determine the relationship between different elements in a sequence and then utilize this relationship to create a new representation of the sequence. Here’s why each component is essential:</li>\n  <li><strong>Query (Q):</strong>\n    <ul>\n      <li>Represents the element we are currently focusing on.</li>\n      <li>Allows the model to ask: “Which other elements in the sequence should I attend to, and to what extent, when I’m considering this particular element?”</li>\n      <li>In self-attention, every element in the sequence has its own Query representation, as each element seeks to understand its relationship with all other elements.</li>\n    </ul>\n  </li>\n  <li><strong>Key (K):</strong>\n    <ul>\n      <li>Represents the elements we are comparing against the Query.</li>\n      <li>Helps in determining how much attention a Query should pay to each other element.</li>\n      <li>The alignment (dot product) of the Query with a Key gives an attention score, indicating the relevance of the corresponding element to the Query.</li>\n    </ul>\n  </li>\n  <li><strong>Value (V):</strong>\n    <ul>\n      <li>Contains the information that the Query uses once it has identified which parts of the sequence to focus on.</li>\n      <li>It’s like the payload that’s being delivered based on the attention scores. The more attention a Query gives to a specific Key, the more of that Key’s Value gets used in the output.</li>\n      <li>It helps in updating the representation of the Query based on its relationships with other elements.</li>\n    </ul>\n  </li>\n  <li><strong>Analogy:</strong> Imagine you’re at a party trying to find people you might get along with:\n    <ul>\n      <li><strong>Query (Q):</strong> This is you, wondering whom to talk to next.</li>\n      <li><strong>Key (K):</strong> These are attributes or vibes from other people at the party. By comparing your interests (Query) with theirs (Key), you determine how much you might get along with each person.</li>\n      <li><strong>Value (V):</strong> Once you’ve identified someone you’d like to chat with based on the alignment of interests, the conversation (Value) you have with them enriches your experience at the party.</li>\n    </ul>\n  </li>\n  <li>Why Not Just Use Q and V?\n    <ul>\n      <li>You might wonder why we can’t just have Queries and Values and skip Keys. The separation of Keys and Values allows for more flexibility and expressiveness in the attention mechanism:\n        <ul>\n          <li>It decouples the process of determining attention scores (via Q-K alignment) from the content that’s being aggregated (Values).</li>\n          <li>This means you can have different transformations for determining attention scores and different transformations for the information you want to aggregate.</li>\n        </ul>\n      </li>\n      <li>In practice, the distinction between Key and Value transformations enables the attention mechanism to focus on different aspects of the data when determining relationships (Keys) versus when aggregating information (Values).</li>\n      <li>In summary, the Q, K, and V setup in self-attention allows the model to determine relationships between elements in a sequence (using Q and K) and then utilize these relationships to compute a new representation of the sequence by aggregating information (using V).</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Represents the element we are currently focusing on.</li>\n      <li>Allows the model to ask: “Which other elements in the sequence should I attend to, and to what extent, when I’m considering this particular element?”</li>\n      <li>In self-attention, every element in the sequence has its own Query representation, as each element seeks to understand its relationship with all other elements.</li>\n    </ul>\n<ul>\n      <li>Represents the elements we are comparing against the Query.</li>\n      <li>Helps in determining how much attention a Query should pay to each other element.</li>\n      <li>The alignment (dot product) of the Query with a Key gives an attention score, indicating the relevance of the corresponding element to the Query.</li>\n    </ul>\n<ul>\n      <li>Contains the information that the Query uses once it has identified which parts of the sequence to focus on.</li>\n      <li>It’s like the payload that’s being delivered based on the attention scores. The more attention a Query gives to a specific Key, the more of that Key’s Value gets used in the output.</li>\n      <li>It helps in updating the representation of the Query based on its relationships with other elements.</li>\n    </ul>\n<ul>\n      <li><strong>Query (Q):</strong> This is you, wondering whom to talk to next.</li>\n      <li><strong>Key (K):</strong> These are attributes or vibes from other people at the party. By comparing your interests (Query) with theirs (Key), you determine how much you might get along with each person.</li>\n      <li><strong>Value (V):</strong> Once you’ve identified someone you’d like to chat with based on the alignment of interests, the conversation (Value) you have with them enriches your experience at the party.</li>\n    </ul>\n<ul>\n      <li>You might wonder why we can’t just have Queries and Values and skip Keys. The separation of Keys and Values allows for more flexibility and expressiveness in the attention mechanism:\n        <ul>\n          <li>It decouples the process of determining attention scores (via Q-K alignment) from the content that’s being aggregated (Values).</li>\n          <li>This means you can have different transformations for determining attention scores and different transformations for the information you want to aggregate.</li>\n        </ul>\n      </li>\n      <li>In practice, the distinction between Key and Value transformations enables the attention mechanism to focus on different aspects of the data when determining relationships (Keys) versus when aggregating information (Values).</li>\n      <li>In summary, the Q, K, and V setup in self-attention allows the model to determine relationships between elements in a sequence (using Q and K) and then utilize these relationships to compute a new representation of the sequence by aggregating information (using V).</li>\n    </ul>\n<ul>\n          <li>It decouples the process of determining attention scores (via Q-K alignment) from the content that’s being aggregated (Values).</li>\n          <li>This means you can have different transformations for determining attention scores and different transformations for the information you want to aggregate.</li>\n        </ul>",
      "contentMarkdown": "*   The concepts of Query (Q), Key (K), and Value (V) in self-attention arise from the need to determine the relationship between different elements in a sequence and then utilize this relationship to create a new representation of the sequence. Here’s why each component is essential:\n*   **Query (Q):**\n    *   Represents the element we are currently focusing on.\n    *   Allows the model to ask: “Which other elements in the sequence should I attend to, and to what extent, when I’m considering this particular element?”\n    *   In self-attention, every element in the sequence has its own Query representation, as each element seeks to understand its relationship with all other elements.\n*   **Key (K):**\n    *   Represents the elements we are comparing against the Query.\n    *   Helps in determining how much attention a Query should pay to each other element.\n    *   The alignment (dot product) of the Query with a Key gives an attention score, indicating the relevance of the corresponding element to the Query.\n*   **Value (V):**\n    *   Contains the information that the Query uses once it has identified which parts of the sequence to focus on.\n    *   It’s like the payload that’s being delivered based on the attention scores. The more attention a Query gives to a specific Key, the more of that Key’s Value gets used in the output.\n    *   It helps in updating the representation of the Query based on its relationships with other elements.\n*   **Analogy:** Imagine you’re at a party trying to find people you might get along with:\n    *   **Query (Q):** This is you, wondering whom to talk to next.\n    *   **Key (K):** These are attributes or vibes from other people at the party. By comparing your interests (Query) with theirs (Key), you determine how much you might get along with each person.\n    *   **Value (V):** Once you’ve identified someone you’d like to chat with based on the alignment of interests, the conversation (Value) you have with them enriches your experience at the party.\n*   Why Not Just Use Q and V?\n    *   You might wonder why we can’t just have Queries and Values and skip Keys. The separation of Keys and Values allows for more flexibility and expressiveness in the attention mechanism:\n        *   It decouples the process of determining attention scores (via Q-K alignment) from the content that’s being aggregated (Values).\n        *   This means you can have different transformations for determining attention scores and different transformations for the information you want to aggregate.\n    *   In practice, the distinction between Key and Value transformations enables the attention mechanism to focus on different aspects of the data when determining relationships (Keys) versus when aggregating information (Values).\n    *   In summary, the Q, K, and V setup in self-attention allows the model to determine relationships between elements in a sequence (using Q and K) and then utilize these relationships to compute a new representation of the sequence by aggregating information (using V).\n\n*   Represents the element we are currently focusing on.\n*   Allows the model to ask: “Which other elements in the sequence should I attend to, and to what extent, when I’m considering this particular element?”\n*   In self-attention, every element in the sequence has its own Query representation, as each element seeks to understand its relationship with all other elements.\n\n*   Represents the elements we are comparing against the Query.\n*   Helps in determining how much attention a Query should pay to each other element.\n*   The alignment (dot product) of the Query with a Key gives an attention score, indicating the relevance of the corresponding element to the Query.\n\n*   Contains the information that the Query uses once it has identified which parts of the sequence to focus on.\n*   It’s like the payload that’s being delivered based on the attention scores. The more attention a Query gives to a specific Key, the more of that Key’s Value gets used in the output.\n*   It helps in updating the representation of the Query based on its relationships with other elements.\n\n*   **Query (Q):** This is you, wondering whom to talk to next.\n*   **Key (K):** These are attributes or vibes from other people at the party. By comparing your interests (Query) with theirs (Key), you determine how much you might get along with each person.\n*   **Value (V):** Once you’ve identified someone you’d like to chat with based on the alignment of interests, the conversation (Value) you have with them enriches your experience at the party.\n\n*   You might wonder why we can’t just have Queries and Values and skip Keys. The separation of Keys and Values allows for more flexibility and expressiveness in the attention mechanism:\n    *   It decouples the process of determining attention scores (via Q-K alignment) from the content that’s being aggregated (Values).\n    *   This means you can have different transformations for determining attention scores and different transformations for the information you want to aggregate.\n*   In practice, the distinction between Key and Value transformations enables the attention mechanism to focus on different aspects of the data when determining relationships (Keys) versus when aggregating information (Values).\n*   In summary, the Q, K, and V setup in self-attention allows the model to determine relationships between elements in a sequence (using Q and K) and then utilize these relationships to compute a new representation of the sequence by aggregating information (using V).\n\n*   It decouples the process of determining attention scores (via Q-K alignment) from the content that’s being aggregated (Values).\n*   This means you can have different transformations for determining attention scores and different transformations for the information you want to aggregate.",
      "order": 80,
      "orderInChapter": 80,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "attention"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 928,
        "contentLength": 6650
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-ddpm-and-ddim-model-81",
        "ai-interview-what-is-the-difference-between-tree-of-thought-pro-82"
      ],
      "relatedCards": [
        "ai-architectures-attention-mechanism-31",
        "ai-diffusion-models-visual-conditioning-in-diffusion-models-25",
        "ai-diffusion-models-summary-33",
        "ai-diffusion-models-sdxl-improving-latent-diffusion-models-for-high-re-63",
        "ai-diffusion-models-dreamix-video-diffusion-models-are-general-video-e-64"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-do-we-need-q,-k-and-v-in-self-attention?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-ddpm-and-ddim-model-81",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between DDPM and DDIM Models?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Denoising Diffusion Probabilistic Models (DDPMs) and Denoising Diffusion Implicit Models (DDIMs) are both types of diffusion models used in deep learning, particularly for generating high-quality, complex data such as images. While they share the same underlying principle of diffusion processes, there are key differences in their approach and characteristics.</li>\n  <li><strong>Denoising Diffusion Probabilistic Models (DDPMs)</strong>:\n    <ul>\n      <li><strong>Basic Principle:</strong> DDPMs work by gradually adding noise to data over a series of steps, transforming the data into a Gaussian noise distribution. The model then learns to reverse this process, generating new data by denoising starting from noise.</li>\n      <li><strong>Markov Chain Process:</strong> The process involves a forward diffusion phase (adding noise) and a reverse diffusion phase (removing noise). Both phases are modeled as Markov chains.</li>\n      <li><strong>Stochastic Sampling:</strong> The reverse process in DDPMs is stochastic. This means that during the generation phase, random noise is introduced at each step, leading to variation in the outputs even if the process starts from the same noise.</li>\n      <li><strong>Sampling Time:</strong> DDPMs typically require a large number of steps to generate a sample, which can be computationally intensive and time-consuming.</li>\n      <li><strong>High-Quality Generation:</strong> DDPMs have been shown to generate high-quality samples that are often indistinguishable from real data, especially in the context of image generation.</li>\n    </ul>\n  </li>\n  <li><strong>Denoising Diffusion Implicit Models (DDIMs)</strong>:\n    <ul>\n      <li><strong>Modified Sampling Process:</strong> DDIMs are a variant of DDPMs that modify the sampling process. They use a deterministic approach instead of a stochastic one.</li>\n      <li><strong>Deterministic Sampling:</strong> In DDIMs, the reverse process is deterministic, meaning no random noise is added during the generation phase. This leads to consistent outputs for the same starting point.</li>\n      <li><strong>Faster Sampling:</strong> Because of the deterministic nature and some modifications to the diffusion process, DDIMs can generate samples in fewer steps compared to traditional DDPMs.</li>\n      <li><strong>Flexibility in Time Steps:</strong> DDIMs offer more flexibility in choosing the number of timesteps, allowing for a trade-off between generation quality and computational efficiency.</li>\n      <li><strong>Quality vs. Diversity Trade-off:</strong> While DDIMs can generate high-quality images like DDPMs, the lack of stochasticity in the reverse process might lead to less diversity in the generated samples.</li>\n    </ul>\n  </li>\n  <li><strong>Summary</strong>:\n    <ul>\n      <li>DDPM uses a stochastic process, adding random noise at each step of the reverse process, leading to high diversity in outputs. It requires more steps for sample generation, which makes it slower but excellent at generating high-quality diverse results.</li>\n      <li>DDIM employs a deterministic reverse process without introducing randomness in the generation phase. It allows for faster sampling with fewer steps and can generate consistent outputs but might lack the diversity seen in DDPM outputs.</li>\n    </ul>\n  </li>\n  <li>Both models represent advanced techniques in generative modeling, particularly for applications like image synthesis, where they can generate realistic and varied outputs. The choice between DDPM and DDIM depends on the specific requirements regarding diversity, computational resources, and generation speed.</li>\n</ul>\n<ul>\n      <li><strong>Basic Principle:</strong> DDPMs work by gradually adding noise to data over a series of steps, transforming the data into a Gaussian noise distribution. The model then learns to reverse this process, generating new data by denoising starting from noise.</li>\n      <li><strong>Markov Chain Process:</strong> The process involves a forward diffusion phase (adding noise) and a reverse diffusion phase (removing noise). Both phases are modeled as Markov chains.</li>\n      <li><strong>Stochastic Sampling:</strong> The reverse process in DDPMs is stochastic. This means that during the generation phase, random noise is introduced at each step, leading to variation in the outputs even if the process starts from the same noise.</li>\n      <li><strong>Sampling Time:</strong> DDPMs typically require a large number of steps to generate a sample, which can be computationally intensive and time-consuming.</li>\n      <li><strong>High-Quality Generation:</strong> DDPMs have been shown to generate high-quality samples that are often indistinguishable from real data, especially in the context of image generation.</li>\n    </ul>\n<ul>\n      <li><strong>Modified Sampling Process:</strong> DDIMs are a variant of DDPMs that modify the sampling process. They use a deterministic approach instead of a stochastic one.</li>\n      <li><strong>Deterministic Sampling:</strong> In DDIMs, the reverse process is deterministic, meaning no random noise is added during the generation phase. This leads to consistent outputs for the same starting point.</li>\n      <li><strong>Faster Sampling:</strong> Because of the deterministic nature and some modifications to the diffusion process, DDIMs can generate samples in fewer steps compared to traditional DDPMs.</li>\n      <li><strong>Flexibility in Time Steps:</strong> DDIMs offer more flexibility in choosing the number of timesteps, allowing for a trade-off between generation quality and computational efficiency.</li>\n      <li><strong>Quality vs. Diversity Trade-off:</strong> While DDIMs can generate high-quality images like DDPMs, the lack of stochasticity in the reverse process might lead to less diversity in the generated samples.</li>\n    </ul>\n<ul>\n      <li>DDPM uses a stochastic process, adding random noise at each step of the reverse process, leading to high diversity in outputs. It requires more steps for sample generation, which makes it slower but excellent at generating high-quality diverse results.</li>\n      <li>DDIM employs a deterministic reverse process without introducing randomness in the generation phase. It allows for faster sampling with fewer steps and can generate consistent outputs but might lack the diversity seen in DDPM outputs.</li>\n    </ul>",
      "contentMarkdown": "*   Denoising Diffusion Probabilistic Models (DDPMs) and Denoising Diffusion Implicit Models (DDIMs) are both types of diffusion models used in deep learning, particularly for generating high-quality, complex data such as images. While they share the same underlying principle of diffusion processes, there are key differences in their approach and characteristics.\n*   **Denoising Diffusion Probabilistic Models (DDPMs)**:\n    *   **Basic Principle:** DDPMs work by gradually adding noise to data over a series of steps, transforming the data into a Gaussian noise distribution. The model then learns to reverse this process, generating new data by denoising starting from noise.\n    *   **Markov Chain Process:** The process involves a forward diffusion phase (adding noise) and a reverse diffusion phase (removing noise). Both phases are modeled as Markov chains.\n    *   **Stochastic Sampling:** The reverse process in DDPMs is stochastic. This means that during the generation phase, random noise is introduced at each step, leading to variation in the outputs even if the process starts from the same noise.\n    *   **Sampling Time:** DDPMs typically require a large number of steps to generate a sample, which can be computationally intensive and time-consuming.\n    *   **High-Quality Generation:** DDPMs have been shown to generate high-quality samples that are often indistinguishable from real data, especially in the context of image generation.\n*   **Denoising Diffusion Implicit Models (DDIMs)**:\n    *   **Modified Sampling Process:** DDIMs are a variant of DDPMs that modify the sampling process. They use a deterministic approach instead of a stochastic one.\n    *   **Deterministic Sampling:** In DDIMs, the reverse process is deterministic, meaning no random noise is added during the generation phase. This leads to consistent outputs for the same starting point.\n    *   **Faster Sampling:** Because of the deterministic nature and some modifications to the diffusion process, DDIMs can generate samples in fewer steps compared to traditional DDPMs.\n    *   **Flexibility in Time Steps:** DDIMs offer more flexibility in choosing the number of timesteps, allowing for a trade-off between generation quality and computational efficiency.\n    *   **Quality vs. Diversity Trade-off:** While DDIMs can generate high-quality images like DDPMs, the lack of stochasticity in the reverse process might lead to less diversity in the generated samples.\n*   **Summary**:\n    *   DDPM uses a stochastic process, adding random noise at each step of the reverse process, leading to high diversity in outputs. It requires more steps for sample generation, which makes it slower but excellent at generating high-quality diverse results.\n    *   DDIM employs a deterministic reverse process without introducing randomness in the generation phase. It allows for faster sampling with fewer steps and can generate consistent outputs but might lack the diversity seen in DDPM outputs.\n*   Both models represent advanced techniques in generative modeling, particularly for applications like image synthesis, where they can generate realistic and varied outputs. The choice between DDPM and DDIM depends on the specific requirements regarding diversity, computational resources, and generation speed.\n\n*   **Basic Principle:** DDPMs work by gradually adding noise to data over a series of steps, transforming the data into a Gaussian noise distribution. The model then learns to reverse this process, generating new data by denoising starting from noise.\n*   **Markov Chain Process:** The process involves a forward diffusion phase (adding noise) and a reverse diffusion phase (removing noise). Both phases are modeled as Markov chains.\n*   **Stochastic Sampling:** The reverse process in DDPMs is stochastic. This means that during the generation phase, random noise is introduced at each step, leading to variation in the outputs even if the process starts from the same noise.\n*   **Sampling Time:** DDPMs typically require a large number of steps to generate a sample, which can be computationally intensive and time-consuming.\n*   **High-Quality Generation:** DDPMs have been shown to generate high-quality samples that are often indistinguishable from real data, especially in the context of image generation.\n\n*   **Modified Sampling Process:** DDIMs are a variant of DDPMs that modify the sampling process. They use a deterministic approach instead of a stochastic one.\n*   **Deterministic Sampling:** In DDIMs, the reverse process is deterministic, meaning no random noise is added during the generation phase. This leads to consistent outputs for the same starting point.\n*   **Faster Sampling:** Because of the deterministic nature and some modifications to the diffusion process, DDIMs can generate samples in fewer steps compared to traditional DDPMs.\n*   **Flexibility in Time Steps:** DDIMs offer more flexibility in choosing the number of timesteps, allowing for a trade-off between generation quality and computational efficiency.\n*   **Quality vs. Diversity Trade-off:** While DDIMs can generate high-quality images like DDPMs, the lack of stochasticity in the reverse process might lead to less diversity in the generated samples.\n\n*   DDPM uses a stochastic process, adding random noise at each step of the reverse process, leading to high diversity in outputs. It requires more steps for sample generation, which makes it slower but excellent at generating high-quality diverse results.\n*   DDIM employs a deterministic reverse process without introducing randomness in the generation phase. It allows for faster sampling with fewer steps and can generate consistent outputs but might lack the diversity seen in DDPM outputs.",
      "order": 81,
      "orderInChapter": 81,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "deep learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 835,
        "contentLength": 6413
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-tree-of-thought-pro-82",
        "ai-interview-what-is-mode-collapse-in-gans-83"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-concept-16",
        "ai-distributed-training-parallelism-conclusion-22",
        "ai-distributed-training-parallelism-concept-24",
        "ai-distributed-training-parallelism-conclusion-30",
        "ai-distributed-training-parallelism-summary-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-ddpm-and-ddim-models?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-tree-of-thought-pro-82",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Tree of Thought Prompting and Chain of Thought Prompting? Which is Better and Why?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>“Chain of Thought” prompting and “Tree of Thought” prompting are methods used to enhance the performance of large language models like GPT-3 or GPT-4, particularly on complex tasks that require multi-step reasoning or problem-solving.</li>\n  <li><strong>Chain of Thought Prompting</strong>\n    <ul>\n      <li><strong>Principle:</strong> In Chain of Thought prompting, the user writes out the intermediate steps or reasoning process that might lead to the answer. This approach helps the model to “think aloud” or follow a logical progression of steps to reach a conclusion.</li>\n      <li><strong>Usage:</strong> It’s particularly useful for complex problems like math word problems, where simply stating the problem doesn’t provide enough guidance for the model. By including a chain of reasoning, the model is encouraged to follow a similar step-by-step approach.</li>\n      <li><strong>Example:</strong> For a math problem, the prompt would include both the problem and a sequential, detailed explanation of how to solve it, guiding the model through the reasoning process.</li>\n    </ul>\n  </li>\n  <li><strong>Tree of Thought Prompting</strong>\n    <ul>\n      <li><strong>Principle:</strong> Tree of Thought prompting is a more sophisticated approach where multiple lines of reasoning are considered in parallel. It’s like creating a decision tree where each branch represents a different path of thought or a different aspect of the problem.</li>\n      <li><strong>Usage:</strong> This method is useful for problems where there might be multiple valid approaches or when the problem’s domain involves dealing with branching possibilities and outcomes.</li>\n      <li><strong>Example:</strong> In a complex scenario with multiple variables or possible outcomes, the prompt would include an exploration of these different paths, like considering different possible causes for a phenomenon in a scientific problem.</li>\n    </ul>\n  </li>\n  <li><strong>Comparison and Effectiveness</strong>\n    <ul>\n      <li><strong>Complexity:</strong> Tree of Thought is inherently more complex as it involves considering multiple lines of reasoning simultaneously. It’s more comprehensive but also more challenging to structure effectively.</li>\n      <li><strong>Applicability:</strong> Chain of Thought is generally more straightforward and can be applied to a wide range of problems, especially where a linear, step-by-step approach is beneficial. Tree of Thought is more suited to scenarios with branching possibilities, where multiple factors or outcomes must be considered.</li>\n      <li><strong>Efficiency:</strong> For simpler problems, Chain of Thought is usually more efficient, as it’s more direct. For more complex, multi-faceted problems, Tree of Thought may provide a more thorough exploration of the problem space.</li>\n      <li><strong>Which is Better?:</strong> The choice between them depends on the nature of the task. For most straightforward problem-solving tasks, Chain of Thought is sufficient and easier to manage. Tree of Thought is better suited for complex, multi-dimensional problems where different hypotheses or scenarios need to be evaluated.</li>\n    </ul>\n  </li>\n  <li>In summary, both methods aim to improve the reasoning capabilities of language models by guiding them through a more structured thought process. The choice of which to use should be based on the specific requirements of the problem at hand.</li>\n</ul>\n<ul>\n      <li><strong>Principle:</strong> In Chain of Thought prompting, the user writes out the intermediate steps or reasoning process that might lead to the answer. This approach helps the model to “think aloud” or follow a logical progression of steps to reach a conclusion.</li>\n      <li><strong>Usage:</strong> It’s particularly useful for complex problems like math word problems, where simply stating the problem doesn’t provide enough guidance for the model. By including a chain of reasoning, the model is encouraged to follow a similar step-by-step approach.</li>\n      <li><strong>Example:</strong> For a math problem, the prompt would include both the problem and a sequential, detailed explanation of how to solve it, guiding the model through the reasoning process.</li>\n    </ul>\n<ul>\n      <li><strong>Principle:</strong> Tree of Thought prompting is a more sophisticated approach where multiple lines of reasoning are considered in parallel. It’s like creating a decision tree where each branch represents a different path of thought or a different aspect of the problem.</li>\n      <li><strong>Usage:</strong> This method is useful for problems where there might be multiple valid approaches or when the problem’s domain involves dealing with branching possibilities and outcomes.</li>\n      <li><strong>Example:</strong> In a complex scenario with multiple variables or possible outcomes, the prompt would include an exploration of these different paths, like considering different possible causes for a phenomenon in a scientific problem.</li>\n    </ul>\n<ul>\n      <li><strong>Complexity:</strong> Tree of Thought is inherently more complex as it involves considering multiple lines of reasoning simultaneously. It’s more comprehensive but also more challenging to structure effectively.</li>\n      <li><strong>Applicability:</strong> Chain of Thought is generally more straightforward and can be applied to a wide range of problems, especially where a linear, step-by-step approach is beneficial. Tree of Thought is more suited to scenarios with branching possibilities, where multiple factors or outcomes must be considered.</li>\n      <li><strong>Efficiency:</strong> For simpler problems, Chain of Thought is usually more efficient, as it’s more direct. For more complex, multi-faceted problems, Tree of Thought may provide a more thorough exploration of the problem space.</li>\n      <li><strong>Which is Better?:</strong> The choice between them depends on the nature of the task. For most straightforward problem-solving tasks, Chain of Thought is sufficient and easier to manage. Tree of Thought is better suited for complex, multi-dimensional problems where different hypotheses or scenarios need to be evaluated.</li>\n    </ul>",
      "contentMarkdown": "*   “Chain of Thought” prompting and “Tree of Thought” prompting are methods used to enhance the performance of large language models like GPT-3 or GPT-4, particularly on complex tasks that require multi-step reasoning or problem-solving.\n*   **Chain of Thought Prompting**\n    *   **Principle:** In Chain of Thought prompting, the user writes out the intermediate steps or reasoning process that might lead to the answer. This approach helps the model to “think aloud” or follow a logical progression of steps to reach a conclusion.\n    *   **Usage:** It’s particularly useful for complex problems like math word problems, where simply stating the problem doesn’t provide enough guidance for the model. By including a chain of reasoning, the model is encouraged to follow a similar step-by-step approach.\n    *   **Example:** For a math problem, the prompt would include both the problem and a sequential, detailed explanation of how to solve it, guiding the model through the reasoning process.\n*   **Tree of Thought Prompting**\n    *   **Principle:** Tree of Thought prompting is a more sophisticated approach where multiple lines of reasoning are considered in parallel. It’s like creating a decision tree where each branch represents a different path of thought or a different aspect of the problem.\n    *   **Usage:** This method is useful for problems where there might be multiple valid approaches or when the problem’s domain involves dealing with branching possibilities and outcomes.\n    *   **Example:** In a complex scenario with multiple variables or possible outcomes, the prompt would include an exploration of these different paths, like considering different possible causes for a phenomenon in a scientific problem.\n*   **Comparison and Effectiveness**\n    *   **Complexity:** Tree of Thought is inherently more complex as it involves considering multiple lines of reasoning simultaneously. It’s more comprehensive but also more challenging to structure effectively.\n    *   **Applicability:** Chain of Thought is generally more straightforward and can be applied to a wide range of problems, especially where a linear, step-by-step approach is beneficial. Tree of Thought is more suited to scenarios with branching possibilities, where multiple factors or outcomes must be considered.\n    *   **Efficiency:** For simpler problems, Chain of Thought is usually more efficient, as it’s more direct. For more complex, multi-faceted problems, Tree of Thought may provide a more thorough exploration of the problem space.\n    *   **Which is Better?:** The choice between them depends on the nature of the task. For most straightforward problem-solving tasks, Chain of Thought is sufficient and easier to manage. Tree of Thought is better suited for complex, multi-dimensional problems where different hypotheses or scenarios need to be evaluated.\n*   In summary, both methods aim to improve the reasoning capabilities of language models by guiding them through a more structured thought process. The choice of which to use should be based on the specific requirements of the problem at hand.\n\n*   **Principle:** In Chain of Thought prompting, the user writes out the intermediate steps or reasoning process that might lead to the answer. This approach helps the model to “think aloud” or follow a logical progression of steps to reach a conclusion.\n*   **Usage:** It’s particularly useful for complex problems like math word problems, where simply stating the problem doesn’t provide enough guidance for the model. By including a chain of reasoning, the model is encouraged to follow a similar step-by-step approach.\n*   **Example:** For a math problem, the prompt would include both the problem and a sequential, detailed explanation of how to solve it, guiding the model through the reasoning process.\n\n*   **Principle:** Tree of Thought prompting is a more sophisticated approach where multiple lines of reasoning are considered in parallel. It’s like creating a decision tree where each branch represents a different path of thought or a different aspect of the problem.\n*   **Usage:** This method is useful for problems where there might be multiple valid approaches or when the problem’s domain involves dealing with branching possibilities and outcomes.\n*   **Example:** In a complex scenario with multiple variables or possible outcomes, the prompt would include an exploration of these different paths, like considering different possible causes for a phenomenon in a scientific problem.\n\n*   **Complexity:** Tree of Thought is inherently more complex as it involves considering multiple lines of reasoning simultaneously. It’s more comprehensive but also more challenging to structure effectively.\n*   **Applicability:** Chain of Thought is generally more straightforward and can be applied to a wide range of problems, especially where a linear, step-by-step approach is beneficial. Tree of Thought is more suited to scenarios with branching possibilities, where multiple factors or outcomes must be considered.\n*   **Efficiency:** For simpler problems, Chain of Thought is usually more efficient, as it’s more direct. For more complex, multi-faceted problems, Tree of Thought may provide a more thorough exploration of the problem space.\n*   **Which is Better?:** The choice between them depends on the nature of the task. For most straightforward problem-solving tasks, Chain of Thought is sufficient and easier to manage. Tree of Thought is better suited for complex, multi-dimensional problems where different hypotheses or scenarios need to be evaluated.",
      "order": 82,
      "orderInChapter": 82,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "gpt"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 832,
        "contentLength": 6217
      },
      "nextCards": [
        "ai-interview-what-is-mode-collapse-in-gans-83",
        "ai-interview-what-loss-functions-are-generally-used-in-gans-84"
      ],
      "relatedCards": [
        "ai-diffusion-models-continuous-time-diffusion-models-representation-ag-8",
        "ai-agents-implementing-agentic-rag-key-approaches-36",
        "ai-agents-babyagi-57",
        "ai-LLM-as-a-judge-cost-and-latency-advantages-31",
        "ai-visualChatGPT-handling-queries-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-tree-of-thought-prompting-and-chain-of-thought-prompting?-which-is-better-and-why?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-mode-collapse-in-gans-83",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Mode Collapse in GANs?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Mode collapse is a common issue in the training of Generative Adversarial Networks (GANs). Here’s a breakdown of what it is and why it happens:</li>\n  <li><strong>What is Mode Collapse?</strong>\n    <ul>\n      <li>In the context of GANs, “modes” refer to distinct features or patterns in the data distribution. For example, in a dataset of face images, different modes might represent different facial features or expressions.</li>\n      <li>Mode collapse occurs when the generator in a GAN starts producing a limited variety of outputs. Instead of capturing the full diversity of the training data (all modes), it focuses on a few modes or even a single mode. This means that the generator keeps producing similar or identical outputs.</li>\n    </ul>\n  </li>\n  <li><strong>Why Does Mode Collapse Happen?</strong>\n    <ul>\n      <li>GANs consist of two networks: a generator and a discriminator. The generator creates data, and the discriminator evaluates it. The goal of the generator is to produce data indistinguishable from real data, while the discriminator’s goal is to distinguish between real and generated data.</li>\n      <li>Mode collapse can occur when the generator finds a particular type of data that consistently fools the discriminator. Instead of continuing to explore and learn the full data distribution, the generator exploits this weakness in the discriminator by producing more of this specific type of data.</li>\n    </ul>\n  </li>\n  <li><strong>Consequences of Mode Collapse</strong>: The primary issue is a lack of diversity in the generated samples, which defeats the purpose of learning the entire distribution of the training data. This limits the utility and effectiveness of the GAN.</li>\n</ul>\n<ul>\n      <li>In the context of GANs, “modes” refer to distinct features or patterns in the data distribution. For example, in a dataset of face images, different modes might represent different facial features or expressions.</li>\n      <li>Mode collapse occurs when the generator in a GAN starts producing a limited variety of outputs. Instead of capturing the full diversity of the training data (all modes), it focuses on a few modes or even a single mode. This means that the generator keeps producing similar or identical outputs.</li>\n    </ul>\n<ul>\n      <li>GANs consist of two networks: a generator and a discriminator. The generator creates data, and the discriminator evaluates it. The goal of the generator is to produce data indistinguishable from real data, while the discriminator’s goal is to distinguish between real and generated data.</li>\n      <li>Mode collapse can occur when the generator finds a particular type of data that consistently fools the discriminator. Instead of continuing to explore and learn the full data distribution, the generator exploits this weakness in the discriminator by producing more of this specific type of data.</li>\n    </ul>",
      "contentMarkdown": "*   Mode collapse is a common issue in the training of Generative Adversarial Networks (GANs). Here’s a breakdown of what it is and why it happens:\n*   **What is Mode Collapse?**\n    *   In the context of GANs, “modes” refer to distinct features or patterns in the data distribution. For example, in a dataset of face images, different modes might represent different facial features or expressions.\n    *   Mode collapse occurs when the generator in a GAN starts producing a limited variety of outputs. Instead of capturing the full diversity of the training data (all modes), it focuses on a few modes or even a single mode. This means that the generator keeps producing similar or identical outputs.\n*   **Why Does Mode Collapse Happen?**\n    *   GANs consist of two networks: a generator and a discriminator. The generator creates data, and the discriminator evaluates it. The goal of the generator is to produce data indistinguishable from real data, while the discriminator’s goal is to distinguish between real and generated data.\n    *   Mode collapse can occur when the generator finds a particular type of data that consistently fools the discriminator. Instead of continuing to explore and learn the full data distribution, the generator exploits this weakness in the discriminator by producing more of this specific type of data.\n*   **Consequences of Mode Collapse**: The primary issue is a lack of diversity in the generated samples, which defeats the purpose of learning the entire distribution of the training data. This limits the utility and effectiveness of the GAN.\n\n*   In the context of GANs, “modes” refer to distinct features or patterns in the data distribution. For example, in a dataset of face images, different modes might represent different facial features or expressions.\n*   Mode collapse occurs when the generator in a GAN starts producing a limited variety of outputs. Instead of capturing the full diversity of the training data (all modes), it focuses on a few modes or even a single mode. This means that the generator keeps producing similar or identical outputs.\n\n*   GANs consist of two networks: a generator and a discriminator. The generator creates data, and the discriminator evaluates it. The goal of the generator is to produce data indistinguishable from real data, while the discriminator’s goal is to distinguish between real and generated data.\n*   Mode collapse can occur when the generator finds a particular type of data that consistently fools the discriminator. Instead of continuing to explore and learn the full data distribution, the generator exploits this weakness in the discriminator by producing more of this specific type of data.",
      "order": 83,
      "orderInChapter": 83,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 430,
        "contentLength": 2917
      },
      "nextCards": [
        "ai-interview-what-loss-functions-are-generally-used-in-gans-84",
        "ai-interview-what-are-some-transformer-specific-regularization--85"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-mode-collapse-in-gans?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-loss-functions-are-generally-used-in-gans-84",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What Loss Functions are Generally Used in GANs?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The choice of loss function in GANs can influence their training dynamics and the occurrence of issues like mode collapse. Commonly used loss functions include:\n    <ul>\n      <li><strong>Minimax (Non-Saturating) Loss:</strong> Originally proposed in the seminal GAN paper, it involves a minimax game where the discriminator tries to maximize the loss by correctly classifying real and fake data, while the generator tries to minimize it by fooling the discriminator. A modification of the minimax loss introduces a non-saturating loss term that addresses the issue of vanishing gradients early in training for the generator. It encourages the generator to produce data that the discriminator classifies as real.</li>\n      <li><strong>Wasserstein Loss (with Gradient Penalty):</strong> Introduced in Wasserstein GANs (WGANs), this loss function measures the Earth Mover’s distance between the real and generated data distributions. It often leads to more stable training and can help mitigate mode collapse. Gradient penalty is sometimes added to enforce a Lipschitz constraint, which further stabilizes training.</li>\n      <li><strong>Least Squares GAN Loss:</strong> In Least Squares GANs (LSGANs), the loss function is based on the least squares error, which penalizes samples that are far from the decision boundary of the discriminator. This can result in higher quality generated images.</li>\n      <li><strong>Hinge Loss:</strong> Used in some GAN variants, hinge loss can lead to faster and more stable training.</li>\n      <li><strong>Perceptual Loss:</strong> Sometimes used in combination with other loss functions, perceptual loss measures high-level perceptual and semantic differences between images, rather than pixel-level differences.</li>\n    </ul>\n  </li>\n  <li>Each of these loss functions has its strengths and weaknesses, and the choice often depends on the specific application and the nature of the data. Additionally, the design and training procedures of the GAN (e.g., architecture, learning rates, regularization) are also crucial in preventing issues like mode collapse.</li>\n</ul>\n<ul>\n      <li><strong>Minimax (Non-Saturating) Loss:</strong> Originally proposed in the seminal GAN paper, it involves a minimax game where the discriminator tries to maximize the loss by correctly classifying real and fake data, while the generator tries to minimize it by fooling the discriminator. A modification of the minimax loss introduces a non-saturating loss term that addresses the issue of vanishing gradients early in training for the generator. It encourages the generator to produce data that the discriminator classifies as real.</li>\n      <li><strong>Wasserstein Loss (with Gradient Penalty):</strong> Introduced in Wasserstein GANs (WGANs), this loss function measures the Earth Mover’s distance between the real and generated data distributions. It often leads to more stable training and can help mitigate mode collapse. Gradient penalty is sometimes added to enforce a Lipschitz constraint, which further stabilizes training.</li>\n      <li><strong>Least Squares GAN Loss:</strong> In Least Squares GANs (LSGANs), the loss function is based on the least squares error, which penalizes samples that are far from the decision boundary of the discriminator. This can result in higher quality generated images.</li>\n      <li><strong>Hinge Loss:</strong> Used in some GAN variants, hinge loss can lead to faster and more stable training.</li>\n      <li><strong>Perceptual Loss:</strong> Sometimes used in combination with other loss functions, perceptual loss measures high-level perceptual and semantic differences between images, rather than pixel-level differences.</li>\n    </ul>",
      "contentMarkdown": "*   The choice of loss function in GANs can influence their training dynamics and the occurrence of issues like mode collapse. Commonly used loss functions include:\n    *   **Minimax (Non-Saturating) Loss:** Originally proposed in the seminal GAN paper, it involves a minimax game where the discriminator tries to maximize the loss by correctly classifying real and fake data, while the generator tries to minimize it by fooling the discriminator. A modification of the minimax loss introduces a non-saturating loss term that addresses the issue of vanishing gradients early in training for the generator. It encourages the generator to produce data that the discriminator classifies as real.\n    *   **Wasserstein Loss (with Gradient Penalty):** Introduced in Wasserstein GANs (WGANs), this loss function measures the Earth Mover’s distance between the real and generated data distributions. It often leads to more stable training and can help mitigate mode collapse. Gradient penalty is sometimes added to enforce a Lipschitz constraint, which further stabilizes training.\n    *   **Least Squares GAN Loss:** In Least Squares GANs (LSGANs), the loss function is based on the least squares error, which penalizes samples that are far from the decision boundary of the discriminator. This can result in higher quality generated images.\n    *   **Hinge Loss:** Used in some GAN variants, hinge loss can lead to faster and more stable training.\n    *   **Perceptual Loss:** Sometimes used in combination with other loss functions, perceptual loss measures high-level perceptual and semantic differences between images, rather than pixel-level differences.\n*   Each of these loss functions has its strengths and weaknesses, and the choice often depends on the specific application and the nature of the data. Additionally, the design and training procedures of the GAN (e.g., architecture, learning rates, regularization) are also crucial in preventing issues like mode collapse.\n\n*   **Minimax (Non-Saturating) Loss:** Originally proposed in the seminal GAN paper, it involves a minimax game where the discriminator tries to maximize the loss by correctly classifying real and fake data, while the generator tries to minimize it by fooling the discriminator. A modification of the minimax loss introduces a non-saturating loss term that addresses the issue of vanishing gradients early in training for the generator. It encourages the generator to produce data that the discriminator classifies as real.\n*   **Wasserstein Loss (with Gradient Penalty):** Introduced in Wasserstein GANs (WGANs), this loss function measures the Earth Mover’s distance between the real and generated data distributions. It often leads to more stable training and can help mitigate mode collapse. Gradient penalty is sometimes added to enforce a Lipschitz constraint, which further stabilizes training.\n*   **Least Squares GAN Loss:** In Least Squares GANs (LSGANs), the loss function is based on the least squares error, which penalizes samples that are far from the decision boundary of the discriminator. This can result in higher quality generated images.\n*   **Hinge Loss:** Used in some GAN variants, hinge loss can lead to faster and more stable training.\n*   **Perceptual Loss:** Sometimes used in combination with other loss functions, perceptual loss measures high-level perceptual and semantic differences between images, rather than pixel-level differences.",
      "order": 84,
      "orderInChapter": 84,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "loss function",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 507,
        "contentLength": 3727
      },
      "nextCards": [
        "ai-interview-what-are-some-transformer-specific-regularization--85",
        "ai-interview-what-are-transformer-specific-normalization-method-86"
      ],
      "relatedCards": [
        "ai-diffusion-models-integration-with-mse-46",
        "ai-regularization-graphical-treatment-6",
        "ai-loss-mean-absolute-error-mae-l1-loss-9",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27",
        "ai-decision-trees-and-ensemble-methods-what-role-does-the-learning-rate-play-in-training--30"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-loss-functions-are-generally-used-in-gans?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-some-transformer-specific-regularization--85",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Some Transformer-specific Regularization Methods?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Transformers have become a cornerstone in modern deep learning, especially for natural language processing tasks. However, their large number of parameters and deep architectures make them prone to overfitting. To mitigate this, several regularization methods specifically suited for Transformers have been developed or adapted:\n    <ul>\n      <li><strong>Dropout:</strong>\n        <ul>\n          <li>Standard Dropout: Randomly sets a fraction of the input units to 0 at each update during training time, which helps prevent overfitting. In Transformers, dropout is often applied in the fully connected layers, the attention scores, or directly on the embeddings.</li>\n          <li>Attention Dropout: Applied specifically to the attention weights, encouraging the model to use a wider range of connections.</li>\n        </ul>\n      </li>\n      <li><strong>Label Smoothing:</strong> This technique involves modifying the target labels to be a mix of the correct label and a uniform distribution over other labels. It prevents the model from becoming too confident about its predictions, which can lead to improved generalization.</li>\n      <li><strong>Weight Decay (L2 Regularization):</strong> Adding an L2 penalty to the loss function encourages the weights to be small, which can prevent overfitting. This is often implemented as part of the optimizer (e.g., AdamW).</li>\n      <li><strong>Layer Normalization:</strong> Although primarily used for stabilizing the training process, layer normalization can also have a regularizing effect by controlling the scale of activations.</li>\n      <li><strong>Stochastic Depth and Layer Dropout:</strong> Randomly dropping entire layers (or residual connections) during training can prevent over-reliance on specific layers and promote redundancy in the network, leading to better generalization.</li>\n      <li><strong>Data Augmentation:</strong> While not a regularization technique in the traditional sense, data augmentation increases the effective size of the training dataset. For NLP, techniques like back-translation, word or sentence shuffling, or synonym replacement can be used.</li>\n      <li><strong>Early Stopping:</strong> Monitoring the model’s performance on a validation set and stopping training when performance stops improving can prevent overfitting.</li>\n      <li><strong>Gradient Clipping:</strong> Capping the gradients during backpropagation to a maximum value can prevent issues with exploding gradients, which can be a form of regularization.</li>\n      <li><strong>Temperature Scaling in Softmax:</strong> Adjusting the temperature parameter in the softmax function can control the sharpness of the distribution, which can indirectly act as a form of regularization.</li>\n      <li><strong>Reducing Model Size:</strong> Smaller models with fewer layers or hidden units are less prone to overfitting. Pruning or distillation are methods to reduce model size while trying to retain performance.</li>\n      <li><strong>Bayesian Techniques:</strong> Implementing Bayesian approaches to model some of the weights or layers in the Transformer. While more computationally intensive, it provides a probabilistic interpretation and can help in regularizing the model.</li>\n      <li><strong>Adversarial Training:</strong> Introducing small perturbations in the input (adversarial examples) and training the model to be robust against these can improve generalization.</li>\n      <li><strong>Sparse Attention Mechanisms:</strong> Rather than attending to all tokens in a sequence, sparse attention mechanisms focus on a subset, which can reduce overfitting by preventing the model from relying too heavily on specific parts of the input.</li>\n    </ul>\n  </li>\n  <li>Each of these methods has its own merits and can be more or less effective depending on the specific application, the size of the dataset, and the particular architecture of the Transformer model being used. In practice, a combination of several of these techniques is often employed to achieve the best results.</li>\n</ul>\n<ul>\n      <li><strong>Dropout:</strong>\n        <ul>\n          <li>Standard Dropout: Randomly sets a fraction of the input units to 0 at each update during training time, which helps prevent overfitting. In Transformers, dropout is often applied in the fully connected layers, the attention scores, or directly on the embeddings.</li>\n          <li>Attention Dropout: Applied specifically to the attention weights, encouraging the model to use a wider range of connections.</li>\n        </ul>\n      </li>\n      <li><strong>Label Smoothing:</strong> This technique involves modifying the target labels to be a mix of the correct label and a uniform distribution over other labels. It prevents the model from becoming too confident about its predictions, which can lead to improved generalization.</li>\n      <li><strong>Weight Decay (L2 Regularization):</strong> Adding an L2 penalty to the loss function encourages the weights to be small, which can prevent overfitting. This is often implemented as part of the optimizer (e.g., AdamW).</li>\n      <li><strong>Layer Normalization:</strong> Although primarily used for stabilizing the training process, layer normalization can also have a regularizing effect by controlling the scale of activations.</li>\n      <li><strong>Stochastic Depth and Layer Dropout:</strong> Randomly dropping entire layers (or residual connections) during training can prevent over-reliance on specific layers and promote redundancy in the network, leading to better generalization.</li>\n      <li><strong>Data Augmentation:</strong> While not a regularization technique in the traditional sense, data augmentation increases the effective size of the training dataset. For NLP, techniques like back-translation, word or sentence shuffling, or synonym replacement can be used.</li>\n      <li><strong>Early Stopping:</strong> Monitoring the model’s performance on a validation set and stopping training when performance stops improving can prevent overfitting.</li>\n      <li><strong>Gradient Clipping:</strong> Capping the gradients during backpropagation to a maximum value can prevent issues with exploding gradients, which can be a form of regularization.</li>\n      <li><strong>Temperature Scaling in Softmax:</strong> Adjusting the temperature parameter in the softmax function can control the sharpness of the distribution, which can indirectly act as a form of regularization.</li>\n      <li><strong>Reducing Model Size:</strong> Smaller models with fewer layers or hidden units are less prone to overfitting. Pruning or distillation are methods to reduce model size while trying to retain performance.</li>\n      <li><strong>Bayesian Techniques:</strong> Implementing Bayesian approaches to model some of the weights or layers in the Transformer. While more computationally intensive, it provides a probabilistic interpretation and can help in regularizing the model.</li>\n      <li><strong>Adversarial Training:</strong> Introducing small perturbations in the input (adversarial examples) and training the model to be robust against these can improve generalization.</li>\n      <li><strong>Sparse Attention Mechanisms:</strong> Rather than attending to all tokens in a sequence, sparse attention mechanisms focus on a subset, which can reduce overfitting by preventing the model from relying too heavily on specific parts of the input.</li>\n    </ul>\n<ul>\n          <li>Standard Dropout: Randomly sets a fraction of the input units to 0 at each update during training time, which helps prevent overfitting. In Transformers, dropout is often applied in the fully connected layers, the attention scores, or directly on the embeddings.</li>\n          <li>Attention Dropout: Applied specifically to the attention weights, encouraging the model to use a wider range of connections.</li>\n        </ul>",
      "contentMarkdown": "*   Transformers have become a cornerstone in modern deep learning, especially for natural language processing tasks. However, their large number of parameters and deep architectures make them prone to overfitting. To mitigate this, several regularization methods specifically suited for Transformers have been developed or adapted:\n    *   **Dropout:**\n        *   Standard Dropout: Randomly sets a fraction of the input units to 0 at each update during training time, which helps prevent overfitting. In Transformers, dropout is often applied in the fully connected layers, the attention scores, or directly on the embeddings.\n        *   Attention Dropout: Applied specifically to the attention weights, encouraging the model to use a wider range of connections.\n    *   **Label Smoothing:** This technique involves modifying the target labels to be a mix of the correct label and a uniform distribution over other labels. It prevents the model from becoming too confident about its predictions, which can lead to improved generalization.\n    *   **Weight Decay (L2 Regularization):** Adding an L2 penalty to the loss function encourages the weights to be small, which can prevent overfitting. This is often implemented as part of the optimizer (e.g., AdamW).\n    *   **Layer Normalization:** Although primarily used for stabilizing the training process, layer normalization can also have a regularizing effect by controlling the scale of activations.\n    *   **Stochastic Depth and Layer Dropout:** Randomly dropping entire layers (or residual connections) during training can prevent over-reliance on specific layers and promote redundancy in the network, leading to better generalization.\n    *   **Data Augmentation:** While not a regularization technique in the traditional sense, data augmentation increases the effective size of the training dataset. For NLP, techniques like back-translation, word or sentence shuffling, or synonym replacement can be used.\n    *   **Early Stopping:** Monitoring the model’s performance on a validation set and stopping training when performance stops improving can prevent overfitting.\n    *   **Gradient Clipping:** Capping the gradients during backpropagation to a maximum value can prevent issues with exploding gradients, which can be a form of regularization.\n    *   **Temperature Scaling in Softmax:** Adjusting the temperature parameter in the softmax function can control the sharpness of the distribution, which can indirectly act as a form of regularization.\n    *   **Reducing Model Size:** Smaller models with fewer layers or hidden units are less prone to overfitting. Pruning or distillation are methods to reduce model size while trying to retain performance.\n    *   **Bayesian Techniques:** Implementing Bayesian approaches to model some of the weights or layers in the Transformer. While more computationally intensive, it provides a probabilistic interpretation and can help in regularizing the model.\n    *   **Adversarial Training:** Introducing small perturbations in the input (adversarial examples) and training the model to be robust against these can improve generalization.\n    *   **Sparse Attention Mechanisms:** Rather than attending to all tokens in a sequence, sparse attention mechanisms focus on a subset, which can reduce overfitting by preventing the model from relying too heavily on specific parts of the input.\n*   Each of these methods has its own merits and can be more or less effective depending on the specific application, the size of the dataset, and the particular architecture of the Transformer model being used. In practice, a combination of several of these techniques is often employed to achieve the best results.\n\n*   **Dropout:**\n    *   Standard Dropout: Randomly sets a fraction of the input units to 0 at each update during training time, which helps prevent overfitting. In Transformers, dropout is often applied in the fully connected layers, the attention scores, or directly on the embeddings.\n    *   Attention Dropout: Applied specifically to the attention weights, encouraging the model to use a wider range of connections.\n*   **Label Smoothing:** This technique involves modifying the target labels to be a mix of the correct label and a uniform distribution over other labels. It prevents the model from becoming too confident about its predictions, which can lead to improved generalization.\n*   **Weight Decay (L2 Regularization):** Adding an L2 penalty to the loss function encourages the weights to be small, which can prevent overfitting. This is often implemented as part of the optimizer (e.g., AdamW).\n*   **Layer Normalization:** Although primarily used for stabilizing the training process, layer normalization can also have a regularizing effect by controlling the scale of activations.\n*   **Stochastic Depth and Layer Dropout:** Randomly dropping entire layers (or residual connections) during training can prevent over-reliance on specific layers and promote redundancy in the network, leading to better generalization.\n*   **Data Augmentation:** While not a regularization technique in the traditional sense, data augmentation increases the effective size of the training dataset. For NLP, techniques like back-translation, word or sentence shuffling, or synonym replacement can be used.\n*   **Early Stopping:** Monitoring the model’s performance on a validation set and stopping training when performance stops improving can prevent overfitting.\n*   **Gradient Clipping:** Capping the gradients during backpropagation to a maximum value can prevent issues with exploding gradients, which can be a form of regularization.\n*   **Temperature Scaling in Softmax:** Adjusting the temperature parameter in the softmax function can control the sharpness of the distribution, which can indirectly act as a form of regularization.\n*   **Reducing Model Size:** Smaller models with fewer layers or hidden units are less prone to overfitting. Pruning or distillation are methods to reduce model size while trying to retain performance.\n*   **Bayesian Techniques:** Implementing Bayesian approaches to model some of the weights or layers in the Transformer. While more computationally intensive, it provides a probabilistic interpretation and can help in regularizing the model.\n*   **Adversarial Training:** Introducing small perturbations in the input (adversarial examples) and training the model to be robust against these can improve generalization.\n*   **Sparse Attention Mechanisms:** Rather than attending to all tokens in a sequence, sparse attention mechanisms focus on a subset, which can reduce overfitting by preventing the model from relying too heavily on specific parts of the input.\n\n*   Standard Dropout: Randomly sets a fraction of the input units to 0 at each update during training time, which helps prevent overfitting. In Transformers, dropout is often applied in the fully connected layers, the attention scores, or directly on the embeddings.\n*   Attention Dropout: Applied specifically to the attention weights, encouraging the model to use a wider range of connections.",
      "order": 85,
      "orderInChapter": 85,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "deep learning",
        "transformer",
        "attention",
        "embedding",
        "nlp",
        "backpropagation",
        "loss function"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1023,
        "contentLength": 7898
      },
      "nextCards": [
        "ai-interview-what-are-transformer-specific-normalization-method-86",
        "ai-interview-what-is-curriculum-training-what-does-it-do-to-the-87"
      ],
      "relatedCards": [
        "ai-diffusion-models-implementing-the-original-paper-34",
        "ai-model-compression-compute-vs-memory-bottlenecks-12",
        "ai-diffusion-models-how-do-you-condition-a-diffusion-model-to-the-text-49",
        "ai-diffusion-models-in-the-context-of-diffusion-models-what-role-does--50",
        "ai-attention-linear-attention-13"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-transformer-specific-regularization-methods?",
      "scrapedAt": "2025-12-28T11:58:12.839Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-transformer-specific-normalization-method-86",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Transformer Specific Normalization Methods?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Transformers, particularly in the context of natural language processing, use specific normalization methods to stabilize and accelerate training. Normalization in deep learning models is crucial for controlling the scale of inputs, weights, or activations, which in turn helps in mitigating issues like vanishing or exploding gradients. For Transformer architectures, the following normalization methods are commonly used:</p>\n  </li>\n  <li><strong>Layer Normalization:</strong>\n    <ul>\n      <li><strong>Principle:</strong> Unlike batch normalization, which normalizes across the batch dimension, layer normalization performs normalization across the features. For each data point in a mini-batch, it computes the mean and standard deviation used for normalization across all features.</li>\n      <li><strong>Application in Transformers:</strong> Layer normalization is typically applied just before the self-attention layer and the feed-forward neural network, as well as after the residual connection (i.e., adding the normalized output to the original input of the block).</li>\n    </ul>\n  </li>\n  <li><strong>Post-Layer Normalization:</strong>\n    <ul>\n      <li><strong>Variation:</strong> In some Transformer models, layer normalization is applied after the residual connection (hence post-layer normalization), which has been found to be effective in stabilizing training in some scenarios.</li>\n      <li><strong>Impact:</strong> This slight modification in the position of the layer normalization can impact training dynamics and model performance.</li>\n    </ul>\n  </li>\n  <li><strong>Pre-Layer Normalization:</strong>\n    <ul>\n      <li><strong>Alternate Approach:</strong> In contrast to post-layer normalization, pre-layer normalization applies the normalization before the residual connection and the self-attention or feed-forward layers.\nBenefits: This approach has been observed to provide more stable training for Transformers, especially in deeper models or models trained with larger learning rates.</li>\n    </ul>\n  </li>\n  <li><strong>Scale Normalization:</strong>\n    <ul>\n      <li><strong>Additional Technique:</strong> Sometimes used in conjunction with layer normalization, scale normalization involves scaling down the weights of the self-attention layers. This can help in managing the magnitude of the outputs in these layers, contributing to more stable training.</li>\n    </ul>\n  </li>\n  <li><strong>Batch Normalization:</strong>\n    <ul>\n      <li><strong>Less Common in Transformers:</strong> While batch normalization is widely used in CNNs, it’s less common in Transformers due to the dynamic nature of sequence lengths and the batch-wise computation it requires. However, it has been explored in some Transformer variants.</li>\n    </ul>\n  </li>\n  <li><strong>Weight Normalization:</strong>\n    <ul>\n      <li><strong>Alternative Approach:</strong> Weight normalization is another technique that decouples the length of the weight vector from its direction. It’s not as commonly used in standard Transformer models but can be considered in custom architectures.</li>\n    </ul>\n  </li>\n  <li><strong>RMSNorm:</strong>\n    <ul>\n      <li><strong>Variant of Layer Norm:</strong> RMSNorm is a simplified version of layer normalization that normalizes the activations by their root mean square (RMS). It omits the bias and gain parameters of layer normalization, potentially simplifying the training process.</li>\n    </ul>\n  </li>\n  <li><strong>Power Normalization:</strong>\n    <ul>\n      <li><strong>Emerging Approach:</strong> Power normalization is an alternative to layer normalization that stabilizes the second-order moments of the activations. It’s a relatively new approach and is being explored in the context of Transformer models.</li>\n    </ul>\n  </li>\n  <li>The choice of normalization method can significantly affect the training efficiency and final performance of Transformer models. Layer normalization and its variants (pre and post) are currently the most widely used due to their effectiveness in handling variable sequence lengths and their compatibility with the Transformer architecture’s requirements.</li>\n</ul>\n<p>Transformers, particularly in the context of natural language processing, use specific normalization methods to stabilize and accelerate training. Normalization in deep learning models is crucial for controlling the scale of inputs, weights, or activations, which in turn helps in mitigating issues like vanishing or exploding gradients. For Transformer architectures, the following normalization methods are commonly used:</p>\n<ul>\n      <li><strong>Principle:</strong> Unlike batch normalization, which normalizes across the batch dimension, layer normalization performs normalization across the features. For each data point in a mini-batch, it computes the mean and standard deviation used for normalization across all features.</li>\n      <li><strong>Application in Transformers:</strong> Layer normalization is typically applied just before the self-attention layer and the feed-forward neural network, as well as after the residual connection (i.e., adding the normalized output to the original input of the block).</li>\n    </ul>\n<ul>\n      <li><strong>Variation:</strong> In some Transformer models, layer normalization is applied after the residual connection (hence post-layer normalization), which has been found to be effective in stabilizing training in some scenarios.</li>\n      <li><strong>Impact:</strong> This slight modification in the position of the layer normalization can impact training dynamics and model performance.</li>\n    </ul>\n<ul>\n      <li><strong>Alternate Approach:</strong> In contrast to post-layer normalization, pre-layer normalization applies the normalization before the residual connection and the self-attention or feed-forward layers.\nBenefits: This approach has been observed to provide more stable training for Transformers, especially in deeper models or models trained with larger learning rates.</li>\n    </ul>\n<ul>\n      <li><strong>Additional Technique:</strong> Sometimes used in conjunction with layer normalization, scale normalization involves scaling down the weights of the self-attention layers. This can help in managing the magnitude of the outputs in these layers, contributing to more stable training.</li>\n    </ul>\n<ul>\n      <li><strong>Less Common in Transformers:</strong> While batch normalization is widely used in CNNs, it’s less common in Transformers due to the dynamic nature of sequence lengths and the batch-wise computation it requires. However, it has been explored in some Transformer variants.</li>\n    </ul>\n<ul>\n      <li><strong>Alternative Approach:</strong> Weight normalization is another technique that decouples the length of the weight vector from its direction. It’s not as commonly used in standard Transformer models but can be considered in custom architectures.</li>\n    </ul>\n<ul>\n      <li><strong>Variant of Layer Norm:</strong> RMSNorm is a simplified version of layer normalization that normalizes the activations by their root mean square (RMS). It omits the bias and gain parameters of layer normalization, potentially simplifying the training process.</li>\n    </ul>\n<ul>\n      <li><strong>Emerging Approach:</strong> Power normalization is an alternative to layer normalization that stabilizes the second-order moments of the activations. It’s a relatively new approach and is being explored in the context of Transformer models.</li>\n    </ul>",
      "contentMarkdown": "*   Transformers, particularly in the context of natural language processing, use specific normalization methods to stabilize and accelerate training. Normalization in deep learning models is crucial for controlling the scale of inputs, weights, or activations, which in turn helps in mitigating issues like vanishing or exploding gradients. For Transformer architectures, the following normalization methods are commonly used:\n    \n*   **Layer Normalization:**\n    *   **Principle:** Unlike batch normalization, which normalizes across the batch dimension, layer normalization performs normalization across the features. For each data point in a mini-batch, it computes the mean and standard deviation used for normalization across all features.\n    *   **Application in Transformers:** Layer normalization is typically applied just before the self-attention layer and the feed-forward neural network, as well as after the residual connection (i.e., adding the normalized output to the original input of the block).\n*   **Post-Layer Normalization:**\n    *   **Variation:** In some Transformer models, layer normalization is applied after the residual connection (hence post-layer normalization), which has been found to be effective in stabilizing training in some scenarios.\n    *   **Impact:** This slight modification in the position of the layer normalization can impact training dynamics and model performance.\n*   **Pre-Layer Normalization:**\n    *   **Alternate Approach:** In contrast to post-layer normalization, pre-layer normalization applies the normalization before the residual connection and the self-attention or feed-forward layers. Benefits: This approach has been observed to provide more stable training for Transformers, especially in deeper models or models trained with larger learning rates.\n*   **Scale Normalization:**\n    *   **Additional Technique:** Sometimes used in conjunction with layer normalization, scale normalization involves scaling down the weights of the self-attention layers. This can help in managing the magnitude of the outputs in these layers, contributing to more stable training.\n*   **Batch Normalization:**\n    *   **Less Common in Transformers:** While batch normalization is widely used in CNNs, it’s less common in Transformers due to the dynamic nature of sequence lengths and the batch-wise computation it requires. However, it has been explored in some Transformer variants.\n*   **Weight Normalization:**\n    *   **Alternative Approach:** Weight normalization is another technique that decouples the length of the weight vector from its direction. It’s not as commonly used in standard Transformer models but can be considered in custom architectures.\n*   **RMSNorm:**\n    *   **Variant of Layer Norm:** RMSNorm is a simplified version of layer normalization that normalizes the activations by their root mean square (RMS). It omits the bias and gain parameters of layer normalization, potentially simplifying the training process.\n*   **Power Normalization:**\n    *   **Emerging Approach:** Power normalization is an alternative to layer normalization that stabilizes the second-order moments of the activations. It’s a relatively new approach and is being explored in the context of Transformer models.\n*   The choice of normalization method can significantly affect the training efficiency and final performance of Transformer models. Layer normalization and its variants (pre and post) are currently the most widely used due to their effectiveness in handling variable sequence lengths and their compatibility with the Transformer architecture’s requirements.\n\nTransformers, particularly in the context of natural language processing, use specific normalization methods to stabilize and accelerate training. Normalization in deep learning models is crucial for controlling the scale of inputs, weights, or activations, which in turn helps in mitigating issues like vanishing or exploding gradients. For Transformer architectures, the following normalization methods are commonly used:\n\n*   **Principle:** Unlike batch normalization, which normalizes across the batch dimension, layer normalization performs normalization across the features. For each data point in a mini-batch, it computes the mean and standard deviation used for normalization across all features.\n*   **Application in Transformers:** Layer normalization is typically applied just before the self-attention layer and the feed-forward neural network, as well as after the residual connection (i.e., adding the normalized output to the original input of the block).\n\n*   **Variation:** In some Transformer models, layer normalization is applied after the residual connection (hence post-layer normalization), which has been found to be effective in stabilizing training in some scenarios.\n*   **Impact:** This slight modification in the position of the layer normalization can impact training dynamics and model performance.\n\n*   **Alternate Approach:** In contrast to post-layer normalization, pre-layer normalization applies the normalization before the residual connection and the self-attention or feed-forward layers. Benefits: This approach has been observed to provide more stable training for Transformers, especially in deeper models or models trained with larger learning rates.\n\n*   **Additional Technique:** Sometimes used in conjunction with layer normalization, scale normalization involves scaling down the weights of the self-attention layers. This can help in managing the magnitude of the outputs in these layers, contributing to more stable training.\n\n*   **Less Common in Transformers:** While batch normalization is widely used in CNNs, it’s less common in Transformers due to the dynamic nature of sequence lengths and the batch-wise computation it requires. However, it has been explored in some Transformer variants.\n\n*   **Alternative Approach:** Weight normalization is another technique that decouples the length of the weight vector from its direction. It’s not as commonly used in standard Transformer models but can be considered in custom architectures.\n\n*   **Variant of Layer Norm:** RMSNorm is a simplified version of layer normalization that normalizes the activations by their root mean square (RMS). It omits the bias and gain parameters of layer normalization, potentially simplifying the training process.\n\n*   **Emerging Approach:** Power normalization is an alternative to layer normalization that stabilizes the second-order moments of the activations. It’s a relatively new approach and is being explored in the context of Transformer models.",
      "order": 86,
      "orderInChapter": 86,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "transformer",
        "attention",
        "cnn",
        "activation",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 903,
        "contentLength": 7543
      },
      "nextCards": [
        "ai-interview-what-is-curriculum-training-what-does-it-do-to-the-87",
        "ai-interview-what-are-types-of-ensemble-models-why-do-they-perf-88"
      ],
      "relatedCards": [
        "ai-transformers-transformer-core-5",
        "ai-mixture-of-experts-relation-to-straight-through-estimators-34",
        "ai-model-acceleration-operator-fusion-12",
        "ai-model-compression-how-mixed-precision-training-works-41",
        "ai-diffusion-models-patch-n-pack-navit-a-vision-transformer-for-any-as-62"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-transformer-specific-normalization-methods?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-curriculum-training-what-does-it-do-to-the-87",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Curriculum Training? What Does It Do to the Loss Surface?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Curriculum learning is a training strategy in machine learning inspired by the way humans learn progressively, starting from simpler concepts and gradually moving to more complex ones. This concept was introduced by Bengio et al. and is based on the idea that starting training with easier examples and gradually increasing the difficulty can improve both the speed and effectiveness of the learning process.</li>\n  <li>How Curriculum Training Works\n    <ul>\n      <li><strong>Sorting Training Examples:</strong> Initially, you sort or group the training examples based on their difficulty. What constitutes “difficulty” can vary depending on the task (e.g., the length of sentences in language tasks, the clarity of images in vision tasks).</li>\n      <li><strong>Gradual Complexity Increase:</strong> Training begins with the simplest examples. As the model’s performance improves, more complex examples are gradually introduced into the training process.</li>\n      <li><strong>Dynamic Adjustment:</strong> The pace at which complexity is increased can be dynamic, based on the model’s current performance and learning rate.</li>\n    </ul>\n  </li>\n  <li>Impact on the Loss Surface\n    <ul>\n      <li>Curriculum learning can have several impacts on the loss surface and the optimization process:</li>\n      <li><strong>Smoothing the Loss Landscape:</strong> Starting with simpler examples can smooth out the loss landscape initially, making it easier for the optimization algorithm (like gradient descent) to find a good path towards the minima.</li>\n      <li><strong>Avoiding Local Minima:</strong> By simplifying the early stages of training, the model may avoid getting stuck in local minima that are more common in complex, high-dimensional loss surfaces.</li>\n      <li><strong>Better Generalization:</strong> There is evidence suggesting that curriculum learning can lead to solutions that generalize better to unseen data. This could be because the model first learns broad, general patterns before fine-tuning on more complex and specific features.</li>\n      <li><strong>Faster Convergence:</strong> It can accelerate the training process, as the model initially works with less complex data, allowing for quicker improvements in performance.</li>\n      <li><strong>Guided Feature Learning:</strong> In the context of deep learning, starting with simpler tasks can guide the model to learn foundational features first, which can be built upon with more complex features as training progresses.</li>\n    </ul>\n  </li>\n  <li>Applications and Variations\n    <ul>\n      <li><strong>Curriculum Learning in NLP:</strong> For language models, curriculum learning might involve starting with shorter or simpler sentences before introducing longer or more complex syntax.</li>\n      <li><strong>In Computer Vision:</strong> Begin with clearer, easier-to-classify images, and then gradually introduce images with more noise or ambiguity.</li>\n      <li><strong>Self-Paced Learning:</strong> A variant where the model itself helps to determine the sequence of training examples based on its current performance.</li>\n      <li><strong>Task-Level Curriculum:</strong> Involves starting with easier tasks and gradually moving to harder tasks, which is particularly relevant in multi-task learning scenarios.</li>\n    </ul>\n  </li>\n  <li>In summary, curriculum learning reshapes the training process to make it more efficient and effective, potentially leading to smoother optimization paths and better generalization. However, designing an effective curriculum requires domain knowledge and understanding of what constitutes “easy” and “difficult” examples in the context of the specific problem being addressed.</li>\n</ul>\n<ul>\n      <li><strong>Sorting Training Examples:</strong> Initially, you sort or group the training examples based on their difficulty. What constitutes “difficulty” can vary depending on the task (e.g., the length of sentences in language tasks, the clarity of images in vision tasks).</li>\n      <li><strong>Gradual Complexity Increase:</strong> Training begins with the simplest examples. As the model’s performance improves, more complex examples are gradually introduced into the training process.</li>\n      <li><strong>Dynamic Adjustment:</strong> The pace at which complexity is increased can be dynamic, based on the model’s current performance and learning rate.</li>\n    </ul>\n<ul>\n      <li>Curriculum learning can have several impacts on the loss surface and the optimization process:</li>\n      <li><strong>Smoothing the Loss Landscape:</strong> Starting with simpler examples can smooth out the loss landscape initially, making it easier for the optimization algorithm (like gradient descent) to find a good path towards the minima.</li>\n      <li><strong>Avoiding Local Minima:</strong> By simplifying the early stages of training, the model may avoid getting stuck in local minima that are more common in complex, high-dimensional loss surfaces.</li>\n      <li><strong>Better Generalization:</strong> There is evidence suggesting that curriculum learning can lead to solutions that generalize better to unseen data. This could be because the model first learns broad, general patterns before fine-tuning on more complex and specific features.</li>\n      <li><strong>Faster Convergence:</strong> It can accelerate the training process, as the model initially works with less complex data, allowing for quicker improvements in performance.</li>\n      <li><strong>Guided Feature Learning:</strong> In the context of deep learning, starting with simpler tasks can guide the model to learn foundational features first, which can be built upon with more complex features as training progresses.</li>\n    </ul>\n<ul>\n      <li><strong>Curriculum Learning in NLP:</strong> For language models, curriculum learning might involve starting with shorter or simpler sentences before introducing longer or more complex syntax.</li>\n      <li><strong>In Computer Vision:</strong> Begin with clearer, easier-to-classify images, and then gradually introduce images with more noise or ambiguity.</li>\n      <li><strong>Self-Paced Learning:</strong> A variant where the model itself helps to determine the sequence of training examples based on its current performance.</li>\n      <li><strong>Task-Level Curriculum:</strong> Involves starting with easier tasks and gradually moving to harder tasks, which is particularly relevant in multi-task learning scenarios.</li>\n    </ul>",
      "contentMarkdown": "*   Curriculum learning is a training strategy in machine learning inspired by the way humans learn progressively, starting from simpler concepts and gradually moving to more complex ones. This concept was introduced by Bengio et al. and is based on the idea that starting training with easier examples and gradually increasing the difficulty can improve both the speed and effectiveness of the learning process.\n*   How Curriculum Training Works\n    *   **Sorting Training Examples:** Initially, you sort or group the training examples based on their difficulty. What constitutes “difficulty” can vary depending on the task (e.g., the length of sentences in language tasks, the clarity of images in vision tasks).\n    *   **Gradual Complexity Increase:** Training begins with the simplest examples. As the model’s performance improves, more complex examples are gradually introduced into the training process.\n    *   **Dynamic Adjustment:** The pace at which complexity is increased can be dynamic, based on the model’s current performance and learning rate.\n*   Impact on the Loss Surface\n    *   Curriculum learning can have several impacts on the loss surface and the optimization process:\n    *   **Smoothing the Loss Landscape:** Starting with simpler examples can smooth out the loss landscape initially, making it easier for the optimization algorithm (like gradient descent) to find a good path towards the minima.\n    *   **Avoiding Local Minima:** By simplifying the early stages of training, the model may avoid getting stuck in local minima that are more common in complex, high-dimensional loss surfaces.\n    *   **Better Generalization:** There is evidence suggesting that curriculum learning can lead to solutions that generalize better to unseen data. This could be because the model first learns broad, general patterns before fine-tuning on more complex and specific features.\n    *   **Faster Convergence:** It can accelerate the training process, as the model initially works with less complex data, allowing for quicker improvements in performance.\n    *   **Guided Feature Learning:** In the context of deep learning, starting with simpler tasks can guide the model to learn foundational features first, which can be built upon with more complex features as training progresses.\n*   Applications and Variations\n    *   **Curriculum Learning in NLP:** For language models, curriculum learning might involve starting with shorter or simpler sentences before introducing longer or more complex syntax.\n    *   **In Computer Vision:** Begin with clearer, easier-to-classify images, and then gradually introduce images with more noise or ambiguity.\n    *   **Self-Paced Learning:** A variant where the model itself helps to determine the sequence of training examples based on its current performance.\n    *   **Task-Level Curriculum:** Involves starting with easier tasks and gradually moving to harder tasks, which is particularly relevant in multi-task learning scenarios.\n*   In summary, curriculum learning reshapes the training process to make it more efficient and effective, potentially leading to smoother optimization paths and better generalization. However, designing an effective curriculum requires domain knowledge and understanding of what constitutes “easy” and “difficult” examples in the context of the specific problem being addressed.\n\n*   **Sorting Training Examples:** Initially, you sort or group the training examples based on their difficulty. What constitutes “difficulty” can vary depending on the task (e.g., the length of sentences in language tasks, the clarity of images in vision tasks).\n*   **Gradual Complexity Increase:** Training begins with the simplest examples. As the model’s performance improves, more complex examples are gradually introduced into the training process.\n*   **Dynamic Adjustment:** The pace at which complexity is increased can be dynamic, based on the model’s current performance and learning rate.\n\n*   Curriculum learning can have several impacts on the loss surface and the optimization process:\n*   **Smoothing the Loss Landscape:** Starting with simpler examples can smooth out the loss landscape initially, making it easier for the optimization algorithm (like gradient descent) to find a good path towards the minima.\n*   **Avoiding Local Minima:** By simplifying the early stages of training, the model may avoid getting stuck in local minima that are more common in complex, high-dimensional loss surfaces.\n*   **Better Generalization:** There is evidence suggesting that curriculum learning can lead to solutions that generalize better to unseen data. This could be because the model first learns broad, general patterns before fine-tuning on more complex and specific features.\n*   **Faster Convergence:** It can accelerate the training process, as the model initially works with less complex data, allowing for quicker improvements in performance.\n*   **Guided Feature Learning:** In the context of deep learning, starting with simpler tasks can guide the model to learn foundational features first, which can be built upon with more complex features as training progresses.\n\n*   **Curriculum Learning in NLP:** For language models, curriculum learning might involve starting with shorter or simpler sentences before introducing longer or more complex syntax.\n*   **In Computer Vision:** Begin with clearer, easier-to-classify images, and then gradually introduce images with more noise or ambiguity.\n*   **Self-Paced Learning:** A variant where the model itself helps to determine the sequence of training examples based on its current performance.\n*   **Task-Level Curriculum:** Involves starting with easier tasks and gradually moving to harder tasks, which is particularly relevant in multi-task learning scenarios.",
      "order": 87,
      "orderInChapter": 87,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "deep learning",
        "machine learning",
        "nlp",
        "computer vision",
        "optimization",
        "gradient descent",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 832,
        "contentLength": 6510
      },
      "nextCards": [
        "ai-interview-what-are-types-of-ensemble-models-why-do-they-perf-88",
        "ai-interview-why-should-you-make-inductive-biases-in-models-wha-89"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-can-decision-trees-be-fine-tuned-ie-do-they-have-i-18",
        "ai-decision-trees-and-ensemble-methods-boosting-9",
        "ai-top-30-papers-dense-passage-retrieval-for-open-domain-question-a-28",
        "ai-LLM-as-a-judge-why-fine-tune-models-for-ltr-13",
        "ai-LLM-llama2-accessory-50"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-curriculum-training?-what-does-it-do-to-the-loss-surface?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-types-of-ensemble-models-why-do-they-perf-88",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Types of Ensemble Models? Why Do They Perform Better Than Regular Models?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Ensemble models in machine learning combine multiple learning algorithms to obtain better predictive performance than could be obtained from any of the individual learning algorithms alone. The key idea behind ensemble methods is that by averaging out biases, reducing variance, and improving predictions, the ensemble’s performance is typically stronger than that of a single model. There are several types of ensemble models:\n    <ul>\n      <li><strong>Bagging (Bootstrap Aggregating)</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> It involves training multiple models in parallel, each on a random subset of the data (with replacement), and then averaging their predictions.</li>\n          <li><strong>Example:</strong> Random Forest is a classic example of a bagging ensemble, where multiple decision trees are trained on different subsets of the dataset.</li>\n          <li><strong>Advantage:</strong> Bagging reduces variance and helps to avoid overfitting.</li>\n        </ul>\n      </li>\n      <li><strong>Boosting</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> In boosting, models are trained sequentially, with each model learning from the errors of the previous ones. The predictions are then combined, typically through a weighted sum.</li>\n          <li><strong>Examples:</strong> XGBoost, AdaBoost, and Gradient Boosting are popular boosting algorithms.</li>\n          <li><strong>Advantage:</strong> Boosting focuses on reducing bias (and also variance), which can lead to very accurate models, especially on structured data like tables.</li>\n        </ul>\n      </li>\n      <li><strong>Stacking (Stacked Generalization)</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> Different models are trained independently, and a new model, often referred to as a meta-model or blender, is trained to combine these individual predictions**.</li>\n          <li><strong>Example:</strong> The base level might consist of various algorithms like decision trees, neural networks, and SVMs, and the meta-model could be a logistic regression.</li>\n          <li><strong>Advantage:</strong> Stacking captures different aspects of the data through diverse models and combines them for improved accuracy.</li>\n        </ul>\n      </li>\n      <li><strong>Voting</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> In a voting ensemble, multiple models are trained independently, and their predictions are combined through majority voting (for classification) or averaging (for regression).</li>\n          <li><strong>Types:</strong> Hard voting (based on predicted labels) and soft voting (based on predicted probabilities).</li>\n          <li><strong>Advantage:</strong> Voting ensembles are simple to implement and can lead to improved performance, especially when combining models with very different methodologies.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Why Do Ensemble Models Perform Better?\n    <ul>\n      <li><strong>Reduction in Variance:</strong> By averaging multiple predictions, the ensemble’s variance is reduced. This is especially true in bagging, where the individual models may overfit the data.</li>\n      <li><strong>Reduction in Bias:</strong> In boosting, models sequentially focus on the hard-to-predict instances, thereby reducing bias.</li>\n      <li><strong>Exploiting Strengths of Individual Models:</strong> Different models have different strengths and weaknesses. Ensembles can combine these models in a way that amplifies their strengths while compensating for their weaknesses.</li>\n      <li><strong>Diversity of Perspectives:</strong> Multiple models provide a variety of “opinions” on the data, capturing different patterns and relationships that a single model might miss.</li>\n      <li><strong>Improved Predictive Performance:</strong> The combination of lower variance, lower bias, and capturing a richer set of patterns generally leads to better overall predictive performance compared to individual models.</li>\n      <li><strong>Robustness:</strong> Ensemble models are typically more robust to outliers and less likely to be thrown off by peculiarities of a single dataset.</li>\n    </ul>\n  </li>\n  <li><strong>Considerations</strong>: While ensemble methods often outperform single models, they are not without drawbacks. They can be more computationally expensive, harder to interpret, and require more resources to train and deploy. Therefore, the decision to use an ensemble approach should consider these trade-offs against the potential benefits in improved performance.</li>\n</ul>\n<ul>\n      <li><strong>Bagging (Bootstrap Aggregating)</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> It involves training multiple models in parallel, each on a random subset of the data (with replacement), and then averaging their predictions.</li>\n          <li><strong>Example:</strong> Random Forest is a classic example of a bagging ensemble, where multiple decision trees are trained on different subsets of the dataset.</li>\n          <li><strong>Advantage:</strong> Bagging reduces variance and helps to avoid overfitting.</li>\n        </ul>\n      </li>\n      <li><strong>Boosting</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> In boosting, models are trained sequentially, with each model learning from the errors of the previous ones. The predictions are then combined, typically through a weighted sum.</li>\n          <li><strong>Examples:</strong> XGBoost, AdaBoost, and Gradient Boosting are popular boosting algorithms.</li>\n          <li><strong>Advantage:</strong> Boosting focuses on reducing bias (and also variance), which can lead to very accurate models, especially on structured data like tables.</li>\n        </ul>\n      </li>\n      <li><strong>Stacking (Stacked Generalization)</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> Different models are trained independently, and a new model, often referred to as a meta-model or blender, is trained to combine these individual predictions**.</li>\n          <li><strong>Example:</strong> The base level might consist of various algorithms like decision trees, neural networks, and SVMs, and the meta-model could be a logistic regression.</li>\n          <li><strong>Advantage:</strong> Stacking captures different aspects of the data through diverse models and combines them for improved accuracy.</li>\n        </ul>\n      </li>\n      <li><strong>Voting</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> In a voting ensemble, multiple models are trained independently, and their predictions are combined through majority voting (for classification) or averaging (for regression).</li>\n          <li><strong>Types:</strong> Hard voting (based on predicted labels) and soft voting (based on predicted probabilities).</li>\n          <li><strong>Advantage:</strong> Voting ensembles are simple to implement and can lead to improved performance, especially when combining models with very different methodologies.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Mechanism:</strong> It involves training multiple models in parallel, each on a random subset of the data (with replacement), and then averaging their predictions.</li>\n          <li><strong>Example:</strong> Random Forest is a classic example of a bagging ensemble, where multiple decision trees are trained on different subsets of the dataset.</li>\n          <li><strong>Advantage:</strong> Bagging reduces variance and helps to avoid overfitting.</li>\n        </ul>\n<ul>\n          <li><strong>Mechanism:</strong> In boosting, models are trained sequentially, with each model learning from the errors of the previous ones. The predictions are then combined, typically through a weighted sum.</li>\n          <li><strong>Examples:</strong> XGBoost, AdaBoost, and Gradient Boosting are popular boosting algorithms.</li>\n          <li><strong>Advantage:</strong> Boosting focuses on reducing bias (and also variance), which can lead to very accurate models, especially on structured data like tables.</li>\n        </ul>\n<ul>\n          <li><strong>Mechanism:</strong> Different models are trained independently, and a new model, often referred to as a meta-model or blender, is trained to combine these individual predictions**.</li>\n          <li><strong>Example:</strong> The base level might consist of various algorithms like decision trees, neural networks, and SVMs, and the meta-model could be a logistic regression.</li>\n          <li><strong>Advantage:</strong> Stacking captures different aspects of the data through diverse models and combines them for improved accuracy.</li>\n        </ul>\n<ul>\n          <li><strong>Mechanism:</strong> In a voting ensemble, multiple models are trained independently, and their predictions are combined through majority voting (for classification) or averaging (for regression).</li>\n          <li><strong>Types:</strong> Hard voting (based on predicted labels) and soft voting (based on predicted probabilities).</li>\n          <li><strong>Advantage:</strong> Voting ensembles are simple to implement and can lead to improved performance, especially when combining models with very different methodologies.</li>\n        </ul>\n<ul>\n      <li><strong>Reduction in Variance:</strong> By averaging multiple predictions, the ensemble’s variance is reduced. This is especially true in bagging, where the individual models may overfit the data.</li>\n      <li><strong>Reduction in Bias:</strong> In boosting, models sequentially focus on the hard-to-predict instances, thereby reducing bias.</li>\n      <li><strong>Exploiting Strengths of Individual Models:</strong> Different models have different strengths and weaknesses. Ensembles can combine these models in a way that amplifies their strengths while compensating for their weaknesses.</li>\n      <li><strong>Diversity of Perspectives:</strong> Multiple models provide a variety of “opinions” on the data, capturing different patterns and relationships that a single model might miss.</li>\n      <li><strong>Improved Predictive Performance:</strong> The combination of lower variance, lower bias, and capturing a richer set of patterns generally leads to better overall predictive performance compared to individual models.</li>\n      <li><strong>Robustness:</strong> Ensemble models are typically more robust to outliers and less likely to be thrown off by peculiarities of a single dataset.</li>\n    </ul>",
      "contentMarkdown": "*   Ensemble models in machine learning combine multiple learning algorithms to obtain better predictive performance than could be obtained from any of the individual learning algorithms alone. The key idea behind ensemble methods is that by averaging out biases, reducing variance, and improving predictions, the ensemble’s performance is typically stronger than that of a single model. There are several types of ensemble models:\n    *   **Bagging (Bootstrap Aggregating)**\n        *   **Mechanism:** It involves training multiple models in parallel, each on a random subset of the data (with replacement), and then averaging their predictions.\n        *   **Example:** Random Forest is a classic example of a bagging ensemble, where multiple decision trees are trained on different subsets of the dataset.\n        *   **Advantage:** Bagging reduces variance and helps to avoid overfitting.\n    *   **Boosting**\n        *   **Mechanism:** In boosting, models are trained sequentially, with each model learning from the errors of the previous ones. The predictions are then combined, typically through a weighted sum.\n        *   **Examples:** XGBoost, AdaBoost, and Gradient Boosting are popular boosting algorithms.\n        *   **Advantage:** Boosting focuses on reducing bias (and also variance), which can lead to very accurate models, especially on structured data like tables.\n    *   **Stacking (Stacked Generalization)**\n        *   **Mechanism:** Different models are trained independently, and a new model, often referred to as a meta-model or blender, is trained to combine these individual predictions\\*\\*.\n        *   **Example:** The base level might consist of various algorithms like decision trees, neural networks, and SVMs, and the meta-model could be a logistic regression.\n        *   **Advantage:** Stacking captures different aspects of the data through diverse models and combines them for improved accuracy.\n    *   **Voting**\n        *   **Mechanism:** In a voting ensemble, multiple models are trained independently, and their predictions are combined through majority voting (for classification) or averaging (for regression).\n        *   **Types:** Hard voting (based on predicted labels) and soft voting (based on predicted probabilities).\n        *   **Advantage:** Voting ensembles are simple to implement and can lead to improved performance, especially when combining models with very different methodologies.\n*   Why Do Ensemble Models Perform Better?\n    *   **Reduction in Variance:** By averaging multiple predictions, the ensemble’s variance is reduced. This is especially true in bagging, where the individual models may overfit the data.\n    *   **Reduction in Bias:** In boosting, models sequentially focus on the hard-to-predict instances, thereby reducing bias.\n    *   **Exploiting Strengths of Individual Models:** Different models have different strengths and weaknesses. Ensembles can combine these models in a way that amplifies their strengths while compensating for their weaknesses.\n    *   **Diversity of Perspectives:** Multiple models provide a variety of “opinions” on the data, capturing different patterns and relationships that a single model might miss.\n    *   **Improved Predictive Performance:** The combination of lower variance, lower bias, and capturing a richer set of patterns generally leads to better overall predictive performance compared to individual models.\n    *   **Robustness:** Ensemble models are typically more robust to outliers and less likely to be thrown off by peculiarities of a single dataset.\n*   **Considerations**: While ensemble methods often outperform single models, they are not without drawbacks. They can be more computationally expensive, harder to interpret, and require more resources to train and deploy. Therefore, the decision to use an ensemble approach should consider these trade-offs against the potential benefits in improved performance.\n\n*   **Bagging (Bootstrap Aggregating)**\n    *   **Mechanism:** It involves training multiple models in parallel, each on a random subset of the data (with replacement), and then averaging their predictions.\n    *   **Example:** Random Forest is a classic example of a bagging ensemble, where multiple decision trees are trained on different subsets of the dataset.\n    *   **Advantage:** Bagging reduces variance and helps to avoid overfitting.\n*   **Boosting**\n    *   **Mechanism:** In boosting, models are trained sequentially, with each model learning from the errors of the previous ones. The predictions are then combined, typically through a weighted sum.\n    *   **Examples:** XGBoost, AdaBoost, and Gradient Boosting are popular boosting algorithms.\n    *   **Advantage:** Boosting focuses on reducing bias (and also variance), which can lead to very accurate models, especially on structured data like tables.\n*   **Stacking (Stacked Generalization)**\n    *   **Mechanism:** Different models are trained independently, and a new model, often referred to as a meta-model or blender, is trained to combine these individual predictions\\*\\*.\n    *   **Example:** The base level might consist of various algorithms like decision trees, neural networks, and SVMs, and the meta-model could be a logistic regression.\n    *   **Advantage:** Stacking captures different aspects of the data through diverse models and combines them for improved accuracy.\n*   **Voting**\n    *   **Mechanism:** In a voting ensemble, multiple models are trained independently, and their predictions are combined through majority voting (for classification) or averaging (for regression).\n    *   **Types:** Hard voting (based on predicted labels) and soft voting (based on predicted probabilities).\n    *   **Advantage:** Voting ensembles are simple to implement and can lead to improved performance, especially when combining models with very different methodologies.\n\n*   **Mechanism:** It involves training multiple models in parallel, each on a random subset of the data (with replacement), and then averaging their predictions.\n*   **Example:** Random Forest is a classic example of a bagging ensemble, where multiple decision trees are trained on different subsets of the dataset.\n*   **Advantage:** Bagging reduces variance and helps to avoid overfitting.\n\n*   **Mechanism:** In boosting, models are trained sequentially, with each model learning from the errors of the previous ones. The predictions are then combined, typically through a weighted sum.\n*   **Examples:** XGBoost, AdaBoost, and Gradient Boosting are popular boosting algorithms.\n*   **Advantage:** Boosting focuses on reducing bias (and also variance), which can lead to very accurate models, especially on structured data like tables.\n\n*   **Mechanism:** Different models are trained independently, and a new model, often referred to as a meta-model or blender, is trained to combine these individual predictions\\*\\*.\n*   **Example:** The base level might consist of various algorithms like decision trees, neural networks, and SVMs, and the meta-model could be a logistic regression.\n*   **Advantage:** Stacking captures different aspects of the data through diverse models and combines them for improved accuracy.\n\n*   **Mechanism:** In a voting ensemble, multiple models are trained independently, and their predictions are combined through majority voting (for classification) or averaging (for regression).\n*   **Types:** Hard voting (based on predicted labels) and soft voting (based on predicted probabilities).\n*   **Advantage:** Voting ensembles are simple to implement and can lead to improved performance, especially when combining models with very different methodologies.\n\n*   **Reduction in Variance:** By averaging multiple predictions, the ensemble’s variance is reduced. This is especially true in bagging, where the individual models may overfit the data.\n*   **Reduction in Bias:** In boosting, models sequentially focus on the hard-to-predict instances, thereby reducing bias.\n*   **Exploiting Strengths of Individual Models:** Different models have different strengths and weaknesses. Ensembles can combine these models in a way that amplifies their strengths while compensating for their weaknesses.\n*   **Diversity of Perspectives:** Multiple models provide a variety of “opinions” on the data, capturing different patterns and relationships that a single model might miss.\n*   **Improved Predictive Performance:** The combination of lower variance, lower bias, and capturing a richer set of patterns generally leads to better overall predictive performance compared to individual models.\n*   **Robustness:** Ensemble models are typically more robust to outliers and less likely to be thrown off by peculiarities of a single dataset.",
      "order": 88,
      "orderInChapter": 88,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1200,
        "contentLength": 10519
      },
      "nextCards": [
        "ai-interview-why-should-you-make-inductive-biases-in-models-wha-89",
        "ai-interview-how-do-you-identify-if-a-model-is-hallucinating-wh-90"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-stacking-stacked-generalization-10",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-top-30-papers-neural-message-passing-for-quantum-chemistry-12",
        "ai-AIDetect-stylometry-3",
        "ai-context-length-extension-ntk-neural-tangent-kernel-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-types-of-ensemble-models?-why-do-they-perform-better-than-regular-models?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-should-you-make-inductive-biases-in-models-wha-89",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Should You Make Inductive Biases in Models? What Can’t We Consider the Whole Search Space?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Inductive biases in machine learning models refer to the set of assumptions the model makes about the underlying pattern it’s trying to learn from the data. These biases guide the learning algorithm to prefer certain solutions over others. Implementing inductive biases is essential for several reasons, and there are practical limitations to considering the entire search space in machine learning tasks.</li>\n  <li><strong>Why Inductive Biases are Necessary:</strong>\n    <ul>\n      <li><strong>Feasibility of Learning:</strong> Without any inductive biases, a learning algorithm would not be able to generalize beyond the training data because it would have no preference for simpler or more probable solutions over more complex ones. In the absence of inductive biases, the model could fit the training data perfectly but fail to generalize to new, unseen data (overfitting).</li>\n      <li><strong>Curse of Dimensionality:</strong> As the dimensionality of the input space increases, the amount of data needed to ensure that all possible combinations of features are well-represented grows exponentially. Inductive biases help to reduce the effective dimensionality or the search space, making learning feasible with a realistic amount of data.</li>\n      <li><strong>No Free Lunch Theorem:</strong> This theorem states that no single learning algorithm is universally better than others when averaged over all possible problems. Inductive biases allow algorithms to specialize, performing better on a certain type of problem at the expense of others.</li>\n      <li><strong>Computational Efficiency:</strong> Exploring the entire hypothesis space is often computationally infeasible, especially for complex problems. Biases help reduce the search space, making training more computationally efficient.</li>\n      <li><strong>Incorporating Domain Knowledge:</strong> Inductive biases can be a way to inject expert knowledge into the model, allowing it to learn more efficiently and effectively. For example, convolutional neural networks are biased towards image data due to their architectural design, which is suited for spatial hierarchies in images.</li>\n    </ul>\n  </li>\n  <li><strong>Limitations of Exploring the Whole Search Space:</strong>\n    <ul>\n      <li><strong>Computational Constraints:</strong> The size of the complete hypothesis space for even moderately complex models can be astronomically large, making it computationally impossible to explore thoroughly.</li>\n      <li><strong>Risk of Overfitting:</strong> Without biases, models are more likely to fit noise in the training data, leading to poor generalization.</li>\n      <li><strong>Data Limitations:</strong> In practice, we have limited data. Without biases guiding the learning process, the amount of data required to learn meaningful patterns would be impractically large.</li>\n      <li><strong>Interpretability and Simplicity:</strong> Models learned without biases tend to be more complex and harder to interpret. Simpler models (encouraged by appropriate biases) are often preferred because they are easier to understand, debug, and validate.</li>\n    </ul>\n  </li>\n  <li><strong>Conclusion</strong>:\n    <ul>\n      <li>In summary, inductive biases in machine learning models are crucial for guiding the learning process, making it computationally feasible, and ensuring that models generalize well to new, unseen data. These biases are a response to practical limitations in data availability, computational resources, and the inherent complexity of learning tasks.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Feasibility of Learning:</strong> Without any inductive biases, a learning algorithm would not be able to generalize beyond the training data because it would have no preference for simpler or more probable solutions over more complex ones. In the absence of inductive biases, the model could fit the training data perfectly but fail to generalize to new, unseen data (overfitting).</li>\n      <li><strong>Curse of Dimensionality:</strong> As the dimensionality of the input space increases, the amount of data needed to ensure that all possible combinations of features are well-represented grows exponentially. Inductive biases help to reduce the effective dimensionality or the search space, making learning feasible with a realistic amount of data.</li>\n      <li><strong>No Free Lunch Theorem:</strong> This theorem states that no single learning algorithm is universally better than others when averaged over all possible problems. Inductive biases allow algorithms to specialize, performing better on a certain type of problem at the expense of others.</li>\n      <li><strong>Computational Efficiency:</strong> Exploring the entire hypothesis space is often computationally infeasible, especially for complex problems. Biases help reduce the search space, making training more computationally efficient.</li>\n      <li><strong>Incorporating Domain Knowledge:</strong> Inductive biases can be a way to inject expert knowledge into the model, allowing it to learn more efficiently and effectively. For example, convolutional neural networks are biased towards image data due to their architectural design, which is suited for spatial hierarchies in images.</li>\n    </ul>\n<ul>\n      <li><strong>Computational Constraints:</strong> The size of the complete hypothesis space for even moderately complex models can be astronomically large, making it computationally impossible to explore thoroughly.</li>\n      <li><strong>Risk of Overfitting:</strong> Without biases, models are more likely to fit noise in the training data, leading to poor generalization.</li>\n      <li><strong>Data Limitations:</strong> In practice, we have limited data. Without biases guiding the learning process, the amount of data required to learn meaningful patterns would be impractically large.</li>\n      <li><strong>Interpretability and Simplicity:</strong> Models learned without biases tend to be more complex and harder to interpret. Simpler models (encouraged by appropriate biases) are often preferred because they are easier to understand, debug, and validate.</li>\n    </ul>\n<ul>\n      <li>In summary, inductive biases in machine learning models are crucial for guiding the learning process, making it computationally feasible, and ensuring that models generalize well to new, unseen data. These biases are a response to practical limitations in data availability, computational resources, and the inherent complexity of learning tasks.</li>\n    </ul>",
      "contentMarkdown": "*   Inductive biases in machine learning models refer to the set of assumptions the model makes about the underlying pattern it’s trying to learn from the data. These biases guide the learning algorithm to prefer certain solutions over others. Implementing inductive biases is essential for several reasons, and there are practical limitations to considering the entire search space in machine learning tasks.\n*   **Why Inductive Biases are Necessary:**\n    *   **Feasibility of Learning:** Without any inductive biases, a learning algorithm would not be able to generalize beyond the training data because it would have no preference for simpler or more probable solutions over more complex ones. In the absence of inductive biases, the model could fit the training data perfectly but fail to generalize to new, unseen data (overfitting).\n    *   **Curse of Dimensionality:** As the dimensionality of the input space increases, the amount of data needed to ensure that all possible combinations of features are well-represented grows exponentially. Inductive biases help to reduce the effective dimensionality or the search space, making learning feasible with a realistic amount of data.\n    *   **No Free Lunch Theorem:** This theorem states that no single learning algorithm is universally better than others when averaged over all possible problems. Inductive biases allow algorithms to specialize, performing better on a certain type of problem at the expense of others.\n    *   **Computational Efficiency:** Exploring the entire hypothesis space is often computationally infeasible, especially for complex problems. Biases help reduce the search space, making training more computationally efficient.\n    *   **Incorporating Domain Knowledge:** Inductive biases can be a way to inject expert knowledge into the model, allowing it to learn more efficiently and effectively. For example, convolutional neural networks are biased towards image data due to their architectural design, which is suited for spatial hierarchies in images.\n*   **Limitations of Exploring the Whole Search Space:**\n    *   **Computational Constraints:** The size of the complete hypothesis space for even moderately complex models can be astronomically large, making it computationally impossible to explore thoroughly.\n    *   **Risk of Overfitting:** Without biases, models are more likely to fit noise in the training data, leading to poor generalization.\n    *   **Data Limitations:** In practice, we have limited data. Without biases guiding the learning process, the amount of data required to learn meaningful patterns would be impractically large.\n    *   **Interpretability and Simplicity:** Models learned without biases tend to be more complex and harder to interpret. Simpler models (encouraged by appropriate biases) are often preferred because they are easier to understand, debug, and validate.\n*   **Conclusion**:\n    *   In summary, inductive biases in machine learning models are crucial for guiding the learning process, making it computationally feasible, and ensuring that models generalize well to new, unseen data. These biases are a response to practical limitations in data availability, computational resources, and the inherent complexity of learning tasks.\n\n*   **Feasibility of Learning:** Without any inductive biases, a learning algorithm would not be able to generalize beyond the training data because it would have no preference for simpler or more probable solutions over more complex ones. In the absence of inductive biases, the model could fit the training data perfectly but fail to generalize to new, unseen data (overfitting).\n*   **Curse of Dimensionality:** As the dimensionality of the input space increases, the amount of data needed to ensure that all possible combinations of features are well-represented grows exponentially. Inductive biases help to reduce the effective dimensionality or the search space, making learning feasible with a realistic amount of data.\n*   **No Free Lunch Theorem:** This theorem states that no single learning algorithm is universally better than others when averaged over all possible problems. Inductive biases allow algorithms to specialize, performing better on a certain type of problem at the expense of others.\n*   **Computational Efficiency:** Exploring the entire hypothesis space is often computationally infeasible, especially for complex problems. Biases help reduce the search space, making training more computationally efficient.\n*   **Incorporating Domain Knowledge:** Inductive biases can be a way to inject expert knowledge into the model, allowing it to learn more efficiently and effectively. For example, convolutional neural networks are biased towards image data due to their architectural design, which is suited for spatial hierarchies in images.\n\n*   **Computational Constraints:** The size of the complete hypothesis space for even moderately complex models can be astronomically large, making it computationally impossible to explore thoroughly.\n*   **Risk of Overfitting:** Without biases, models are more likely to fit noise in the training data, leading to poor generalization.\n*   **Data Limitations:** In practice, we have limited data. Without biases guiding the learning process, the amount of data required to learn meaningful patterns would be impractically large.\n*   **Interpretability and Simplicity:** Models learned without biases tend to be more complex and harder to interpret. Simpler models (encouraged by appropriate biases) are often preferred because they are easier to understand, debug, and validate.\n\n*   In summary, inductive biases in machine learning models are crucial for guiding the learning process, making it computationally feasible, and ensuring that models generalize well to new, unseen data. These biases are a response to practical limitations in data availability, computational resources, and the inherent complexity of learning tasks.",
      "order": 89,
      "orderInChapter": 89,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "machine learning",
        "convolution"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 854,
        "contentLength": 6563
      },
      "nextCards": [
        "ai-interview-how-do-you-identify-if-a-model-is-hallucinating-wh-90",
        "ai-interview-why-were-rnns-introduced-how-are-lstms-different-a-91"
      ],
      "relatedCards": [
        "ai-gnn-introductory-content-21",
        "ai-decision-trees-and-ensemble-methods-stacking-stacked-generalization-10",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-dl-comp-pros-of-cnns-compared-to-fcns-2",
        "ai-nlp-tasks-common-architectures-and-models-17"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-should-you-make-inductive-biases-in-models?-what-can’t-we-consider-the-whole-search-space?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-identify-if-a-model-is-hallucinating-wh-90",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Identify If a Model is Hallucinating? What are Some Mitigation Strategies?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Identifying if a machine learning model, especially a language model like GPT-3 or GPT-4, is “hallucinating” — that is, generating false or nonsensical information — can be a crucial aspect of evaluating its reliability and suitability for various applications. Hallucinations in this context refer to the model confidently generating outputs that are incorrect, irrelevant, or nonsensical.</p>\n  </li>\n  <li><strong>Strategies to Identify Model Hallucination</strong>:\n    <ul>\n      <li><strong>Result Verification:</strong> Cross-reference the model’s outputs with trusted sources or ground truth data. This is especially important for factual information where accuracy is critical. This can be done in an automated manner (looking up factual information on the web and performing NLI on the model’s output vs. web information) or with a human-in-the-loop setup. In many cases, especially for complex tasks like story generation or open-ended question answering, human judgment is crucial to evaluate the sensibility and correctness of the output.</li>\n      <li><strong>Consistency Checks:</strong> Test the model with similar or paraphrased queries to see if it provides consistent answers. Inconsistent responses can indicate hallucinations.</li>\n      <li><strong>Sensitivity Analysis:</strong> Analyze how slight changes in the input affect the output. Excessive sensitivity or dramatic changes in output for minor input modifications can suggest hallucinatory behavior.</li>\n      <li><strong>Out-of-Distribution Detection:</strong> Check how the model performs on data that is significantly different from the training data. Poor handling of such data might lead to hallucinations.</li>\n      <li><strong>Error Analysis:</strong> Perform a detailed analysis of the model’s errors. Categorize these errors to understand if they are due to hallucinations or other issues like overfitting or underfitting.</li>\n      <li><strong>Challenge with Counterfactuals:</strong> Present the model with counterfactual or hypothetical scenarios. Models prone to hallucination may struggle to handle such inputs appropriately.</li>\n      <li><strong>Model Confidence Assessment:</strong> For models that output confidence scores (like some classification models), compare these scores with actual performance. Overconfidence in incorrect answers can be a sign of hallucination.</li>\n      <li><strong>Benchmarking Against Known Tasks:</strong> Compare the model’s performance on well-established datasets or tasks where the expected outputs are known.</li>\n      <li><strong>Input Truncation Tests:</strong> Truncate or alter inputs to see if the model still generates plausible outputs. Illogical outputs in response to incomplete or nonsensical inputs can indicate a tendency to hallucinate.</li>\n    </ul>\n  </li>\n  <li><strong>Preventing or Mitigating Hallucinations</strong>:\n    <ul>\n      <li><strong>Training Data Quality and Diversity:</strong> Ensure the training data is diverse, high-quality, and representative of the problem space.</li>\n      <li><strong>Regularization and Fine-tuning:</strong> Apply techniques to prevent overfitting and fine-tune the model on specific domains or types of data to improve its accuracy.</li>\n      <li><strong>Explicitly Modeling Uncertainty:</strong> In some cases, incorporating mechanisms for the model to express uncertainty can be helpful.</li>\n      <li><strong>Post-Processing Rules:</strong> Implement rules or filters to catch and correct certain types of hallucinations.</li>\n      <li><strong>User Feedback Loop:</strong> Incorporate user feedback to continuously improve the model and reduce hallucinations over time.</li>\n    </ul>\n  </li>\n  <li>Identifying hallucinations in AI models is particularly important in scenarios where trust, safety, and accuracy are critical, such as in medical, financial, or legal applications. Regular monitoring and evaluation are essential to ensure that the models perform reliably and sensibly in their intended applications.</li>\n</ul>\n<p>Identifying if a machine learning model, especially a language model like GPT-3 or GPT-4, is “hallucinating” — that is, generating false or nonsensical information — can be a crucial aspect of evaluating its reliability and suitability for various applications. Hallucinations in this context refer to the model confidently generating outputs that are incorrect, irrelevant, or nonsensical.</p>\n<ul>\n      <li><strong>Result Verification:</strong> Cross-reference the model’s outputs with trusted sources or ground truth data. This is especially important for factual information where accuracy is critical. This can be done in an automated manner (looking up factual information on the web and performing NLI on the model’s output vs. web information) or with a human-in-the-loop setup. In many cases, especially for complex tasks like story generation or open-ended question answering, human judgment is crucial to evaluate the sensibility and correctness of the output.</li>\n      <li><strong>Consistency Checks:</strong> Test the model with similar or paraphrased queries to see if it provides consistent answers. Inconsistent responses can indicate hallucinations.</li>\n      <li><strong>Sensitivity Analysis:</strong> Analyze how slight changes in the input affect the output. Excessive sensitivity or dramatic changes in output for minor input modifications can suggest hallucinatory behavior.</li>\n      <li><strong>Out-of-Distribution Detection:</strong> Check how the model performs on data that is significantly different from the training data. Poor handling of such data might lead to hallucinations.</li>\n      <li><strong>Error Analysis:</strong> Perform a detailed analysis of the model’s errors. Categorize these errors to understand if they are due to hallucinations or other issues like overfitting or underfitting.</li>\n      <li><strong>Challenge with Counterfactuals:</strong> Present the model with counterfactual or hypothetical scenarios. Models prone to hallucination may struggle to handle such inputs appropriately.</li>\n      <li><strong>Model Confidence Assessment:</strong> For models that output confidence scores (like some classification models), compare these scores with actual performance. Overconfidence in incorrect answers can be a sign of hallucination.</li>\n      <li><strong>Benchmarking Against Known Tasks:</strong> Compare the model’s performance on well-established datasets or tasks where the expected outputs are known.</li>\n      <li><strong>Input Truncation Tests:</strong> Truncate or alter inputs to see if the model still generates plausible outputs. Illogical outputs in response to incomplete or nonsensical inputs can indicate a tendency to hallucinate.</li>\n    </ul>\n<ul>\n      <li><strong>Training Data Quality and Diversity:</strong> Ensure the training data is diverse, high-quality, and representative of the problem space.</li>\n      <li><strong>Regularization and Fine-tuning:</strong> Apply techniques to prevent overfitting and fine-tune the model on specific domains or types of data to improve its accuracy.</li>\n      <li><strong>Explicitly Modeling Uncertainty:</strong> In some cases, incorporating mechanisms for the model to express uncertainty can be helpful.</li>\n      <li><strong>Post-Processing Rules:</strong> Implement rules or filters to catch and correct certain types of hallucinations.</li>\n      <li><strong>User Feedback Loop:</strong> Incorporate user feedback to continuously improve the model and reduce hallucinations over time.</li>\n    </ul>",
      "contentMarkdown": "*   Identifying if a machine learning model, especially a language model like GPT-3 or GPT-4, is “hallucinating” — that is, generating false or nonsensical information — can be a crucial aspect of evaluating its reliability and suitability for various applications. Hallucinations in this context refer to the model confidently generating outputs that are incorrect, irrelevant, or nonsensical.\n    \n*   **Strategies to Identify Model Hallucination**:\n    *   **Result Verification:** Cross-reference the model’s outputs with trusted sources or ground truth data. This is especially important for factual information where accuracy is critical. This can be done in an automated manner (looking up factual information on the web and performing NLI on the model’s output vs. web information) or with a human-in-the-loop setup. In many cases, especially for complex tasks like story generation or open-ended question answering, human judgment is crucial to evaluate the sensibility and correctness of the output.\n    *   **Consistency Checks:** Test the model with similar or paraphrased queries to see if it provides consistent answers. Inconsistent responses can indicate hallucinations.\n    *   **Sensitivity Analysis:** Analyze how slight changes in the input affect the output. Excessive sensitivity or dramatic changes in output for minor input modifications can suggest hallucinatory behavior.\n    *   **Out-of-Distribution Detection:** Check how the model performs on data that is significantly different from the training data. Poor handling of such data might lead to hallucinations.\n    *   **Error Analysis:** Perform a detailed analysis of the model’s errors. Categorize these errors to understand if they are due to hallucinations or other issues like overfitting or underfitting.\n    *   **Challenge with Counterfactuals:** Present the model with counterfactual or hypothetical scenarios. Models prone to hallucination may struggle to handle such inputs appropriately.\n    *   **Model Confidence Assessment:** For models that output confidence scores (like some classification models), compare these scores with actual performance. Overconfidence in incorrect answers can be a sign of hallucination.\n    *   **Benchmarking Against Known Tasks:** Compare the model’s performance on well-established datasets or tasks where the expected outputs are known.\n    *   **Input Truncation Tests:** Truncate or alter inputs to see if the model still generates plausible outputs. Illogical outputs in response to incomplete or nonsensical inputs can indicate a tendency to hallucinate.\n*   **Preventing or Mitigating Hallucinations**:\n    *   **Training Data Quality and Diversity:** Ensure the training data is diverse, high-quality, and representative of the problem space.\n    *   **Regularization and Fine-tuning:** Apply techniques to prevent overfitting and fine-tune the model on specific domains or types of data to improve its accuracy.\n    *   **Explicitly Modeling Uncertainty:** In some cases, incorporating mechanisms for the model to express uncertainty can be helpful.\n    *   **Post-Processing Rules:** Implement rules or filters to catch and correct certain types of hallucinations.\n    *   **User Feedback Loop:** Incorporate user feedback to continuously improve the model and reduce hallucinations over time.\n*   Identifying hallucinations in AI models is particularly important in scenarios where trust, safety, and accuracy are critical, such as in medical, financial, or legal applications. Regular monitoring and evaluation are essential to ensure that the models perform reliably and sensibly in their intended applications.\n\nIdentifying if a machine learning model, especially a language model like GPT-3 or GPT-4, is “hallucinating” — that is, generating false or nonsensical information — can be a crucial aspect of evaluating its reliability and suitability for various applications. Hallucinations in this context refer to the model confidently generating outputs that are incorrect, irrelevant, or nonsensical.\n\n*   **Result Verification:** Cross-reference the model’s outputs with trusted sources or ground truth data. This is especially important for factual information where accuracy is critical. This can be done in an automated manner (looking up factual information on the web and performing NLI on the model’s output vs. web information) or with a human-in-the-loop setup. In many cases, especially for complex tasks like story generation or open-ended question answering, human judgment is crucial to evaluate the sensibility and correctness of the output.\n*   **Consistency Checks:** Test the model with similar or paraphrased queries to see if it provides consistent answers. Inconsistent responses can indicate hallucinations.\n*   **Sensitivity Analysis:** Analyze how slight changes in the input affect the output. Excessive sensitivity or dramatic changes in output for minor input modifications can suggest hallucinatory behavior.\n*   **Out-of-Distribution Detection:** Check how the model performs on data that is significantly different from the training data. Poor handling of such data might lead to hallucinations.\n*   **Error Analysis:** Perform a detailed analysis of the model’s errors. Categorize these errors to understand if they are due to hallucinations or other issues like overfitting or underfitting.\n*   **Challenge with Counterfactuals:** Present the model with counterfactual or hypothetical scenarios. Models prone to hallucination may struggle to handle such inputs appropriately.\n*   **Model Confidence Assessment:** For models that output confidence scores (like some classification models), compare these scores with actual performance. Overconfidence in incorrect answers can be a sign of hallucination.\n*   **Benchmarking Against Known Tasks:** Compare the model’s performance on well-established datasets or tasks where the expected outputs are known.\n*   **Input Truncation Tests:** Truncate or alter inputs to see if the model still generates plausible outputs. Illogical outputs in response to incomplete or nonsensical inputs can indicate a tendency to hallucinate.\n\n*   **Training Data Quality and Diversity:** Ensure the training data is diverse, high-quality, and representative of the problem space.\n*   **Regularization and Fine-tuning:** Apply techniques to prevent overfitting and fine-tune the model on specific domains or types of data to improve its accuracy.\n*   **Explicitly Modeling Uncertainty:** In some cases, incorporating mechanisms for the model to express uncertainty can be helpful.\n*   **Post-Processing Rules:** Implement rules or filters to catch and correct certain types of hallucinations.\n*   **User Feedback Loop:** Incorporate user feedback to continuously improve the model and reduce hallucinations over time.",
      "order": 90,
      "orderInChapter": 90,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "machine learning",
        "gpt",
        "regularization",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 943,
        "contentLength": 7588
      },
      "nextCards": [
        "ai-interview-why-were-rnns-introduced-how-are-lstms-different-a-91",
        "ai-interview-what-is-the-need-for-dl-models-explain-traditional-92"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-boosting-9",
        "ai-mixture-of-experts-overview-19",
        "ai-LLM-fine-tuning-vs-prompting-16",
        "ai-preference-optimization-integration-of-policy-reference-reward-and-value-m-8",
        "ai-top-30-papers-lost-in-the-middle-how-language-models-use-long-co-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-identify-if-a-model-is-hallucinating?-what-are-some-mitigation-strategies?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-were-rnns-introduced-how-are-lstms-different-a-91",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Were RNNs Introduced? How are LSTMs Different and What Issue Do They Solve?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Recurrent Neural Networks (RNNs) were introduced to handle sequential data, where the order and context of data points are important. Before RNNs, traditional neural networks, like feed-forward networks, assumed that all inputs (and outputs) were independent of each other, which limited their ability to model data where the sequence matters, like time series or text.</li>\n  <li><strong>Why RNNs Were Introduced</strong>:\n    <ul>\n      <li>Handling Sequences:**: RNNs are designed to process sequences of data by maintaining a ‘memory’ (hidden state) of previous inputs. This allows them to capture information about the sequence as a whole.</li>\n      <li><strong>Variable-Length Inputs:</strong>: They can handle inputs of varying lengths, unlike traditional neural networks that require fixed-sized inputs.</li>\n      <li><strong>Parameter Sharing Across Time:</strong>: RNNs use the same weights while processing different time steps of the sequence, making them more efficient and reducing the number of parameters.</li>\n      <li><strong>Applications in Time Series and NLP:</strong>: They became a natural choice for time series analysis, natural language processing, speech recognition, and other tasks involving sequential data.</li>\n    </ul>\n  </li>\n  <li><strong>Limitations of RNNs and Introduction of LSTMs</strong>: However, standard RNNs have significant limitations:\n    <ul>\n      <li><strong>Vanishing Gradient Problem:</strong>: During backpropagation, RNNs suffer from the vanishing (and sometimes exploding) gradients problem, making it difficult to learn long-range dependencies in sequences.</li>\n      <li><strong>Limited Memory:</strong>: They can struggle with retaining information from early time steps in long sequences.</li>\n      <li><strong>Lack of a mechanism to add or remove information</strong>: Traditional Recurrent Neural Networks (RNNs) do not have gates in the same sense as Long Short-Term Memory (LSTM) units or Gated Recurrent Units (GRUs). The basic architecture of a traditional RNN is simpler and does not include the sophisticated gating mechanisms that are characteristic of LSTMs and GRUs.</li>\n    </ul>\n  </li>\n  <li><strong>How LSTMs Solve These Issues</strong>: Long Short-Term Memory networks (LSTMs), a type of RNN, were introduced to overcome these limitations.\n    <ul>\n      <li><strong>Memory Cells:</strong>: LSTMs have a complex mechanism with memory cells that can store information for long periods. The key components of these cells are the input, output, and forget gates.</li>\n      <li><strong>Gates Mechanism:</strong>:\n        <ul>\n          <li><strong>Input Gate:</strong> Controls how much of the new information should be added to the cell state.</li>\n          <li><strong>Forget Gate:</strong> Decides what information should be discarded from the cell state.</li>\n          <li><strong>Output Gate:</strong> Controls the output of the cell state to the next hidden state.</li>\n          <li><strong>Long-Range Dependencies:</strong> The gated structure of LSTMs allows them to learn which data in the sequence is important to keep or throw away, thus mitigating the vanishing gradient problem and enabling them to capture long-range dependencies.</li>\n        </ul>\n      </li>\n      <li><strong>Better Memory Management:</strong>: The ability to add or remove information from the cell state selectively allows LSTMs to maintain longer-term dependencies.</li>\n      <li><strong>Summary</strong>: In summary, RNNs were introduced to model sequential data, a task that traditional neural networks weren’t equipped for. LSTMs evolved as a special kind of RNN to address the vanishing gradient problem and to better capture long-range dependencies within the input sequences. This made LSTMs particularly effective for complex sequential tasks like language modeling, machine translation, and speech recognition.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Handling Sequences:**: RNNs are designed to process sequences of data by maintaining a ‘memory’ (hidden state) of previous inputs. This allows them to capture information about the sequence as a whole.</li>\n      <li><strong>Variable-Length Inputs:</strong>: They can handle inputs of varying lengths, unlike traditional neural networks that require fixed-sized inputs.</li>\n      <li><strong>Parameter Sharing Across Time:</strong>: RNNs use the same weights while processing different time steps of the sequence, making them more efficient and reducing the number of parameters.</li>\n      <li><strong>Applications in Time Series and NLP:</strong>: They became a natural choice for time series analysis, natural language processing, speech recognition, and other tasks involving sequential data.</li>\n    </ul>\n<ul>\n      <li><strong>Vanishing Gradient Problem:</strong>: During backpropagation, RNNs suffer from the vanishing (and sometimes exploding) gradients problem, making it difficult to learn long-range dependencies in sequences.</li>\n      <li><strong>Limited Memory:</strong>: They can struggle with retaining information from early time steps in long sequences.</li>\n      <li><strong>Lack of a mechanism to add or remove information</strong>: Traditional Recurrent Neural Networks (RNNs) do not have gates in the same sense as Long Short-Term Memory (LSTM) units or Gated Recurrent Units (GRUs). The basic architecture of a traditional RNN is simpler and does not include the sophisticated gating mechanisms that are characteristic of LSTMs and GRUs.</li>\n    </ul>\n<ul>\n      <li><strong>Memory Cells:</strong>: LSTMs have a complex mechanism with memory cells that can store information for long periods. The key components of these cells are the input, output, and forget gates.</li>\n      <li><strong>Gates Mechanism:</strong>:\n        <ul>\n          <li><strong>Input Gate:</strong> Controls how much of the new information should be added to the cell state.</li>\n          <li><strong>Forget Gate:</strong> Decides what information should be discarded from the cell state.</li>\n          <li><strong>Output Gate:</strong> Controls the output of the cell state to the next hidden state.</li>\n          <li><strong>Long-Range Dependencies:</strong> The gated structure of LSTMs allows them to learn which data in the sequence is important to keep or throw away, thus mitigating the vanishing gradient problem and enabling them to capture long-range dependencies.</li>\n        </ul>\n      </li>\n      <li><strong>Better Memory Management:</strong>: The ability to add or remove information from the cell state selectively allows LSTMs to maintain longer-term dependencies.</li>\n      <li><strong>Summary</strong>: In summary, RNNs were introduced to model sequential data, a task that traditional neural networks weren’t equipped for. LSTMs evolved as a special kind of RNN to address the vanishing gradient problem and to better capture long-range dependencies within the input sequences. This made LSTMs particularly effective for complex sequential tasks like language modeling, machine translation, and speech recognition.</li>\n    </ul>\n<ul>\n          <li><strong>Input Gate:</strong> Controls how much of the new information should be added to the cell state.</li>\n          <li><strong>Forget Gate:</strong> Decides what information should be discarded from the cell state.</li>\n          <li><strong>Output Gate:</strong> Controls the output of the cell state to the next hidden state.</li>\n          <li><strong>Long-Range Dependencies:</strong> The gated structure of LSTMs allows them to learn which data in the sequence is important to keep or throw away, thus mitigating the vanishing gradient problem and enabling them to capture long-range dependencies.</li>\n        </ul>",
      "contentMarkdown": "*   Recurrent Neural Networks (RNNs) were introduced to handle sequential data, where the order and context of data points are important. Before RNNs, traditional neural networks, like feed-forward networks, assumed that all inputs (and outputs) were independent of each other, which limited their ability to model data where the sequence matters, like time series or text.\n*   **Why RNNs Were Introduced**:\n    *   Handling Sequences:\\*\\*: RNNs are designed to process sequences of data by maintaining a ‘memory’ (hidden state) of previous inputs. This allows them to capture information about the sequence as a whole.\n    *   **Variable-Length Inputs:**: They can handle inputs of varying lengths, unlike traditional neural networks that require fixed-sized inputs.\n    *   **Parameter Sharing Across Time:**: RNNs use the same weights while processing different time steps of the sequence, making them more efficient and reducing the number of parameters.\n    *   **Applications in Time Series and NLP:**: They became a natural choice for time series analysis, natural language processing, speech recognition, and other tasks involving sequential data.\n*   **Limitations of RNNs and Introduction of LSTMs**: However, standard RNNs have significant limitations:\n    *   **Vanishing Gradient Problem:**: During backpropagation, RNNs suffer from the vanishing (and sometimes exploding) gradients problem, making it difficult to learn long-range dependencies in sequences.\n    *   **Limited Memory:**: They can struggle with retaining information from early time steps in long sequences.\n    *   **Lack of a mechanism to add or remove information**: Traditional Recurrent Neural Networks (RNNs) do not have gates in the same sense as Long Short-Term Memory (LSTM) units or Gated Recurrent Units (GRUs). The basic architecture of a traditional RNN is simpler and does not include the sophisticated gating mechanisms that are characteristic of LSTMs and GRUs.\n*   **How LSTMs Solve These Issues**: Long Short-Term Memory networks (LSTMs), a type of RNN, were introduced to overcome these limitations.\n    *   **Memory Cells:**: LSTMs have a complex mechanism with memory cells that can store information for long periods. The key components of these cells are the input, output, and forget gates.\n    *   **Gates Mechanism:**:\n        *   **Input Gate:** Controls how much of the new information should be added to the cell state.\n        *   **Forget Gate:** Decides what information should be discarded from the cell state.\n        *   **Output Gate:** Controls the output of the cell state to the next hidden state.\n        *   **Long-Range Dependencies:** The gated structure of LSTMs allows them to learn which data in the sequence is important to keep or throw away, thus mitigating the vanishing gradient problem and enabling them to capture long-range dependencies.\n    *   **Better Memory Management:**: The ability to add or remove information from the cell state selectively allows LSTMs to maintain longer-term dependencies.\n    *   **Summary**: In summary, RNNs were introduced to model sequential data, a task that traditional neural networks weren’t equipped for. LSTMs evolved as a special kind of RNN to address the vanishing gradient problem and to better capture long-range dependencies within the input sequences. This made LSTMs particularly effective for complex sequential tasks like language modeling, machine translation, and speech recognition.\n\n*   Handling Sequences:\\*\\*: RNNs are designed to process sequences of data by maintaining a ‘memory’ (hidden state) of previous inputs. This allows them to capture information about the sequence as a whole.\n*   **Variable-Length Inputs:**: They can handle inputs of varying lengths, unlike traditional neural networks that require fixed-sized inputs.\n*   **Parameter Sharing Across Time:**: RNNs use the same weights while processing different time steps of the sequence, making them more efficient and reducing the number of parameters.\n*   **Applications in Time Series and NLP:**: They became a natural choice for time series analysis, natural language processing, speech recognition, and other tasks involving sequential data.\n\n*   **Vanishing Gradient Problem:**: During backpropagation, RNNs suffer from the vanishing (and sometimes exploding) gradients problem, making it difficult to learn long-range dependencies in sequences.\n*   **Limited Memory:**: They can struggle with retaining information from early time steps in long sequences.\n*   **Lack of a mechanism to add or remove information**: Traditional Recurrent Neural Networks (RNNs) do not have gates in the same sense as Long Short-Term Memory (LSTM) units or Gated Recurrent Units (GRUs). The basic architecture of a traditional RNN is simpler and does not include the sophisticated gating mechanisms that are characteristic of LSTMs and GRUs.\n\n*   **Memory Cells:**: LSTMs have a complex mechanism with memory cells that can store information for long periods. The key components of these cells are the input, output, and forget gates.\n*   **Gates Mechanism:**:\n    *   **Input Gate:** Controls how much of the new information should be added to the cell state.\n    *   **Forget Gate:** Decides what information should be discarded from the cell state.\n    *   **Output Gate:** Controls the output of the cell state to the next hidden state.\n    *   **Long-Range Dependencies:** The gated structure of LSTMs allows them to learn which data in the sequence is important to keep or throw away, thus mitigating the vanishing gradient problem and enabling them to capture long-range dependencies.\n*   **Better Memory Management:**: The ability to add or remove information from the cell state selectively allows LSTMs to maintain longer-term dependencies.\n*   **Summary**: In summary, RNNs were introduced to model sequential data, a task that traditional neural networks weren’t equipped for. LSTMs evolved as a special kind of RNN to address the vanishing gradient problem and to better capture long-range dependencies within the input sequences. This made LSTMs particularly effective for complex sequential tasks like language modeling, machine translation, and speech recognition.\n\n*   **Input Gate:** Controls how much of the new information should be added to the cell state.\n*   **Forget Gate:** Decides what information should be discarded from the cell state.\n*   **Output Gate:** Controls the output of the cell state to the next hidden state.\n*   **Long-Range Dependencies:** The gated structure of LSTMs allows them to learn which data in the sequence is important to keep or throw away, thus mitigating the vanishing gradient problem and enabling them to capture long-range dependencies.",
      "order": 91,
      "orderInChapter": 91,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "rnn",
        "lstm",
        "gru",
        "nlp",
        "backpropagation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 984,
        "contentLength": 7751
      },
      "nextCards": [
        "ai-interview-what-is-the-need-for-dl-models-explain-traditional-92",
        "ai-interview-in-self-attention-why-do-we-use-projections-of-kqv-93"
      ],
      "relatedCards": [
        "ai-word-vectors-contextual-and-sequential-data-embeddings-18",
        "ai-encoder-vs-decoder-models-summary-10",
        "ai-speech-processing-automatic-speech-recognition-20",
        "ai-model-compression-quantization-with-pytorch-10",
        "ai-dl-comp-vanishing-gradient-problem-solutions-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-were-rnns-introduced?-how-are-lstms-different-and-what-issue-do-they-solve?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-need-for-dl-models-explain-traditional-92",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Need for DL Models? Explain Traditional ML Models and Cases Where They Would Fail?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>Deep Learning (DL) models and traditional Machine Learning (ML) models serve different purposes and excel in various types of tasks. Understanding their strengths and limitations is crucial in selecting the right approach for a given problem.</p>\n  </li>\n  <li><strong>Traditional Machine Learning Models</strong>: Traditional ML models include algorithms like linear regression, logistic regression, decision trees, random forests, support vector machines (SVMs), and k-nearest neighbors (k-NN). These models are often preferred for their simplicity, interpretability, and efficiency on smaller or structured datasets.\n    <ul>\n      <li><strong>Strengths:</strong>\n        <ul>\n          <li><strong>Efficiency:</strong> They generally require less computational resources.</li>\n          <li><strong>Interpretability:</strong> Many traditional models are easier to interpret and understand, which is crucial in domains like finance and healthcare.</li>\n          <li><strong>Small Data:</strong> They can perform well with smaller datasets.</li>\n        </ul>\n      </li>\n      <li><strong>Limitations:</strong>\n        <ul>\n          <li><strong>Feature Engineering:</strong> Traditional ML models often rely heavily on feature engineering, i.e., manually creating and selecting the most relevant features from the data.</li>\n          <li><strong>Handling High-Dimensional Data:</strong> They might struggle with very high-dimensional data or data with complex structures, like images and natural language.</li>\n          <li><strong>Modeling Complex Patterns:</strong> Traditional models can be limited in their ability to capture complex, non-linear relationships in data.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Deep Learning Models</strong>: Deep Learning models, particularly neural networks, are designed to learn hierarchical representations of data, making them extremely effective for tasks involving unstructured data like images, audio, and text.\n    <ul>\n      <li><strong>Strengths:</strong>\n        <ul>\n          <li><strong>Handling Unstructured Data:</strong> DL models excel in tasks involving high-dimensional and unstructured data (e.g., image and speech recognition, natural language processing).</li>\n          <li><strong>Automatic Feature Extraction:</strong> They automatically learn and extract features from raw data, reducing the need for manual feature engineering.</li>\n          <li><strong>Modeling Complex Patterns:</strong> Deep neural networks are capable of modeling highly complex and non-linear relationships.</li>\n        </ul>\n      </li>\n      <li><strong>Limitations:</strong>\n        <ul>\n          <li><strong>Data Requirements:</strong> DL models usually require large amounts of labeled training data.</li>\n          <li><strong>Computational Resources:</strong> They are computationally intensive and require more processing power, often necessitating GPUs for training.</li>\n          <li><strong>Interpretability:</strong> Deep Learning models are often considered “black boxes” due to their complexity, making them less interpretable.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Cases Where Traditional ML Models Might Fail</strong>:\n    <ul>\n      <li><strong>Image Recognition:</strong> Tasks like object detection or facial recognition involve processing high-dimensional pixel data and recognizing complex patterns, something traditional ML models are generally not equipped to handle effectively.</li>\n      <li><strong>Natural Language Processing:</strong> Tasks like machine translation, sentiment analysis, or question-answering involve understanding human language’s nuances, context, and syntax. Traditional ML struggles with such tasks due to the complexity and variability of language.</li>\n      <li><strong>Sequence Data:</strong> Handling sequence data (like time-series forecasting with long sequences or predicting the next word in a sentence) can be challenging for traditional ML models. Deep Learning models, especially RNNs, LSTMs, and Transformers, are more adept at capturing long-range dependencies in sequences.</li>\n    </ul>\n  </li>\n  <li>In summary, the choice between traditional ML and DL models depends on the nature of the task, the type and amount of data available, the need for interpretability, and the computational resources at hand. While traditional models are effective for structured data and provide simplicity and interpretability, DL models are better suited for tasks involving complex patterns and high-dimensional, unstructured data.</li>\n</ul>\n<p>Deep Learning (DL) models and traditional Machine Learning (ML) models serve different purposes and excel in various types of tasks. Understanding their strengths and limitations is crucial in selecting the right approach for a given problem.</p>\n<ul>\n      <li><strong>Strengths:</strong>\n        <ul>\n          <li><strong>Efficiency:</strong> They generally require less computational resources.</li>\n          <li><strong>Interpretability:</strong> Many traditional models are easier to interpret and understand, which is crucial in domains like finance and healthcare.</li>\n          <li><strong>Small Data:</strong> They can perform well with smaller datasets.</li>\n        </ul>\n      </li>\n      <li><strong>Limitations:</strong>\n        <ul>\n          <li><strong>Feature Engineering:</strong> Traditional ML models often rely heavily on feature engineering, i.e., manually creating and selecting the most relevant features from the data.</li>\n          <li><strong>Handling High-Dimensional Data:</strong> They might struggle with very high-dimensional data or data with complex structures, like images and natural language.</li>\n          <li><strong>Modeling Complex Patterns:</strong> Traditional models can be limited in their ability to capture complex, non-linear relationships in data.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Efficiency:</strong> They generally require less computational resources.</li>\n          <li><strong>Interpretability:</strong> Many traditional models are easier to interpret and understand, which is crucial in domains like finance and healthcare.</li>\n          <li><strong>Small Data:</strong> They can perform well with smaller datasets.</li>\n        </ul>\n<ul>\n          <li><strong>Feature Engineering:</strong> Traditional ML models often rely heavily on feature engineering, i.e., manually creating and selecting the most relevant features from the data.</li>\n          <li><strong>Handling High-Dimensional Data:</strong> They might struggle with very high-dimensional data or data with complex structures, like images and natural language.</li>\n          <li><strong>Modeling Complex Patterns:</strong> Traditional models can be limited in their ability to capture complex, non-linear relationships in data.</li>\n        </ul>\n<ul>\n      <li><strong>Strengths:</strong>\n        <ul>\n          <li><strong>Handling Unstructured Data:</strong> DL models excel in tasks involving high-dimensional and unstructured data (e.g., image and speech recognition, natural language processing).</li>\n          <li><strong>Automatic Feature Extraction:</strong> They automatically learn and extract features from raw data, reducing the need for manual feature engineering.</li>\n          <li><strong>Modeling Complex Patterns:</strong> Deep neural networks are capable of modeling highly complex and non-linear relationships.</li>\n        </ul>\n      </li>\n      <li><strong>Limitations:</strong>\n        <ul>\n          <li><strong>Data Requirements:</strong> DL models usually require large amounts of labeled training data.</li>\n          <li><strong>Computational Resources:</strong> They are computationally intensive and require more processing power, often necessitating GPUs for training.</li>\n          <li><strong>Interpretability:</strong> Deep Learning models are often considered “black boxes” due to their complexity, making them less interpretable.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Handling Unstructured Data:</strong> DL models excel in tasks involving high-dimensional and unstructured data (e.g., image and speech recognition, natural language processing).</li>\n          <li><strong>Automatic Feature Extraction:</strong> They automatically learn and extract features from raw data, reducing the need for manual feature engineering.</li>\n          <li><strong>Modeling Complex Patterns:</strong> Deep neural networks are capable of modeling highly complex and non-linear relationships.</li>\n        </ul>\n<ul>\n          <li><strong>Data Requirements:</strong> DL models usually require large amounts of labeled training data.</li>\n          <li><strong>Computational Resources:</strong> They are computationally intensive and require more processing power, often necessitating GPUs for training.</li>\n          <li><strong>Interpretability:</strong> Deep Learning models are often considered “black boxes” due to their complexity, making them less interpretable.</li>\n        </ul>\n<ul>\n      <li><strong>Image Recognition:</strong> Tasks like object detection or facial recognition involve processing high-dimensional pixel data and recognizing complex patterns, something traditional ML models are generally not equipped to handle effectively.</li>\n      <li><strong>Natural Language Processing:</strong> Tasks like machine translation, sentiment analysis, or question-answering involve understanding human language’s nuances, context, and syntax. Traditional ML struggles with such tasks due to the complexity and variability of language.</li>\n      <li><strong>Sequence Data:</strong> Handling sequence data (like time-series forecasting with long sequences or predicting the next word in a sentence) can be challenging for traditional ML models. Deep Learning models, especially RNNs, LSTMs, and Transformers, are more adept at capturing long-range dependencies in sequences.</li>\n    </ul>",
      "contentMarkdown": "*   Deep Learning (DL) models and traditional Machine Learning (ML) models serve different purposes and excel in various types of tasks. Understanding their strengths and limitations is crucial in selecting the right approach for a given problem.\n    \n*   **Traditional Machine Learning Models**: Traditional ML models include algorithms like linear regression, logistic regression, decision trees, random forests, support vector machines (SVMs), and k-nearest neighbors (k-NN). These models are often preferred for their simplicity, interpretability, and efficiency on smaller or structured datasets.\n    *   **Strengths:**\n        *   **Efficiency:** They generally require less computational resources.\n        *   **Interpretability:** Many traditional models are easier to interpret and understand, which is crucial in domains like finance and healthcare.\n        *   **Small Data:** They can perform well with smaller datasets.\n    *   **Limitations:**\n        *   **Feature Engineering:** Traditional ML models often rely heavily on feature engineering, i.e., manually creating and selecting the most relevant features from the data.\n        *   **Handling High-Dimensional Data:** They might struggle with very high-dimensional data or data with complex structures, like images and natural language.\n        *   **Modeling Complex Patterns:** Traditional models can be limited in their ability to capture complex, non-linear relationships in data.\n*   **Deep Learning Models**: Deep Learning models, particularly neural networks, are designed to learn hierarchical representations of data, making them extremely effective for tasks involving unstructured data like images, audio, and text.\n    *   **Strengths:**\n        *   **Handling Unstructured Data:** DL models excel in tasks involving high-dimensional and unstructured data (e.g., image and speech recognition, natural language processing).\n        *   **Automatic Feature Extraction:** They automatically learn and extract features from raw data, reducing the need for manual feature engineering.\n        *   **Modeling Complex Patterns:** Deep neural networks are capable of modeling highly complex and non-linear relationships.\n    *   **Limitations:**\n        *   **Data Requirements:** DL models usually require large amounts of labeled training data.\n        *   **Computational Resources:** They are computationally intensive and require more processing power, often necessitating GPUs for training.\n        *   **Interpretability:** Deep Learning models are often considered “black boxes” due to their complexity, making them less interpretable.\n*   **Cases Where Traditional ML Models Might Fail**:\n    *   **Image Recognition:** Tasks like object detection or facial recognition involve processing high-dimensional pixel data and recognizing complex patterns, something traditional ML models are generally not equipped to handle effectively.\n    *   **Natural Language Processing:** Tasks like machine translation, sentiment analysis, or question-answering involve understanding human language’s nuances, context, and syntax. Traditional ML struggles with such tasks due to the complexity and variability of language.\n    *   **Sequence Data:** Handling sequence data (like time-series forecasting with long sequences or predicting the next word in a sentence) can be challenging for traditional ML models. Deep Learning models, especially RNNs, LSTMs, and Transformers, are more adept at capturing long-range dependencies in sequences.\n*   In summary, the choice between traditional ML and DL models depends on the nature of the task, the type and amount of data available, the need for interpretability, and the computational resources at hand. While traditional models are effective for structured data and provide simplicity and interpretability, DL models are better suited for tasks involving complex patterns and high-dimensional, unstructured data.\n\nDeep Learning (DL) models and traditional Machine Learning (ML) models serve different purposes and excel in various types of tasks. Understanding their strengths and limitations is crucial in selecting the right approach for a given problem.\n\n*   **Strengths:**\n    *   **Efficiency:** They generally require less computational resources.\n    *   **Interpretability:** Many traditional models are easier to interpret and understand, which is crucial in domains like finance and healthcare.\n    *   **Small Data:** They can perform well with smaller datasets.\n*   **Limitations:**\n    *   **Feature Engineering:** Traditional ML models often rely heavily on feature engineering, i.e., manually creating and selecting the most relevant features from the data.\n    *   **Handling High-Dimensional Data:** They might struggle with very high-dimensional data or data with complex structures, like images and natural language.\n    *   **Modeling Complex Patterns:** Traditional models can be limited in their ability to capture complex, non-linear relationships in data.\n\n*   **Efficiency:** They generally require less computational resources.\n*   **Interpretability:** Many traditional models are easier to interpret and understand, which is crucial in domains like finance and healthcare.\n*   **Small Data:** They can perform well with smaller datasets.\n\n*   **Feature Engineering:** Traditional ML models often rely heavily on feature engineering, i.e., manually creating and selecting the most relevant features from the data.\n*   **Handling High-Dimensional Data:** They might struggle with very high-dimensional data or data with complex structures, like images and natural language.\n*   **Modeling Complex Patterns:** Traditional models can be limited in their ability to capture complex, non-linear relationships in data.\n\n*   **Strengths:**\n    *   **Handling Unstructured Data:** DL models excel in tasks involving high-dimensional and unstructured data (e.g., image and speech recognition, natural language processing).\n    *   **Automatic Feature Extraction:** They automatically learn and extract features from raw data, reducing the need for manual feature engineering.\n    *   **Modeling Complex Patterns:** Deep neural networks are capable of modeling highly complex and non-linear relationships.\n*   **Limitations:**\n    *   **Data Requirements:** DL models usually require large amounts of labeled training data.\n    *   **Computational Resources:** They are computationally intensive and require more processing power, often necessitating GPUs for training.\n    *   **Interpretability:** Deep Learning models are often considered “black boxes” due to their complexity, making them less interpretable.\n\n*   **Handling Unstructured Data:** DL models excel in tasks involving high-dimensional and unstructured data (e.g., image and speech recognition, natural language processing).\n*   **Automatic Feature Extraction:** They automatically learn and extract features from raw data, reducing the need for manual feature engineering.\n*   **Modeling Complex Patterns:** Deep neural networks are capable of modeling highly complex and non-linear relationships.\n\n*   **Data Requirements:** DL models usually require large amounts of labeled training data.\n*   **Computational Resources:** They are computationally intensive and require more processing power, often necessitating GPUs for training.\n*   **Interpretability:** Deep Learning models are often considered “black boxes” due to their complexity, making them less interpretable.\n\n*   **Image Recognition:** Tasks like object detection or facial recognition involve processing high-dimensional pixel data and recognizing complex patterns, something traditional ML models are generally not equipped to handle effectively.\n*   **Natural Language Processing:** Tasks like machine translation, sentiment analysis, or question-answering involve understanding human language’s nuances, context, and syntax. Traditional ML struggles with such tasks due to the complexity and variability of language.\n*   **Sequence Data:** Handling sequence data (like time-series forecasting with long sequences or predicting the next word in a sentence) can be challenging for traditional ML models. Deep Learning models, especially RNNs, LSTMs, and Transformers, are more adept at capturing long-range dependencies in sequences.",
      "order": 92,
      "orderInChapter": 92,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "machine learning",
        "transformer",
        "rnn",
        "lstm"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1074,
        "contentLength": 10028
      },
      "nextCards": [
        "ai-interview-in-self-attention-why-do-we-use-projections-of-kqv-93",
        "ai-interview-what-does-the-stable-in-stable-diffusion-refer-to-94"
      ],
      "relatedCards": [
        "ai-nlp-tasks-common-architectures-and-models-17",
        "ai-nlp-tasks-methodologies-and-models-36",
        "ai-transformers-inductive-biases-of-transformers-25",
        "ai-padding-and-packing-motivation-the-problem-with-padding-6",
        "ai-top-30-papers-neural-turing-machines-20"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-need-for-dl-models?-explain-traditional-ml-models-and-cases-where-they-would-fail?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-in-self-attention-why-do-we-use-projections-of-kqv-93",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "In Self-attention, Why Do We Use Projections of K,Q,V Instead of the Original Values?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In self-attention mechanisms, particularly those used in Transformer models, the use of projections (linear transformations) for Key (K), Query (Q), and Value (V) vectors, instead of their original values, is a crucial design choice that offers several benefits:</li>\n  <li><strong>Increasing Model Capacity and Flexibility</strong>:\n    <ul>\n      <li>Learning Task-Specific Representations: By projecting the inputs into Q, K, and V spaces, the model can learn representations that are specifically tailored for the task of attention. This is analogous to feature learning, where the model learns the most effective ways to represent data for a specific task.</li>\n      <li>Dimensionality Control: Projections allow control over the dimensionality of the Q, K, and V vectors. This is important for computational efficiency and to ensure that the dot-products (used in calculating attention scores) don’t grow too large with increasing input size.</li>\n      <li>Model Depth and Complexity: Using different projections for each head in multi-head attention allows the model to capture different types of relationships. Each head can focus on different parts of the input sequence, adding depth and complexity to the model’s understanding.</li>\n    </ul>\n  </li>\n  <li><strong>Enhancing the Model’s Ability to Capture Dependencies</strong>:\n    <ul>\n      <li><strong>Richer Representations:</strong> By transforming the inputs into different subspaces (for Q, K, and V), the model can create richer and more nuanced representations, which is crucial for capturing complex dependencies in the data.</li>\n      <li><strong>Facilitating Diverse Attention Patterns:</strong> Different projections enable the model to focus on different aspects of the input data, which is especially useful in multi-head attention. This diversity allows the model to simultaneously attend to different types of information, such as different levels of syntactic and semantic features in a sentence.</li>\n    </ul>\n  </li>\n  <li><strong>Practical Considerations</strong>:\n    <ul>\n      <li><strong>Parameterization and Learning:</strong> The projection matrices for Q, K, and V are learnable parameters. During training, the model optimizes these matrices, allowing the self-attention mechanism to adapt to the specific requirements of the data and task.</li>\n      <li><strong>Scalability:</strong> By choosing the dimensions of Q, K, and V, you can make a trade-off between computational cost and model expressiveness. This is important for scalability, especially when dealing with large input sequences.</li>\n    </ul>\n  </li>\n  <li>In summary, using projections for K, Q, and V in self-attention mechanisms is not just a matter of enhancing the model’s capacity and flexibility, but it is also crucial for enabling the model to learn and adapt to complex data patterns effectively. This approach allows the self-attention mechanism to be more expressive and context-aware, which is essential for tasks involving complex sequential data, such as language processing.</li>\n</ul>\n<ul>\n      <li>Learning Task-Specific Representations: By projecting the inputs into Q, K, and V spaces, the model can learn representations that are specifically tailored for the task of attention. This is analogous to feature learning, where the model learns the most effective ways to represent data for a specific task.</li>\n      <li>Dimensionality Control: Projections allow control over the dimensionality of the Q, K, and V vectors. This is important for computational efficiency and to ensure that the dot-products (used in calculating attention scores) don’t grow too large with increasing input size.</li>\n      <li>Model Depth and Complexity: Using different projections for each head in multi-head attention allows the model to capture different types of relationships. Each head can focus on different parts of the input sequence, adding depth and complexity to the model’s understanding.</li>\n    </ul>\n<ul>\n      <li><strong>Richer Representations:</strong> By transforming the inputs into different subspaces (for Q, K, and V), the model can create richer and more nuanced representations, which is crucial for capturing complex dependencies in the data.</li>\n      <li><strong>Facilitating Diverse Attention Patterns:</strong> Different projections enable the model to focus on different aspects of the input data, which is especially useful in multi-head attention. This diversity allows the model to simultaneously attend to different types of information, such as different levels of syntactic and semantic features in a sentence.</li>\n    </ul>\n<ul>\n      <li><strong>Parameterization and Learning:</strong> The projection matrices for Q, K, and V are learnable parameters. During training, the model optimizes these matrices, allowing the self-attention mechanism to adapt to the specific requirements of the data and task.</li>\n      <li><strong>Scalability:</strong> By choosing the dimensions of Q, K, and V, you can make a trade-off between computational cost and model expressiveness. This is important for scalability, especially when dealing with large input sequences.</li>\n    </ul>",
      "contentMarkdown": "*   In self-attention mechanisms, particularly those used in Transformer models, the use of projections (linear transformations) for Key (K), Query (Q), and Value (V) vectors, instead of their original values, is a crucial design choice that offers several benefits:\n*   **Increasing Model Capacity and Flexibility**:\n    *   Learning Task-Specific Representations: By projecting the inputs into Q, K, and V spaces, the model can learn representations that are specifically tailored for the task of attention. This is analogous to feature learning, where the model learns the most effective ways to represent data for a specific task.\n    *   Dimensionality Control: Projections allow control over the dimensionality of the Q, K, and V vectors. This is important for computational efficiency and to ensure that the dot-products (used in calculating attention scores) don’t grow too large with increasing input size.\n    *   Model Depth and Complexity: Using different projections for each head in multi-head attention allows the model to capture different types of relationships. Each head can focus on different parts of the input sequence, adding depth and complexity to the model’s understanding.\n*   **Enhancing the Model’s Ability to Capture Dependencies**:\n    *   **Richer Representations:** By transforming the inputs into different subspaces (for Q, K, and V), the model can create richer and more nuanced representations, which is crucial for capturing complex dependencies in the data.\n    *   **Facilitating Diverse Attention Patterns:** Different projections enable the model to focus on different aspects of the input data, which is especially useful in multi-head attention. This diversity allows the model to simultaneously attend to different types of information, such as different levels of syntactic and semantic features in a sentence.\n*   **Practical Considerations**:\n    *   **Parameterization and Learning:** The projection matrices for Q, K, and V are learnable parameters. During training, the model optimizes these matrices, allowing the self-attention mechanism to adapt to the specific requirements of the data and task.\n    *   **Scalability:** By choosing the dimensions of Q, K, and V, you can make a trade-off between computational cost and model expressiveness. This is important for scalability, especially when dealing with large input sequences.\n*   In summary, using projections for K, Q, and V in self-attention mechanisms is not just a matter of enhancing the model’s capacity and flexibility, but it is also crucial for enabling the model to learn and adapt to complex data patterns effectively. This approach allows the self-attention mechanism to be more expressive and context-aware, which is essential for tasks involving complex sequential data, such as language processing.\n\n*   Learning Task-Specific Representations: By projecting the inputs into Q, K, and V spaces, the model can learn representations that are specifically tailored for the task of attention. This is analogous to feature learning, where the model learns the most effective ways to represent data for a specific task.\n*   Dimensionality Control: Projections allow control over the dimensionality of the Q, K, and V vectors. This is important for computational efficiency and to ensure that the dot-products (used in calculating attention scores) don’t grow too large with increasing input size.\n*   Model Depth and Complexity: Using different projections for each head in multi-head attention allows the model to capture different types of relationships. Each head can focus on different parts of the input sequence, adding depth and complexity to the model’s understanding.\n\n*   **Richer Representations:** By transforming the inputs into different subspaces (for Q, K, and V), the model can create richer and more nuanced representations, which is crucial for capturing complex dependencies in the data.\n*   **Facilitating Diverse Attention Patterns:** Different projections enable the model to focus on different aspects of the input data, which is especially useful in multi-head attention. This diversity allows the model to simultaneously attend to different types of information, such as different levels of syntactic and semantic features in a sentence.\n\n*   **Parameterization and Learning:** The projection matrices for Q, K, and V are learnable parameters. During training, the model optimizes these matrices, allowing the self-attention mechanism to adapt to the specific requirements of the data and task.\n*   **Scalability:** By choosing the dimensions of Q, K, and V, you can make a trade-off between computational cost and model expressiveness. This is important for scalability, especially when dealing with large input sequences.",
      "order": 93,
      "orderInChapter": 93,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "transformer",
        "attention"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 700,
        "contentLength": 5188
      },
      "nextCards": [
        "ai-interview-what-does-the-stable-in-stable-diffusion-refer-to-94",
        "ai-interview-what-are-some-automated-ways-to-evaluate-the-quali-95"
      ],
      "relatedCards": [
        "ai-diffusion-models-diffusion-transformer-dit-17",
        "ai-transformers-multimodal-tasks-3",
        "ai-transformers-step-8-keyvalue-kv-caching-for-efficient-inference-22",
        "ai-transformers-transformers-27",
        "ai-transformers-attention-is-all-you-need-44"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#in-self-attention,-why-do-we-use-projections-of-k,q,v-instead-of-the-original-values?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-does-the-stable-in-stable-diffusion-refer-to-94",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What Does the “stable” in Stable Diffusion Refer To?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The “stability” in stable diffusion also refers to maintaining image content in the latent space throughout the diffusion process. In diffusion models, the image is transformed from the pixel space to the “latent space” – this is a high-dimensional abstract representation of the image. Here are the differences between the two:\n    <ul>\n      <li><strong>Pixel Space:</strong>\n        <ul>\n          <li>This refers to the space in which the data (such as images) is represented in its raw form – as pixels.</li>\n          <li>Each dimension corresponds to a pixel value, so an image of size 100x100 would have a pixel space of 10,000 dimensions.</li>\n          <li>Pixel space representations are direct and intuitive but can be very high-dimensional and sparse for complex data like images.</li>\n        </ul>\n      </li>\n      <li><strong>Latent Space:</strong>\n        <ul>\n          <li>Latent space is a lower-dimensional space where data is represented in a more compressed and abstract form.</li>\n          <li>Generative models, like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs), encode high-dimensional data (from pixel space) into this lower-dimensional latent space.</li>\n          <li>The latent representation captures the essential features or characteristics of the data, allowing for more efficient processing and manipulation.</li>\n          <li>Operations and transformations are often performed in latent space because they can be more meaningful and computationally efficient. For example, interpolating between two points in latent space can result in a smooth transition between two images when decoded back to pixel space.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>The “Stable” in Stable Diffusion refers to the fact that the forward and reverse diffusion process occur in a low-dimensional latent space vs. a high-dimensional pixel space leading to stability during diffusion.\nIf the latent space becomes unstable and loses image content too quickly, the generated pixel space images will be poor.</li>\n  <li>Stable diffusion uses techniques to keep the latent space more stable throughout the diffusion process:\n    <ul>\n      <li>The denoising model tries to remove noise while preserving latent space content at each step.</li>\n      <li>Regularization prevents the denoising model from changing too drastically between steps.</li>\n      <li>Careful noise scheduling maintains stability in early diffusion steps.</li>\n    </ul>\n  </li>\n  <li>This stable latent space leads to higher quality pixel generations. At the end, Stable Diffusion transforms the image from latent space back to the pixel space.</li>\n</ul>\n<ul>\n      <li><strong>Pixel Space:</strong>\n        <ul>\n          <li>This refers to the space in which the data (such as images) is represented in its raw form – as pixels.</li>\n          <li>Each dimension corresponds to a pixel value, so an image of size 100x100 would have a pixel space of 10,000 dimensions.</li>\n          <li>Pixel space representations are direct and intuitive but can be very high-dimensional and sparse for complex data like images.</li>\n        </ul>\n      </li>\n      <li><strong>Latent Space:</strong>\n        <ul>\n          <li>Latent space is a lower-dimensional space where data is represented in a more compressed and abstract form.</li>\n          <li>Generative models, like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs), encode high-dimensional data (from pixel space) into this lower-dimensional latent space.</li>\n          <li>The latent representation captures the essential features or characteristics of the data, allowing for more efficient processing and manipulation.</li>\n          <li>Operations and transformations are often performed in latent space because they can be more meaningful and computationally efficient. For example, interpolating between two points in latent space can result in a smooth transition between two images when decoded back to pixel space.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>This refers to the space in which the data (such as images) is represented in its raw form – as pixels.</li>\n          <li>Each dimension corresponds to a pixel value, so an image of size 100x100 would have a pixel space of 10,000 dimensions.</li>\n          <li>Pixel space representations are direct and intuitive but can be very high-dimensional and sparse for complex data like images.</li>\n        </ul>\n<ul>\n          <li>Latent space is a lower-dimensional space where data is represented in a more compressed and abstract form.</li>\n          <li>Generative models, like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs), encode high-dimensional data (from pixel space) into this lower-dimensional latent space.</li>\n          <li>The latent representation captures the essential features or characteristics of the data, allowing for more efficient processing and manipulation.</li>\n          <li>Operations and transformations are often performed in latent space because they can be more meaningful and computationally efficient. For example, interpolating between two points in latent space can result in a smooth transition between two images when decoded back to pixel space.</li>\n        </ul>\n<ul>\n      <li>The denoising model tries to remove noise while preserving latent space content at each step.</li>\n      <li>Regularization prevents the denoising model from changing too drastically between steps.</li>\n      <li>Careful noise scheduling maintains stability in early diffusion steps.</li>\n    </ul>",
      "contentMarkdown": "*   The “stability” in stable diffusion also refers to maintaining image content in the latent space throughout the diffusion process. In diffusion models, the image is transformed from the pixel space to the “latent space” – this is a high-dimensional abstract representation of the image. Here are the differences between the two:\n    *   **Pixel Space:**\n        *   This refers to the space in which the data (such as images) is represented in its raw form – as pixels.\n        *   Each dimension corresponds to a pixel value, so an image of size 100x100 would have a pixel space of 10,000 dimensions.\n        *   Pixel space representations are direct and intuitive but can be very high-dimensional and sparse for complex data like images.\n    *   **Latent Space:**\n        *   Latent space is a lower-dimensional space where data is represented in a more compressed and abstract form.\n        *   Generative models, like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs), encode high-dimensional data (from pixel space) into this lower-dimensional latent space.\n        *   The latent representation captures the essential features or characteristics of the data, allowing for more efficient processing and manipulation.\n        *   Operations and transformations are often performed in latent space because they can be more meaningful and computationally efficient. For example, interpolating between two points in latent space can result in a smooth transition between two images when decoded back to pixel space.\n*   The “Stable” in Stable Diffusion refers to the fact that the forward and reverse diffusion process occur in a low-dimensional latent space vs. a high-dimensional pixel space leading to stability during diffusion. If the latent space becomes unstable and loses image content too quickly, the generated pixel space images will be poor.\n*   Stable diffusion uses techniques to keep the latent space more stable throughout the diffusion process:\n    *   The denoising model tries to remove noise while preserving latent space content at each step.\n    *   Regularization prevents the denoising model from changing too drastically between steps.\n    *   Careful noise scheduling maintains stability in early diffusion steps.\n*   This stable latent space leads to higher quality pixel generations. At the end, Stable Diffusion transforms the image from latent space back to the pixel space.\n\n*   **Pixel Space:**\n    *   This refers to the space in which the data (such as images) is represented in its raw form – as pixels.\n    *   Each dimension corresponds to a pixel value, so an image of size 100x100 would have a pixel space of 10,000 dimensions.\n    *   Pixel space representations are direct and intuitive but can be very high-dimensional and sparse for complex data like images.\n*   **Latent Space:**\n    *   Latent space is a lower-dimensional space where data is represented in a more compressed and abstract form.\n    *   Generative models, like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs), encode high-dimensional data (from pixel space) into this lower-dimensional latent space.\n    *   The latent representation captures the essential features or characteristics of the data, allowing for more efficient processing and manipulation.\n    *   Operations and transformations are often performed in latent space because they can be more meaningful and computationally efficient. For example, interpolating between two points in latent space can result in a smooth transition between two images when decoded back to pixel space.\n\n*   This refers to the space in which the data (such as images) is represented in its raw form – as pixels.\n*   Each dimension corresponds to a pixel value, so an image of size 100x100 would have a pixel space of 10,000 dimensions.\n*   Pixel space representations are direct and intuitive but can be very high-dimensional and sparse for complex data like images.\n\n*   Latent space is a lower-dimensional space where data is represented in a more compressed and abstract form.\n*   Generative models, like Variational Autoencoders (VAEs) or Generative Adversarial Networks (GANs), encode high-dimensional data (from pixel space) into this lower-dimensional latent space.\n*   The latent representation captures the essential features or characteristics of the data, allowing for more efficient processing and manipulation.\n*   Operations and transformations are often performed in latent space because they can be more meaningful and computationally efficient. For example, interpolating between two points in latent space can result in a smooth transition between two images when decoded back to pixel space.\n\n*   The denoising model tries to remove noise while preserving latent space content at each step.\n*   Regularization prevents the denoising model from changing too drastically between steps.\n*   Careful noise scheduling maintains stability in early diffusion steps.",
      "order": 94,
      "orderInChapter": 94,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 740,
        "contentLength": 5643
      },
      "nextCards": [
        "ai-interview-what-are-some-automated-ways-to-evaluate-the-quali-95",
        "ai-interview-how-do-you-avoid-saddle-points-during-optimization-96"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-regularization-in-decision-trees-13",
        "ai-decision-trees-and-ensemble-methods-summary-of-regularization-parameters-15",
        "ai-decision-trees-and-ensemble-methods-why-are-decision-trees-rarely-used-by-themselves-w-20",
        "ai-decision-trees-and-ensemble-methods-does-boosting-reduce-bias-and-variance-both-compar-24",
        "ai-decision-trees-and-ensemble-methods-is-an-occasional-side-effect-of-boosting-an-increa-28"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-does-the-“stable”-in-stable-diffusion-refer-to?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-some-automated-ways-to-evaluate-the-quali-95",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Some Automated Ways to Evaluate the Quality of LLM Generated Output Without Reference Data?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Evaluating the quality of output generated by Large Language Models (LLMs) without reference data is challenging, as many traditional metrics like BLEU or ROUGE rely on comparing the generated text to a ground truth. However, there are several automated approaches that can provide insights into the quality of LLM outputs in the absence of reference data:\n  <strong>1. Perplexity</strong>\n      - <strong>Description:</strong> Perplexity measures how well a probability model predicts a sample. A lower perplexity score suggests that the model is more confident and possibly more accurate in its predictions.\n      - <strong>Limitation:</strong> Perplexity primarily assesses fluency and is not a direct measure of content quality, relevance, or factual accuracy.\n  <strong>1. Language Model Scoring</strong>\n      - <strong>Description:</strong> Use another pre-trained language model to evaluate the likelihood of the generated text. More probable text according to the language model might indicate higher quality.\n      - <strong>Limitation:</strong> Only measures n-gram overlap, not semantic similarity.\n  <strong>1. ROUGE-C Variant</strong>\n      - <strong>Description:</strong> Reference-free variant of the ROGUE metric. ROUGE-C measures overlap between an automated summary and the context.\n      - <strong>Limitation:</strong> Like perplexity, this approach is better at assessing fluency than content accuracy or relevance.\n  <strong>1. Grammatical Error Analysis</strong>\n      - <strong>Description:</strong> Automated grammar checking tools can assess the grammatical correctness of the text.\n      - <strong>Limitation:</strong> This method focuses only on grammar, not on content quality or factual accuracy.\n  <strong>1. Coherence and Consistency Checks</strong>\n      - <strong>Description:</strong> Algorithms can be employed to check for internal consistency and coherence in the generated text. This includes checking for consistent use of names, places, dates, and overall thematic consistency.\n      - <strong>Limitation:</strong> Developing sophisticated coherence-checking algorithms is challenging and an active area of research.\n  <strong>1. Sentiment Analysis</strong>\n      - <strong>Description:</strong> For texts where sentiment is important, automated sentiment analysis tools can evaluate whether the text maintains a consistent and appropriate sentiment throughout.\n      - <strong>Limitation:</strong> This method is only relevant for texts where sentiment is a key aspect of quality.\n  <strong>1. Keyword and Concept Frequency Analysis</strong>\n      - <strong>Description:</strong> Analyze the frequency and distribution of key terms and concepts to ensure that the text aligns with expected or typical patterns for a given topic or style.\n      - <strong>Limitation:</strong> It doesn’t assess the correctness or coherence of the content.\n  <strong>1. Readability Metrics</strong>\n      - <strong>Description:</strong> Automated readability tests (like Flesch-Kincaid, Gunning-Fog) can assess the complexity and readability of the text.\n      - <strong>Limitation:</strong> These metrics don’t evaluate the content’s accuracy or relevance.\n  <strong>1. Factual Consistency Checkers</strong>\n      - <strong>Description:</strong> Tools that cross-reference statements or claims in the text with trusted data sources or knowledge bases to check factual accuracy.\n      - <strong>Limitation:</strong> Limited by the availability and scope of external data sources and may not cover all types of content.\n  <strong>1. Novelty Measures</strong>\n      - <strong>Description:</strong> Evaluate the text for originality and novelty by comparing it with a large corpus of existing texts.\n      - <strong>Limitation:</strong> Novelty does not equate to quality, and false positives can occur.\n  <strong>10. Topic Modeling</strong>\n      - <strong>Description:</strong> Use unsupervised learning techniques like LDA (Latent Dirichlet Allocation) to determine if the generated text aligns well with specific topics.\n      - <strong>Limitation:</strong> It only provides a high-level view of the content’s relevance to the topic.\n  <strong>Conclusion</strong>: While these automated methods can offer valuable insights, they generally lack the nuanced understanding of human evaluators. They are best used as complementary tools to provide initial assessments or filter out low-quality outputs before more detailed human evaluation. It’s also important to remember that these methods each focus on different aspects of text quality and should be selected based on the specific requirements of the task at hand.</li>\n</ul>",
      "contentMarkdown": "*   Evaluating the quality of output generated by Large Language Models (LLMs) without reference data is challenging, as many traditional metrics like BLEU or ROUGE rely on comparing the generated text to a ground truth. However, there are several automated approaches that can provide insights into the quality of LLM outputs in the absence of reference data: **1\\. Perplexity** - **Description:** Perplexity measures how well a probability model predicts a sample. A lower perplexity score suggests that the model is more confident and possibly more accurate in its predictions. - **Limitation:** Perplexity primarily assesses fluency and is not a direct measure of content quality, relevance, or factual accuracy. **1\\. Language Model Scoring** - **Description:** Use another pre-trained language model to evaluate the likelihood of the generated text. More probable text according to the language model might indicate higher quality. - **Limitation:** Only measures n-gram overlap, not semantic similarity. **1\\. ROUGE-C Variant** - **Description:** Reference-free variant of the ROGUE metric. ROUGE-C measures overlap between an automated summary and the context. - **Limitation:** Like perplexity, this approach is better at assessing fluency than content accuracy or relevance. **1\\. Grammatical Error Analysis** - **Description:** Automated grammar checking tools can assess the grammatical correctness of the text. - **Limitation:** This method focuses only on grammar, not on content quality or factual accuracy. **1\\. Coherence and Consistency Checks** - **Description:** Algorithms can be employed to check for internal consistency and coherence in the generated text. This includes checking for consistent use of names, places, dates, and overall thematic consistency. - **Limitation:** Developing sophisticated coherence-checking algorithms is challenging and an active area of research. **1\\. Sentiment Analysis** - **Description:** For texts where sentiment is important, automated sentiment analysis tools can evaluate whether the text maintains a consistent and appropriate sentiment throughout. - **Limitation:** This method is only relevant for texts where sentiment is a key aspect of quality. **1\\. Keyword and Concept Frequency Analysis** - **Description:** Analyze the frequency and distribution of key terms and concepts to ensure that the text aligns with expected or typical patterns for a given topic or style. - **Limitation:** It doesn’t assess the correctness or coherence of the content. **1\\. Readability Metrics** - **Description:** Automated readability tests (like Flesch-Kincaid, Gunning-Fog) can assess the complexity and readability of the text. - **Limitation:** These metrics don’t evaluate the content’s accuracy or relevance. **1\\. Factual Consistency Checkers** - **Description:** Tools that cross-reference statements or claims in the text with trusted data sources or knowledge bases to check factual accuracy. - **Limitation:** Limited by the availability and scope of external data sources and may not cover all types of content. **1\\. Novelty Measures** - **Description:** Evaluate the text for originality and novelty by comparing it with a large corpus of existing texts. - **Limitation:** Novelty does not equate to quality, and false positives can occur. **10\\. Topic Modeling** - **Description:** Use unsupervised learning techniques like LDA (Latent Dirichlet Allocation) to determine if the generated text aligns well with specific topics. - **Limitation:** It only provides a high-level view of the content’s relevance to the topic. **Conclusion**: While these automated methods can offer valuable insights, they generally lack the nuanced understanding of human evaluators. They are best used as complementary tools to provide initial assessments or filter out low-quality outputs before more detailed human evaluation. It’s also important to remember that these methods each focus on different aspects of text quality and should be selected based on the specific requirements of the task at hand.",
      "order": 95,
      "orderInChapter": 95,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "llm",
        "supervised learning",
        "unsupervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 580,
        "contentLength": 4660
      },
      "nextCards": [
        "ai-interview-how-do-you-avoid-saddle-points-during-optimization-96",
        "ai-interview-when-do-you-use-bayesian-optimization-can-you-expl-97"
      ],
      "relatedCards": [
        "ai-clustering-partitioning-clustering-1",
        "ai-ann-similarity-search-clustering-based-methods-6",
        "ai-ml-comp-model-ensembles-7",
        "ai-reinforcement-learning-model-based-reinforcement-learning-12",
        "ai-agentic-RL-what-is-imitation-learning-and-why-sft-is-used-bef-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-automated-ways-to-evaluate-the-quality-of-llm-generated-output-without-reference-data?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-avoid-saddle-points-during-optimization-96",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Avoid Saddle Points During Optimization?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Avoiding or efficiently navigating through saddle points is a significant challenge in the optimization of high-dimensional non-convex functions, a common scenario in training deep neural networks. Saddle points are points where the gradient is zero, but unlike local minima, they are not optimal points for the function (the function has a flat curvature in some dimensions and negative curvature in others). Here are several strategies to deal with saddle points:\n    <ul>\n      <li><strong>Use of Advanced Optimization Algorithms:</strong>\n        <ul>\n          <li><strong>Adam, RMSprop:</strong> These optimizers adapt the learning rate during training and are generally better at dealing with saddle points compared to basic stochastic gradient descent (SGD).</li>\n          <li><strong>Momentum:</strong> Incorporating momentum helps in accumulating gradients over iterations, which can provide the necessary push to escape flat regions or saddle points.</li>\n        </ul>\n      </li>\n      <li><strong>Second-Order Methods:</strong> Methods like Newton’s method use second-order derivatives (Hessian matrix) to navigate the loss landscape. They can, in theory, differentiate between saddle points and minima by evaluating the curvature.\n  Limitation: Second-order methods are computationally expensive and less practical for very large models, although approximations (like quasi-Newton methods) exist.</li>\n      <li><strong>Random Perturbations:</strong> Adding noise to the gradients or weights can help the optimizer to jump out of saddle points or flat regions.\n  Stochastic Gradient Descent with Restarts: Periodically resetting the learning rate (also known as learning rate annealing) can also help escape saddle points.</li>\n      <li><strong>Adaptive Learning Rates:</strong> Learning rate schedules or adaptive learning rate methods can adjust the learning rate during training, helping to move out of saddle points more effectively.</li>\n      <li><strong>Batch Normalization:</strong> Batch normalization normalizes the input layer by adjusting the mean and variance. This can help in smoother optimization landscapes and can indirectly assist in dealing with saddle points.</li>\n      <li><strong>Proper Initialization and Regularization:</strong>\n        <ul>\n          <li>Good initialization strategies (like He or Glorot initialization) can set the training process on a good trajectory.</li>\n          <li>Regularization techniques like dropout or L2 regularization can also help in generalizing the learning process, which might contribute to avoiding getting stuck in saddle points.</li>\n        </ul>\n      </li>\n      <li><strong>Warm-up Phases:</strong> Starting with a lower learning rate and gradually increasing it (warm-up) can help the model to initially navigate the loss landscape more gently, avoiding getting stuck in sharp saddle points early in training.</li>\n      <li><strong>Escape Techniques:</strong> Research has proposed various escape techniques, such as perturbing the parameters if the learning process stalls, which can help the optimizer to escape saddle points.</li>\n    </ul>\n  </li>\n  <li>While these techniques can help mitigate the impact of saddle points, it’s important to note that in high-dimensional spaces (like those encountered in deep learning), saddle points are less problematic than poor local minima. Modern optimization algorithms, especially those with momentum and adaptive learning rates, are generally quite effective at navigating through saddle points.</li>\n</ul>\n<ul>\n      <li><strong>Use of Advanced Optimization Algorithms:</strong>\n        <ul>\n          <li><strong>Adam, RMSprop:</strong> These optimizers adapt the learning rate during training and are generally better at dealing with saddle points compared to basic stochastic gradient descent (SGD).</li>\n          <li><strong>Momentum:</strong> Incorporating momentum helps in accumulating gradients over iterations, which can provide the necessary push to escape flat regions or saddle points.</li>\n        </ul>\n      </li>\n      <li><strong>Second-Order Methods:</strong> Methods like Newton’s method use second-order derivatives (Hessian matrix) to navigate the loss landscape. They can, in theory, differentiate between saddle points and minima by evaluating the curvature.\n  Limitation: Second-order methods are computationally expensive and less practical for very large models, although approximations (like quasi-Newton methods) exist.</li>\n      <li><strong>Random Perturbations:</strong> Adding noise to the gradients or weights can help the optimizer to jump out of saddle points or flat regions.\n  Stochastic Gradient Descent with Restarts: Periodically resetting the learning rate (also known as learning rate annealing) can also help escape saddle points.</li>\n      <li><strong>Adaptive Learning Rates:</strong> Learning rate schedules or adaptive learning rate methods can adjust the learning rate during training, helping to move out of saddle points more effectively.</li>\n      <li><strong>Batch Normalization:</strong> Batch normalization normalizes the input layer by adjusting the mean and variance. This can help in smoother optimization landscapes and can indirectly assist in dealing with saddle points.</li>\n      <li><strong>Proper Initialization and Regularization:</strong>\n        <ul>\n          <li>Good initialization strategies (like He or Glorot initialization) can set the training process on a good trajectory.</li>\n          <li>Regularization techniques like dropout or L2 regularization can also help in generalizing the learning process, which might contribute to avoiding getting stuck in saddle points.</li>\n        </ul>\n      </li>\n      <li><strong>Warm-up Phases:</strong> Starting with a lower learning rate and gradually increasing it (warm-up) can help the model to initially navigate the loss landscape more gently, avoiding getting stuck in sharp saddle points early in training.</li>\n      <li><strong>Escape Techniques:</strong> Research has proposed various escape techniques, such as perturbing the parameters if the learning process stalls, which can help the optimizer to escape saddle points.</li>\n    </ul>\n<ul>\n          <li><strong>Adam, RMSprop:</strong> These optimizers adapt the learning rate during training and are generally better at dealing with saddle points compared to basic stochastic gradient descent (SGD).</li>\n          <li><strong>Momentum:</strong> Incorporating momentum helps in accumulating gradients over iterations, which can provide the necessary push to escape flat regions or saddle points.</li>\n        </ul>\n<ul>\n          <li>Good initialization strategies (like He or Glorot initialization) can set the training process on a good trajectory.</li>\n          <li>Regularization techniques like dropout or L2 regularization can also help in generalizing the learning process, which might contribute to avoiding getting stuck in saddle points.</li>\n        </ul>",
      "contentMarkdown": "*   Avoiding or efficiently navigating through saddle points is a significant challenge in the optimization of high-dimensional non-convex functions, a common scenario in training deep neural networks. Saddle points are points where the gradient is zero, but unlike local minima, they are not optimal points for the function (the function has a flat curvature in some dimensions and negative curvature in others). Here are several strategies to deal with saddle points:\n    *   **Use of Advanced Optimization Algorithms:**\n        *   **Adam, RMSprop:** These optimizers adapt the learning rate during training and are generally better at dealing with saddle points compared to basic stochastic gradient descent (SGD).\n        *   **Momentum:** Incorporating momentum helps in accumulating gradients over iterations, which can provide the necessary push to escape flat regions or saddle points.\n    *   **Second-Order Methods:** Methods like Newton’s method use second-order derivatives (Hessian matrix) to navigate the loss landscape. They can, in theory, differentiate between saddle points and minima by evaluating the curvature. Limitation: Second-order methods are computationally expensive and less practical for very large models, although approximations (like quasi-Newton methods) exist.\n    *   **Random Perturbations:** Adding noise to the gradients or weights can help the optimizer to jump out of saddle points or flat regions. Stochastic Gradient Descent with Restarts: Periodically resetting the learning rate (also known as learning rate annealing) can also help escape saddle points.\n    *   **Adaptive Learning Rates:** Learning rate schedules or adaptive learning rate methods can adjust the learning rate during training, helping to move out of saddle points more effectively.\n    *   **Batch Normalization:** Batch normalization normalizes the input layer by adjusting the mean and variance. This can help in smoother optimization landscapes and can indirectly assist in dealing with saddle points.\n    *   **Proper Initialization and Regularization:**\n        *   Good initialization strategies (like He or Glorot initialization) can set the training process on a good trajectory.\n        *   Regularization techniques like dropout or L2 regularization can also help in generalizing the learning process, which might contribute to avoiding getting stuck in saddle points.\n    *   **Warm-up Phases:** Starting with a lower learning rate and gradually increasing it (warm-up) can help the model to initially navigate the loss landscape more gently, avoiding getting stuck in sharp saddle points early in training.\n    *   **Escape Techniques:** Research has proposed various escape techniques, such as perturbing the parameters if the learning process stalls, which can help the optimizer to escape saddle points.\n*   While these techniques can help mitigate the impact of saddle points, it’s important to note that in high-dimensional spaces (like those encountered in deep learning), saddle points are less problematic than poor local minima. Modern optimization algorithms, especially those with momentum and adaptive learning rates, are generally quite effective at navigating through saddle points.\n\n*   **Use of Advanced Optimization Algorithms:**\n    *   **Adam, RMSprop:** These optimizers adapt the learning rate during training and are generally better at dealing with saddle points compared to basic stochastic gradient descent (SGD).\n    *   **Momentum:** Incorporating momentum helps in accumulating gradients over iterations, which can provide the necessary push to escape flat regions or saddle points.\n*   **Second-Order Methods:** Methods like Newton’s method use second-order derivatives (Hessian matrix) to navigate the loss landscape. They can, in theory, differentiate between saddle points and minima by evaluating the curvature. Limitation: Second-order methods are computationally expensive and less practical for very large models, although approximations (like quasi-Newton methods) exist.\n*   **Random Perturbations:** Adding noise to the gradients or weights can help the optimizer to jump out of saddle points or flat regions. Stochastic Gradient Descent with Restarts: Periodically resetting the learning rate (also known as learning rate annealing) can also help escape saddle points.\n*   **Adaptive Learning Rates:** Learning rate schedules or adaptive learning rate methods can adjust the learning rate during training, helping to move out of saddle points more effectively.\n*   **Batch Normalization:** Batch normalization normalizes the input layer by adjusting the mean and variance. This can help in smoother optimization landscapes and can indirectly assist in dealing with saddle points.\n*   **Proper Initialization and Regularization:**\n    *   Good initialization strategies (like He or Glorot initialization) can set the training process on a good trajectory.\n    *   Regularization techniques like dropout or L2 regularization can also help in generalizing the learning process, which might contribute to avoiding getting stuck in saddle points.\n*   **Warm-up Phases:** Starting with a lower learning rate and gradually increasing it (warm-up) can help the model to initially navigate the loss landscape more gently, avoiding getting stuck in sharp saddle points early in training.\n*   **Escape Techniques:** Research has proposed various escape techniques, such as perturbing the parameters if the learning process stalls, which can help the optimizer to escape saddle points.\n\n*   **Adam, RMSprop:** These optimizers adapt the learning rate during training and are generally better at dealing with saddle points compared to basic stochastic gradient descent (SGD).\n*   **Momentum:** Incorporating momentum helps in accumulating gradients over iterations, which can provide the necessary push to escape flat regions or saddle points.\n\n*   Good initialization strategies (like He or Glorot initialization) can set the training process on a good trajectory.\n*   Regularization techniques like dropout or L2 regularization can also help in generalizing the learning process, which might contribute to avoiding getting stuck in saddle points.",
      "order": 96,
      "orderInChapter": 96,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "optimization",
        "gradient descent",
        "regularization",
        "dropout",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 866,
        "contentLength": 7005
      },
      "nextCards": [
        "ai-interview-when-do-you-use-bayesian-optimization-can-you-expl-97",
        "ai-interview-what-is-the-difference-between-auto-encoder-ae-and-98"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-model-debugging-knowledge-distillation-student-teacher-approach-16",
        "ai-decision-trees-and-ensemble-methods-what-are-the-biggest-advantages-of-using-gbdts-com-22",
        "ai-bias-variance-tradeoff-techniques-to-prevent-underfitting-11",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-avoid-saddle-points-during-optimization?",
      "scrapedAt": "2025-12-28T11:58:12.840Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-when-do-you-use-bayesian-optimization-can-you-expl-97",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "When Do You Use Bayesian Optimization? Can You Explain How It Works?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Bayesian optimization is a powerful strategy for optimizing objective functions that are expensive to evaluate, non-convex, or do not have an analytical form. It’s particularly useful when you have limited data points and when each evaluation of the function is costly (in terms of time or resources). Common use cases include hyperparameter tuning of machine learning models, optimizing complex systems in engineering, and designing experiments.</li>\n  <li><strong>When to Use Bayesian Optimization:</strong>\n    <ul>\n      <li><strong>Expensive Evaluations:</strong> Ideal when each evaluation of the function is time-consuming or resource-intensive, like training a complex machine learning model.</li>\n      <li><strong>Limited Data:</strong> Useful when you can only afford a small number of function evaluations.</li>\n      <li><strong>Noisy Objective Functions:</strong> Effective for functions where evaluations provide noisy or uncertain results.</li>\n      <li><strong>Black-Box Functions:</strong> Suitable for functions without an explicit closed form (i.e., you can get function outputs for given inputs, but you don’t have an analytical expression for the function).</li>\n      <li><strong>Global Optimization of Non-Convex Functions:</strong> Good for finding the global optimum in cases where the objective function is non-convex and traditional methods might get stuck in local optima.</li>\n    </ul>\n  </li>\n  <li><strong>How Bayesian Optimization Works:</strong>\n    <ul>\n      <li><strong>Surrogate Model:</strong> Bayesian optimization builds a surrogate probabilistic model of the objective function. This model is used to make predictions about the function and to estimate the uncertainty in those predictions. Gaussian Processes (GPs) are commonly used as the surrogate model due to their ability to model uncertainty effectively.</li>\n      <li><strong>Acquisition Function:</strong> This function is derived from the surrogate model and is used to decide where to sample next. It balances exploration (sampling where the model is uncertain) and exploitation (sampling where the model predicts high values). Common acquisition functions include Expected Improvement (EI), Probability of Improvement (PI), and Upper Confidence Bound (UCB).</li>\n      <li><strong>Iterative Process:</strong>\n        <ul>\n          <li><strong>Initialization:</strong> Start with a few random evaluations of the objective function.</li>\n          <li><strong>Update the Model:</strong> Use these evaluations to update the surrogate model.</li>\n          <li><strong>Optimize Acquisition Function:</strong> Use the surrogate model to optimize the acquisition function. This step gives you the next point to evaluate the objective function.</li>\n          <li><strong>Sample the Objective Function:</strong> Evaluate the objective function at this new point.</li>\n          <li><strong>Update the Surrogate Model:</strong> Incorporate the new result into the surrogate model.</li>\n          <li>Repeat the process of optimizing the acquisition function and updating the model with the new evaluation until a stopping criterion is met (like a maximum number of evaluations).</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Handling Constraints and Multiple Objectives:</strong> Bayesian optimization can be extended to handle constraints and multiple objectives, often through additional surrogate models or modified acquisition functions.</li>\n  <li><strong>Summary</strong>: Bayesian optimization is an efficient method for optimizing complex, expensive-to-evaluate functions, particularly when the number of evaluations is limited. Its strength lies in balancing exploration and exploitation using a surrogate model and an acquisition function. It’s widely used in hyperparameter tuning and scenarios where traditional optimization methods are less effective or too costly to apply.</li>\n</ul>\n<ul>\n      <li><strong>Expensive Evaluations:</strong> Ideal when each evaluation of the function is time-consuming or resource-intensive, like training a complex machine learning model.</li>\n      <li><strong>Limited Data:</strong> Useful when you can only afford a small number of function evaluations.</li>\n      <li><strong>Noisy Objective Functions:</strong> Effective for functions where evaluations provide noisy or uncertain results.</li>\n      <li><strong>Black-Box Functions:</strong> Suitable for functions without an explicit closed form (i.e., you can get function outputs for given inputs, but you don’t have an analytical expression for the function).</li>\n      <li><strong>Global Optimization of Non-Convex Functions:</strong> Good for finding the global optimum in cases where the objective function is non-convex and traditional methods might get stuck in local optima.</li>\n    </ul>\n<ul>\n      <li><strong>Surrogate Model:</strong> Bayesian optimization builds a surrogate probabilistic model of the objective function. This model is used to make predictions about the function and to estimate the uncertainty in those predictions. Gaussian Processes (GPs) are commonly used as the surrogate model due to their ability to model uncertainty effectively.</li>\n      <li><strong>Acquisition Function:</strong> This function is derived from the surrogate model and is used to decide where to sample next. It balances exploration (sampling where the model is uncertain) and exploitation (sampling where the model predicts high values). Common acquisition functions include Expected Improvement (EI), Probability of Improvement (PI), and Upper Confidence Bound (UCB).</li>\n      <li><strong>Iterative Process:</strong>\n        <ul>\n          <li><strong>Initialization:</strong> Start with a few random evaluations of the objective function.</li>\n          <li><strong>Update the Model:</strong> Use these evaluations to update the surrogate model.</li>\n          <li><strong>Optimize Acquisition Function:</strong> Use the surrogate model to optimize the acquisition function. This step gives you the next point to evaluate the objective function.</li>\n          <li><strong>Sample the Objective Function:</strong> Evaluate the objective function at this new point.</li>\n          <li><strong>Update the Surrogate Model:</strong> Incorporate the new result into the surrogate model.</li>\n          <li>Repeat the process of optimizing the acquisition function and updating the model with the new evaluation until a stopping criterion is met (like a maximum number of evaluations).</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Initialization:</strong> Start with a few random evaluations of the objective function.</li>\n          <li><strong>Update the Model:</strong> Use these evaluations to update the surrogate model.</li>\n          <li><strong>Optimize Acquisition Function:</strong> Use the surrogate model to optimize the acquisition function. This step gives you the next point to evaluate the objective function.</li>\n          <li><strong>Sample the Objective Function:</strong> Evaluate the objective function at this new point.</li>\n          <li><strong>Update the Surrogate Model:</strong> Incorporate the new result into the surrogate model.</li>\n          <li>Repeat the process of optimizing the acquisition function and updating the model with the new evaluation until a stopping criterion is met (like a maximum number of evaluations).</li>\n        </ul>",
      "contentMarkdown": "*   Bayesian optimization is a powerful strategy for optimizing objective functions that are expensive to evaluate, non-convex, or do not have an analytical form. It’s particularly useful when you have limited data points and when each evaluation of the function is costly (in terms of time or resources). Common use cases include hyperparameter tuning of machine learning models, optimizing complex systems in engineering, and designing experiments.\n*   **When to Use Bayesian Optimization:**\n    *   **Expensive Evaluations:** Ideal when each evaluation of the function is time-consuming or resource-intensive, like training a complex machine learning model.\n    *   **Limited Data:** Useful when you can only afford a small number of function evaluations.\n    *   **Noisy Objective Functions:** Effective for functions where evaluations provide noisy or uncertain results.\n    *   **Black-Box Functions:** Suitable for functions without an explicit closed form (i.e., you can get function outputs for given inputs, but you don’t have an analytical expression for the function).\n    *   **Global Optimization of Non-Convex Functions:** Good for finding the global optimum in cases where the objective function is non-convex and traditional methods might get stuck in local optima.\n*   **How Bayesian Optimization Works:**\n    *   **Surrogate Model:** Bayesian optimization builds a surrogate probabilistic model of the objective function. This model is used to make predictions about the function and to estimate the uncertainty in those predictions. Gaussian Processes (GPs) are commonly used as the surrogate model due to their ability to model uncertainty effectively.\n    *   **Acquisition Function:** This function is derived from the surrogate model and is used to decide where to sample next. It balances exploration (sampling where the model is uncertain) and exploitation (sampling where the model predicts high values). Common acquisition functions include Expected Improvement (EI), Probability of Improvement (PI), and Upper Confidence Bound (UCB).\n    *   **Iterative Process:**\n        *   **Initialization:** Start with a few random evaluations of the objective function.\n        *   **Update the Model:** Use these evaluations to update the surrogate model.\n        *   **Optimize Acquisition Function:** Use the surrogate model to optimize the acquisition function. This step gives you the next point to evaluate the objective function.\n        *   **Sample the Objective Function:** Evaluate the objective function at this new point.\n        *   **Update the Surrogate Model:** Incorporate the new result into the surrogate model.\n        *   Repeat the process of optimizing the acquisition function and updating the model with the new evaluation until a stopping criterion is met (like a maximum number of evaluations).\n*   **Handling Constraints and Multiple Objectives:** Bayesian optimization can be extended to handle constraints and multiple objectives, often through additional surrogate models or modified acquisition functions.\n*   **Summary**: Bayesian optimization is an efficient method for optimizing complex, expensive-to-evaluate functions, particularly when the number of evaluations is limited. Its strength lies in balancing exploration and exploitation using a surrogate model and an acquisition function. It’s widely used in hyperparameter tuning and scenarios where traditional optimization methods are less effective or too costly to apply.\n\n*   **Expensive Evaluations:** Ideal when each evaluation of the function is time-consuming or resource-intensive, like training a complex machine learning model.\n*   **Limited Data:** Useful when you can only afford a small number of function evaluations.\n*   **Noisy Objective Functions:** Effective for functions where evaluations provide noisy or uncertain results.\n*   **Black-Box Functions:** Suitable for functions without an explicit closed form (i.e., you can get function outputs for given inputs, but you don’t have an analytical expression for the function).\n*   **Global Optimization of Non-Convex Functions:** Good for finding the global optimum in cases where the objective function is non-convex and traditional methods might get stuck in local optima.\n\n*   **Surrogate Model:** Bayesian optimization builds a surrogate probabilistic model of the objective function. This model is used to make predictions about the function and to estimate the uncertainty in those predictions. Gaussian Processes (GPs) are commonly used as the surrogate model due to their ability to model uncertainty effectively.\n*   **Acquisition Function:** This function is derived from the surrogate model and is used to decide where to sample next. It balances exploration (sampling where the model is uncertain) and exploitation (sampling where the model predicts high values). Common acquisition functions include Expected Improvement (EI), Probability of Improvement (PI), and Upper Confidence Bound (UCB).\n*   **Iterative Process:**\n    *   **Initialization:** Start with a few random evaluations of the objective function.\n    *   **Update the Model:** Use these evaluations to update the surrogate model.\n    *   **Optimize Acquisition Function:** Use the surrogate model to optimize the acquisition function. This step gives you the next point to evaluate the objective function.\n    *   **Sample the Objective Function:** Evaluate the objective function at this new point.\n    *   **Update the Surrogate Model:** Incorporate the new result into the surrogate model.\n    *   Repeat the process of optimizing the acquisition function and updating the model with the new evaluation until a stopping criterion is met (like a maximum number of evaluations).\n\n*   **Initialization:** Start with a few random evaluations of the objective function.\n*   **Update the Model:** Use these evaluations to update the surrogate model.\n*   **Optimize Acquisition Function:** Use the surrogate model to optimize the acquisition function. This step gives you the next point to evaluate the objective function.\n*   **Sample the Objective Function:** Evaluate the objective function at this new point.\n*   **Update the Surrogate Model:** Incorporate the new result into the surrogate model.\n*   Repeat the process of optimizing the acquisition function and updating the model with the new evaluation until a stopping criterion is met (like a maximum number of evaluations).",
      "order": 97,
      "orderInChapter": 97,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "machine learning",
        "optimization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 904,
        "contentLength": 7438
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-auto-encoder-ae-and-98",
        "ai-interview-the-cross-entropy-loss-function-is-non-convex-when-99"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-for-practical-deployments-why-is-boosting-preferre-23",
        "ai-loss-mean-squared-error-mse-l2-loss-10",
        "ai-decision-trees-and-ensemble-methods-can-decision-trees-be-fine-tuned-ie-do-they-have-i-18",
        "ai-support-vector-machines-optimization-problem-4",
        "ai-support-vector-machines-conceptual-overview-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#when-do-you-use-bayesian-optimization?-can-you-explain-how-it-works?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-auto-encoder-ae-and-98",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Auto-encoder (AE) and Variational Auto-encoder (VAE)? What Do We Include in the Loss Function of the VAE to Enforce Its Properties?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Autoencoders (AE) and Variational Autoencoders (VAE) are both neural network architectures used for unsupervised learning, typically in the context of data compression and reconstruction. However, they have distinct characteristics, especially in how they handle the encoding process and the nature of their loss functions.</li>\n  <li><strong>Autoencoders (AE)</strong>:\n    <ul>\n      <li><strong>Structure:</strong> An autoencoder consists of two main components: an encoder and a decoder. The encoder compresses the input into a lower-dimensional latent space (encoding), and the decoder reconstructs the input from this latent space.</li>\n      <li><strong>Objective:</strong> The goal is to minimize the reconstruction error, typically measured by a loss function like mean squared error (MSE) for continuous input data or cross-entropy for binary input data.</li>\n      <li><strong>Use Cases:</strong> AEs are used for dimensionality reduction, denoising, and feature learning.</li>\n      <li><strong>Characteristics:</strong> The latent space in standard AEs doesn’t impose any constraints on how the data points are organized or distributed within it.</li>\n    </ul>\n  </li>\n  <li><strong>Variational Autoencoders (VAE)</strong>\n    <ul>\n      <li><strong>Structure:</strong> Similar to AEs, VAEs have an encoder and a decoder. However, the encoder in a VAE maps the input into a probability distribution (usually Gaussian) in the latent space.</li>\n      <li><strong>Objective:</strong> VAEs aim to optimize the reconstruction while also regularizing the encoder by imposing a distribution on the latent space.</li>\n      <li><strong>Use Cases:</strong> VAEs are used for generative tasks, such as generating new data samples that resemble the input data, in addition to tasks similar to AEs.</li>\n      <li><strong>Characteristics:</strong> The latent space in VAEs is regularized, meaning the encoder learns to generate latent vectors that roughly follow a predefined distribution (typically a Gaussian distribution).</li>\n    </ul>\n  </li>\n  <li><strong>Loss Function of a VAE</strong>: The loss function in a VAE consists of two main components:\n    <ul>\n      <li><strong>Reconstruction Loss:</strong> Like in an AE, this part of the loss function measures how well the decoder is able to reconstruct the input data from the latent representation. This is often the MSE or binary cross-entropy.</li>\n      <li><strong>Kullback-Leibler (KL) Divergence:</strong> This component is the key differentiator for VAEs. It measures how much the learned distribution in the latent space deviates from a predefined distribution (again, typically Gaussian). The KL divergence acts as a regularizer in the loss function, enforcing the distribution of the latent space to follow the desired distribution.\n        <ul>\n          <li><strong>Regularization:</strong> This regularization encourages the model to create a well-structured and continuous latent space, which is crucial for generating new data points.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Summary</strong>:\n    <ul>\n      <li>Autoencoders are primarily used for efficient data encoding and reconstruction, focusing on minimizing the reconstruction error.</li>\n      <li>Variational Autoencoders, while also capable of data reconstruction, are designed as generative models. They regularize the latent space to follow a specific distribution, facilitating the generation of new data points that are similar to the training data. This regularization is enforced through the inclusion of the KL divergence in the loss function.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Structure:</strong> An autoencoder consists of two main components: an encoder and a decoder. The encoder compresses the input into a lower-dimensional latent space (encoding), and the decoder reconstructs the input from this latent space.</li>\n      <li><strong>Objective:</strong> The goal is to minimize the reconstruction error, typically measured by a loss function like mean squared error (MSE) for continuous input data or cross-entropy for binary input data.</li>\n      <li><strong>Use Cases:</strong> AEs are used for dimensionality reduction, denoising, and feature learning.</li>\n      <li><strong>Characteristics:</strong> The latent space in standard AEs doesn’t impose any constraints on how the data points are organized or distributed within it.</li>\n    </ul>\n<ul>\n      <li><strong>Structure:</strong> Similar to AEs, VAEs have an encoder and a decoder. However, the encoder in a VAE maps the input into a probability distribution (usually Gaussian) in the latent space.</li>\n      <li><strong>Objective:</strong> VAEs aim to optimize the reconstruction while also regularizing the encoder by imposing a distribution on the latent space.</li>\n      <li><strong>Use Cases:</strong> VAEs are used for generative tasks, such as generating new data samples that resemble the input data, in addition to tasks similar to AEs.</li>\n      <li><strong>Characteristics:</strong> The latent space in VAEs is regularized, meaning the encoder learns to generate latent vectors that roughly follow a predefined distribution (typically a Gaussian distribution).</li>\n    </ul>\n<ul>\n      <li><strong>Reconstruction Loss:</strong> Like in an AE, this part of the loss function measures how well the decoder is able to reconstruct the input data from the latent representation. This is often the MSE or binary cross-entropy.</li>\n      <li><strong>Kullback-Leibler (KL) Divergence:</strong> This component is the key differentiator for VAEs. It measures how much the learned distribution in the latent space deviates from a predefined distribution (again, typically Gaussian). The KL divergence acts as a regularizer in the loss function, enforcing the distribution of the latent space to follow the desired distribution.\n        <ul>\n          <li><strong>Regularization:</strong> This regularization encourages the model to create a well-structured and continuous latent space, which is crucial for generating new data points.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Regularization:</strong> This regularization encourages the model to create a well-structured and continuous latent space, which is crucial for generating new data points.</li>\n        </ul>\n<ul>\n      <li>Autoencoders are primarily used for efficient data encoding and reconstruction, focusing on minimizing the reconstruction error.</li>\n      <li>Variational Autoencoders, while also capable of data reconstruction, are designed as generative models. They regularize the latent space to follow a specific distribution, facilitating the generation of new data points that are similar to the training data. This regularization is enforced through the inclusion of the KL divergence in the loss function.</li>\n    </ul>",
      "contentMarkdown": "*   Autoencoders (AE) and Variational Autoencoders (VAE) are both neural network architectures used for unsupervised learning, typically in the context of data compression and reconstruction. However, they have distinct characteristics, especially in how they handle the encoding process and the nature of their loss functions.\n*   **Autoencoders (AE)**:\n    *   **Structure:** An autoencoder consists of two main components: an encoder and a decoder. The encoder compresses the input into a lower-dimensional latent space (encoding), and the decoder reconstructs the input from this latent space.\n    *   **Objective:** The goal is to minimize the reconstruction error, typically measured by a loss function like mean squared error (MSE) for continuous input data or cross-entropy for binary input data.\n    *   **Use Cases:** AEs are used for dimensionality reduction, denoising, and feature learning.\n    *   **Characteristics:** The latent space in standard AEs doesn’t impose any constraints on how the data points are organized or distributed within it.\n*   **Variational Autoencoders (VAE)**\n    *   **Structure:** Similar to AEs, VAEs have an encoder and a decoder. However, the encoder in a VAE maps the input into a probability distribution (usually Gaussian) in the latent space.\n    *   **Objective:** VAEs aim to optimize the reconstruction while also regularizing the encoder by imposing a distribution on the latent space.\n    *   **Use Cases:** VAEs are used for generative tasks, such as generating new data samples that resemble the input data, in addition to tasks similar to AEs.\n    *   **Characteristics:** The latent space in VAEs is regularized, meaning the encoder learns to generate latent vectors that roughly follow a predefined distribution (typically a Gaussian distribution).\n*   **Loss Function of a VAE**: The loss function in a VAE consists of two main components:\n    *   **Reconstruction Loss:** Like in an AE, this part of the loss function measures how well the decoder is able to reconstruct the input data from the latent representation. This is often the MSE or binary cross-entropy.\n    *   **Kullback-Leibler (KL) Divergence:** This component is the key differentiator for VAEs. It measures how much the learned distribution in the latent space deviates from a predefined distribution (again, typically Gaussian). The KL divergence acts as a regularizer in the loss function, enforcing the distribution of the latent space to follow the desired distribution.\n        *   **Regularization:** This regularization encourages the model to create a well-structured and continuous latent space, which is crucial for generating new data points.\n*   **Summary**:\n    *   Autoencoders are primarily used for efficient data encoding and reconstruction, focusing on minimizing the reconstruction error.\n    *   Variational Autoencoders, while also capable of data reconstruction, are designed as generative models. They regularize the latent space to follow a specific distribution, facilitating the generation of new data points that are similar to the training data. This regularization is enforced through the inclusion of the KL divergence in the loss function.\n\n*   **Structure:** An autoencoder consists of two main components: an encoder and a decoder. The encoder compresses the input into a lower-dimensional latent space (encoding), and the decoder reconstructs the input from this latent space.\n*   **Objective:** The goal is to minimize the reconstruction error, typically measured by a loss function like mean squared error (MSE) for continuous input data or cross-entropy for binary input data.\n*   **Use Cases:** AEs are used for dimensionality reduction, denoising, and feature learning.\n*   **Characteristics:** The latent space in standard AEs doesn’t impose any constraints on how the data points are organized or distributed within it.\n\n*   **Structure:** Similar to AEs, VAEs have an encoder and a decoder. However, the encoder in a VAE maps the input into a probability distribution (usually Gaussian) in the latent space.\n*   **Objective:** VAEs aim to optimize the reconstruction while also regularizing the encoder by imposing a distribution on the latent space.\n*   **Use Cases:** VAEs are used for generative tasks, such as generating new data samples that resemble the input data, in addition to tasks similar to AEs.\n*   **Characteristics:** The latent space in VAEs is regularized, meaning the encoder learns to generate latent vectors that roughly follow a predefined distribution (typically a Gaussian distribution).\n\n*   **Reconstruction Loss:** Like in an AE, this part of the loss function measures how well the decoder is able to reconstruct the input data from the latent representation. This is often the MSE or binary cross-entropy.\n*   **Kullback-Leibler (KL) Divergence:** This component is the key differentiator for VAEs. It measures how much the learned distribution in the latent space deviates from a predefined distribution (again, typically Gaussian). The KL divergence acts as a regularizer in the loss function, enforcing the distribution of the latent space to follow the desired distribution.\n    *   **Regularization:** This regularization encourages the model to create a well-structured and continuous latent space, which is crucial for generating new data points.\n\n*   **Regularization:** This regularization encourages the model to create a well-structured and continuous latent space, which is crucial for generating new data points.\n\n*   Autoencoders are primarily used for efficient data encoding and reconstruction, focusing on minimizing the reconstruction error.\n*   Variational Autoencoders, while also capable of data reconstruction, are designed as generative models. They regularize the latent space to follow a specific distribution, facilitating the generation of new data points that are similar to the training data. This regularization is enforced through the inclusion of the KL divergence in the loss function.",
      "order": 98,
      "orderInChapter": 98,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "supervised learning",
        "unsupervised learning",
        "loss function",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 878,
        "contentLength": 6892
      },
      "nextCards": [
        "ai-interview-the-cross-entropy-loss-function-is-non-convex-when-99",
        "ai-interview-how-would-you-make-a-gcn-graph-convolutional-neura-100"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32",
        "ai-ml-comp-model-ensembles-7",
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-diffusion-models-at-a-high-level-how-do-diffusion-models-work-what--42",
        "ai-loss-cross-entropy-loss-function-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-auto-encoder-(ae)-and-variational-auto-encoder-(vae)?-what-do-we-include-in-the-loss-function-of-the-vae-to-enforce-its-properties?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-the-cross-entropy-loss-function-is-non-convex-when-99",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "The Cross Entropy Loss Function is Non-convex When Used in Complex Deep Neural Networks. Yet, This is Rarely a Problem Despite the High Likelihood of Ending up in a Local Minimum. Why?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The observation that the cross-entropy loss function, when used in complex deep neural networks, is non-convex yet doesn’t usually result in problematic local - minima, is an interesting aspect of modern deep learning. Here’s an explanation of why this apparent paradox isn’t usually a significant issue:\n    <ul>\n      <li><strong>High-Dimensional Loss Landscapes:</strong> Deep neural networks operate in very high-dimensional spaces. In such spaces, the behavior of loss functions and the nature of local minima are quite different from what we might intuit from low-dimensional spaces. In high dimensions, it’s actually more likely for a local minimum to be very close to a global minimum in terms of the loss value.</li>\n      <li><strong>Saddle Points vs. Local Minima:</strong> Research indicates that in high-dimensional spaces, saddle points (where the gradient is zero but which are not minima) are more common than local minima. Optimization algorithms, especially those with momentum, are quite good at escaping saddle points.</li>\n      <li><strong>Empirical Success of Gradient Descent:</strong> Gradient descent and its variants, despite their simplicity, have been empirically successful in finding good minima in - complex loss landscapes of deep networks. They tend to find “flat” minima, which are areas in the loss landscape where the loss value doesn’t change much, and these flat minima often generalize better than “sharp” minima.</li>\n      <li><strong>Role of Overparameterization:</strong> Many deep learning models are overparameterized (having more parameters than the number of training samples). This - overparameterization can turn out to be beneficial, as it can smooth the loss landscape and make it easier for gradient-based methods to find good solutions.</li>\n      <li><strong>Regularization and Batch Normalization:</strong> Techniques like regularization and batch normalization also help in shaping the loss landscape, making it easier for the optimization process to converge to good solutions. Batch normalization, in particular, helps in avoiding sharp minima.</li>\n      <li><strong>Random Initialization and Stochasticity:</strong> The random initialization of weights and the stochastic nature of algorithms like Stochastic Gradient Descent (SGD) can help in exploring the loss landscape more thoroughly and avoiding getting stuck in poor local minima.</li>\n      <li><strong>Learning Rate Schedules:</strong> The use of adaptive learning rates (as in Adam, RMSprop) or learning rate schedules (like learning rate decay) helps in fine-tuning the steps of the optimization process, which can improve the chances of finding a better minimum.</li>\n    </ul>\n  </li>\n  <li>In summary, while the non-convex nature of the cross-entropy loss function in deep neural networks does imply the existence of multiple local minima, various factors intrinsic to the architecture and training process of these networks, along with the high-dimensional space they operate in, contribute to the effective navigation of this complex landscape. The result is that, in practice, these models are quite successful in finding solutions that generalize well, despite the theoretical challenges posed by non-convexity.</li>\n</ul>\n<ul>\n      <li><strong>High-Dimensional Loss Landscapes:</strong> Deep neural networks operate in very high-dimensional spaces. In such spaces, the behavior of loss functions and the nature of local minima are quite different from what we might intuit from low-dimensional spaces. In high dimensions, it’s actually more likely for a local minimum to be very close to a global minimum in terms of the loss value.</li>\n      <li><strong>Saddle Points vs. Local Minima:</strong> Research indicates that in high-dimensional spaces, saddle points (where the gradient is zero but which are not minima) are more common than local minima. Optimization algorithms, especially those with momentum, are quite good at escaping saddle points.</li>\n      <li><strong>Empirical Success of Gradient Descent:</strong> Gradient descent and its variants, despite their simplicity, have been empirically successful in finding good minima in - complex loss landscapes of deep networks. They tend to find “flat” minima, which are areas in the loss landscape where the loss value doesn’t change much, and these flat minima often generalize better than “sharp” minima.</li>\n      <li><strong>Role of Overparameterization:</strong> Many deep learning models are overparameterized (having more parameters than the number of training samples). This - overparameterization can turn out to be beneficial, as it can smooth the loss landscape and make it easier for gradient-based methods to find good solutions.</li>\n      <li><strong>Regularization and Batch Normalization:</strong> Techniques like regularization and batch normalization also help in shaping the loss landscape, making it easier for the optimization process to converge to good solutions. Batch normalization, in particular, helps in avoiding sharp minima.</li>\n      <li><strong>Random Initialization and Stochasticity:</strong> The random initialization of weights and the stochastic nature of algorithms like Stochastic Gradient Descent (SGD) can help in exploring the loss landscape more thoroughly and avoiding getting stuck in poor local minima.</li>\n      <li><strong>Learning Rate Schedules:</strong> The use of adaptive learning rates (as in Adam, RMSprop) or learning rate schedules (like learning rate decay) helps in fine-tuning the steps of the optimization process, which can improve the chances of finding a better minimum.</li>\n    </ul>",
      "contentMarkdown": "*   The observation that the cross-entropy loss function, when used in complex deep neural networks, is non-convex yet doesn’t usually result in problematic local - minima, is an interesting aspect of modern deep learning. Here’s an explanation of why this apparent paradox isn’t usually a significant issue:\n    *   **High-Dimensional Loss Landscapes:** Deep neural networks operate in very high-dimensional spaces. In such spaces, the behavior of loss functions and the nature of local minima are quite different from what we might intuit from low-dimensional spaces. In high dimensions, it’s actually more likely for a local minimum to be very close to a global minimum in terms of the loss value.\n    *   **Saddle Points vs. Local Minima:** Research indicates that in high-dimensional spaces, saddle points (where the gradient is zero but which are not minima) are more common than local minima. Optimization algorithms, especially those with momentum, are quite good at escaping saddle points.\n    *   **Empirical Success of Gradient Descent:** Gradient descent and its variants, despite their simplicity, have been empirically successful in finding good minima in - complex loss landscapes of deep networks. They tend to find “flat” minima, which are areas in the loss landscape where the loss value doesn’t change much, and these flat minima often generalize better than “sharp” minima.\n    *   **Role of Overparameterization:** Many deep learning models are overparameterized (having more parameters than the number of training samples). This - overparameterization can turn out to be beneficial, as it can smooth the loss landscape and make it easier for gradient-based methods to find good solutions.\n    *   **Regularization and Batch Normalization:** Techniques like regularization and batch normalization also help in shaping the loss landscape, making it easier for the optimization process to converge to good solutions. Batch normalization, in particular, helps in avoiding sharp minima.\n    *   **Random Initialization and Stochasticity:** The random initialization of weights and the stochastic nature of algorithms like Stochastic Gradient Descent (SGD) can help in exploring the loss landscape more thoroughly and avoiding getting stuck in poor local minima.\n    *   **Learning Rate Schedules:** The use of adaptive learning rates (as in Adam, RMSprop) or learning rate schedules (like learning rate decay) helps in fine-tuning the steps of the optimization process, which can improve the chances of finding a better minimum.\n*   In summary, while the non-convex nature of the cross-entropy loss function in deep neural networks does imply the existence of multiple local minima, various factors intrinsic to the architecture and training process of these networks, along with the high-dimensional space they operate in, contribute to the effective navigation of this complex landscape. The result is that, in practice, these models are quite successful in finding solutions that generalize well, despite the theoretical challenges posed by non-convexity.\n\n*   **High-Dimensional Loss Landscapes:** Deep neural networks operate in very high-dimensional spaces. In such spaces, the behavior of loss functions and the nature of local minima are quite different from what we might intuit from low-dimensional spaces. In high dimensions, it’s actually more likely for a local minimum to be very close to a global minimum in terms of the loss value.\n*   **Saddle Points vs. Local Minima:** Research indicates that in high-dimensional spaces, saddle points (where the gradient is zero but which are not minima) are more common than local minima. Optimization algorithms, especially those with momentum, are quite good at escaping saddle points.\n*   **Empirical Success of Gradient Descent:** Gradient descent and its variants, despite their simplicity, have been empirically successful in finding good minima in - complex loss landscapes of deep networks. They tend to find “flat” minima, which are areas in the loss landscape where the loss value doesn’t change much, and these flat minima often generalize better than “sharp” minima.\n*   **Role of Overparameterization:** Many deep learning models are overparameterized (having more parameters than the number of training samples). This - overparameterization can turn out to be beneficial, as it can smooth the loss landscape and make it easier for gradient-based methods to find good solutions.\n*   **Regularization and Batch Normalization:** Techniques like regularization and batch normalization also help in shaping the loss landscape, making it easier for the optimization process to converge to good solutions. Batch normalization, in particular, helps in avoiding sharp minima.\n*   **Random Initialization and Stochasticity:** The random initialization of weights and the stochastic nature of algorithms like Stochastic Gradient Descent (SGD) can help in exploring the loss landscape more thoroughly and avoiding getting stuck in poor local minima.\n*   **Learning Rate Schedules:** The use of adaptive learning rates (as in Adam, RMSprop) or learning rate schedules (like learning rate decay) helps in fine-tuning the steps of the optimization process, which can improve the chances of finding a better minimum.",
      "order": 99,
      "orderInChapter": 99,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "optimization",
        "gradient descent",
        "loss function",
        "regularization",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 782,
        "contentLength": 5654
      },
      "nextCards": [
        "ai-interview-how-would-you-make-a-gcn-graph-convolutional-neura-100",
        "ai-interview-explain-how-lora-works-101"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-model-debugging-knowledge-distillation-student-teacher-approach-16",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27",
        "ai-decision-trees-and-ensemble-methods-what-role-does-the-learning-rate-play-in-training--30",
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#the-cross-entropy-loss-function-is-non-convex-when-used-in-complex-deep-neural-networks.-yet,-this-is-rarely-a-problem-despite-the-high-likelihood-of-ending-up-in-a-local-minimum.-why?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-would-you-make-a-gcn-graph-convolutional-neura-100",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Would You Make a GCN (Graph Convolutional Neural Network) Behave Like a Transformer (or Simulate a Transformer)?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Making a Graph Convolutional Network (GCN) behave like a Transformer, or simulate aspects of a Transformer, involves incorporating certain key elements of Transformer architecture into the GCN. This fusion aims to leverage the strengths of both GCNs in handling graph-structured data and Transformers in capturing long-range dependencies and dynamic attention. Here are steps to achieve this:\n    <ul>\n      <li><strong>Integrate Attention Mechanisms:</strong>\n        <ul>\n          <li><strong>Self-Attention in GCNs:</strong> Implement a form of self-attention mechanism within the GCN. The original GCN aggregates node features based on the graph structure (typically using mean or sum pooling of neighbor features). By integrating self-attention, each node can dynamically weigh its neighbors’ importance, similar to how attention works in Transformers.</li>\n          <li><strong>Graph Attention Networks (GATs):</strong> These already use attention mechanisms in graph neural networks. A GAT can be a starting point, as it applies self-attention over the nodes, allowing each node to attend over its neighbors, much like how attention heads in Transformers weigh the importance of different tokens.</li>\n        </ul>\n      </li>\n      <li><strong>Positional Encoding:</strong>\n        <ul>\n          <li><strong>Incorporate Positional Information:</strong> While GCNs inherently use the structure of the graph, they don’t use positional information like Transformers. You can add positional encodings to node features to give the model a sense of the node’s position within the graph or sequence.</li>\n          <li>Relative Positional Encoding: If the graph represents a sequence (like a sentence in NLP), relative positional encodings can be particularly effective, as used in some Transformer models.</li>\n        </ul>\n      </li>\n      <li><strong>Multi-Head Attention:</strong>\n        <ul>\n          <li><strong>Multiple Attention Heads:</strong> Implementing multi-head attention within the GCN can help the network focus on different types of relationships simultaneously, similar to how multi-head attention in Transformers allows the model to jointly attend to information from different representation subspaces.</li>\n        </ul>\n      </li>\n      <li><strong>Layer Normalization and Feed-Forward Networks:</strong>\n        <ul>\n          <li><strong>Layer Normalization:</strong> Just like in Transformers, apply layer normalization in your GCN, which can be particularly effective for stabilizing the learning process.</li>\n          <li><strong>Feed-Forward Networks:</strong> Incorporate point-wise feed-forward networks as in Transformers. This can be done for each node after the attention and aggregation steps.</li>\n        </ul>\n      </li>\n      <li><strong>Skip Connections:</strong>\n        <ul>\n          <li><strong>Residual Connections:</strong> Use skip (or residual) connections around each layer (both the attention and feed-forward layers), which is a key feature in Transformers to alleviate the vanishing gradient problem and promote feature reuse.</li>\n        </ul>\n      </li>\n      <li><strong>Adapt the Training Regime:</strong>\n        <ul>\n          <li><strong>Optimizer and Learning Rate Scheduling:</strong> Use optimizers like Adam, commonly used in training Transformers, with learning rate warm-up and decay strategies.</li>\n        </ul>\n      </li>\n      <li><strong>Scale to Larger Contexts:</strong>\n        <ul>\n          <li><strong>Handling Larger Graphs:</strong> Unlike standard GCNs, which might struggle with very large graphs, try to adapt your GCN to handle larger contexts, inspired by the ability of Transformers to manage long sequences.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Conclusion</strong>: By integrating these aspects, especially the attention mechanism and positional encoding, a GCN can start to exhibit behaviors similar to a Transformer. This approach is beneficial when working with graph-structured data where the flexibility and dynamic attention of Transformers can offer significant advantages. However, it’s important to note that the architectural changes should align with the specific nature of the graph data and the problem at hand.</li>\n</ul>\n<ul>\n      <li><strong>Integrate Attention Mechanisms:</strong>\n        <ul>\n          <li><strong>Self-Attention in GCNs:</strong> Implement a form of self-attention mechanism within the GCN. The original GCN aggregates node features based on the graph structure (typically using mean or sum pooling of neighbor features). By integrating self-attention, each node can dynamically weigh its neighbors’ importance, similar to how attention works in Transformers.</li>\n          <li><strong>Graph Attention Networks (GATs):</strong> These already use attention mechanisms in graph neural networks. A GAT can be a starting point, as it applies self-attention over the nodes, allowing each node to attend over its neighbors, much like how attention heads in Transformers weigh the importance of different tokens.</li>\n        </ul>\n      </li>\n      <li><strong>Positional Encoding:</strong>\n        <ul>\n          <li><strong>Incorporate Positional Information:</strong> While GCNs inherently use the structure of the graph, they don’t use positional information like Transformers. You can add positional encodings to node features to give the model a sense of the node’s position within the graph or sequence.</li>\n          <li>Relative Positional Encoding: If the graph represents a sequence (like a sentence in NLP), relative positional encodings can be particularly effective, as used in some Transformer models.</li>\n        </ul>\n      </li>\n      <li><strong>Multi-Head Attention:</strong>\n        <ul>\n          <li><strong>Multiple Attention Heads:</strong> Implementing multi-head attention within the GCN can help the network focus on different types of relationships simultaneously, similar to how multi-head attention in Transformers allows the model to jointly attend to information from different representation subspaces.</li>\n        </ul>\n      </li>\n      <li><strong>Layer Normalization and Feed-Forward Networks:</strong>\n        <ul>\n          <li><strong>Layer Normalization:</strong> Just like in Transformers, apply layer normalization in your GCN, which can be particularly effective for stabilizing the learning process.</li>\n          <li><strong>Feed-Forward Networks:</strong> Incorporate point-wise feed-forward networks as in Transformers. This can be done for each node after the attention and aggregation steps.</li>\n        </ul>\n      </li>\n      <li><strong>Skip Connections:</strong>\n        <ul>\n          <li><strong>Residual Connections:</strong> Use skip (or residual) connections around each layer (both the attention and feed-forward layers), which is a key feature in Transformers to alleviate the vanishing gradient problem and promote feature reuse.</li>\n        </ul>\n      </li>\n      <li><strong>Adapt the Training Regime:</strong>\n        <ul>\n          <li><strong>Optimizer and Learning Rate Scheduling:</strong> Use optimizers like Adam, commonly used in training Transformers, with learning rate warm-up and decay strategies.</li>\n        </ul>\n      </li>\n      <li><strong>Scale to Larger Contexts:</strong>\n        <ul>\n          <li><strong>Handling Larger Graphs:</strong> Unlike standard GCNs, which might struggle with very large graphs, try to adapt your GCN to handle larger contexts, inspired by the ability of Transformers to manage long sequences.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Self-Attention in GCNs:</strong> Implement a form of self-attention mechanism within the GCN. The original GCN aggregates node features based on the graph structure (typically using mean or sum pooling of neighbor features). By integrating self-attention, each node can dynamically weigh its neighbors’ importance, similar to how attention works in Transformers.</li>\n          <li><strong>Graph Attention Networks (GATs):</strong> These already use attention mechanisms in graph neural networks. A GAT can be a starting point, as it applies self-attention over the nodes, allowing each node to attend over its neighbors, much like how attention heads in Transformers weigh the importance of different tokens.</li>\n        </ul>\n<ul>\n          <li><strong>Incorporate Positional Information:</strong> While GCNs inherently use the structure of the graph, they don’t use positional information like Transformers. You can add positional encodings to node features to give the model a sense of the node’s position within the graph or sequence.</li>\n          <li>Relative Positional Encoding: If the graph represents a sequence (like a sentence in NLP), relative positional encodings can be particularly effective, as used in some Transformer models.</li>\n        </ul>\n<ul>\n          <li><strong>Multiple Attention Heads:</strong> Implementing multi-head attention within the GCN can help the network focus on different types of relationships simultaneously, similar to how multi-head attention in Transformers allows the model to jointly attend to information from different representation subspaces.</li>\n        </ul>\n<ul>\n          <li><strong>Layer Normalization:</strong> Just like in Transformers, apply layer normalization in your GCN, which can be particularly effective for stabilizing the learning process.</li>\n          <li><strong>Feed-Forward Networks:</strong> Incorporate point-wise feed-forward networks as in Transformers. This can be done for each node after the attention and aggregation steps.</li>\n        </ul>\n<ul>\n          <li><strong>Residual Connections:</strong> Use skip (or residual) connections around each layer (both the attention and feed-forward layers), which is a key feature in Transformers to alleviate the vanishing gradient problem and promote feature reuse.</li>\n        </ul>\n<ul>\n          <li><strong>Optimizer and Learning Rate Scheduling:</strong> Use optimizers like Adam, commonly used in training Transformers, with learning rate warm-up and decay strategies.</li>\n        </ul>\n<ul>\n          <li><strong>Handling Larger Graphs:</strong> Unlike standard GCNs, which might struggle with very large graphs, try to adapt your GCN to handle larger contexts, inspired by the ability of Transformers to manage long sequences.</li>\n        </ul>",
      "contentMarkdown": "*   Making a Graph Convolutional Network (GCN) behave like a Transformer, or simulate aspects of a Transformer, involves incorporating certain key elements of Transformer architecture into the GCN. This fusion aims to leverage the strengths of both GCNs in handling graph-structured data and Transformers in capturing long-range dependencies and dynamic attention. Here are steps to achieve this:\n    *   **Integrate Attention Mechanisms:**\n        *   **Self-Attention in GCNs:** Implement a form of self-attention mechanism within the GCN. The original GCN aggregates node features based on the graph structure (typically using mean or sum pooling of neighbor features). By integrating self-attention, each node can dynamically weigh its neighbors’ importance, similar to how attention works in Transformers.\n        *   **Graph Attention Networks (GATs):** These already use attention mechanisms in graph neural networks. A GAT can be a starting point, as it applies self-attention over the nodes, allowing each node to attend over its neighbors, much like how attention heads in Transformers weigh the importance of different tokens.\n    *   **Positional Encoding:**\n        *   **Incorporate Positional Information:** While GCNs inherently use the structure of the graph, they don’t use positional information like Transformers. You can add positional encodings to node features to give the model a sense of the node’s position within the graph or sequence.\n        *   Relative Positional Encoding: If the graph represents a sequence (like a sentence in NLP), relative positional encodings can be particularly effective, as used in some Transformer models.\n    *   **Multi-Head Attention:**\n        *   **Multiple Attention Heads:** Implementing multi-head attention within the GCN can help the network focus on different types of relationships simultaneously, similar to how multi-head attention in Transformers allows the model to jointly attend to information from different representation subspaces.\n    *   **Layer Normalization and Feed-Forward Networks:**\n        *   **Layer Normalization:** Just like in Transformers, apply layer normalization in your GCN, which can be particularly effective for stabilizing the learning process.\n        *   **Feed-Forward Networks:** Incorporate point-wise feed-forward networks as in Transformers. This can be done for each node after the attention and aggregation steps.\n    *   **Skip Connections:**\n        *   **Residual Connections:** Use skip (or residual) connections around each layer (both the attention and feed-forward layers), which is a key feature in Transformers to alleviate the vanishing gradient problem and promote feature reuse.\n    *   **Adapt the Training Regime:**\n        *   **Optimizer and Learning Rate Scheduling:** Use optimizers like Adam, commonly used in training Transformers, with learning rate warm-up and decay strategies.\n    *   **Scale to Larger Contexts:**\n        *   **Handling Larger Graphs:** Unlike standard GCNs, which might struggle with very large graphs, try to adapt your GCN to handle larger contexts, inspired by the ability of Transformers to manage long sequences.\n*   **Conclusion**: By integrating these aspects, especially the attention mechanism and positional encoding, a GCN can start to exhibit behaviors similar to a Transformer. This approach is beneficial when working with graph-structured data where the flexibility and dynamic attention of Transformers can offer significant advantages. However, it’s important to note that the architectural changes should align with the specific nature of the graph data and the problem at hand.\n\n*   **Integrate Attention Mechanisms:**\n    *   **Self-Attention in GCNs:** Implement a form of self-attention mechanism within the GCN. The original GCN aggregates node features based on the graph structure (typically using mean or sum pooling of neighbor features). By integrating self-attention, each node can dynamically weigh its neighbors’ importance, similar to how attention works in Transformers.\n    *   **Graph Attention Networks (GATs):** These already use attention mechanisms in graph neural networks. A GAT can be a starting point, as it applies self-attention over the nodes, allowing each node to attend over its neighbors, much like how attention heads in Transformers weigh the importance of different tokens.\n*   **Positional Encoding:**\n    *   **Incorporate Positional Information:** While GCNs inherently use the structure of the graph, they don’t use positional information like Transformers. You can add positional encodings to node features to give the model a sense of the node’s position within the graph or sequence.\n    *   Relative Positional Encoding: If the graph represents a sequence (like a sentence in NLP), relative positional encodings can be particularly effective, as used in some Transformer models.\n*   **Multi-Head Attention:**\n    *   **Multiple Attention Heads:** Implementing multi-head attention within the GCN can help the network focus on different types of relationships simultaneously, similar to how multi-head attention in Transformers allows the model to jointly attend to information from different representation subspaces.\n*   **Layer Normalization and Feed-Forward Networks:**\n    *   **Layer Normalization:** Just like in Transformers, apply layer normalization in your GCN, which can be particularly effective for stabilizing the learning process.\n    *   **Feed-Forward Networks:** Incorporate point-wise feed-forward networks as in Transformers. This can be done for each node after the attention and aggregation steps.\n*   **Skip Connections:**\n    *   **Residual Connections:** Use skip (or residual) connections around each layer (both the attention and feed-forward layers), which is a key feature in Transformers to alleviate the vanishing gradient problem and promote feature reuse.\n*   **Adapt the Training Regime:**\n    *   **Optimizer and Learning Rate Scheduling:** Use optimizers like Adam, commonly used in training Transformers, with learning rate warm-up and decay strategies.\n*   **Scale to Larger Contexts:**\n    *   **Handling Larger Graphs:** Unlike standard GCNs, which might struggle with very large graphs, try to adapt your GCN to handle larger contexts, inspired by the ability of Transformers to manage long sequences.\n\n*   **Self-Attention in GCNs:** Implement a form of self-attention mechanism within the GCN. The original GCN aggregates node features based on the graph structure (typically using mean or sum pooling of neighbor features). By integrating self-attention, each node can dynamically weigh its neighbors’ importance, similar to how attention works in Transformers.\n*   **Graph Attention Networks (GATs):** These already use attention mechanisms in graph neural networks. A GAT can be a starting point, as it applies self-attention over the nodes, allowing each node to attend over its neighbors, much like how attention heads in Transformers weigh the importance of different tokens.\n\n*   **Incorporate Positional Information:** While GCNs inherently use the structure of the graph, they don’t use positional information like Transformers. You can add positional encodings to node features to give the model a sense of the node’s position within the graph or sequence.\n*   Relative Positional Encoding: If the graph represents a sequence (like a sentence in NLP), relative positional encodings can be particularly effective, as used in some Transformer models.\n\n*   **Multiple Attention Heads:** Implementing multi-head attention within the GCN can help the network focus on different types of relationships simultaneously, similar to how multi-head attention in Transformers allows the model to jointly attend to information from different representation subspaces.\n\n*   **Layer Normalization:** Just like in Transformers, apply layer normalization in your GCN, which can be particularly effective for stabilizing the learning process.\n*   **Feed-Forward Networks:** Incorporate point-wise feed-forward networks as in Transformers. This can be done for each node after the attention and aggregation steps.\n\n*   **Residual Connections:** Use skip (or residual) connections around each layer (both the attention and feed-forward layers), which is a key feature in Transformers to alleviate the vanishing gradient problem and promote feature reuse.\n\n*   **Optimizer and Learning Rate Scheduling:** Use optimizers like Adam, commonly used in training Transformers, with learning rate warm-up and decay strategies.\n\n*   **Handling Larger Graphs:** Unlike standard GCNs, which might struggle with very large graphs, try to adapt your GCN to handle larger contexts, inspired by the ability of Transformers to manage long sequences.",
      "order": 100,
      "orderInChapter": 100,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "neural network",
        "transformer",
        "attention",
        "convolution",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1222,
        "contentLength": 10445
      },
      "nextCards": [
        "ai-interview-explain-how-lora-works-101",
        "ai-interview-what-is-the-difficulty-with-using-the-natural-grad-102"
      ],
      "relatedCards": [
        "ai-transformers-gnns-build-representations-of-graphs-23",
        "ai-transformers-vision-2",
        "ai-vit-why-does-vit-use-linear-projections-of-flattened-p-3",
        "ai-diffusion-models-implementing-the-original-paper-34",
        "ai-diffusion-models-patch-n-pack-navit-a-vision-transformer-for-any-as-62"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-would-you-make-a-gcn-(graph-convolutional-neural-network)-behave-like-a-transformer-(or-simulate-a-transformer)?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-how-lora-works-101",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain How LoRA Works.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li><strong>Overview/Motivation</strong>:\n    <ul>\n      <li>Looking to avoid high GPU costs when fine-tuning a model?</li>\n      <li>The basic idea behind LoRA is:</li>\n    </ul>\n\n    <blockquote>\n      <p>Heavily Parameterized Large Language Models + Basic Linear Algebra Theorem = Save GPU memory!</p>\n    </blockquote>\n\n    <ul>\n      <li>The downsides of some of the other fine-tuning techniques for multitask learning are:\n        <ul>\n          <li><strong>Adapters:</strong> Adapters introduce inference latency that becomes significant in online low batch size inference settings.</li>\n          <li><strong>Prefix tuning:</strong> Prefix tuning reduces the model’s usable sequence length.</li>\n        </ul>\n      </li>\n      <li>Low-Rank Adaptation (LoRA) is a PEFT technique used to efficiently fine-tune large language models like GPT-3 or BERT while keeping most of the pre-trained parameters frozen. This approach, introduced in a paper by Hu et al., aims to adapt large models to specific tasks without the extensive computational costs typically associated with full-model fine-tuning.</li>\n      <li>LoRA relies on a simple concept: decomposition of non-full rank matrices.</li>\n      <li>LoRA hypothesizes that “change in weights” during adaptation has a “low intrinsic rank”. <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-109-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-883\" style=\"width: 2.086em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.721em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1001.72em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-884\"><span class=\"mi\" id=\"MathJax-Span-885\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-886\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-109\">\\Delta W</script> is non-full rank and so can be written as <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-110-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi><mo>=</mo><mi>B</mi><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-887\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.27em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-888\"><span class=\"mi\" id=\"MathJax-Span-889\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-890\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-891\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-892\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">B</span><span class=\"mi\" id=\"MathJax-Span-893\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi><mo>=</mo><mi>B</mi><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-110\">\\Delta W = BA</script> (cf. figure below).\n        <ul>\n          <li>A matrix is said to be rank-deficient if it does not have full rank. The rank deficiency of a matrix is the difference between the lesser of the number of rows and columns, and the rank. For more, refer <a href=\"https://en.wikipedia.org/wiki/Rank_(linear_algebra)\">Wikipedia: Rank</a>.</li>\n        </ul>\n      </li>\n    </ul>\n\n    <p><img src=\"/primers/ai/assets/interview/lora.jpeg\" alt=\"\"></p>\n\n    <ul>\n      <li>“Low intrinsic rank” is inspired by the idea of “low intrinsic dimensionality” that these over-parameterized pre-trained models are seen to reside on, and that’s also the explanation behind why fine-tuning only a part of the full model rather than full fine-tuning can yield good results.\n        <ul>\n          <li>LoRA operates under the hypothesis that the weight changes in the adaptation of a model (fine-tuning) have a low intrinsic rank. In other words, even though a weight matrix may be large, the actual changes made to this matrix during adaptation can be represented in a compressed format, specifically through a low-rank approximation.</li>\n        </ul>\n      </li>\n      <li>The image below <a href=\"https://www.reddit.com/media?url=https%3A%2F%2Fi.redd.it%2Fwell-researched-comparison-of-training-techniques-lora-v0-vl01e5grs6ca1.png%3Fs%3Dcfb3d4eb7d253025ffc68f6791740f7737604c84\">source</a> shows LoRA in action for a diffusion model.</li>\n    </ul>\n\n    <p><img src=\"/primers/ai/assets/interview/lora2.png\" alt=\"\"></p>\n  </li>\n  <li><strong>How LoRA Works:</strong>\n    <ul>\n      <li>Basic Concept: LoRA focuses on adapting only a small fraction of the model’s parameters during fine-tuning. Instead of updating the entire weight matrices in the Transformer layers, it introduces and optimizes low-rank matrices that capture the necessary adaptations for the specific task.</li>\n      <li><strong>Modification of Weight Matrices:</strong>\n        <ul>\n          <li>In a standard Transformer model, each layer has weight matrices (like those in the multi-head self-attention and feed-forward networks).</li>\n          <li>Rather than directly modifying these weight matrices, LoRA adds trainable low-rank matrices to them. Specifically, for a weight matrix <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-111-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-894\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-895\"><span class=\"mi\" id=\"MathJax-Span-896\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-111\">W</script>, the adaptation is done using two smaller matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-112-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-897\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-898\"><span class=\"mi\" id=\"MathJax-Span-899\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-112\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-113-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-900\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-901\"><span class=\"mi\" id=\"MathJax-Span-902\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-113\">B</script> (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-114-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-903\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-904\"><span class=\"mi\" id=\"MathJax-Span-905\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-114\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-115-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-906\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-907\"><span class=\"mi\" id=\"MathJax-Span-908\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-115\">B</script> are much smaller in size compared to <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-116-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-909\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-910\"><span class=\"mi\" id=\"MathJax-Span-911\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-116\">W</script>).</li>\n          <li>The original weight matrix <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-117-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-912\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-913\"><span class=\"mi\" id=\"MathJax-Span-914\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-117\">W</script> remains frozen. During training, the outputs from <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-118-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-915\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-916\"><span class=\"mi\" id=\"MathJax-Span-917\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-118\">W</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-119-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi><mo>=</mo><mi>A</mi><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-918\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.33em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-919\"><span class=\"mi\" id=\"MathJax-Span-920\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-921\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-922\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-923\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">A</span><span class=\"mi\" id=\"MathJax-Span-924\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi><mo>=</mo><mi>A</mi><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-119\">\\Delta W = AB</script> are added component wise, and the update is effectively: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-120-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi><mo>+</mo><mi>A</mi><msup><mi>B</mi><mi>T</mi></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-925\" style=\"width: 4.794em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.961em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1003.96em, 2.398em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-926\"><span class=\"mi\" id=\"MathJax-Span-927\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-928\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-929\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">A</span><span class=\"msubsup\" id=\"MathJax-Span-930\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-931\" style=\"font-family: STIXGeneral-Italic;\">B</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.628em;\"><span class=\"mi\" id=\"MathJax-Span-932\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi><mo>+</mo><mi>A</mi><msup><mi>B</mi><mi>T</mi></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-120\">W + AB^T</script>.</li>\n        </ul>\n      </li>\n      <li><strong>Training Process:</strong>\n        <ul>\n          <li>All we’re now left to optimize is the new matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-121-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-933\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-934\"><span class=\"mi\" id=\"MathJax-Span-935\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-121\">B</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-122-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-936\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-937\"><span class=\"mi\" id=\"MathJax-Span-938\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-122\">A</script> that contain a very smaller number of parameters (combined) than the full matrix due to their dimensions. Put simply, during training, only the low-rank matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-123-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-939\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-940\"><span class=\"mi\" id=\"MathJax-Span-941\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-123\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-124-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-942\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-943\"><span class=\"mi\" id=\"MathJax-Span-944\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-124\">B</script> are updated, while the pre-trained weights are kept unchanged.</li>\n          <li>In summary, all of the pre-trained weights <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-125-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-945\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-946\"><span class=\"mi\" id=\"MathJax-Span-947\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-125\">W</script> are kept frozen and the rank decomposition matrices of the “change in weight matrix”, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-126-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-948\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-949\"><span class=\"mi\" id=\"MathJax-Span-950\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-126\">B</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-127-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-951\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-952\"><span class=\"mi\" id=\"MathJax-Span-953\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-127\">A</script>, are optimized. This process reduces the number of trainable parameters significantly, making the fine-tuning process much more efficient in terms of computational resources and time.</li>\n        </ul>\n      </li>\n      <li><strong>Effectiveness:</strong>\n        <ul>\n          <li>The key to LoRA’s effectiveness lies in the ability of the low-rank matrices to capture the essential changes needed for the new task while leveraging the extensive knowledge already encoded in the pre-trained model.</li>\n          <li>Despite updating only a small fraction of parameters, LoRA can achieve performance comparable to full-model fine-tuning on various NLP tasks.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Advantages of LoRA:</strong> LoRA yields significant benefits as compared to full-fine tuning:\n    <ul>\n      <li><strong>Time and memory  Efficiency:</strong> Reduces computational and memory costs compared to traditional fine-tuning, where all parameters of the model are updated. With a large percentage of the parameters being frozen, the training time and the GPU memory is saved. Saving is more when using stateful optimizers like Adam, Adadelta, etc.</li>\n      <li><strong>Scalability:</strong> Enables the adaptation of very large models to specific tasks without prohibitive computational costs.</li>\n      <li><strong>Storage efficiency:</strong> No need to store huge checkpoints for different downstream tasks. Checkpoint size is greatly reduced with reduction in trainable parameters.</li>\n      <li><strong>No additional inference latency:</strong> (unlike adapters) just add the learned matrix to the pre-trained one.</li>\n      <li><strong>Easy task-switching in deployment:</strong> all we need to change is a handful of weights as compared to the full model.</li>\n      <li><strong>Preservation of Pre-trained Knowledge:</strong> By keeping the majority of the pre-trained weights frozen, LoRA maintains the rich representations learned during pre-training, reducing the risk of catastrophic forgetting.</li>\n      <li><strong>Flexibility:</strong> Can be applied to different parts of a Transformer model (like attention or feed-forward layers) depending on the task requirements.</li>\n    </ul>\n  </li>\n  <li><strong>Results:</strong>\n    <ul>\n      <li>With GPT-3 175B, the VRAM consumption during training reduced from 1.2TB to 350GB, while the trained checkpoint size reduced from 350GB to 35MB!</li>\n      <li>LoRA achieves performances comparable to and sometimes even better than fine-tuning the full model.</li>\n    </ul>\n  </li>\n  <li><strong>Applications:</strong>\n    <ul>\n      <li>LoRA is particularly useful for adapting large-scale language models to specific domains or tasks, especially when computational resources are limited or when it’s desirable to maintain the integrity of the pre-trained model while still achieving task-specific performance gains. This approach represents a shift towards more parameter-efficient methods of adapting large models, which is increasingly important as state-of-the-art models continue to grow in size.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Looking to avoid high GPU costs when fine-tuning a model?</li>\n      <li>The basic idea behind LoRA is:</li>\n    </ul>\n<blockquote>\n      <p>Heavily Parameterized Large Language Models + Basic Linear Algebra Theorem = Save GPU memory!</p>\n    </blockquote>\n<p>Heavily Parameterized Large Language Models + Basic Linear Algebra Theorem = Save GPU memory!</p>\n<ul>\n      <li>The downsides of some of the other fine-tuning techniques for multitask learning are:\n        <ul>\n          <li><strong>Adapters:</strong> Adapters introduce inference latency that becomes significant in online low batch size inference settings.</li>\n          <li><strong>Prefix tuning:</strong> Prefix tuning reduces the model’s usable sequence length.</li>\n        </ul>\n      </li>\n      <li>Low-Rank Adaptation (LoRA) is a PEFT technique used to efficiently fine-tune large language models like GPT-3 or BERT while keeping most of the pre-trained parameters frozen. This approach, introduced in a paper by Hu et al., aims to adapt large models to specific tasks without the extensive computational costs typically associated with full-model fine-tuning.</li>\n      <li>LoRA relies on a simple concept: decomposition of non-full rank matrices.</li>\n      <li>LoRA hypothesizes that “change in weights” during adaptation has a “low intrinsic rank”. <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-109-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-883\" style=\"width: 2.086em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.721em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1001.72em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-884\"><span class=\"mi\" id=\"MathJax-Span-885\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-886\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-109\">\\Delta W</script> is non-full rank and so can be written as <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-110-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi><mo>=</mo><mi>B</mi><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-887\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.27em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-888\"><span class=\"mi\" id=\"MathJax-Span-889\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-890\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-891\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-892\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">B</span><span class=\"mi\" id=\"MathJax-Span-893\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi><mo>=</mo><mi>B</mi><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-110\">\\Delta W = BA</script> (cf. figure below).\n        <ul>\n          <li>A matrix is said to be rank-deficient if it does not have full rank. The rank deficiency of a matrix is the difference between the lesser of the number of rows and columns, and the rank. For more, refer <a href=\"https://en.wikipedia.org/wiki/Rank_(linear_algebra)\">Wikipedia: Rank</a>.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Adapters:</strong> Adapters introduce inference latency that becomes significant in online low batch size inference settings.</li>\n          <li><strong>Prefix tuning:</strong> Prefix tuning reduces the model’s usable sequence length.</li>\n        </ul>\n<ul>\n          <li>A matrix is said to be rank-deficient if it does not have full rank. The rank deficiency of a matrix is the difference between the lesser of the number of rows and columns, and the rank. For more, refer <a href=\"https://en.wikipedia.org/wiki/Rank_(linear_algebra)\">Wikipedia: Rank</a>.</li>\n        </ul>\n<p><img src=\"/primers/ai/assets/interview/lora.jpeg\" alt=\"\"></p>\n<ul>\n      <li>“Low intrinsic rank” is inspired by the idea of “low intrinsic dimensionality” that these over-parameterized pre-trained models are seen to reside on, and that’s also the explanation behind why fine-tuning only a part of the full model rather than full fine-tuning can yield good results.\n        <ul>\n          <li>LoRA operates under the hypothesis that the weight changes in the adaptation of a model (fine-tuning) have a low intrinsic rank. In other words, even though a weight matrix may be large, the actual changes made to this matrix during adaptation can be represented in a compressed format, specifically through a low-rank approximation.</li>\n        </ul>\n      </li>\n      <li>The image below <a href=\"https://www.reddit.com/media?url=https%3A%2F%2Fi.redd.it%2Fwell-researched-comparison-of-training-techniques-lora-v0-vl01e5grs6ca1.png%3Fs%3Dcfb3d4eb7d253025ffc68f6791740f7737604c84\">source</a> shows LoRA in action for a diffusion model.</li>\n    </ul>\n<ul>\n          <li>LoRA operates under the hypothesis that the weight changes in the adaptation of a model (fine-tuning) have a low intrinsic rank. In other words, even though a weight matrix may be large, the actual changes made to this matrix during adaptation can be represented in a compressed format, specifically through a low-rank approximation.</li>\n        </ul>\n<p><img src=\"/primers/ai/assets/interview/lora2.png\" alt=\"\"></p>\n<ul>\n      <li>Basic Concept: LoRA focuses on adapting only a small fraction of the model’s parameters during fine-tuning. Instead of updating the entire weight matrices in the Transformer layers, it introduces and optimizes low-rank matrices that capture the necessary adaptations for the specific task.</li>\n      <li><strong>Modification of Weight Matrices:</strong>\n        <ul>\n          <li>In a standard Transformer model, each layer has weight matrices (like those in the multi-head self-attention and feed-forward networks).</li>\n          <li>Rather than directly modifying these weight matrices, LoRA adds trainable low-rank matrices to them. Specifically, for a weight matrix <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-111-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-894\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-895\"><span class=\"mi\" id=\"MathJax-Span-896\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-111\">W</script>, the adaptation is done using two smaller matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-112-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-897\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-898\"><span class=\"mi\" id=\"MathJax-Span-899\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-112\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-113-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-900\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-901\"><span class=\"mi\" id=\"MathJax-Span-902\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-113\">B</script> (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-114-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-903\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-904\"><span class=\"mi\" id=\"MathJax-Span-905\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-114\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-115-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-906\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-907\"><span class=\"mi\" id=\"MathJax-Span-908\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-115\">B</script> are much smaller in size compared to <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-116-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-909\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-910\"><span class=\"mi\" id=\"MathJax-Span-911\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-116\">W</script>).</li>\n          <li>The original weight matrix <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-117-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-912\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-913\"><span class=\"mi\" id=\"MathJax-Span-914\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-117\">W</script> remains frozen. During training, the outputs from <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-118-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-915\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-916\"><span class=\"mi\" id=\"MathJax-Span-917\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-118\">W</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-119-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi><mo>=</mo><mi>A</mi><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-918\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.33em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-919\"><span class=\"mi\" id=\"MathJax-Span-920\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-921\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-922\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-923\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">A</span><span class=\"mi\" id=\"MathJax-Span-924\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi><mo>=</mo><mi>A</mi><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-119\">\\Delta W = AB</script> are added component wise, and the update is effectively: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-120-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi><mo>+</mo><mi>A</mi><msup><mi>B</mi><mi>T</mi></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-925\" style=\"width: 4.794em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.961em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1003.96em, 2.398em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-926\"><span class=\"mi\" id=\"MathJax-Span-927\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-928\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-929\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">A</span><span class=\"msubsup\" id=\"MathJax-Span-930\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-931\" style=\"font-family: STIXGeneral-Italic;\">B</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.628em;\"><span class=\"mi\" id=\"MathJax-Span-932\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi><mo>+</mo><mi>A</mi><msup><mi>B</mi><mi>T</mi></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-120\">W + AB^T</script>.</li>\n        </ul>\n      </li>\n      <li><strong>Training Process:</strong>\n        <ul>\n          <li>All we’re now left to optimize is the new matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-121-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-933\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-934\"><span class=\"mi\" id=\"MathJax-Span-935\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-121\">B</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-122-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-936\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-937\"><span class=\"mi\" id=\"MathJax-Span-938\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-122\">A</script> that contain a very smaller number of parameters (combined) than the full matrix due to their dimensions. Put simply, during training, only the low-rank matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-123-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-939\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-940\"><span class=\"mi\" id=\"MathJax-Span-941\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-123\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-124-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-942\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-943\"><span class=\"mi\" id=\"MathJax-Span-944\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-124\">B</script> are updated, while the pre-trained weights are kept unchanged.</li>\n          <li>In summary, all of the pre-trained weights <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-125-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-945\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-946\"><span class=\"mi\" id=\"MathJax-Span-947\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-125\">W</script> are kept frozen and the rank decomposition matrices of the “change in weight matrix”, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-126-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-948\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-949\"><span class=\"mi\" id=\"MathJax-Span-950\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-126\">B</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-127-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-951\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-952\"><span class=\"mi\" id=\"MathJax-Span-953\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-127\">A</script>, are optimized. This process reduces the number of trainable parameters significantly, making the fine-tuning process much more efficient in terms of computational resources and time.</li>\n        </ul>\n      </li>\n      <li><strong>Effectiveness:</strong>\n        <ul>\n          <li>The key to LoRA’s effectiveness lies in the ability of the low-rank matrices to capture the essential changes needed for the new task while leveraging the extensive knowledge already encoded in the pre-trained model.</li>\n          <li>Despite updating only a small fraction of parameters, LoRA can achieve performance comparable to full-model fine-tuning on various NLP tasks.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>In a standard Transformer model, each layer has weight matrices (like those in the multi-head self-attention and feed-forward networks).</li>\n          <li>Rather than directly modifying these weight matrices, LoRA adds trainable low-rank matrices to them. Specifically, for a weight matrix <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-111-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-894\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-895\"><span class=\"mi\" id=\"MathJax-Span-896\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-111\">W</script>, the adaptation is done using two smaller matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-112-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-897\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-898\"><span class=\"mi\" id=\"MathJax-Span-899\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-112\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-113-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-900\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-901\"><span class=\"mi\" id=\"MathJax-Span-902\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-113\">B</script> (where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-114-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-903\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-904\"><span class=\"mi\" id=\"MathJax-Span-905\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-114\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-115-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-906\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-907\"><span class=\"mi\" id=\"MathJax-Span-908\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-115\">B</script> are much smaller in size compared to <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-116-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-909\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-910\"><span class=\"mi\" id=\"MathJax-Span-911\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-116\">W</script>).</li>\n          <li>The original weight matrix <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-117-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-912\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-913\"><span class=\"mi\" id=\"MathJax-Span-914\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-117\">W</script> remains frozen. During training, the outputs from <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-118-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-915\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-916\"><span class=\"mi\" id=\"MathJax-Span-917\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-118\">W</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-119-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x0394;</mi><mi>W</mi><mo>=</mo><mi>A</mi><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-918\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.33em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-919\"><span class=\"mi\" id=\"MathJax-Span-920\" style=\"font-family: STIXGeneral-Regular;\">Δ</span><span class=\"mi\" id=\"MathJax-Span-921\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-922\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mi\" id=\"MathJax-Span-923\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.315em;\">A</span><span class=\"mi\" id=\"MathJax-Span-924\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi mathvariant=\"normal\">Δ</mi><mi>W</mi><mo>=</mo><mi>A</mi><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-119\">\\Delta W = AB</script> are added component wise, and the update is effectively: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-120-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi><mo>+</mo><mi>A</mi><msup><mi>B</mi><mi>T</mi></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-925\" style=\"width: 4.794em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.961em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1003.96em, 2.398em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-926\"><span class=\"mi\" id=\"MathJax-Span-927\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-928\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-929\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">A</span><span class=\"msubsup\" id=\"MathJax-Span-930\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-931\" style=\"font-family: STIXGeneral-Italic;\">B</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.628em;\"><span class=\"mi\" id=\"MathJax-Span-932\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">T<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.122em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi><mo>+</mo><mi>A</mi><msup><mi>B</mi><mi>T</mi></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-120\">W + AB^T</script>.</li>\n        </ul>\n<ul>\n          <li>All we’re now left to optimize is the new matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-121-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-933\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-934\"><span class=\"mi\" id=\"MathJax-Span-935\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-121\">B</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-122-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-936\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-937\"><span class=\"mi\" id=\"MathJax-Span-938\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-122\">A</script> that contain a very smaller number of parameters (combined) than the full matrix due to their dimensions. Put simply, during training, only the low-rank matrices <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-123-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-939\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-940\"><span class=\"mi\" id=\"MathJax-Span-941\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-123\">A</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-124-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-942\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-943\"><span class=\"mi\" id=\"MathJax-Span-944\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-124\">B</script> are updated, while the pre-trained weights are kept unchanged.</li>\n          <li>In summary, all of the pre-trained weights <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-125-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>W</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-945\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.99em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-946\"><span class=\"mi\" id=\"MathJax-Span-947\" style=\"font-family: STIXGeneral-Italic;\">W<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>W</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-125\">W</script> are kept frozen and the rank decomposition matrices of the “change in weight matrix”, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-126-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-948\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-949\"><span class=\"mi\" id=\"MathJax-Span-950\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-126\">B</script> and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-127-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-951\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-952\"><span class=\"mi\" id=\"MathJax-Span-953\" style=\"font-family: STIXGeneral-Italic;\">A</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>A</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-127\">A</script>, are optimized. This process reduces the number of trainable parameters significantly, making the fine-tuning process much more efficient in terms of computational resources and time.</li>\n        </ul>\n<ul>\n          <li>The key to LoRA’s effectiveness lies in the ability of the low-rank matrices to capture the essential changes needed for the new task while leveraging the extensive knowledge already encoded in the pre-trained model.</li>\n          <li>Despite updating only a small fraction of parameters, LoRA can achieve performance comparable to full-model fine-tuning on various NLP tasks.</li>\n        </ul>\n<ul>\n      <li><strong>Time and memory  Efficiency:</strong> Reduces computational and memory costs compared to traditional fine-tuning, where all parameters of the model are updated. With a large percentage of the parameters being frozen, the training time and the GPU memory is saved. Saving is more when using stateful optimizers like Adam, Adadelta, etc.</li>\n      <li><strong>Scalability:</strong> Enables the adaptation of very large models to specific tasks without prohibitive computational costs.</li>\n      <li><strong>Storage efficiency:</strong> No need to store huge checkpoints for different downstream tasks. Checkpoint size is greatly reduced with reduction in trainable parameters.</li>\n      <li><strong>No additional inference latency:</strong> (unlike adapters) just add the learned matrix to the pre-trained one.</li>\n      <li><strong>Easy task-switching in deployment:</strong> all we need to change is a handful of weights as compared to the full model.</li>\n      <li><strong>Preservation of Pre-trained Knowledge:</strong> By keeping the majority of the pre-trained weights frozen, LoRA maintains the rich representations learned during pre-training, reducing the risk of catastrophic forgetting.</li>\n      <li><strong>Flexibility:</strong> Can be applied to different parts of a Transformer model (like attention or feed-forward layers) depending on the task requirements.</li>\n    </ul>\n<ul>\n      <li>With GPT-3 175B, the VRAM consumption during training reduced from 1.2TB to 350GB, while the trained checkpoint size reduced from 350GB to 35MB!</li>\n      <li>LoRA achieves performances comparable to and sometimes even better than fine-tuning the full model.</li>\n    </ul>\n<ul>\n      <li>LoRA is particularly useful for adapting large-scale language models to specific domains or tasks, especially when computational resources are limited or when it’s desirable to maintain the integrity of the pre-trained model while still achieving task-specific performance gains. This approach represents a shift towards more parameter-efficient methods of adapting large models, which is increasingly important as state-of-the-art models continue to grow in size.</li>\n    </ul>",
      "contentMarkdown": "*   **Overview/Motivation**:\n    \n    *   Looking to avoid high GPU costs when fine-tuning a model?\n    *   The basic idea behind LoRA is:\n    \n    > Heavily Parameterized Large Language Models + Basic Linear Algebra Theorem = Save GPU memory!\n    \n    *   The downsides of some of the other fine-tuning techniques for multitask learning are:\n        *   **Adapters:** Adapters introduce inference latency that becomes significant in online low batch size inference settings.\n        *   **Prefix tuning:** Prefix tuning reduces the model’s usable sequence length.\n    *   Low-Rank Adaptation (LoRA) is a PEFT technique used to efficiently fine-tune large language models like GPT-3 or BERT while keeping most of the pre-trained parameters frozen. This approach, introduced in a paper by Hu et al., aims to adapt large models to specific tasks without the extensive computational costs typically associated with full-model fine-tuning.\n    *   LoRA relies on a simple concept: decomposition of non-full rank matrices.\n    *   LoRA hypothesizes that “change in weights” during adaptation has a “low intrinsic rank”. ΔWΔW\\\\Delta W is non-full rank and so can be written as ΔW\\=BAΔW\\=BA\\\\Delta W = BA (cf. figure below).\n        *   A matrix is said to be rank-deficient if it does not have full rank. The rank deficiency of a matrix is the difference between the lesser of the number of rows and columns, and the rank. For more, refer [Wikipedia: Rank](https://en.wikipedia.org/wiki/Rank_\\(linear_algebra\\)).\n    \n    ![](/primers/ai/assets/interview/lora.jpeg)\n    \n    *   “Low intrinsic rank” is inspired by the idea of “low intrinsic dimensionality” that these over-parameterized pre-trained models are seen to reside on, and that’s also the explanation behind why fine-tuning only a part of the full model rather than full fine-tuning can yield good results.\n        *   LoRA operates under the hypothesis that the weight changes in the adaptation of a model (fine-tuning) have a low intrinsic rank. In other words, even though a weight matrix may be large, the actual changes made to this matrix during adaptation can be represented in a compressed format, specifically through a low-rank approximation.\n    *   The image below [source](https://www.reddit.com/media?url=https%3A%2F%2Fi.redd.it%2Fwell-researched-comparison-of-training-techniques-lora-v0-vl01e5grs6ca1.png%3Fs%3Dcfb3d4eb7d253025ffc68f6791740f7737604c84) shows LoRA in action for a diffusion model.\n    \n    ![](/primers/ai/assets/interview/lora2.png)\n    \n*   **How LoRA Works:**\n    *   Basic Concept: LoRA focuses on adapting only a small fraction of the model’s parameters during fine-tuning. Instead of updating the entire weight matrices in the Transformer layers, it introduces and optimizes low-rank matrices that capture the necessary adaptations for the specific task.\n    *   **Modification of Weight Matrices:**\n        *   In a standard Transformer model, each layer has weight matrices (like those in the multi-head self-attention and feed-forward networks).\n        *   Rather than directly modifying these weight matrices, LoRA adds trainable low-rank matrices to them. Specifically, for a weight matrix WWW, the adaptation is done using two smaller matrices AAA and BBB (where AAA and BBB are much smaller in size compared to WWW).\n        *   The original weight matrix WWW remains frozen. During training, the outputs from WWW and ΔW\\=ABΔW\\=AB\\\\Delta W = AB are added component wise, and the update is effectively: W+ABTW+ABTW + AB^T.\n    *   **Training Process:**\n        *   All we’re now left to optimize is the new matrices BBB and AAA that contain a very smaller number of parameters (combined) than the full matrix due to their dimensions. Put simply, during training, only the low-rank matrices AAA and BBB are updated, while the pre-trained weights are kept unchanged.\n        *   In summary, all of the pre-trained weights WWW are kept frozen and the rank decomposition matrices of the “change in weight matrix”, BBB and AAA, are optimized. This process reduces the number of trainable parameters significantly, making the fine-tuning process much more efficient in terms of computational resources and time.\n    *   **Effectiveness:**\n        *   The key to LoRA’s effectiveness lies in the ability of the low-rank matrices to capture the essential changes needed for the new task while leveraging the extensive knowledge already encoded in the pre-trained model.\n        *   Despite updating only a small fraction of parameters, LoRA can achieve performance comparable to full-model fine-tuning on various NLP tasks.\n*   **Advantages of LoRA:** LoRA yields significant benefits as compared to full-fine tuning:\n    *   **Time and memory Efficiency:** Reduces computational and memory costs compared to traditional fine-tuning, where all parameters of the model are updated. With a large percentage of the parameters being frozen, the training time and the GPU memory is saved. Saving is more when using stateful optimizers like Adam, Adadelta, etc.\n    *   **Scalability:** Enables the adaptation of very large models to specific tasks without prohibitive computational costs.\n    *   **Storage efficiency:** No need to store huge checkpoints for different downstream tasks. Checkpoint size is greatly reduced with reduction in trainable parameters.\n    *   **No additional inference latency:** (unlike adapters) just add the learned matrix to the pre-trained one.\n    *   **Easy task-switching in deployment:** all we need to change is a handful of weights as compared to the full model.\n    *   **Preservation of Pre-trained Knowledge:** By keeping the majority of the pre-trained weights frozen, LoRA maintains the rich representations learned during pre-training, reducing the risk of catastrophic forgetting.\n    *   **Flexibility:** Can be applied to different parts of a Transformer model (like attention or feed-forward layers) depending on the task requirements.\n*   **Results:**\n    *   With GPT-3 175B, the VRAM consumption during training reduced from 1.2TB to 350GB, while the trained checkpoint size reduced from 350GB to 35MB!\n    *   LoRA achieves performances comparable to and sometimes even better than fine-tuning the full model.\n*   **Applications:**\n    *   LoRA is particularly useful for adapting large-scale language models to specific domains or tasks, especially when computational resources are limited or when it’s desirable to maintain the integrity of the pre-trained model while still achieving task-specific performance gains. This approach represents a shift towards more parameter-efficient methods of adapting large models, which is increasingly important as state-of-the-art models continue to grow in size.\n\n*   Looking to avoid high GPU costs when fine-tuning a model?\n*   The basic idea behind LoRA is:\n\n> Heavily Parameterized Large Language Models + Basic Linear Algebra Theorem = Save GPU memory!\n\nHeavily Parameterized Large Language Models + Basic Linear Algebra Theorem = Save GPU memory!\n\n*   The downsides of some of the other fine-tuning techniques for multitask learning are:\n    *   **Adapters:** Adapters introduce inference latency that becomes significant in online low batch size inference settings.\n    *   **Prefix tuning:** Prefix tuning reduces the model’s usable sequence length.\n*   Low-Rank Adaptation (LoRA) is a PEFT technique used to efficiently fine-tune large language models like GPT-3 or BERT while keeping most of the pre-trained parameters frozen. This approach, introduced in a paper by Hu et al., aims to adapt large models to specific tasks without the extensive computational costs typically associated with full-model fine-tuning.\n*   LoRA relies on a simple concept: decomposition of non-full rank matrices.\n*   LoRA hypothesizes that “change in weights” during adaptation has a “low intrinsic rank”. ΔWΔW\\\\Delta W is non-full rank and so can be written as ΔW\\=BAΔW\\=BA\\\\Delta W = BA (cf. figure below).\n    *   A matrix is said to be rank-deficient if it does not have full rank. The rank deficiency of a matrix is the difference between the lesser of the number of rows and columns, and the rank. For more, refer [Wikipedia: Rank](https://en.wikipedia.org/wiki/Rank_\\(linear_algebra\\)).\n\n*   **Adapters:** Adapters introduce inference latency that becomes significant in online low batch size inference settings.\n*   **Prefix tuning:** Prefix tuning reduces the model’s usable sequence length.\n\n*   A matrix is said to be rank-deficient if it does not have full rank. The rank deficiency of a matrix is the difference between the lesser of the number of rows and columns, and the rank. For more, refer [Wikipedia: Rank](https://en.wikipedia.org/wiki/Rank_\\(linear_algebra\\)).\n\n![](/primers/ai/assets/interview/lora.jpeg)\n\n*   “Low intrinsic rank” is inspired by the idea of “low intrinsic dimensionality” that these over-parameterized pre-trained models are seen to reside on, and that’s also the explanation behind why fine-tuning only a part of the full model rather than full fine-tuning can yield good results.\n    *   LoRA operates under the hypothesis that the weight changes in the adaptation of a model (fine-tuning) have a low intrinsic rank. In other words, even though a weight matrix may be large, the actual changes made to this matrix during adaptation can be represented in a compressed format, specifically through a low-rank approximation.\n*   The image below [source](https://www.reddit.com/media?url=https%3A%2F%2Fi.redd.it%2Fwell-researched-comparison-of-training-techniques-lora-v0-vl01e5grs6ca1.png%3Fs%3Dcfb3d4eb7d253025ffc68f6791740f7737604c84) shows LoRA in action for a diffusion model.\n\n*   LoRA operates under the hypothesis that the weight changes in the adaptation of a model (fine-tuning) have a low intrinsic rank. In other words, even though a weight matrix may be large, the actual changes made to this matrix during adaptation can be represented in a compressed format, specifically through a low-rank approximation.\n\n![](/primers/ai/assets/interview/lora2.png)\n\n*   Basic Concept: LoRA focuses on adapting only a small fraction of the model’s parameters during fine-tuning. Instead of updating the entire weight matrices in the Transformer layers, it introduces and optimizes low-rank matrices that capture the necessary adaptations for the specific task.\n*   **Modification of Weight Matrices:**\n    *   In a standard Transformer model, each layer has weight matrices (like those in the multi-head self-attention and feed-forward networks).\n    *   Rather than directly modifying these weight matrices, LoRA adds trainable low-rank matrices to them. Specifically, for a weight matrix WWW, the adaptation is done using two smaller matrices AAA and BBB (where AAA and BBB are much smaller in size compared to WWW).\n    *   The original weight matrix WWW remains frozen. During training, the outputs from WWW and ΔW\\=ABΔW\\=AB\\\\Delta W = AB are added component wise, and the update is effectively: W+ABTW+ABTW + AB^T.\n*   **Training Process:**\n    *   All we’re now left to optimize is the new matrices BBB and AAA that contain a very smaller number of parameters (combined) than the full matrix due to their dimensions. Put simply, during training, only the low-rank matrices AAA and BBB are updated, while the pre-trained weights are kept unchanged.\n    *   In summary, all of the pre-trained weights WWW are kept frozen and the rank decomposition matrices of the “change in weight matrix”, BBB and AAA, are optimized. This process reduces the number of trainable parameters significantly, making the fine-tuning process much more efficient in terms of computational resources and time.\n*   **Effectiveness:**\n    *   The key to LoRA’s effectiveness lies in the ability of the low-rank matrices to capture the essential changes needed for the new task while leveraging the extensive knowledge already encoded in the pre-trained model.\n    *   Despite updating only a small fraction of parameters, LoRA can achieve performance comparable to full-model fine-tuning on various NLP tasks.\n\n*   In a standard Transformer model, each layer has weight matrices (like those in the multi-head self-attention and feed-forward networks).\n*   Rather than directly modifying these weight matrices, LoRA adds trainable low-rank matrices to them. Specifically, for a weight matrix WWW, the adaptation is done using two smaller matrices AAA and BBB (where AAA and BBB are much smaller in size compared to WWW).\n*   The original weight matrix WWW remains frozen. During training, the outputs from WWW and ΔW\\=ABΔW\\=AB\\\\Delta W = AB are added component wise, and the update is effectively: W+ABTW+ABTW + AB^T.\n\n*   All we’re now left to optimize is the new matrices BBB and AAA that contain a very smaller number of parameters (combined) than the full matrix due to their dimensions. Put simply, during training, only the low-rank matrices AAA and BBB are updated, while the pre-trained weights are kept unchanged.\n*   In summary, all of the pre-trained weights WWW are kept frozen and the rank decomposition matrices of the “change in weight matrix”, BBB and AAA, are optimized. This process reduces the number of trainable parameters significantly, making the fine-tuning process much more efficient in terms of computational resources and time.\n\n*   The key to LoRA’s effectiveness lies in the ability of the low-rank matrices to capture the essential changes needed for the new task while leveraging the extensive knowledge already encoded in the pre-trained model.\n*   Despite updating only a small fraction of parameters, LoRA can achieve performance comparable to full-model fine-tuning on various NLP tasks.\n\n*   **Time and memory Efficiency:** Reduces computational and memory costs compared to traditional fine-tuning, where all parameters of the model are updated. With a large percentage of the parameters being frozen, the training time and the GPU memory is saved. Saving is more when using stateful optimizers like Adam, Adadelta, etc.\n*   **Scalability:** Enables the adaptation of very large models to specific tasks without prohibitive computational costs.\n*   **Storage efficiency:** No need to store huge checkpoints for different downstream tasks. Checkpoint size is greatly reduced with reduction in trainable parameters.\n*   **No additional inference latency:** (unlike adapters) just add the learned matrix to the pre-trained one.\n*   **Easy task-switching in deployment:** all we need to change is a handful of weights as compared to the full model.\n*   **Preservation of Pre-trained Knowledge:** By keeping the majority of the pre-trained weights frozen, LoRA maintains the rich representations learned during pre-training, reducing the risk of catastrophic forgetting.\n*   **Flexibility:** Can be applied to different parts of a Transformer model (like attention or feed-forward layers) depending on the task requirements.\n\n*   With GPT-3 175B, the VRAM consumption during training reduced from 1.2TB to 350GB, while the trained checkpoint size reduced from 350GB to 35MB!\n*   LoRA achieves performances comparable to and sometimes even better than fine-tuning the full model.\n\n*   LoRA is particularly useful for adapting large-scale language models to specific domains or tasks, especially when computational resources are limited or when it’s desirable to maintain the integrity of the pre-trained model while still achieving task-specific performance gains. This approach represents a shift towards more parameter-efficient methods of adapting large models, which is increasingly important as state-of-the-art models continue to grow in size.",
      "order": 101,
      "orderInChapter": 101,
      "difficulty": 5,
      "estimatedMinutes": 12,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "bert",
        "gpt",
        "nlp",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 2245,
        "contentLength": 91136
      },
      "nextCards": [
        "ai-interview-what-is-the-difficulty-with-using-the-natural-grad-102",
        "ai-interview-in-the-past-cnns-were-used-for-translation-explain-103"
      ],
      "relatedCards": [
        "ai-transformers-are-transformers-learning-neural-syntax-33",
        "ai-transformers-what-is-the-fraction-of-attention-weights-relative-60",
        "ai-word-vectors-contextualized-embeddings-and-the-post-word2vec-er-38",
        "ai-LLM-how-do-you-add-a-new-token-to-the-tokenizers-vocab-68",
        "ai-VLM-video-llms-for-generation-17"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-how-lora-works.",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difficulty-with-using-the-natural-grad-102",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difficulty with Using the Natural Gradient (second Order Gradient) in Optimisation Rather Than the Regular Gradient Descent Family (first Order)?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Using the natural gradient, which is a second-order optimization method, in place of the regular gradient descent (a first-order method) presents several challenges and difficulties, particularly in the context of training deep neural networks. Here’s a breakdown of these challenges:\n    <ul>\n      <li><strong>Computational Complexity</strong>:\n        <ul>\n          <li><strong>Calculation of the Hessian or Fisher Information Matrix:</strong>\n            <ul>\n              <li>Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.</li>\n              <li>Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Memory Requirements</strong>:\n        <ul>\n          <li><strong>Storage Space:</strong> Storing the Hessian or Fisher Information Matrix requires a significant amount of memory. For models with millions of parameters, this can quickly become impractical, especially on typical hardware used for training neural networks.</li>\n        </ul>\n      </li>\n      <li><strong>Numerical Stability</strong>:\n        <ul>\n          <li>Stability and Inversion Issues:\n            <ul>\n              <li>The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.</li>\n              <li>Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Implementation Complexity</strong>:\n        <ul>\n          <li>More Complex Implementation: Implementing natural gradient descent is more complex compared to first-order methods. The simplicity and ease of implementation of first-order methods like stochastic gradient descent (SGD) and its variants (Adam, RMSprop) make them more appealing in practice.</li>\n        </ul>\n      </li>\n      <li><strong>Efficiency in Deep Learning</strong>:\n        <ul>\n          <li><strong>Efficiency in High-Dimensional Spaces:</strong> Despite the theoretical advantages of second-order methods in terms of convergence speed, in practice, first-order methods have shown remarkable efficiency and effectiveness in the high-dimensional spaces characteristic of deep learning.</li>\n          <li><strong>Adaptive First-Order Methods:</strong> Adaptive gradient methods like Adam partially address some of the issues that natural gradients aim to solve, such as adapting the learning rate to the parameters, making them a more practical choice in many scenarios.</li>\n        </ul>\n      </li>\n      <li><strong>Applications</strong>:\n        <ul>\n          <li><strong>Niche Applications:</strong> Natural gradient methods are more commonly used in specific scenarios where the computational cost is justifiable, such as in smaller models or models where precise convergence is crucial.</li>\n        </ul>\n      </li>\n      <li><strong>Summary</strong>: While natural gradient descent offers theoretical advantages, particularly in terms of faster convergence by taking into account the geometry of the parameter space, its practical application in deep learning is limited due to computational and memory constraints, numerical stability issues, and implementation complexity. In contrast, first-order methods, despite their simplicity, provide a good balance between computational efficiency, ease of use, and performance in large-scale deep learning tasks.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Computational Complexity</strong>:\n        <ul>\n          <li><strong>Calculation of the Hessian or Fisher Information Matrix:</strong>\n            <ul>\n              <li>Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.</li>\n              <li>Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Memory Requirements</strong>:\n        <ul>\n          <li><strong>Storage Space:</strong> Storing the Hessian or Fisher Information Matrix requires a significant amount of memory. For models with millions of parameters, this can quickly become impractical, especially on typical hardware used for training neural networks.</li>\n        </ul>\n      </li>\n      <li><strong>Numerical Stability</strong>:\n        <ul>\n          <li>Stability and Inversion Issues:\n            <ul>\n              <li>The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.</li>\n              <li>Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Implementation Complexity</strong>:\n        <ul>\n          <li>More Complex Implementation: Implementing natural gradient descent is more complex compared to first-order methods. The simplicity and ease of implementation of first-order methods like stochastic gradient descent (SGD) and its variants (Adam, RMSprop) make them more appealing in practice.</li>\n        </ul>\n      </li>\n      <li><strong>Efficiency in Deep Learning</strong>:\n        <ul>\n          <li><strong>Efficiency in High-Dimensional Spaces:</strong> Despite the theoretical advantages of second-order methods in terms of convergence speed, in practice, first-order methods have shown remarkable efficiency and effectiveness in the high-dimensional spaces characteristic of deep learning.</li>\n          <li><strong>Adaptive First-Order Methods:</strong> Adaptive gradient methods like Adam partially address some of the issues that natural gradients aim to solve, such as adapting the learning rate to the parameters, making them a more practical choice in many scenarios.</li>\n        </ul>\n      </li>\n      <li><strong>Applications</strong>:\n        <ul>\n          <li><strong>Niche Applications:</strong> Natural gradient methods are more commonly used in specific scenarios where the computational cost is justifiable, such as in smaller models or models where precise convergence is crucial.</li>\n        </ul>\n      </li>\n      <li><strong>Summary</strong>: While natural gradient descent offers theoretical advantages, particularly in terms of faster convergence by taking into account the geometry of the parameter space, its practical application in deep learning is limited due to computational and memory constraints, numerical stability issues, and implementation complexity. In contrast, first-order methods, despite their simplicity, provide a good balance between computational efficiency, ease of use, and performance in large-scale deep learning tasks.</li>\n    </ul>\n<ul>\n          <li><strong>Calculation of the Hessian or Fisher Information Matrix:</strong>\n            <ul>\n              <li>Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.</li>\n              <li>Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.</li>\n              <li>Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.</li>\n            </ul>\n<ul>\n          <li><strong>Storage Space:</strong> Storing the Hessian or Fisher Information Matrix requires a significant amount of memory. For models with millions of parameters, this can quickly become impractical, especially on typical hardware used for training neural networks.</li>\n        </ul>\n<ul>\n          <li>Stability and Inversion Issues:\n            <ul>\n              <li>The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.</li>\n              <li>Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.</li>\n              <li>Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.</li>\n            </ul>\n<ul>\n          <li>More Complex Implementation: Implementing natural gradient descent is more complex compared to first-order methods. The simplicity and ease of implementation of first-order methods like stochastic gradient descent (SGD) and its variants (Adam, RMSprop) make them more appealing in practice.</li>\n        </ul>\n<ul>\n          <li><strong>Efficiency in High-Dimensional Spaces:</strong> Despite the theoretical advantages of second-order methods in terms of convergence speed, in practice, first-order methods have shown remarkable efficiency and effectiveness in the high-dimensional spaces characteristic of deep learning.</li>\n          <li><strong>Adaptive First-Order Methods:</strong> Adaptive gradient methods like Adam partially address some of the issues that natural gradients aim to solve, such as adapting the learning rate to the parameters, making them a more practical choice in many scenarios.</li>\n        </ul>\n<ul>\n          <li><strong>Niche Applications:</strong> Natural gradient methods are more commonly used in specific scenarios where the computational cost is justifiable, such as in smaller models or models where precise convergence is crucial.</li>\n        </ul>",
      "contentMarkdown": "*   Using the natural gradient, which is a second-order optimization method, in place of the regular gradient descent (a first-order method) presents several challenges and difficulties, particularly in the context of training deep neural networks. Here’s a breakdown of these challenges:\n    *   **Computational Complexity**:\n        *   **Calculation of the Hessian or Fisher Information Matrix:**\n            *   Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.\n            *   Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.\n    *   **Memory Requirements**:\n        *   **Storage Space:** Storing the Hessian or Fisher Information Matrix requires a significant amount of memory. For models with millions of parameters, this can quickly become impractical, especially on typical hardware used for training neural networks.\n    *   **Numerical Stability**:\n        *   Stability and Inversion Issues:\n            *   The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.\n            *   Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.\n    *   **Implementation Complexity**:\n        *   More Complex Implementation: Implementing natural gradient descent is more complex compared to first-order methods. The simplicity and ease of implementation of first-order methods like stochastic gradient descent (SGD) and its variants (Adam, RMSprop) make them more appealing in practice.\n    *   **Efficiency in Deep Learning**:\n        *   **Efficiency in High-Dimensional Spaces:** Despite the theoretical advantages of second-order methods in terms of convergence speed, in practice, first-order methods have shown remarkable efficiency and effectiveness in the high-dimensional spaces characteristic of deep learning.\n        *   **Adaptive First-Order Methods:** Adaptive gradient methods like Adam partially address some of the issues that natural gradients aim to solve, such as adapting the learning rate to the parameters, making them a more practical choice in many scenarios.\n    *   **Applications**:\n        *   **Niche Applications:** Natural gradient methods are more commonly used in specific scenarios where the computational cost is justifiable, such as in smaller models or models where precise convergence is crucial.\n    *   **Summary**: While natural gradient descent offers theoretical advantages, particularly in terms of faster convergence by taking into account the geometry of the parameter space, its practical application in deep learning is limited due to computational and memory constraints, numerical stability issues, and implementation complexity. In contrast, first-order methods, despite their simplicity, provide a good balance between computational efficiency, ease of use, and performance in large-scale deep learning tasks.\n\n*   **Computational Complexity**:\n    *   **Calculation of the Hessian or Fisher Information Matrix:**\n        *   Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.\n        *   Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.\n*   **Memory Requirements**:\n    *   **Storage Space:** Storing the Hessian or Fisher Information Matrix requires a significant amount of memory. For models with millions of parameters, this can quickly become impractical, especially on typical hardware used for training neural networks.\n*   **Numerical Stability**:\n    *   Stability and Inversion Issues:\n        *   The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.\n        *   Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.\n*   **Implementation Complexity**:\n    *   More Complex Implementation: Implementing natural gradient descent is more complex compared to first-order methods. The simplicity and ease of implementation of first-order methods like stochastic gradient descent (SGD) and its variants (Adam, RMSprop) make them more appealing in practice.\n*   **Efficiency in Deep Learning**:\n    *   **Efficiency in High-Dimensional Spaces:** Despite the theoretical advantages of second-order methods in terms of convergence speed, in practice, first-order methods have shown remarkable efficiency and effectiveness in the high-dimensional spaces characteristic of deep learning.\n    *   **Adaptive First-Order Methods:** Adaptive gradient methods like Adam partially address some of the issues that natural gradients aim to solve, such as adapting the learning rate to the parameters, making them a more practical choice in many scenarios.\n*   **Applications**:\n    *   **Niche Applications:** Natural gradient methods are more commonly used in specific scenarios where the computational cost is justifiable, such as in smaller models or models where precise convergence is crucial.\n*   **Summary**: While natural gradient descent offers theoretical advantages, particularly in terms of faster convergence by taking into account the geometry of the parameter space, its practical application in deep learning is limited due to computational and memory constraints, numerical stability issues, and implementation complexity. In contrast, first-order methods, despite their simplicity, provide a good balance between computational efficiency, ease of use, and performance in large-scale deep learning tasks.\n\n*   **Calculation of the Hessian or Fisher Information Matrix:**\n    *   Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.\n    *   Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.\n\n*   Natural gradient descent requires the computation of the Hessian matrix (second-order partial derivatives) or the Fisher Information Matrix. For deep networks with a large number of parameters, this matrix is extremely large and computationally expensive to calculate.\n*   Inverting the Hessian or Fisher Information Matrix, necessary for natural gradient computations, is computationally intensive and often not feasible for high-dimensional parameter spaces typical in deep learning.\n\n*   **Storage Space:** Storing the Hessian or Fisher Information Matrix requires a significant amount of memory. For models with millions of parameters, this can quickly become impractical, especially on typical hardware used for training neural networks.\n\n*   Stability and Inversion Issues:\n    *   The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.\n    *   Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.\n\n*   The Hessian or Fisher Information Matrix can be ill-conditioned, making its inversion numerically unstable. Regularization techniques can be used to mitigate this, but they add additional complexity.\n*   Approximations to the matrix inversion (like using the matrix inverse lemma) can help but might introduce approximation errors.\n\n*   More Complex Implementation: Implementing natural gradient descent is more complex compared to first-order methods. The simplicity and ease of implementation of first-order methods like stochastic gradient descent (SGD) and its variants (Adam, RMSprop) make them more appealing in practice.\n\n*   **Efficiency in High-Dimensional Spaces:** Despite the theoretical advantages of second-order methods in terms of convergence speed, in practice, first-order methods have shown remarkable efficiency and effectiveness in the high-dimensional spaces characteristic of deep learning.\n*   **Adaptive First-Order Methods:** Adaptive gradient methods like Adam partially address some of the issues that natural gradients aim to solve, such as adapting the learning rate to the parameters, making them a more practical choice in many scenarios.\n\n*   **Niche Applications:** Natural gradient methods are more commonly used in specific scenarios where the computational cost is justifiable, such as in smaller models or models where precise convergence is crucial.",
      "order": 102,
      "orderInChapter": 102,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "optimization",
        "gradient descent",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1254,
        "contentLength": 11292
      },
      "nextCards": [
        "ai-interview-in-the-past-cnns-were-used-for-translation-explain-103",
        "ai-interview-why-in-transformers-positional-encodings-are-used--104"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-model-debugging-knowledge-distillation-student-teacher-approach-16",
        "ai-bias-variance-tradeoff-techniques-to-prevent-underfitting-11",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27",
        "ai-decision-trees-and-ensemble-methods-what-role-does-the-learning-rate-play-in-training--30"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difficulty-with-using-the-natural-gradient-(second-order-gradient)-in-optimisation-rather-than-the-regular-gradient-descent-family-(first-order)?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-in-the-past-cnns-were-used-for-translation-explain-103",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "In the Past, CNNs Were Used for Translation. Explain Why They are Not Anymore?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Convolutional Neural Networks (CNNs) have indeed been used in the past for machine translation tasks, but their prevalence has diminished, especially with the advent of Transformer models. Let’s explore why CNNs are no longer the primary choice for translation:\n    <ul>\n      <li><strong>- Early Use of CNNs in Translation</strong>:\n        <ul>\n          <li><strong>Feature Extraction:</strong> CNNs are effective at extracting local features and recognizing patterns in data, which made them useful in early attempts at neural machine translation.</li>\n          <li><strong>Handling Sequences:</strong> Initially, CNNs were adapted to handle sequential data by applying convolutions across sequences, capturing local dependencies.</li>\n        </ul>\n      </li>\n      <li><strong>Shift to RNNs and Then to Transformers</strong>:\n        <ul>\n          <li><strong>Recurrent Neural Networks (RNNs):</strong> RNNs, and later LSTMs and GRUs, became more popular for translation due to their inherent ability to handle sequential data and capture long-range dependencies across sentences.</li>\n          <li><strong>Introduction of Transformers:</strong>\n            <ul>\n              <li>The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. \tTransformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.</li>\n              <li>The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Limitations of CNNs for Translation</strong>:\n        <ul>\n          <li><strong>Local Focus:</strong> CNNs are primarily designed to capture local patterns. While they can be stacked to increase their receptive field, they are inherently less efficient at capturing long-range dependencies in sequences compared to self-attention mechanisms.</li>\n          <li><strong>Parallelization Limitations:</strong> Unlike Transformers, the sequential nature of CNN operations (even when adapted for sequence processing) limits their parallelization capabilities, leading to less efficient training and inference for long sequences.</li>\n          <li><strong>Contextual Understanding:</strong> CNNs have limitations in their ability to understand the broader context of a sentence, which is crucial in translation for capturing nuances, idiomatic expressions, and context-dependent meanings.</li>\n        </ul>\n      </li>\n      <li><strong>Conclusion</strong>: While CNNs were once a part of the evolving landscape of neural machine translation, the field has progressively moved towards architectures that are more naturally suited to the sequential and context-rich nature of language. The Transformer model, with its superior ability to handle long sequences, context, and parallel processing, has largely supplanted CNNs in this domain. However, it’s worth noting that CNNs still play a vital role in many other areas of deep learning, particularly in image processing and computer vision.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>- Early Use of CNNs in Translation</strong>:\n        <ul>\n          <li><strong>Feature Extraction:</strong> CNNs are effective at extracting local features and recognizing patterns in data, which made them useful in early attempts at neural machine translation.</li>\n          <li><strong>Handling Sequences:</strong> Initially, CNNs were adapted to handle sequential data by applying convolutions across sequences, capturing local dependencies.</li>\n        </ul>\n      </li>\n      <li><strong>Shift to RNNs and Then to Transformers</strong>:\n        <ul>\n          <li><strong>Recurrent Neural Networks (RNNs):</strong> RNNs, and later LSTMs and GRUs, became more popular for translation due to their inherent ability to handle sequential data and capture long-range dependencies across sentences.</li>\n          <li><strong>Introduction of Transformers:</strong>\n            <ul>\n              <li>The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. \tTransformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.</li>\n              <li>The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Limitations of CNNs for Translation</strong>:\n        <ul>\n          <li><strong>Local Focus:</strong> CNNs are primarily designed to capture local patterns. While they can be stacked to increase their receptive field, they are inherently less efficient at capturing long-range dependencies in sequences compared to self-attention mechanisms.</li>\n          <li><strong>Parallelization Limitations:</strong> Unlike Transformers, the sequential nature of CNN operations (even when adapted for sequence processing) limits their parallelization capabilities, leading to less efficient training and inference for long sequences.</li>\n          <li><strong>Contextual Understanding:</strong> CNNs have limitations in their ability to understand the broader context of a sentence, which is crucial in translation for capturing nuances, idiomatic expressions, and context-dependent meanings.</li>\n        </ul>\n      </li>\n      <li><strong>Conclusion</strong>: While CNNs were once a part of the evolving landscape of neural machine translation, the field has progressively moved towards architectures that are more naturally suited to the sequential and context-rich nature of language. The Transformer model, with its superior ability to handle long sequences, context, and parallel processing, has largely supplanted CNNs in this domain. However, it’s worth noting that CNNs still play a vital role in many other areas of deep learning, particularly in image processing and computer vision.</li>\n    </ul>\n<ul>\n          <li><strong>Feature Extraction:</strong> CNNs are effective at extracting local features and recognizing patterns in data, which made them useful in early attempts at neural machine translation.</li>\n          <li><strong>Handling Sequences:</strong> Initially, CNNs were adapted to handle sequential data by applying convolutions across sequences, capturing local dependencies.</li>\n        </ul>\n<ul>\n          <li><strong>Recurrent Neural Networks (RNNs):</strong> RNNs, and later LSTMs and GRUs, became more popular for translation due to their inherent ability to handle sequential data and capture long-range dependencies across sentences.</li>\n          <li><strong>Introduction of Transformers:</strong>\n            <ul>\n              <li>The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. \tTransformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.</li>\n              <li>The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. \tTransformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.</li>\n              <li>The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.</li>\n            </ul>\n<ul>\n          <li><strong>Local Focus:</strong> CNNs are primarily designed to capture local patterns. While they can be stacked to increase their receptive field, they are inherently less efficient at capturing long-range dependencies in sequences compared to self-attention mechanisms.</li>\n          <li><strong>Parallelization Limitations:</strong> Unlike Transformers, the sequential nature of CNN operations (even when adapted for sequence processing) limits their parallelization capabilities, leading to less efficient training and inference for long sequences.</li>\n          <li><strong>Contextual Understanding:</strong> CNNs have limitations in their ability to understand the broader context of a sentence, which is crucial in translation for capturing nuances, idiomatic expressions, and context-dependent meanings.</li>\n        </ul>",
      "contentMarkdown": "*   Convolutional Neural Networks (CNNs) have indeed been used in the past for machine translation tasks, but their prevalence has diminished, especially with the advent of Transformer models. Let’s explore why CNNs are no longer the primary choice for translation:\n    *   **\\- Early Use of CNNs in Translation**:\n        *   **Feature Extraction:** CNNs are effective at extracting local features and recognizing patterns in data, which made them useful in early attempts at neural machine translation.\n        *   **Handling Sequences:** Initially, CNNs were adapted to handle sequential data by applying convolutions across sequences, capturing local dependencies.\n    *   **Shift to RNNs and Then to Transformers**:\n        *   **Recurrent Neural Networks (RNNs):** RNNs, and later LSTMs and GRUs, became more popular for translation due to their inherent ability to handle sequential data and capture long-range dependencies across sentences.\n        *   **Introduction of Transformers:**\n            *   The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. Transformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.\n            *   The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.\n    *   **Limitations of CNNs for Translation**:\n        *   **Local Focus:** CNNs are primarily designed to capture local patterns. While they can be stacked to increase their receptive field, they are inherently less efficient at capturing long-range dependencies in sequences compared to self-attention mechanisms.\n        *   **Parallelization Limitations:** Unlike Transformers, the sequential nature of CNN operations (even when adapted for sequence processing) limits their parallelization capabilities, leading to less efficient training and inference for long sequences.\n        *   **Contextual Understanding:** CNNs have limitations in their ability to understand the broader context of a sentence, which is crucial in translation for capturing nuances, idiomatic expressions, and context-dependent meanings.\n    *   **Conclusion**: While CNNs were once a part of the evolving landscape of neural machine translation, the field has progressively moved towards architectures that are more naturally suited to the sequential and context-rich nature of language. The Transformer model, with its superior ability to handle long sequences, context, and parallel processing, has largely supplanted CNNs in this domain. However, it’s worth noting that CNNs still play a vital role in many other areas of deep learning, particularly in image processing and computer vision.\n\n*   **\\- Early Use of CNNs in Translation**:\n    *   **Feature Extraction:** CNNs are effective at extracting local features and recognizing patterns in data, which made them useful in early attempts at neural machine translation.\n    *   **Handling Sequences:** Initially, CNNs were adapted to handle sequential data by applying convolutions across sequences, capturing local dependencies.\n*   **Shift to RNNs and Then to Transformers**:\n    *   **Recurrent Neural Networks (RNNs):** RNNs, and later LSTMs and GRUs, became more popular for translation due to their inherent ability to handle sequential data and capture long-range dependencies across sentences.\n    *   **Introduction of Transformers:**\n        *   The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. Transformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.\n        *   The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.\n*   **Limitations of CNNs for Translation**:\n    *   **Local Focus:** CNNs are primarily designed to capture local patterns. While they can be stacked to increase their receptive field, they are inherently less efficient at capturing long-range dependencies in sequences compared to self-attention mechanisms.\n    *   **Parallelization Limitations:** Unlike Transformers, the sequential nature of CNN operations (even when adapted for sequence processing) limits their parallelization capabilities, leading to less efficient training and inference for long sequences.\n    *   **Contextual Understanding:** CNNs have limitations in their ability to understand the broader context of a sentence, which is crucial in translation for capturing nuances, idiomatic expressions, and context-dependent meanings.\n*   **Conclusion**: While CNNs were once a part of the evolving landscape of neural machine translation, the field has progressively moved towards architectures that are more naturally suited to the sequential and context-rich nature of language. The Transformer model, with its superior ability to handle long sequences, context, and parallel processing, has largely supplanted CNNs in this domain. However, it’s worth noting that CNNs still play a vital role in many other areas of deep learning, particularly in image processing and computer vision.\n\n*   **Feature Extraction:** CNNs are effective at extracting local features and recognizing patterns in data, which made them useful in early attempts at neural machine translation.\n*   **Handling Sequences:** Initially, CNNs were adapted to handle sequential data by applying convolutions across sequences, capturing local dependencies.\n\n*   **Recurrent Neural Networks (RNNs):** RNNs, and later LSTMs and GRUs, became more popular for translation due to their inherent ability to handle sequential data and capture long-range dependencies across sentences.\n*   **Introduction of Transformers:**\n    *   The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. Transformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.\n    *   The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.\n\n*   The introduction of the Transformer model by Vaswani et al. in 2017 marked a significant shift in machine translation. Transformers use self-attention mechanisms, which allow them to process entire sequences of data simultaneously and capture long-range dependencies more effectively than both CNNs and RNNs.\n*   The parallel processing capability of Transformers significantly improved training efficiency and model performance, making them the de facto choice for machine translation.\n\n*   **Local Focus:** CNNs are primarily designed to capture local patterns. While they can be stacked to increase their receptive field, they are inherently less efficient at capturing long-range dependencies in sequences compared to self-attention mechanisms.\n*   **Parallelization Limitations:** Unlike Transformers, the sequential nature of CNN operations (even when adapted for sequence processing) limits their parallelization capabilities, leading to less efficient training and inference for long sequences.\n*   **Contextual Understanding:** CNNs have limitations in their ability to understand the broader context of a sentence, which is crucial in translation for capturing nuances, idiomatic expressions, and context-dependent meanings.",
      "order": 103,
      "orderInChapter": 103,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "transformer",
        "attention",
        "convolution",
        "cnn",
        "rnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1053,
        "contentLength": 9051
      },
      "nextCards": [
        "ai-interview-why-in-transformers-positional-encodings-are-used--104",
        "ai-interview-in-diffusion-models-there-is-a-forward-diffusion-p-105"
      ],
      "relatedCards": [
        "ai-dl-comp-use-cases-of-transformers-6",
        "ai-transformers-transformer-core-5",
        "ai-nlp-tasks-methodologies-and-models-36",
        "ai-model-compression-how-mixed-precision-training-works-41",
        "ai-ml-runtimes-architecture-33"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#in-the-past,-cnns-were-used-for-translation.-explain-why-they-are-not-anymore?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-in-transformers-positional-encodings-are-used--104",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why in Transformers Positional Encodings are Used Whereas No Such Mechanisms are Used in RNNs or CNNs. Follow- Up: Why Don’t We Use an Incremental Positional Encoding to Inform about the Positions (1, 2, 3, 4, 5,….), and Why Do We Use Sinusoidal Functions Instead?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Transformers use positional encodings because, unlike RNNs or CNNs, they lack any inherent mechanism to process data in a sequential order. Each follow-up question addresses specific aspects of this design choice:\n    <ul>\n      <li><strong>Why Positional Encodings are Used in Transformers</strong>:</li>\n      <li><strong>Lack of Sequential Processing:</strong> In RNNs, the sequential input is inherent in the model’s architecture, as each step’s output depends on the previous step. CNNs, when adapted for sequence processing, also capture local sequence information through their convolutional filters.\nTransformers, on the other hand, process the entire input sequence simultaneously. This parallel processing is efficient but doesn’t inherently capture the sequential or positional information of the data.</li>\n      <li><strong>Preserving Sequence Information:</strong> To address this, Transformers add positional encodings to the input embeddings to maintain the order of the sequence. This way, the model can understand the position of each element in the sequence, which is crucial in tasks like language understanding.</li>\n      <li><strong>Why Not Use Incremental Positional Encoding</strong>:</li>\n      <li><strong>Incremental Positional Encoding Limitations:</strong>\n        <ul>\n          <li>Simple incremental encodings (like 1, 2, 3, …) could be used, but they have limitations. They might not scale well with longer sequences, and the model might not generalize well to sequence lengths not seen during training.</li>\n          <li>Incremental encodings also do not inherently capture the relative positions of tokens in the sequence.</li>\n        </ul>\n      </li>\n      <li><strong>Continuous and Relative Position Information:</strong>\n        <ul>\n          <li>Sinusoidal functions provide a way to encode position that allows the model to easily learn to attend by relative positions, as the difference in the encoding between positions is consistent. This is important for generalizing to different sequence lengths and for tasks where relative positioning is crucial.</li>\n          <li>The use of sine and cosine functions also ensures that each dimension of the positional encoding varies at a different frequency, making it easier for the model to learn and distinguish between different positions.</li>\n        </ul>\n      </li>\n      <li><strong>Why Use Sinusoidal Functions</strong>:\n        <ul>\n          <li><strong>Generalization to Longer Sequences:</strong> Sinusoidal encodings can be extrapolated and hence allow models to generalize to sequence lengths greater than those encountered during training.</li>\n          <li><strong>Encoding Relative Positions:</strong> The sine and cosine functions provide a smooth and continuous way to encode positions. They also have the property that their sum/difference can represent relative positions effectively, which is a useful property for understanding language.</li>\n          <li><strong>Robustness and Efficiency:</strong> Sinusoidal positional encodings add minimal computational complexity and are fixed, not learned, which can provide some stability and reduce overfitting.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>In summary, while Transformers need positional encodings to make sense of the sequence order, the choice of sinusoidal functions is driven by the need for scalability, efficiency, and the ability to capture relative positional information, which are not as effectively addressed by simple incremental encodings.</li>\n</ul>\n<ul>\n      <li><strong>Why Positional Encodings are Used in Transformers</strong>:</li>\n      <li><strong>Lack of Sequential Processing:</strong> In RNNs, the sequential input is inherent in the model’s architecture, as each step’s output depends on the previous step. CNNs, when adapted for sequence processing, also capture local sequence information through their convolutional filters.\nTransformers, on the other hand, process the entire input sequence simultaneously. This parallel processing is efficient but doesn’t inherently capture the sequential or positional information of the data.</li>\n      <li><strong>Preserving Sequence Information:</strong> To address this, Transformers add positional encodings to the input embeddings to maintain the order of the sequence. This way, the model can understand the position of each element in the sequence, which is crucial in tasks like language understanding.</li>\n      <li><strong>Why Not Use Incremental Positional Encoding</strong>:</li>\n      <li><strong>Incremental Positional Encoding Limitations:</strong>\n        <ul>\n          <li>Simple incremental encodings (like 1, 2, 3, …) could be used, but they have limitations. They might not scale well with longer sequences, and the model might not generalize well to sequence lengths not seen during training.</li>\n          <li>Incremental encodings also do not inherently capture the relative positions of tokens in the sequence.</li>\n        </ul>\n      </li>\n      <li><strong>Continuous and Relative Position Information:</strong>\n        <ul>\n          <li>Sinusoidal functions provide a way to encode position that allows the model to easily learn to attend by relative positions, as the difference in the encoding between positions is consistent. This is important for generalizing to different sequence lengths and for tasks where relative positioning is crucial.</li>\n          <li>The use of sine and cosine functions also ensures that each dimension of the positional encoding varies at a different frequency, making it easier for the model to learn and distinguish between different positions.</li>\n        </ul>\n      </li>\n      <li><strong>Why Use Sinusoidal Functions</strong>:\n        <ul>\n          <li><strong>Generalization to Longer Sequences:</strong> Sinusoidal encodings can be extrapolated and hence allow models to generalize to sequence lengths greater than those encountered during training.</li>\n          <li><strong>Encoding Relative Positions:</strong> The sine and cosine functions provide a smooth and continuous way to encode positions. They also have the property that their sum/difference can represent relative positions effectively, which is a useful property for understanding language.</li>\n          <li><strong>Robustness and Efficiency:</strong> Sinusoidal positional encodings add minimal computational complexity and are fixed, not learned, which can provide some stability and reduce overfitting.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Simple incremental encodings (like 1, 2, 3, …) could be used, but they have limitations. They might not scale well with longer sequences, and the model might not generalize well to sequence lengths not seen during training.</li>\n          <li>Incremental encodings also do not inherently capture the relative positions of tokens in the sequence.</li>\n        </ul>\n<ul>\n          <li>Sinusoidal functions provide a way to encode position that allows the model to easily learn to attend by relative positions, as the difference in the encoding between positions is consistent. This is important for generalizing to different sequence lengths and for tasks where relative positioning is crucial.</li>\n          <li>The use of sine and cosine functions also ensures that each dimension of the positional encoding varies at a different frequency, making it easier for the model to learn and distinguish between different positions.</li>\n        </ul>\n<ul>\n          <li><strong>Generalization to Longer Sequences:</strong> Sinusoidal encodings can be extrapolated and hence allow models to generalize to sequence lengths greater than those encountered during training.</li>\n          <li><strong>Encoding Relative Positions:</strong> The sine and cosine functions provide a smooth and continuous way to encode positions. They also have the property that their sum/difference can represent relative positions effectively, which is a useful property for understanding language.</li>\n          <li><strong>Robustness and Efficiency:</strong> Sinusoidal positional encodings add minimal computational complexity and are fixed, not learned, which can provide some stability and reduce overfitting.</li>\n        </ul>",
      "contentMarkdown": "*   Transformers use positional encodings because, unlike RNNs or CNNs, they lack any inherent mechanism to process data in a sequential order. Each follow-up question addresses specific aspects of this design choice:\n    *   **Why Positional Encodings are Used in Transformers**:\n    *   **Lack of Sequential Processing:** In RNNs, the sequential input is inherent in the model’s architecture, as each step’s output depends on the previous step. CNNs, when adapted for sequence processing, also capture local sequence information through their convolutional filters. Transformers, on the other hand, process the entire input sequence simultaneously. This parallel processing is efficient but doesn’t inherently capture the sequential or positional information of the data.\n    *   **Preserving Sequence Information:** To address this, Transformers add positional encodings to the input embeddings to maintain the order of the sequence. This way, the model can understand the position of each element in the sequence, which is crucial in tasks like language understanding.\n    *   **Why Not Use Incremental Positional Encoding**:\n    *   **Incremental Positional Encoding Limitations:**\n        *   Simple incremental encodings (like 1, 2, 3, …) could be used, but they have limitations. They might not scale well with longer sequences, and the model might not generalize well to sequence lengths not seen during training.\n        *   Incremental encodings also do not inherently capture the relative positions of tokens in the sequence.\n    *   **Continuous and Relative Position Information:**\n        *   Sinusoidal functions provide a way to encode position that allows the model to easily learn to attend by relative positions, as the difference in the encoding between positions is consistent. This is important for generalizing to different sequence lengths and for tasks where relative positioning is crucial.\n        *   The use of sine and cosine functions also ensures that each dimension of the positional encoding varies at a different frequency, making it easier for the model to learn and distinguish between different positions.\n    *   **Why Use Sinusoidal Functions**:\n        *   **Generalization to Longer Sequences:** Sinusoidal encodings can be extrapolated and hence allow models to generalize to sequence lengths greater than those encountered during training.\n        *   **Encoding Relative Positions:** The sine and cosine functions provide a smooth and continuous way to encode positions. They also have the property that their sum/difference can represent relative positions effectively, which is a useful property for understanding language.\n        *   **Robustness and Efficiency:** Sinusoidal positional encodings add minimal computational complexity and are fixed, not learned, which can provide some stability and reduce overfitting.\n*   In summary, while Transformers need positional encodings to make sense of the sequence order, the choice of sinusoidal functions is driven by the need for scalability, efficiency, and the ability to capture relative positional information, which are not as effectively addressed by simple incremental encodings.\n\n*   **Why Positional Encodings are Used in Transformers**:\n*   **Lack of Sequential Processing:** In RNNs, the sequential input is inherent in the model’s architecture, as each step’s output depends on the previous step. CNNs, when adapted for sequence processing, also capture local sequence information through their convolutional filters. Transformers, on the other hand, process the entire input sequence simultaneously. This parallel processing is efficient but doesn’t inherently capture the sequential or positional information of the data.\n*   **Preserving Sequence Information:** To address this, Transformers add positional encodings to the input embeddings to maintain the order of the sequence. This way, the model can understand the position of each element in the sequence, which is crucial in tasks like language understanding.\n*   **Why Not Use Incremental Positional Encoding**:\n*   **Incremental Positional Encoding Limitations:**\n    *   Simple incremental encodings (like 1, 2, 3, …) could be used, but they have limitations. They might not scale well with longer sequences, and the model might not generalize well to sequence lengths not seen during training.\n    *   Incremental encodings also do not inherently capture the relative positions of tokens in the sequence.\n*   **Continuous and Relative Position Information:**\n    *   Sinusoidal functions provide a way to encode position that allows the model to easily learn to attend by relative positions, as the difference in the encoding between positions is consistent. This is important for generalizing to different sequence lengths and for tasks where relative positioning is crucial.\n    *   The use of sine and cosine functions also ensures that each dimension of the positional encoding varies at a different frequency, making it easier for the model to learn and distinguish between different positions.\n*   **Why Use Sinusoidal Functions**:\n    *   **Generalization to Longer Sequences:** Sinusoidal encodings can be extrapolated and hence allow models to generalize to sequence lengths greater than those encountered during training.\n    *   **Encoding Relative Positions:** The sine and cosine functions provide a smooth and continuous way to encode positions. They also have the property that their sum/difference can represent relative positions effectively, which is a useful property for understanding language.\n    *   **Robustness and Efficiency:** Sinusoidal positional encodings add minimal computational complexity and are fixed, not learned, which can provide some stability and reduce overfitting.\n\n*   Simple incremental encodings (like 1, 2, 3, …) could be used, but they have limitations. They might not scale well with longer sequences, and the model might not generalize well to sequence lengths not seen during training.\n*   Incremental encodings also do not inherently capture the relative positions of tokens in the sequence.\n\n*   Sinusoidal functions provide a way to encode position that allows the model to easily learn to attend by relative positions, as the difference in the encoding between positions is consistent. This is important for generalizing to different sequence lengths and for tasks where relative positioning is crucial.\n*   The use of sine and cosine functions also ensures that each dimension of the positional encoding varies at a different frequency, making it easier for the model to learn and distinguish between different positions.\n\n*   **Generalization to Longer Sequences:** Sinusoidal encodings can be extrapolated and hence allow models to generalize to sequence lengths greater than those encountered during training.\n*   **Encoding Relative Positions:** The sine and cosine functions provide a smooth and continuous way to encode positions. They also have the property that their sum/difference can represent relative positions effectively, which is a useful property for understanding language.\n*   **Robustness and Efficiency:** Sinusoidal positional encodings add minimal computational complexity and are fixed, not learned, which can provide some stability and reduce overfitting.",
      "order": 104,
      "orderInChapter": 104,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "transformer",
        "embedding",
        "convolution",
        "cnn",
        "rnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1039,
        "contentLength": 8284
      },
      "nextCards": [
        "ai-interview-in-diffusion-models-there-is-a-forward-diffusion-p-105",
        "ai-interview-at-a-high-level-how-do-diffusion-models-work-what--106"
      ],
      "relatedCards": [
        "ai-state-space-models-efficiently-modeling-long-sequences-with-structure-3",
        "ai-model-compression-principles-of-lightweight-design-50",
        "ai-ml-runtimes-runtime-specific-execution-lifecycles-62",
        "ai-ml-runtimes-architecture-33",
        "ai-diffusion-models-patch-n-pack-navit-a-vision-transformer-for-any-as-62"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-in-transformers-positional-encodings-are-used-whereas-no-such-mechanisms-are-used-in-rnns-or-cnns.-follow--up:-why-don’t-we-use-an-incremental-positional-encoding-to-inform-about-the-positions-(1,-2,-3,-4,-5,….),-and-why-do-we-use-sinusoidal-functions-instead?",
      "scrapedAt": "2025-12-28T11:58:12.841Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-in-diffusion-models-there-is-a-forward-diffusion-p-105",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "In Diffusion Models, There is a Forward Diffusion Process, and a Denoising Process. for These Two Processes, When Do You Use Them in Training and Inference?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In diffusion models, which are a class of generative models, the forward diffusion process and the denoising process play distinct roles during training and inference. Understanding when and how these processes are used is key to grasping how diffusion models work.\n    <ul>\n      <li><strong>Forward Diffusion Process</strong>\n        <ul>\n          <li><strong>During Training:</strong>\n            <ul>\n              <li>Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.</li>\n              <li>Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.</li>\n            </ul>\n          </li>\n          <li><strong>During Inference:</strong>\n            <ul>\n              <li>Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Denoising Process</strong>\n        <ul>\n          <li><strong>During Training:</strong>\n            <ul>\n              <li>Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.</li>\n              <li>Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.</li>\n            </ul>\n          </li>\n          <li><strong>During Inference:</strong>\n            <ul>\n              <li>Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.</li>\n              <li>Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Summary</strong>\n        <ul>\n          <li><strong>Training Phase:</strong> Both the forward diffusion (adding noise) and the denoising (removing noise) processes are actively used. The model learns how to reverse the gradual corruption of the data (caused by adding noise) by being trained to predict and remove the noise at each step.</li>\n          <li><strong>Inference Phase:</strong> Only the denoising process is used, where the model starts with noise and iteratively applies the learned denoising steps to generate a sample. The forward process is not explicitly run during inference, but its principles underpin the reverse process.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>In essence, the forward diffusion process is crucial for training the model to understand and reverse the noise addition, while the denoising process is used both in training (to learn this reversal) and in inference (to generate new data).</li>\n</ul>\n<ul>\n      <li><strong>Forward Diffusion Process</strong>\n        <ul>\n          <li><strong>During Training:</strong>\n            <ul>\n              <li>Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.</li>\n              <li>Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.</li>\n            </ul>\n          </li>\n          <li><strong>During Inference:</strong>\n            <ul>\n              <li>Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Denoising Process</strong>\n        <ul>\n          <li><strong>During Training:</strong>\n            <ul>\n              <li>Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.</li>\n              <li>Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.</li>\n            </ul>\n          </li>\n          <li><strong>During Inference:</strong>\n            <ul>\n              <li>Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.</li>\n              <li>Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Summary</strong>\n        <ul>\n          <li><strong>Training Phase:</strong> Both the forward diffusion (adding noise) and the denoising (removing noise) processes are actively used. The model learns how to reverse the gradual corruption of the data (caused by adding noise) by being trained to predict and remove the noise at each step.</li>\n          <li><strong>Inference Phase:</strong> Only the denoising process is used, where the model starts with noise and iteratively applies the learned denoising steps to generate a sample. The forward process is not explicitly run during inference, but its principles underpin the reverse process.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>During Training:</strong>\n            <ul>\n              <li>Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.</li>\n              <li>Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.</li>\n            </ul>\n          </li>\n          <li><strong>During Inference:</strong>\n            <ul>\n              <li>Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.</li>\n              <li>Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.</li>\n            </ul>\n<ul>\n              <li>Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.</li>\n            </ul>\n<ul>\n          <li><strong>During Training:</strong>\n            <ul>\n              <li>Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.</li>\n              <li>Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.</li>\n            </ul>\n          </li>\n          <li><strong>During Inference:</strong>\n            <ul>\n              <li>Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.</li>\n              <li>Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.</li>\n              <li>Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.</li>\n            </ul>\n<ul>\n              <li>Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.</li>\n              <li>Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.</li>\n            </ul>\n<ul>\n          <li><strong>Training Phase:</strong> Both the forward diffusion (adding noise) and the denoising (removing noise) processes are actively used. The model learns how to reverse the gradual corruption of the data (caused by adding noise) by being trained to predict and remove the noise at each step.</li>\n          <li><strong>Inference Phase:</strong> Only the denoising process is used, where the model starts with noise and iteratively applies the learned denoising steps to generate a sample. The forward process is not explicitly run during inference, but its principles underpin the reverse process.</li>\n        </ul>",
      "contentMarkdown": "*   In diffusion models, which are a class of generative models, the forward diffusion process and the denoising process play distinct roles during training and inference. Understanding when and how these processes are used is key to grasping how diffusion models work.\n    *   **Forward Diffusion Process**\n        *   **During Training:**\n            *   Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.\n            *   Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.\n        *   **During Inference:**\n            *   Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.\n    *   **Denoising Process**\n        *   **During Training:**\n            *   Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.\n            *   Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.\n        *   **During Inference:**\n            *   Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.\n            *   Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.\n    *   **Summary**\n        *   **Training Phase:** Both the forward diffusion (adding noise) and the denoising (removing noise) processes are actively used. The model learns how to reverse the gradual corruption of the data (caused by adding noise) by being trained to predict and remove the noise at each step.\n        *   **Inference Phase:** Only the denoising process is used, where the model starts with noise and iteratively applies the learned denoising steps to generate a sample. The forward process is not explicitly run during inference, but its principles underpin the reverse process.\n*   In essence, the forward diffusion process is crucial for training the model to understand and reverse the noise addition, while the denoising process is used both in training (to learn this reversal) and in inference (to generate new data).\n\n*   **Forward Diffusion Process**\n    *   **During Training:**\n        *   Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.\n        *   Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.\n    *   **During Inference:**\n        *   Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.\n*   **Denoising Process**\n    *   **During Training:**\n        *   Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.\n        *   Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.\n    *   **During Inference:**\n        *   Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.\n        *   Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.\n*   **Summary**\n    *   **Training Phase:** Both the forward diffusion (adding noise) and the denoising (removing noise) processes are actively used. The model learns how to reverse the gradual corruption of the data (caused by adding noise) by being trained to predict and remove the noise at each step.\n    *   **Inference Phase:** Only the denoising process is used, where the model starts with noise and iteratively applies the learned denoising steps to generate a sample. The forward process is not explicitly run during inference, but its principles underpin the reverse process.\n\n*   **During Training:**\n    *   Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.\n    *   Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.\n*   **During Inference:**\n    *   Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.\n\n*   Noise Addition: In the forward diffusion process, noise is gradually added to the data over several steps or iterations. This process transforms the original data into a pure noise distribution through a predefined sequence of steps.\n*   Training Objective: The model is trained to predict the noise that was added at each step. Essentially, it learns to reverse the diffusion process.\n\n*   Not Directly Used: The forward diffusion process is not explicitly used during inference. However, the knowledge gained during training (about how noise is added) is implicitly used to guide the denoising process.\n\n*   **During Training:**\n    *   Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.\n    *   Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.\n*   **During Inference:**\n    *   Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.\n    *   Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.\n\n*   Learning to Reverse Noise: The model learns to denoise the data, i.e., to reverse the forward diffusion process. It does this by predicting the noise that was added at each step during the forward diffusion and then subtracting this noise.\n*   Parameter Optimization: The parameters of the model are optimized to make accurate predictions of the added noise, thereby learning to gradually denoise the data back to its original form.\n\n*   Data Generation: The denoising process is the key to generating new data. Starting from pure noise, the model iteratively denoises this input, using the reverse of the forward process, to generate a sample.\n*   Iterative Refinement: At each step, the model predicts the noise to remove, effectively refining the sample from random noise into a coherent output.\n\n*   **Training Phase:** Both the forward diffusion (adding noise) and the denoising (removing noise) processes are actively used. The model learns how to reverse the gradual corruption of the data (caused by adding noise) by being trained to predict and remove the noise at each step.\n*   **Inference Phase:** Only the denoising process is used, where the model starts with noise and iteratively applies the learned denoising steps to generate a sample. The forward process is not explicitly run during inference, but its principles underpin the reverse process.",
      "order": 105,
      "orderInChapter": 105,
      "difficulty": 4,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "optimization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1296,
        "contentLength": 10448
      },
      "nextCards": [
        "ai-interview-at-a-high-level-how-do-diffusion-models-work-what--106",
        "ai-interview-what-are-the-loss-functions-used-in-diffusion-mode-107"
      ],
      "relatedCards": [
        "ai-support-vector-machines-optimization-problem-4",
        "ai-support-vector-machines-model-16",
        "ai-decision-trees-and-ensemble-methods-why-do-decision-tree-models-not-require-data-norma-19",
        "ai-diffusion-models-in-diffusion-models-there-is-a-forward-diffusion-p-44",
        "ai-diffusion-models-diffusion-model-alignment-using-direct-preference--55"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#in-diffusion-models,-there-is-a-forward-diffusion-process,-and-a-denoising-process.-for-these-two-processes,-when-do-you-use-them-in-training-and-inference?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-at-a-high-level-how-do-diffusion-models-work-what--106",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "At a High Level, How Do Diffusion Models Work? What are Some Other Models That are Useful for Image Generation, and How Do They Compare to Diffusion Models?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Diffusion models, along with Variational Autoencoders (VAEs) and Generative Adversarial Networks (GANs), are powerful tools in the domain of image generation. Each of these models employs distinct mechanisms and has its strengths and limitations.</li>\n  <li><strong>How Diffusion Models Work</strong>\n    <ul>\n      <li><strong>Reversible Noising Process:</strong>\n        <ul>\n          <li><strong>Forward Process:</strong> Diffusion models work by gradually adding noise to an image (or any data) over a series of steps, transitioning it from the original data distribution to a noise distribution. This process is known as the forward diffusion process.</li>\n          <li><strong>Backward Process:</strong> The model then learns to reverse this process, which is where the actual generative modeling happens. By learning this reverse diffusion process, the model effectively learns to generate data starting from noise.</li>\n        </ul>\n      </li>\n      <li><strong>Data Generation:</strong> In the generative phase, the model starts with a sample of random noise and applies the learned reverse transformation to this noise, progressively denoising it to generate a sample of data (e.g., an image).</li>\n      <li><strong>Higher Quality Samples:</strong> Diffusion models are known for generating high-quality samples that are often more realistic and less prone to artifacts compared to other generative models.</li>\n    </ul>\n  </li>\n  <li><strong>Comparison with VAEs and GANs</strong>\n    <ul>\n      <li><strong>Variational Autoencoders (VAEs):</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> VAEs consist of an encoder that maps input data to a latent space and a decoder that reconstructs the data from this latent space. The training involves optimizing the reconstruction loss and a regularization term (KL divergence) that keeps the latent space distributions well-behaved.</li>\n          <li><strong>Image Generation:</strong> VAEs are effective for image generation but can sometimes produce blurrier results compared to GANs and diffusion models.</li>\n        </ul>\n      </li>\n      <li><strong>Generative Adversarial Networks (GANs):</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> GANs involve a generator that creates images and a discriminator that evaluates them. The generator learns to produce increasingly realistic images, while the discriminator improves at distinguishing real images from generated ones.</li>\n          <li><strong>Training Instability:</strong> GANs can generate high-quality, sharp images but are known for their training instability issues, such as mode collapse, where the generator produces a limited variety of outputs.</li>\n          <li><strong>Comparison to Diffusion Models:</strong> Diffusion models, in contrast, generally don’t have these training instabilities and can produce high-quality images, arguably with more consistency than GANs.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Summary</strong>\n    <ul>\n      <li><strong>Diffusion Models:</strong> Known for their ability to generate high-quality images and a more stable training process compared to GANs. They work by reversing a learned noising process and are particularly good at capturing fine details in images such as text in generated images, hair follicles as part of a person’s face, etc.</li>\n      <li><strong>VAEs:</strong> Offer a stable training regime and good general-purpose image generation but sometimes lack the sharpness and realism provided by GANs and diffusion models.</li>\n      <li><strong>GANs:</strong> Excel in creating sharp and realistic images but can be challenging to train and may suffer from stability issues.\n  Each of these models has its place in the field of image generation, with the choice depending on factors like desired image quality, training stability, and architectural complexity.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Reversible Noising Process:</strong>\n        <ul>\n          <li><strong>Forward Process:</strong> Diffusion models work by gradually adding noise to an image (or any data) over a series of steps, transitioning it from the original data distribution to a noise distribution. This process is known as the forward diffusion process.</li>\n          <li><strong>Backward Process:</strong> The model then learns to reverse this process, which is where the actual generative modeling happens. By learning this reverse diffusion process, the model effectively learns to generate data starting from noise.</li>\n        </ul>\n      </li>\n      <li><strong>Data Generation:</strong> In the generative phase, the model starts with a sample of random noise and applies the learned reverse transformation to this noise, progressively denoising it to generate a sample of data (e.g., an image).</li>\n      <li><strong>Higher Quality Samples:</strong> Diffusion models are known for generating high-quality samples that are often more realistic and less prone to artifacts compared to other generative models.</li>\n    </ul>\n<ul>\n          <li><strong>Forward Process:</strong> Diffusion models work by gradually adding noise to an image (or any data) over a series of steps, transitioning it from the original data distribution to a noise distribution. This process is known as the forward diffusion process.</li>\n          <li><strong>Backward Process:</strong> The model then learns to reverse this process, which is where the actual generative modeling happens. By learning this reverse diffusion process, the model effectively learns to generate data starting from noise.</li>\n        </ul>\n<ul>\n      <li><strong>Variational Autoencoders (VAEs):</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> VAEs consist of an encoder that maps input data to a latent space and a decoder that reconstructs the data from this latent space. The training involves optimizing the reconstruction loss and a regularization term (KL divergence) that keeps the latent space distributions well-behaved.</li>\n          <li><strong>Image Generation:</strong> VAEs are effective for image generation but can sometimes produce blurrier results compared to GANs and diffusion models.</li>\n        </ul>\n      </li>\n      <li><strong>Generative Adversarial Networks (GANs):</strong>\n        <ul>\n          <li><strong>Mechanism:</strong> GANs involve a generator that creates images and a discriminator that evaluates them. The generator learns to produce increasingly realistic images, while the discriminator improves at distinguishing real images from generated ones.</li>\n          <li><strong>Training Instability:</strong> GANs can generate high-quality, sharp images but are known for their training instability issues, such as mode collapse, where the generator produces a limited variety of outputs.</li>\n          <li><strong>Comparison to Diffusion Models:</strong> Diffusion models, in contrast, generally don’t have these training instabilities and can produce high-quality images, arguably with more consistency than GANs.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Mechanism:</strong> VAEs consist of an encoder that maps input data to a latent space and a decoder that reconstructs the data from this latent space. The training involves optimizing the reconstruction loss and a regularization term (KL divergence) that keeps the latent space distributions well-behaved.</li>\n          <li><strong>Image Generation:</strong> VAEs are effective for image generation but can sometimes produce blurrier results compared to GANs and diffusion models.</li>\n        </ul>\n<ul>\n          <li><strong>Mechanism:</strong> GANs involve a generator that creates images and a discriminator that evaluates them. The generator learns to produce increasingly realistic images, while the discriminator improves at distinguishing real images from generated ones.</li>\n          <li><strong>Training Instability:</strong> GANs can generate high-quality, sharp images but are known for their training instability issues, such as mode collapse, where the generator produces a limited variety of outputs.</li>\n          <li><strong>Comparison to Diffusion Models:</strong> Diffusion models, in contrast, generally don’t have these training instabilities and can produce high-quality images, arguably with more consistency than GANs.</li>\n        </ul>\n<ul>\n      <li><strong>Diffusion Models:</strong> Known for their ability to generate high-quality images and a more stable training process compared to GANs. They work by reversing a learned noising process and are particularly good at capturing fine details in images such as text in generated images, hair follicles as part of a person’s face, etc.</li>\n      <li><strong>VAEs:</strong> Offer a stable training regime and good general-purpose image generation but sometimes lack the sharpness and realism provided by GANs and diffusion models.</li>\n      <li><strong>GANs:</strong> Excel in creating sharp and realistic images but can be challenging to train and may suffer from stability issues.\n  Each of these models has its place in the field of image generation, with the choice depending on factors like desired image quality, training stability, and architectural complexity.</li>\n    </ul>",
      "contentMarkdown": "*   Diffusion models, along with Variational Autoencoders (VAEs) and Generative Adversarial Networks (GANs), are powerful tools in the domain of image generation. Each of these models employs distinct mechanisms and has its strengths and limitations.\n*   **How Diffusion Models Work**\n    *   **Reversible Noising Process:**\n        *   **Forward Process:** Diffusion models work by gradually adding noise to an image (or any data) over a series of steps, transitioning it from the original data distribution to a noise distribution. This process is known as the forward diffusion process.\n        *   **Backward Process:** The model then learns to reverse this process, which is where the actual generative modeling happens. By learning this reverse diffusion process, the model effectively learns to generate data starting from noise.\n    *   **Data Generation:** In the generative phase, the model starts with a sample of random noise and applies the learned reverse transformation to this noise, progressively denoising it to generate a sample of data (e.g., an image).\n    *   **Higher Quality Samples:** Diffusion models are known for generating high-quality samples that are often more realistic and less prone to artifacts compared to other generative models.\n*   **Comparison with VAEs and GANs**\n    *   **Variational Autoencoders (VAEs):**\n        *   **Mechanism:** VAEs consist of an encoder that maps input data to a latent space and a decoder that reconstructs the data from this latent space. The training involves optimizing the reconstruction loss and a regularization term (KL divergence) that keeps the latent space distributions well-behaved.\n        *   **Image Generation:** VAEs are effective for image generation but can sometimes produce blurrier results compared to GANs and diffusion models.\n    *   **Generative Adversarial Networks (GANs):**\n        *   **Mechanism:** GANs involve a generator that creates images and a discriminator that evaluates them. The generator learns to produce increasingly realistic images, while the discriminator improves at distinguishing real images from generated ones.\n        *   **Training Instability:** GANs can generate high-quality, sharp images but are known for their training instability issues, such as mode collapse, where the generator produces a limited variety of outputs.\n        *   **Comparison to Diffusion Models:** Diffusion models, in contrast, generally don’t have these training instabilities and can produce high-quality images, arguably with more consistency than GANs.\n*   **Summary**\n    *   **Diffusion Models:** Known for their ability to generate high-quality images and a more stable training process compared to GANs. They work by reversing a learned noising process and are particularly good at capturing fine details in images such as text in generated images, hair follicles as part of a person’s face, etc.\n    *   **VAEs:** Offer a stable training regime and good general-purpose image generation but sometimes lack the sharpness and realism provided by GANs and diffusion models.\n    *   **GANs:** Excel in creating sharp and realistic images but can be challenging to train and may suffer from stability issues. Each of these models has its place in the field of image generation, with the choice depending on factors like desired image quality, training stability, and architectural complexity.\n\n*   **Reversible Noising Process:**\n    *   **Forward Process:** Diffusion models work by gradually adding noise to an image (or any data) over a series of steps, transitioning it from the original data distribution to a noise distribution. This process is known as the forward diffusion process.\n    *   **Backward Process:** The model then learns to reverse this process, which is where the actual generative modeling happens. By learning this reverse diffusion process, the model effectively learns to generate data starting from noise.\n*   **Data Generation:** In the generative phase, the model starts with a sample of random noise and applies the learned reverse transformation to this noise, progressively denoising it to generate a sample of data (e.g., an image).\n*   **Higher Quality Samples:** Diffusion models are known for generating high-quality samples that are often more realistic and less prone to artifacts compared to other generative models.\n\n*   **Forward Process:** Diffusion models work by gradually adding noise to an image (or any data) over a series of steps, transitioning it from the original data distribution to a noise distribution. This process is known as the forward diffusion process.\n*   **Backward Process:** The model then learns to reverse this process, which is where the actual generative modeling happens. By learning this reverse diffusion process, the model effectively learns to generate data starting from noise.\n\n*   **Variational Autoencoders (VAEs):**\n    *   **Mechanism:** VAEs consist of an encoder that maps input data to a latent space and a decoder that reconstructs the data from this latent space. The training involves optimizing the reconstruction loss and a regularization term (KL divergence) that keeps the latent space distributions well-behaved.\n    *   **Image Generation:** VAEs are effective for image generation but can sometimes produce blurrier results compared to GANs and diffusion models.\n*   **Generative Adversarial Networks (GANs):**\n    *   **Mechanism:** GANs involve a generator that creates images and a discriminator that evaluates them. The generator learns to produce increasingly realistic images, while the discriminator improves at distinguishing real images from generated ones.\n    *   **Training Instability:** GANs can generate high-quality, sharp images but are known for their training instability issues, such as mode collapse, where the generator produces a limited variety of outputs.\n    *   **Comparison to Diffusion Models:** Diffusion models, in contrast, generally don’t have these training instabilities and can produce high-quality images, arguably with more consistency than GANs.\n\n*   **Mechanism:** VAEs consist of an encoder that maps input data to a latent space and a decoder that reconstructs the data from this latent space. The training involves optimizing the reconstruction loss and a regularization term (KL divergence) that keeps the latent space distributions well-behaved.\n*   **Image Generation:** VAEs are effective for image generation but can sometimes produce blurrier results compared to GANs and diffusion models.\n\n*   **Mechanism:** GANs involve a generator that creates images and a discriminator that evaluates them. The generator learns to produce increasingly realistic images, while the discriminator improves at distinguishing real images from generated ones.\n*   **Training Instability:** GANs can generate high-quality, sharp images but are known for their training instability issues, such as mode collapse, where the generator produces a limited variety of outputs.\n*   **Comparison to Diffusion Models:** Diffusion models, in contrast, generally don’t have these training instabilities and can produce high-quality images, arguably with more consistency than GANs.\n\n*   **Diffusion Models:** Known for their ability to generate high-quality images and a more stable training process compared to GANs. They work by reversing a learned noising process and are particularly good at capturing fine details in images such as text in generated images, hair follicles as part of a person’s face, etc.\n*   **VAEs:** Offer a stable training regime and good general-purpose image generation but sometimes lack the sharpness and realism provided by GANs and diffusion models.\n*   **GANs:** Excel in creating sharp and realistic images but can be challenging to train and may suffer from stability issues. Each of these models has its place in the field of image generation, with the choice depending on factors like desired image quality, training stability, and architectural complexity.",
      "order": 106,
      "orderInChapter": 106,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1155,
        "contentLength": 9317
      },
      "nextCards": [
        "ai-interview-what-are-the-loss-functions-used-in-diffusion-mode-107",
        "ai-interview-what-is-the-denoising-score-matching-loss-in-diffu-108"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-regularization-in-decision-trees-13",
        "ai-decision-trees-and-ensemble-methods-summary-of-regularization-parameters-15",
        "ai-decision-trees-and-ensemble-methods-why-are-decision-trees-rarely-used-by-themselves-w-20",
        "ai-decision-trees-and-ensemble-methods-does-boosting-reduce-bias-and-variance-both-compar-24",
        "ai-decision-trees-and-ensemble-methods-is-an-occasional-side-effect-of-boosting-an-increa-28"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#at-a-high-level,-how-do-diffusion-models-work?-what-are-some-other-models-that-are-useful-for-image-generation,-and-how-do-they-compare-to-diffusion-models?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-loss-functions-used-in-diffusion-mode-107",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Loss Functions Used in Diffusion Models?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Diffusion models, which are a type of generative model, use a specific approach to learning that involves gradually adding noise to data and then learning to reverse this process. The loss functions used in diffusion models are designed to facilitate this learning process. The primary loss function used is the denoising score matching loss, often combined with other components depending on the specific type of diffusion model.</li>\n  <li><strong>Denoising Score Matching Loss</strong>\n    <ul>\n      <li>In diffusion models, the training process involves adding noise to the data in small increments over many steps, resulting in a series of noisier and noisier versions of the original data. The model then learns to reverse this process. The key loss function used in this context is the denoising score matching loss, which can be described as follows:\n        <ul>\n          <li><strong>Objective:</strong> The model is trained to predict the noise that was added to the data at each step. Essentially, it learns how to reverse the diffusion process.</li>\n          <li><strong>Implementation:</strong> Mathematically, this can be implemented as a regression problem where the model predicts the noise added to each data point. The loss function then measures the difference between the predicted noise and the actual noise that was added. A common choice for this is the mean squared error (MSE) between these two values.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Variational Lower Bound (ELBO) in Variational Diffusion Models</strong>\n    <ul>\n      <li>Some diffusion models, particularly variational ones, use a loss function derived from the evidence lower bound (ELBO) principle common in variational inference:\n        <ul>\n          <li><strong>Objective:</strong> This loss function aims to maximize the likelihood of the data under the model while regularizing the latent space representations.</li>\n          <li><strong>Components:</strong> The ELBO for diffusion models typically includes terms that represent the reconstruction error (similar to the denoising score matching loss) and terms that regularize the latent space (like KL divergence in VAEs).</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Additional Regularization Terms</strong>\n    <ul>\n      <li>Depending on the specific architecture and objectives of the diffusion model, additional regularization terms might be included:\n        <ul>\n          <li><strong>KL Divergence:</strong> In some models, especially those that involve variational approaches, a KL divergence term can be included to ensure that the learned distributions in the latent space adhere to certain desired properties.</li>\n          <li><strong>Adversarial Loss:</strong> For models that integrate adversarial training principles, an adversarial loss term might be added to encourage the generation of more realistic data.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Summary:</strong> The choice of loss function in diffusion models is closely tied to their unique training process, which involves learning to reverse a controlled noise-adding process. The denoising score matching loss is central to this, often supplemented by other loss components based on variational principles or additional regularization objectives. The combination of these loss functions allows diffusion models to effectively learn the complex process of generating high-quality data from noisy inputs.</li>\n</ul>\n<ul>\n      <li>In diffusion models, the training process involves adding noise to the data in small increments over many steps, resulting in a series of noisier and noisier versions of the original data. The model then learns to reverse this process. The key loss function used in this context is the denoising score matching loss, which can be described as follows:\n        <ul>\n          <li><strong>Objective:</strong> The model is trained to predict the noise that was added to the data at each step. Essentially, it learns how to reverse the diffusion process.</li>\n          <li><strong>Implementation:</strong> Mathematically, this can be implemented as a regression problem where the model predicts the noise added to each data point. The loss function then measures the difference between the predicted noise and the actual noise that was added. A common choice for this is the mean squared error (MSE) between these two values.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Objective:</strong> The model is trained to predict the noise that was added to the data at each step. Essentially, it learns how to reverse the diffusion process.</li>\n          <li><strong>Implementation:</strong> Mathematically, this can be implemented as a regression problem where the model predicts the noise added to each data point. The loss function then measures the difference between the predicted noise and the actual noise that was added. A common choice for this is the mean squared error (MSE) between these two values.</li>\n        </ul>\n<ul>\n      <li>Some diffusion models, particularly variational ones, use a loss function derived from the evidence lower bound (ELBO) principle common in variational inference:\n        <ul>\n          <li><strong>Objective:</strong> This loss function aims to maximize the likelihood of the data under the model while regularizing the latent space representations.</li>\n          <li><strong>Components:</strong> The ELBO for diffusion models typically includes terms that represent the reconstruction error (similar to the denoising score matching loss) and terms that regularize the latent space (like KL divergence in VAEs).</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Objective:</strong> This loss function aims to maximize the likelihood of the data under the model while regularizing the latent space representations.</li>\n          <li><strong>Components:</strong> The ELBO for diffusion models typically includes terms that represent the reconstruction error (similar to the denoising score matching loss) and terms that regularize the latent space (like KL divergence in VAEs).</li>\n        </ul>\n<ul>\n      <li>Depending on the specific architecture and objectives of the diffusion model, additional regularization terms might be included:\n        <ul>\n          <li><strong>KL Divergence:</strong> In some models, especially those that involve variational approaches, a KL divergence term can be included to ensure that the learned distributions in the latent space adhere to certain desired properties.</li>\n          <li><strong>Adversarial Loss:</strong> For models that integrate adversarial training principles, an adversarial loss term might be added to encourage the generation of more realistic data.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>KL Divergence:</strong> In some models, especially those that involve variational approaches, a KL divergence term can be included to ensure that the learned distributions in the latent space adhere to certain desired properties.</li>\n          <li><strong>Adversarial Loss:</strong> For models that integrate adversarial training principles, an adversarial loss term might be added to encourage the generation of more realistic data.</li>\n        </ul>",
      "contentMarkdown": "*   Diffusion models, which are a type of generative model, use a specific approach to learning that involves gradually adding noise to data and then learning to reverse this process. The loss functions used in diffusion models are designed to facilitate this learning process. The primary loss function used is the denoising score matching loss, often combined with other components depending on the specific type of diffusion model.\n*   **Denoising Score Matching Loss**\n    *   In diffusion models, the training process involves adding noise to the data in small increments over many steps, resulting in a series of noisier and noisier versions of the original data. The model then learns to reverse this process. The key loss function used in this context is the denoising score matching loss, which can be described as follows:\n        *   **Objective:** The model is trained to predict the noise that was added to the data at each step. Essentially, it learns how to reverse the diffusion process.\n        *   **Implementation:** Mathematically, this can be implemented as a regression problem where the model predicts the noise added to each data point. The loss function then measures the difference between the predicted noise and the actual noise that was added. A common choice for this is the mean squared error (MSE) between these two values.\n*   **Variational Lower Bound (ELBO) in Variational Diffusion Models**\n    *   Some diffusion models, particularly variational ones, use a loss function derived from the evidence lower bound (ELBO) principle common in variational inference:\n        *   **Objective:** This loss function aims to maximize the likelihood of the data under the model while regularizing the latent space representations.\n        *   **Components:** The ELBO for diffusion models typically includes terms that represent the reconstruction error (similar to the denoising score matching loss) and terms that regularize the latent space (like KL divergence in VAEs).\n*   **Additional Regularization Terms**\n    *   Depending on the specific architecture and objectives of the diffusion model, additional regularization terms might be included:\n        *   **KL Divergence:** In some models, especially those that involve variational approaches, a KL divergence term can be included to ensure that the learned distributions in the latent space adhere to certain desired properties.\n        *   **Adversarial Loss:** For models that integrate adversarial training principles, an adversarial loss term might be added to encourage the generation of more realistic data.\n*   **Summary:** The choice of loss function in diffusion models is closely tied to their unique training process, which involves learning to reverse a controlled noise-adding process. The denoising score matching loss is central to this, often supplemented by other loss components based on variational principles or additional regularization objectives. The combination of these loss functions allows diffusion models to effectively learn the complex process of generating high-quality data from noisy inputs.\n\n*   In diffusion models, the training process involves adding noise to the data in small increments over many steps, resulting in a series of noisier and noisier versions of the original data. The model then learns to reverse this process. The key loss function used in this context is the denoising score matching loss, which can be described as follows:\n    *   **Objective:** The model is trained to predict the noise that was added to the data at each step. Essentially, it learns how to reverse the diffusion process.\n    *   **Implementation:** Mathematically, this can be implemented as a regression problem where the model predicts the noise added to each data point. The loss function then measures the difference between the predicted noise and the actual noise that was added. A common choice for this is the mean squared error (MSE) between these two values.\n\n*   **Objective:** The model is trained to predict the noise that was added to the data at each step. Essentially, it learns how to reverse the diffusion process.\n*   **Implementation:** Mathematically, this can be implemented as a regression problem where the model predicts the noise added to each data point. The loss function then measures the difference between the predicted noise and the actual noise that was added. A common choice for this is the mean squared error (MSE) between these two values.\n\n*   Some diffusion models, particularly variational ones, use a loss function derived from the evidence lower bound (ELBO) principle common in variational inference:\n    *   **Objective:** This loss function aims to maximize the likelihood of the data under the model while regularizing the latent space representations.\n    *   **Components:** The ELBO for diffusion models typically includes terms that represent the reconstruction error (similar to the denoising score matching loss) and terms that regularize the latent space (like KL divergence in VAEs).\n\n*   **Objective:** This loss function aims to maximize the likelihood of the data under the model while regularizing the latent space representations.\n*   **Components:** The ELBO for diffusion models typically includes terms that represent the reconstruction error (similar to the denoising score matching loss) and terms that regularize the latent space (like KL divergence in VAEs).\n\n*   Depending on the specific architecture and objectives of the diffusion model, additional regularization terms might be included:\n    *   **KL Divergence:** In some models, especially those that involve variational approaches, a KL divergence term can be included to ensure that the learned distributions in the latent space adhere to certain desired properties.\n    *   **Adversarial Loss:** For models that integrate adversarial training principles, an adversarial loss term might be added to encourage the generation of more realistic data.\n\n*   **KL Divergence:** In some models, especially those that involve variational approaches, a KL divergence term can be included to ensure that the learned distributions in the latent space adhere to certain desired properties.\n*   **Adversarial Loss:** For models that integrate adversarial training principles, an adversarial loss term might be added to encourage the generation of more realistic data.",
      "order": 107,
      "orderInChapter": 107,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "loss function",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 954,
        "contentLength": 7342
      },
      "nextCards": [
        "ai-interview-what-is-the-denoising-score-matching-loss-in-diffu-108",
        "ai-interview-at-a-high-level-what-is-rlhf-why-is-this-a-novel-p-109"
      ],
      "relatedCards": [
        "ai-diffusion-models-integration-with-mse-46",
        "ai-loss-mean-absolute-error-mae-l1-loss-9",
        "ai-regularization-graphical-treatment-6",
        "ai-regularization-l2l2l2-regularization-weight-shrinkage-ie-uniform--8",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-loss-functions-used-in-diffusion-models?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-denoising-score-matching-loss-in-diffu-108",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Denoising Score Matching Loss in Diffusion Models? Provide Equation and Intuition.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The Denoising Score Matching Loss is a critical component in the training of diffusion models, a class of generative models. This loss function is designed to train the model to effectively reverse a diffusion process, which gradually adds noise to the data over a series of steps.</li>\n  <li><strong>Denoising Score Matching Loss: Equation and Intuition</strong>\n    <ul>\n      <li><strong>Background:</strong>\n        <ul>\n          <li>In diffusion models, the data is incrementally noised over a sequence of steps. The reverse process, which the model learns, involves denoising or reversing this noise addition to recreate the original data from noise.</li>\n          <li><strong>Equation:</strong></li>\n          <li>The denoising score matching loss at a particular timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-128-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-954\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-955\"><span class=\"mi\" id=\"MathJax-Span-956\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-128\">t</script> can be formulated as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-129-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi><mo stretchy=&quot;false&quot;>(</mo><mi>&amp;#x03B8;</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>E</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>&amp;#x03F5;</mi><mo>&amp;#x223C;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi class=&quot;MJX-tex-caligraphic&quot; mathvariant=&quot;script&quot;>N</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo stretchy=&quot;false&quot;>)</mo><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo>[</mo><msup><mrow><mo symmetric=&quot;true&quot;>&amp;#x2016;</mo><mrow><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow><mo>&amp;#x2212;</mo><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></mrow><mo symmetric=&quot;true&quot;>&amp;#x2016;</mo></mrow><mn>2</mn></msup><mo>]</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-957\" style=\"width: 26.878em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 22.398em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(2.034em, 1022.19em, 3.753em, -999.997em); top: -3.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-958\"><span class=\"mi\" id=\"MathJax-Span-959\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-960\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-961\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-962\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-963\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"msubsup\" id=\"MathJax-Span-964\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 4.69em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"texatom\" id=\"MathJax-Span-965\"><span class=\"mrow\" id=\"MathJax-Span-966\"><span class=\"mi\" id=\"MathJax-Span-967\" style=\"font-family: STIXGeneral-Regular;\">𝔼</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.799em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-968\"><span class=\"mrow\" id=\"MathJax-Span-969\"><span class=\"msubsup\" id=\"MathJax-Span-970\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-971\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-972\" style=\"font-size: 50%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-973\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-974\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">ϵ</span><span class=\"mo\" id=\"MathJax-Span-975\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∼</span><span class=\"texatom\" id=\"MathJax-Span-976\"><span class=\"mrow\" id=\"MathJax-Span-977\"><span class=\"mi\" id=\"MathJax-Span-978\" style=\"font-size: 70.7%; font-family: STIXNonUnicode-Italic;\"><span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-979\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-980\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-981\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-982\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">I<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-983\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-984\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-985\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-986\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-987\" style=\"vertical-align: -0.258em;\"><span><span style=\"font-size: 110%; font-family: STIXSizeOneSym;\">[</span></span></span><span class=\"msubsup\" id=\"MathJax-Span-988\"><span style=\"display: inline-block; position: relative; width: 13.596em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1013.02em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-989\"><span class=\"mo\" id=\"MathJax-Span-990\" style=\"vertical-align: 0.784em;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.331em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.122em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-991\"><span class=\"msubsup\" id=\"MathJax-Span-992\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-993\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-994\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-995\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-996\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-997\"><span class=\"msubsup\" id=\"MathJax-Span-998\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-999\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1000\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1001\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1002\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1003\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span class=\"mo\" id=\"MathJax-Span-1004\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-1005\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1006\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1007\"><span class=\"mrow\" id=\"MathJax-Span-1008\"><span class=\"msubsup\" id=\"MathJax-Span-1009\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1010\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1011\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1012\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1013\"></span><span class=\"msubsup\" id=\"MathJax-Span-1014\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1015\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1016\"><span class=\"mrow\" id=\"MathJax-Span-1017\"><span class=\"mi\" id=\"MathJax-Span-1018\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1019\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1020\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1021\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1022\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1023\"><span class=\"msubsup\" id=\"MathJax-Span-1024\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1025\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1026\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1027\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1028\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1029\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1030\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1031\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1032\" style=\"vertical-align: 0.784em;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.331em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.122em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.529em; left: 13.18em;\"><span class=\"mn\" id=\"MathJax-Span-1033\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1034\" style=\"vertical-align: -0.258em;\"><span><span style=\"font-size: 110%; font-family: STIXSizeOneSym;\">]</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 3.18em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.559em; border-left: 0px solid; width: 0px; height: 1.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi><mo stretchy=\"false\">(</mo><mi>θ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow class=\"MJX-TeXAtom-ORD\"><mi mathvariant=\"double-struck\">E</mi></mrow><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>ϵ</mi><mo>∼</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi class=\"MJX-tex-caligraphic\" mathvariant=\"script\">N</mi></mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo stretchy=\"false\">)</mo><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo>[</mo><msup><mrow><mo symmetric=\"true\">‖</mo><mrow><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow><mo>−</mo><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></mrow><mo symmetric=\"true\">‖</mo></mrow><mn>2</mn></msup><mo>]</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-129\">L(\\theta)=\\mathbb{E}_{x_0, \\epsilon \\sim \\mathcal{N}(0, I), t}\\left[\\left\\|s_\\theta\\left(x_t, t\\right)-\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)\\right\\|^2\\right]</script>\n            <ul>\n              <li>where, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-130-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1035\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1036\"><span class=\"msubsup\" id=\"MathJax-Span-1037\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1038\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1039\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-130\">x_0</script> is the original data, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-131-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1040\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1041\"><span class=\"msubsup\" id=\"MathJax-Span-1042\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1043\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1044\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-131\">x_t</script> is the noised data at timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-132-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1045\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1046\"><span class=\"mi\" id=\"MathJax-Span-1047\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-132\">t</script>, and $\\epsilon$ is the added Gaussian noise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-133-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1048\" style=\"width: 3.857em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.18em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.13em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1049\"><span class=\"msubsup\" id=\"MathJax-Span-1050\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1051\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1052\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1053\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1054\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-1055\"><span class=\"msubsup\" id=\"MathJax-Span-1056\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1057\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1058\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1059\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1060\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1061\" style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-133\">s_\\theta\\left(x_t, t\\right)</script> is the score (gradient of the log probability) predicted by the model with parameters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-134-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B8;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1062\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1063\"><span class=\"mi\" id=\"MathJax-Span-1064\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>θ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-134\">\\theta</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-135-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1065\" style=\"width: 9.326em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 7.763em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1007.71em, 2.659em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1066\"><span class=\"msubsup\" id=\"MathJax-Span-1067\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1068\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1069\"><span class=\"mrow\" id=\"MathJax-Span-1070\"><span class=\"msubsup\" id=\"MathJax-Span-1071\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1072\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1073\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1074\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1075\"></span><span class=\"msubsup\" id=\"MathJax-Span-1076\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1077\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1078\"><span class=\"mrow\" id=\"MathJax-Span-1079\"><span class=\"mi\" id=\"MathJax-Span-1080\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1081\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1082\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1083\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1084\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1085\"><span class=\"msubsup\" id=\"MathJax-Span-1086\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1087\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1088\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1089\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1090\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1091\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1092\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1093\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-135\">\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)</script> is the true score, which is the gradient of the log probability of the noised data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-136-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1094\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1095\"><span class=\"msubsup\" id=\"MathJax-Span-1096\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1097\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1098\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-136\">x_t</script> conditioned on the original data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-137-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1099\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1100\"><span class=\"msubsup\" id=\"MathJax-Span-1101\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1102\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1103\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-137\">x_0</script>.</li>\n            </ul>\n          </li>\n          <li><strong>Intuition:</strong>\n            <ul>\n              <li>The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.</li>\n              <li>By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.</li>\n              <li>This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.</li>\n            </ul>\n          </li>\n          <li><strong>Importance in Training:</strong> The denoising score matching loss is crucial for training diffusion models to generate high-quality samples. It ensures that the model learns a detailed and accurate reverse mapping of the diffusion process, capturing the complex data distribution.</li>\n          <li><strong>Advantages:</strong> This approach allows diffusion models to generate samples that are often of higher quality and more diverse compared to other generative models, as it carefully guides the generative process through the learned noise reversal.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>In summary, the denoising score matching loss in diffusion models is fundamental in training these models to effectively reverse the process of gradual noise addition, enabling the generation of high-quality data samples from a noise distribution. This loss function is key to the model’s ability to learn the intricate details of the data distribution and the precise dynamics of the denoising process.</li>\n</ul>\n<ul>\n      <li><strong>Background:</strong>\n        <ul>\n          <li>In diffusion models, the data is incrementally noised over a sequence of steps. The reverse process, which the model learns, involves denoising or reversing this noise addition to recreate the original data from noise.</li>\n          <li><strong>Equation:</strong></li>\n          <li>The denoising score matching loss at a particular timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-128-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-954\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-955\"><span class=\"mi\" id=\"MathJax-Span-956\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-128\">t</script> can be formulated as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-129-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi><mo stretchy=&quot;false&quot;>(</mo><mi>&amp;#x03B8;</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>E</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>&amp;#x03F5;</mi><mo>&amp;#x223C;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi class=&quot;MJX-tex-caligraphic&quot; mathvariant=&quot;script&quot;>N</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo stretchy=&quot;false&quot;>)</mo><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo>[</mo><msup><mrow><mo symmetric=&quot;true&quot;>&amp;#x2016;</mo><mrow><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow><mo>&amp;#x2212;</mo><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></mrow><mo symmetric=&quot;true&quot;>&amp;#x2016;</mo></mrow><mn>2</mn></msup><mo>]</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-957\" style=\"width: 26.878em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 22.398em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(2.034em, 1022.19em, 3.753em, -999.997em); top: -3.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-958\"><span class=\"mi\" id=\"MathJax-Span-959\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-960\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-961\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-962\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-963\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"msubsup\" id=\"MathJax-Span-964\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 4.69em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"texatom\" id=\"MathJax-Span-965\"><span class=\"mrow\" id=\"MathJax-Span-966\"><span class=\"mi\" id=\"MathJax-Span-967\" style=\"font-family: STIXGeneral-Regular;\">𝔼</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.799em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-968\"><span class=\"mrow\" id=\"MathJax-Span-969\"><span class=\"msubsup\" id=\"MathJax-Span-970\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-971\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-972\" style=\"font-size: 50%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-973\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-974\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">ϵ</span><span class=\"mo\" id=\"MathJax-Span-975\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∼</span><span class=\"texatom\" id=\"MathJax-Span-976\"><span class=\"mrow\" id=\"MathJax-Span-977\"><span class=\"mi\" id=\"MathJax-Span-978\" style=\"font-size: 70.7%; font-family: STIXNonUnicode-Italic;\"><span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-979\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-980\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-981\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-982\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">I<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-983\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-984\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-985\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-986\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-987\" style=\"vertical-align: -0.258em;\"><span><span style=\"font-size: 110%; font-family: STIXSizeOneSym;\">[</span></span></span><span class=\"msubsup\" id=\"MathJax-Span-988\"><span style=\"display: inline-block; position: relative; width: 13.596em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1013.02em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-989\"><span class=\"mo\" id=\"MathJax-Span-990\" style=\"vertical-align: 0.784em;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.331em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.122em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-991\"><span class=\"msubsup\" id=\"MathJax-Span-992\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-993\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-994\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-995\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-996\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-997\"><span class=\"msubsup\" id=\"MathJax-Span-998\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-999\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1000\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1001\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1002\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1003\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span class=\"mo\" id=\"MathJax-Span-1004\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-1005\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1006\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1007\"><span class=\"mrow\" id=\"MathJax-Span-1008\"><span class=\"msubsup\" id=\"MathJax-Span-1009\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1010\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1011\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1012\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1013\"></span><span class=\"msubsup\" id=\"MathJax-Span-1014\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1015\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1016\"><span class=\"mrow\" id=\"MathJax-Span-1017\"><span class=\"mi\" id=\"MathJax-Span-1018\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1019\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1020\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1021\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1022\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1023\"><span class=\"msubsup\" id=\"MathJax-Span-1024\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1025\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1026\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1027\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1028\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1029\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1030\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1031\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1032\" style=\"vertical-align: 0.784em;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.331em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.122em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.529em; left: 13.18em;\"><span class=\"mn\" id=\"MathJax-Span-1033\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1034\" style=\"vertical-align: -0.258em;\"><span><span style=\"font-size: 110%; font-family: STIXSizeOneSym;\">]</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 3.18em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.559em; border-left: 0px solid; width: 0px; height: 1.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi><mo stretchy=\"false\">(</mo><mi>θ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow class=\"MJX-TeXAtom-ORD\"><mi mathvariant=\"double-struck\">E</mi></mrow><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>ϵ</mi><mo>∼</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi class=\"MJX-tex-caligraphic\" mathvariant=\"script\">N</mi></mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo stretchy=\"false\">)</mo><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo>[</mo><msup><mrow><mo symmetric=\"true\">‖</mo><mrow><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow><mo>−</mo><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></mrow><mo symmetric=\"true\">‖</mo></mrow><mn>2</mn></msup><mo>]</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-129\">L(\\theta)=\\mathbb{E}_{x_0, \\epsilon \\sim \\mathcal{N}(0, I), t}\\left[\\left\\|s_\\theta\\left(x_t, t\\right)-\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)\\right\\|^2\\right]</script>\n            <ul>\n              <li>where, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-130-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1035\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1036\"><span class=\"msubsup\" id=\"MathJax-Span-1037\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1038\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1039\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-130\">x_0</script> is the original data, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-131-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1040\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1041\"><span class=\"msubsup\" id=\"MathJax-Span-1042\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1043\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1044\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-131\">x_t</script> is the noised data at timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-132-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1045\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1046\"><span class=\"mi\" id=\"MathJax-Span-1047\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-132\">t</script>, and $\\epsilon$ is the added Gaussian noise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-133-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1048\" style=\"width: 3.857em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.18em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.13em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1049\"><span class=\"msubsup\" id=\"MathJax-Span-1050\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1051\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1052\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1053\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1054\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-1055\"><span class=\"msubsup\" id=\"MathJax-Span-1056\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1057\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1058\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1059\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1060\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1061\" style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-133\">s_\\theta\\left(x_t, t\\right)</script> is the score (gradient of the log probability) predicted by the model with parameters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-134-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B8;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1062\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1063\"><span class=\"mi\" id=\"MathJax-Span-1064\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>θ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-134\">\\theta</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-135-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1065\" style=\"width: 9.326em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 7.763em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1007.71em, 2.659em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1066\"><span class=\"msubsup\" id=\"MathJax-Span-1067\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1068\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1069\"><span class=\"mrow\" id=\"MathJax-Span-1070\"><span class=\"msubsup\" id=\"MathJax-Span-1071\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1072\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1073\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1074\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1075\"></span><span class=\"msubsup\" id=\"MathJax-Span-1076\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1077\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1078\"><span class=\"mrow\" id=\"MathJax-Span-1079\"><span class=\"mi\" id=\"MathJax-Span-1080\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1081\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1082\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1083\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1084\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1085\"><span class=\"msubsup\" id=\"MathJax-Span-1086\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1087\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1088\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1089\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1090\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1091\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1092\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1093\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-135\">\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)</script> is the true score, which is the gradient of the log probability of the noised data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-136-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1094\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1095\"><span class=\"msubsup\" id=\"MathJax-Span-1096\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1097\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1098\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-136\">x_t</script> conditioned on the original data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-137-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1099\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1100\"><span class=\"msubsup\" id=\"MathJax-Span-1101\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1102\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1103\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-137\">x_0</script>.</li>\n            </ul>\n          </li>\n          <li><strong>Intuition:</strong>\n            <ul>\n              <li>The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.</li>\n              <li>By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.</li>\n              <li>This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.</li>\n            </ul>\n          </li>\n          <li><strong>Importance in Training:</strong> The denoising score matching loss is crucial for training diffusion models to generate high-quality samples. It ensures that the model learns a detailed and accurate reverse mapping of the diffusion process, capturing the complex data distribution.</li>\n          <li><strong>Advantages:</strong> This approach allows diffusion models to generate samples that are often of higher quality and more diverse compared to other generative models, as it carefully guides the generative process through the learned noise reversal.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>In diffusion models, the data is incrementally noised over a sequence of steps. The reverse process, which the model learns, involves denoising or reversing this noise addition to recreate the original data from noise.</li>\n          <li><strong>Equation:</strong></li>\n          <li>The denoising score matching loss at a particular timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-128-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-954\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-955\"><span class=\"mi\" id=\"MathJax-Span-956\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-128\">t</script> can be formulated as:\n  <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-129-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>L</mi><mo stretchy=&quot;false&quot;>(</mo><mi>&amp;#x03B8;</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;double-struck&quot;>E</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>&amp;#x03F5;</mi><mo>&amp;#x223C;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi class=&quot;MJX-tex-caligraphic&quot; mathvariant=&quot;script&quot;>N</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo stretchy=&quot;false&quot;>)</mo><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo>[</mo><msup><mrow><mo symmetric=&quot;true&quot;>&amp;#x2016;</mo><mrow><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow><mo>&amp;#x2212;</mo><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></mrow><mo symmetric=&quot;true&quot;>&amp;#x2016;</mo></mrow><mn>2</mn></msup><mo>]</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-957\" style=\"width: 26.878em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 22.398em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(2.034em, 1022.19em, 3.753em, -999.997em); top: -3.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-958\"><span class=\"mi\" id=\"MathJax-Span-959\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-960\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-961\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-962\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-963\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"msubsup\" id=\"MathJax-Span-964\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 4.69em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"texatom\" id=\"MathJax-Span-965\"><span class=\"mrow\" id=\"MathJax-Span-966\"><span class=\"mi\" id=\"MathJax-Span-967\" style=\"font-family: STIXGeneral-Regular;\">𝔼</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.799em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-968\"><span class=\"mrow\" id=\"MathJax-Span-969\"><span class=\"msubsup\" id=\"MathJax-Span-970\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-971\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mn\" id=\"MathJax-Span-972\" style=\"font-size: 50%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-973\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-974\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">ϵ</span><span class=\"mo\" id=\"MathJax-Span-975\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∼</span><span class=\"texatom\" id=\"MathJax-Span-976\"><span class=\"mrow\" id=\"MathJax-Span-977\"><span class=\"mi\" id=\"MathJax-Span-978\" style=\"font-size: 70.7%; font-family: STIXNonUnicode-Italic;\"><span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-979\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-980\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span class=\"mo\" id=\"MathJax-Span-981\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-982\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">I<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-983\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-984\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-985\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-986\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-987\" style=\"vertical-align: -0.258em;\"><span><span style=\"font-size: 110%; font-family: STIXSizeOneSym;\">[</span></span></span><span class=\"msubsup\" id=\"MathJax-Span-988\"><span style=\"display: inline-block; position: relative; width: 13.596em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1013.02em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-989\"><span class=\"mo\" id=\"MathJax-Span-990\" style=\"vertical-align: 0.784em;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.331em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.122em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-991\"><span class=\"msubsup\" id=\"MathJax-Span-992\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-993\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-994\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-995\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-996\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-997\"><span class=\"msubsup\" id=\"MathJax-Span-998\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-999\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1000\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1001\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1002\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1003\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span class=\"mo\" id=\"MathJax-Span-1004\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-1005\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1006\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1007\"><span class=\"mrow\" id=\"MathJax-Span-1008\"><span class=\"msubsup\" id=\"MathJax-Span-1009\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1010\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1011\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1012\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1013\"></span><span class=\"msubsup\" id=\"MathJax-Span-1014\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1015\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1016\"><span class=\"mrow\" id=\"MathJax-Span-1017\"><span class=\"mi\" id=\"MathJax-Span-1018\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1019\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1020\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1021\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1022\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1023\"><span class=\"msubsup\" id=\"MathJax-Span-1024\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1025\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1026\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1027\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1028\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1029\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1030\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1031\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1032\" style=\"vertical-align: 0.784em;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.331em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; font-family: STIXGeneral-Regular; top: -3.122em; left: 0em;\">‖<span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.529em; left: 13.18em;\"><span class=\"mn\" id=\"MathJax-Span-1033\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1034\" style=\"vertical-align: -0.258em;\"><span><span style=\"font-size: 110%; font-family: STIXSizeOneSym;\">]</span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 3.18em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.559em; border-left: 0px solid; width: 0px; height: 1.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>L</mi><mo stretchy=\"false\">(</mo><mi>θ</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow class=\"MJX-TeXAtom-ORD\"><mi mathvariant=\"double-struck\">E</mi></mrow><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mn>0</mn></msub><mo>,</mo><mi>ϵ</mi><mo>∼</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi class=\"MJX-tex-caligraphic\" mathvariant=\"script\">N</mi></mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo stretchy=\"false\">)</mo><mo>,</mo><mi>t</mi></mrow></msub><mrow><mo>[</mo><msup><mrow><mo symmetric=\"true\">‖</mo><mrow><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow><mo>−</mo><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></mrow><mo symmetric=\"true\">‖</mo></mrow><mn>2</mn></msup><mo>]</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-129\">L(\\theta)=\\mathbb{E}_{x_0, \\epsilon \\sim \\mathcal{N}(0, I), t}\\left[\\left\\|s_\\theta\\left(x_t, t\\right)-\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)\\right\\|^2\\right]</script>\n            <ul>\n              <li>where, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-130-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1035\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1036\"><span class=\"msubsup\" id=\"MathJax-Span-1037\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1038\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1039\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-130\">x_0</script> is the original data, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-131-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1040\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1041\"><span class=\"msubsup\" id=\"MathJax-Span-1042\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1043\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1044\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-131\">x_t</script> is the noised data at timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-132-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1045\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1046\"><span class=\"mi\" id=\"MathJax-Span-1047\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-132\">t</script>, and $\\epsilon$ is the added Gaussian noise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-133-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1048\" style=\"width: 3.857em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.18em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.13em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1049\"><span class=\"msubsup\" id=\"MathJax-Span-1050\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1051\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1052\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1053\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1054\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-1055\"><span class=\"msubsup\" id=\"MathJax-Span-1056\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1057\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1058\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1059\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1060\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1061\" style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-133\">s_\\theta\\left(x_t, t\\right)</script> is the score (gradient of the log probability) predicted by the model with parameters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-134-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B8;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1062\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1063\"><span class=\"mi\" id=\"MathJax-Span-1064\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>θ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-134\">\\theta</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-135-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1065\" style=\"width: 9.326em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 7.763em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1007.71em, 2.659em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1066\"><span class=\"msubsup\" id=\"MathJax-Span-1067\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1068\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1069\"><span class=\"mrow\" id=\"MathJax-Span-1070\"><span class=\"msubsup\" id=\"MathJax-Span-1071\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1072\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1073\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1074\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1075\"></span><span class=\"msubsup\" id=\"MathJax-Span-1076\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1077\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1078\"><span class=\"mrow\" id=\"MathJax-Span-1079\"><span class=\"mi\" id=\"MathJax-Span-1080\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1081\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1082\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1083\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1084\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1085\"><span class=\"msubsup\" id=\"MathJax-Span-1086\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1087\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1088\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1089\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1090\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1091\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1092\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1093\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-135\">\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)</script> is the true score, which is the gradient of the log probability of the noised data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-136-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1094\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1095\"><span class=\"msubsup\" id=\"MathJax-Span-1096\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1097\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1098\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-136\">x_t</script> conditioned on the original data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-137-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1099\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1100\"><span class=\"msubsup\" id=\"MathJax-Span-1101\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1102\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1103\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-137\">x_0</script>.</li>\n            </ul>\n          </li>\n          <li><strong>Intuition:</strong>\n            <ul>\n              <li>The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.</li>\n              <li>By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.</li>\n              <li>This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.</li>\n            </ul>\n          </li>\n          <li><strong>Importance in Training:</strong> The denoising score matching loss is crucial for training diffusion models to generate high-quality samples. It ensures that the model learns a detailed and accurate reverse mapping of the diffusion process, capturing the complex data distribution.</li>\n          <li><strong>Advantages:</strong> This approach allows diffusion models to generate samples that are often of higher quality and more diverse compared to other generative models, as it carefully guides the generative process through the learned noise reversal.</li>\n        </ul>\n<ul>\n              <li>where, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-130-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1035\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1036\"><span class=\"msubsup\" id=\"MathJax-Span-1037\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1038\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1039\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-130\">x_0</script> is the original data, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-131-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1040\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1041\"><span class=\"msubsup\" id=\"MathJax-Span-1042\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1043\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1044\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-131\">x_t</script> is the noised data at timestep <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-132-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1045\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.513em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1046\"><span class=\"mi\" id=\"MathJax-Span-1047\" style=\"font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>t</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-132\">t</script>, and $\\epsilon$ is the added Gaussian noise.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-133-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>&amp;#x03B8;</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1048\" style=\"width: 3.857em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.18em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1003.13em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1049\"><span class=\"msubsup\" id=\"MathJax-Span-1050\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1051\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1052\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1053\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1054\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mrow\" id=\"MathJax-Span-1055\"><span class=\"msubsup\" id=\"MathJax-Span-1056\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1057\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1058\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1059\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1060\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span class=\"mo\" id=\"MathJax-Span-1061\" style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>θ</mi></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>,</mo><mi>t</mi></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-133\">s_\\theta\\left(x_t, t\\right)</script> is the score (gradient of the log probability) predicted by the model with parameters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-134-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B8;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1062\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1063\"><span class=\"mi\" id=\"MathJax-Span-1064\" style=\"font-family: STIXGeneral-Italic;\">θ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>θ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-134\">\\theta</script>.</li>\n              <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-135-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi mathvariant=&quot;normal&quot;>&amp;#x2207;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>&amp;#x2223;</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>&amp;#x2223;</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1065\" style=\"width: 9.326em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 7.763em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1007.71em, 2.659em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1066\"><span class=\"msubsup\" id=\"MathJax-Span-1067\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1068\" style=\"font-family: STIXGeneral-Regular;\">∇</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.732em;\"><span class=\"texatom\" id=\"MathJax-Span-1069\"><span class=\"mrow\" id=\"MathJax-Span-1070\"><span class=\"msubsup\" id=\"MathJax-Span-1071\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.32em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1072\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.315em;\"><span class=\"mi\" id=\"MathJax-Span-1073\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1074\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1075\"></span><span class=\"msubsup\" id=\"MathJax-Span-1076\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.357em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1077\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-1078\"><span class=\"mrow\" id=\"MathJax-Span-1079\"><span class=\"mi\" id=\"MathJax-Span-1080\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1081\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∣</span><span class=\"mn\" id=\"MathJax-Span-1082\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mrow\" id=\"MathJax-Span-1083\" style=\"padding-left: 0.211em;\"><span class=\"mo\" id=\"MathJax-Span-1084\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-1085\"><span class=\"msubsup\" id=\"MathJax-Span-1086\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1087\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1088\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1089\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">∣</span><span class=\"msubsup\" id=\"MathJax-Span-1090\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1091\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1092\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1093\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi mathvariant=\"normal\">∇</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>x</mi><mi>t</mi></msub></mrow></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mo>∣</mo><mn>0</mn></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∣</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-135\">\\nabla_{x_t} \\log p_{t \\mid 0}\\left(x_t \\mid x_0\\right)</script> is the true score, which is the gradient of the log probability of the noised data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-136-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mi>t</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1094\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.73em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1095\"><span class=\"msubsup\" id=\"MathJax-Span-1096\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1097\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1098\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mi>t</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-136\">x_t</script> conditioned on the original data <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-137-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>x</mi><mn>0</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1099\" style=\"width: 1.096em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.89em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1100\"><span class=\"msubsup\" id=\"MathJax-Span-1101\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1102\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1103\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>x</mi><mn>0</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-137\">x_0</script>.</li>\n            </ul>\n<ul>\n              <li>The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.</li>\n              <li>By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.</li>\n              <li>This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.</li>\n            </ul>",
      "contentMarkdown": "*   The Denoising Score Matching Loss is a critical component in the training of diffusion models, a class of generative models. This loss function is designed to train the model to effectively reverse a diffusion process, which gradually adds noise to the data over a series of steps.\n*   **Denoising Score Matching Loss: Equation and Intuition**\n    *   **Background:**\n        *   In diffusion models, the data is incrementally noised over a sequence of steps. The reverse process, which the model learns, involves denoising or reversing this noise addition to recreate the original data from noise.\n        *   **Equation:**\n        *   The denoising score matching loss at a particular timestep ttt can be formulated as: L(θ)\\=𝔼x0,ϵ∼(0,I),t\\[‖‖sθ(xt,t)−∇xtlogpt∣0(xt∣x0)‖‖2\\]L(θ)\\=Ex0,ϵ∼N(0,I),t\\[‖sθ(xt,t)−∇xtlog⁡pt∣0(xt∣x0)‖2\\]L(\\\\theta)=\\\\mathbb{E}\\_{x\\_0, \\\\epsilon \\\\sim \\\\mathcal{N}(0, I), t}\\\\left\\[\\\\left\\\\|s\\_\\\\theta\\\\left(x\\_t, t\\\\right)-\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right)\\\\right\\\\|^2\\\\right\\]\n            *   where, x0x0x\\_0 is the original data, xtxtx\\_t is the noised data at timestep ttt, and $\\\\epsilon$ is the added Gaussian noise.\n            *   sθ(xt,t)sθ(xt,t)s\\_\\\\theta\\\\left(x\\_t, t\\\\right) is the score (gradient of the log probability) predicted by the model with parameters θθ\\\\theta.\n            *   ∇xtlogpt∣0(xt∣x0)∇xtlog⁡pt∣0(xt∣x0)\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right) is the true score, which is the gradient of the log probability of the noised data xtxtx\\_t conditioned on the original data x0x0x\\_0.\n        *   **Intuition:**\n            *   The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.\n            *   By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.\n            *   This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.\n        *   **Importance in Training:** The denoising score matching loss is crucial for training diffusion models to generate high-quality samples. It ensures that the model learns a detailed and accurate reverse mapping of the diffusion process, capturing the complex data distribution.\n        *   **Advantages:** This approach allows diffusion models to generate samples that are often of higher quality and more diverse compared to other generative models, as it carefully guides the generative process through the learned noise reversal.\n*   In summary, the denoising score matching loss in diffusion models is fundamental in training these models to effectively reverse the process of gradual noise addition, enabling the generation of high-quality data samples from a noise distribution. This loss function is key to the model’s ability to learn the intricate details of the data distribution and the precise dynamics of the denoising process.\n\n*   **Background:**\n    *   In diffusion models, the data is incrementally noised over a sequence of steps. The reverse process, which the model learns, involves denoising or reversing this noise addition to recreate the original data from noise.\n    *   **Equation:**\n    *   The denoising score matching loss at a particular timestep ttt can be formulated as: L(θ)\\=𝔼x0,ϵ∼(0,I),t\\[‖‖sθ(xt,t)−∇xtlogpt∣0(xt∣x0)‖‖2\\]L(θ)\\=Ex0,ϵ∼N(0,I),t\\[‖sθ(xt,t)−∇xtlog⁡pt∣0(xt∣x0)‖2\\]L(\\\\theta)=\\\\mathbb{E}\\_{x\\_0, \\\\epsilon \\\\sim \\\\mathcal{N}(0, I), t}\\\\left\\[\\\\left\\\\|s\\_\\\\theta\\\\left(x\\_t, t\\\\right)-\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right)\\\\right\\\\|^2\\\\right\\]\n        *   where, x0x0x\\_0 is the original data, xtxtx\\_t is the noised data at timestep ttt, and $\\\\epsilon$ is the added Gaussian noise.\n        *   sθ(xt,t)sθ(xt,t)s\\_\\\\theta\\\\left(x\\_t, t\\\\right) is the score (gradient of the log probability) predicted by the model with parameters θθ\\\\theta.\n        *   ∇xtlogpt∣0(xt∣x0)∇xtlog⁡pt∣0(xt∣x0)\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right) is the true score, which is the gradient of the log probability of the noised data xtxtx\\_t conditioned on the original data x0x0x\\_0.\n    *   **Intuition:**\n        *   The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.\n        *   By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.\n        *   This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.\n    *   **Importance in Training:** The denoising score matching loss is crucial for training diffusion models to generate high-quality samples. It ensures that the model learns a detailed and accurate reverse mapping of the diffusion process, capturing the complex data distribution.\n    *   **Advantages:** This approach allows diffusion models to generate samples that are often of higher quality and more diverse compared to other generative models, as it carefully guides the generative process through the learned noise reversal.\n\n*   In diffusion models, the data is incrementally noised over a sequence of steps. The reverse process, which the model learns, involves denoising or reversing this noise addition to recreate the original data from noise.\n*   **Equation:**\n*   The denoising score matching loss at a particular timestep ttt can be formulated as: L(θ)\\=𝔼x0,ϵ∼(0,I),t\\[‖‖sθ(xt,t)−∇xtlogpt∣0(xt∣x0)‖‖2\\]L(θ)\\=Ex0,ϵ∼N(0,I),t\\[‖sθ(xt,t)−∇xtlog⁡pt∣0(xt∣x0)‖2\\]L(\\\\theta)=\\\\mathbb{E}\\_{x\\_0, \\\\epsilon \\\\sim \\\\mathcal{N}(0, I), t}\\\\left\\[\\\\left\\\\|s\\_\\\\theta\\\\left(x\\_t, t\\\\right)-\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right)\\\\right\\\\|^2\\\\right\\]\n    *   where, x0x0x\\_0 is the original data, xtxtx\\_t is the noised data at timestep ttt, and $\\\\epsilon$ is the added Gaussian noise.\n    *   sθ(xt,t)sθ(xt,t)s\\_\\\\theta\\\\left(x\\_t, t\\\\right) is the score (gradient of the log probability) predicted by the model with parameters θθ\\\\theta.\n    *   ∇xtlogpt∣0(xt∣x0)∇xtlog⁡pt∣0(xt∣x0)\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right) is the true score, which is the gradient of the log probability of the noised data xtxtx\\_t conditioned on the original data x0x0x\\_0.\n*   **Intuition:**\n    *   The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.\n    *   By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.\n    *   This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.\n*   **Importance in Training:** The denoising score matching loss is crucial for training diffusion models to generate high-quality samples. It ensures that the model learns a detailed and accurate reverse mapping of the diffusion process, capturing the complex data distribution.\n*   **Advantages:** This approach allows diffusion models to generate samples that are often of higher quality and more diverse compared to other generative models, as it carefully guides the generative process through the learned noise reversal.\n\n*   where, x0x0x\\_0 is the original data, xtxtx\\_t is the noised data at timestep ttt, and $\\\\epsilon$ is the added Gaussian noise.\n*   sθ(xt,t)sθ(xt,t)s\\_\\\\theta\\\\left(x\\_t, t\\\\right) is the score (gradient of the log probability) predicted by the model with parameters θθ\\\\theta.\n*   ∇xtlogpt∣0(xt∣x0)∇xtlog⁡pt∣0(xt∣x0)\\\\nabla\\_{x\\_t} \\\\log p\\_{t \\\\mid 0}\\\\left(x\\_t \\\\mid x\\_0\\\\right) is the true score, which is the gradient of the log probability of the noised data xtxtx\\_t conditioned on the original data x0x0x\\_0.\n\n*   The loss function encourages the model to predict the gradient of the log probability of the noised data with respect to the data itself. Essentially, it’s training the model to estimate how to reverse the diffusion process at each step.\n*   By minimizing this loss, the model learns to approximate the reverse of the noising process, thereby learning to generate data starting from noise.\n*   This process effectively teaches the model the denoising direction at each step of the noised data, guiding it on how to gradually remove noise and reconstruct the original data.",
      "order": 108,
      "orderInChapter": 108,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "gpt",
        "loss function"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 1216,
        "contentLength": 146802
      },
      "nextCards": [
        "ai-interview-at-a-high-level-what-is-rlhf-why-is-this-a-novel-p-109",
        "ai-interview-can-you-please-describe-the-structure-of-cnns-the--110"
      ],
      "relatedCards": [
        "ai-diffusion-models-what-is-the-denoising-score-matching-loss-in-diffu-47",
        "ai-gpt4o-native-image-generation-loss-function-for-windowed-denoising-26",
        "ai-mixture-of-experts-cumo-scaling-multimodal-llm-with-co-upcycled-mixtu-85",
        "ai-LLM-as-a-judge-prometheus-vision-fine-grained-multimodal-evaluati-38",
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-denoising-score-matching-loss-in-diffusion-models?-provide-equation-and-intuition.",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-at-a-high-level-what-is-rlhf-why-is-this-a-novel-p-109",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "At a High Level, What is RLHF? Why is This a Novel Paradigm Compared To, for Example, Self-supervised Learning on an Uncurated Text Corpus? What Does Alignment Mean in the Context of LLMs?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>RLHF, short for Reinforcement Learning from Human Feedback, is an advanced machine learning paradigm that significantly differs from traditional training methods like using uncurated text corpora. This approach is particularly relevant in the context of training language models, where aligning the model’s output with human values and preferences is crucial.</li>\n  <li><strong>High-Level Overview of RLHF</strong>\n    <ul>\n      <li><strong>Integration of Human Feedback:</strong> RLHF involves training models, particularly reinforcement learning models, using feedback derived from human interactions or evaluations. Instead of solely relying on pre-existing datasets or unstructured text, RLHF utilizes human-generated feedback to guide the learning process.</li>\n      <li><strong>Fine-Tuning on Human Rankings:</strong>\n        <ul>\n          <li>In this approach, the model is fine-tuned based on human judgments or rankings of its outputs. For example, humans may evaluate a set of responses or actions generated by the model and rank them according to their relevance, quality, or alignment with specific criteria.</li>\n          <li>The model then uses these rankings to adjust its parameters, essentially learning to prefer actions or outputs that are more highly ranked by humans.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Novelty and Advantages of RLHF Compared to Uncurated Text Corpora</strong>\n    <ul>\n      <li><strong>Better Human Alignment:</strong>\n        <ul>\n          <li>RLHF allows for the creation of models that are better aligned with human values, preferences, and nuances of judgment; for e.g., safe, helpful, adheres to guidelines and constraints. This is particularly important in applications where ethical, cultural, or subjective considerations play a significant role.</li>\n          <li>Traditional models trained on uncurated text corpora may inadvertently learn and amplify biases, inaccuracies, or undesirable behaviors present in the training data.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Customized and Targeted Learning:</strong>\n      - With RLHF, the learning process is more targeted and customized to specific goals or standards set by humans. This is in contrast to the more generalized learning from uncurated corpora, which might not be tailored to specific use-cases or quality standards.</li>\n  <li><strong>Improved Performance in Complex Tasks:</strong>\n      - RLHF can lead to improved performance in complex tasks, especially those that require understanding of context, subtlety, and nuances that are not easily captured by standard datasets but are understandable to humans.</li>\n  <li><strong>Flexibility and Adaptability:</strong>\n      - This approach offers flexibility, as the criteria for human feedback can be adjusted based on the desired outcome. It allows the model to adapt to evolving standards or preferences over time.</li>\n  <li><strong>Conclusion</strong> RLHF represents a novel paradigm in machine learning by directly incorporating human feedback into the training process. This method addresses some of the limitations of training on unstructured text corpora, particularly in terms of aligning AI behavior with human values and expectations. By fine-tuning models based on human rankings and feedback, RLHF fosters the development of AI systems that are not only technically proficient but also ethically and contextually aware, catering to more nuanced and human-centric applications.</li>\n</ul>\n<ul>\n      <li><strong>Integration of Human Feedback:</strong> RLHF involves training models, particularly reinforcement learning models, using feedback derived from human interactions or evaluations. Instead of solely relying on pre-existing datasets or unstructured text, RLHF utilizes human-generated feedback to guide the learning process.</li>\n      <li><strong>Fine-Tuning on Human Rankings:</strong>\n        <ul>\n          <li>In this approach, the model is fine-tuned based on human judgments or rankings of its outputs. For example, humans may evaluate a set of responses or actions generated by the model and rank them according to their relevance, quality, or alignment with specific criteria.</li>\n          <li>The model then uses these rankings to adjust its parameters, essentially learning to prefer actions or outputs that are more highly ranked by humans.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>In this approach, the model is fine-tuned based on human judgments or rankings of its outputs. For example, humans may evaluate a set of responses or actions generated by the model and rank them according to their relevance, quality, or alignment with specific criteria.</li>\n          <li>The model then uses these rankings to adjust its parameters, essentially learning to prefer actions or outputs that are more highly ranked by humans.</li>\n        </ul>\n<ul>\n      <li><strong>Better Human Alignment:</strong>\n        <ul>\n          <li>RLHF allows for the creation of models that are better aligned with human values, preferences, and nuances of judgment; for e.g., safe, helpful, adheres to guidelines and constraints. This is particularly important in applications where ethical, cultural, or subjective considerations play a significant role.</li>\n          <li>Traditional models trained on uncurated text corpora may inadvertently learn and amplify biases, inaccuracies, or undesirable behaviors present in the training data.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>RLHF allows for the creation of models that are better aligned with human values, preferences, and nuances of judgment; for e.g., safe, helpful, adheres to guidelines and constraints. This is particularly important in applications where ethical, cultural, or subjective considerations play a significant role.</li>\n          <li>Traditional models trained on uncurated text corpora may inadvertently learn and amplify biases, inaccuracies, or undesirable behaviors present in the training data.</li>\n        </ul>",
      "contentMarkdown": "*   RLHF, short for Reinforcement Learning from Human Feedback, is an advanced machine learning paradigm that significantly differs from traditional training methods like using uncurated text corpora. This approach is particularly relevant in the context of training language models, where aligning the model’s output with human values and preferences is crucial.\n*   **High-Level Overview of RLHF**\n    *   **Integration of Human Feedback:** RLHF involves training models, particularly reinforcement learning models, using feedback derived from human interactions or evaluations. Instead of solely relying on pre-existing datasets or unstructured text, RLHF utilizes human-generated feedback to guide the learning process.\n    *   **Fine-Tuning on Human Rankings:**\n        *   In this approach, the model is fine-tuned based on human judgments or rankings of its outputs. For example, humans may evaluate a set of responses or actions generated by the model and rank them according to their relevance, quality, or alignment with specific criteria.\n        *   The model then uses these rankings to adjust its parameters, essentially learning to prefer actions or outputs that are more highly ranked by humans.\n*   **Novelty and Advantages of RLHF Compared to Uncurated Text Corpora**\n    *   **Better Human Alignment:**\n        *   RLHF allows for the creation of models that are better aligned with human values, preferences, and nuances of judgment; for e.g., safe, helpful, adheres to guidelines and constraints. This is particularly important in applications where ethical, cultural, or subjective considerations play a significant role.\n        *   Traditional models trained on uncurated text corpora may inadvertently learn and amplify biases, inaccuracies, or undesirable behaviors present in the training data.\n*   **Customized and Targeted Learning:** - With RLHF, the learning process is more targeted and customized to specific goals or standards set by humans. This is in contrast to the more generalized learning from uncurated corpora, which might not be tailored to specific use-cases or quality standards.\n*   **Improved Performance in Complex Tasks:** - RLHF can lead to improved performance in complex tasks, especially those that require understanding of context, subtlety, and nuances that are not easily captured by standard datasets but are understandable to humans.\n*   **Flexibility and Adaptability:** - This approach offers flexibility, as the criteria for human feedback can be adjusted based on the desired outcome. It allows the model to adapt to evolving standards or preferences over time.\n*   **Conclusion** RLHF represents a novel paradigm in machine learning by directly incorporating human feedback into the training process. This method addresses some of the limitations of training on unstructured text corpora, particularly in terms of aligning AI behavior with human values and expectations. By fine-tuning models based on human rankings and feedback, RLHF fosters the development of AI systems that are not only technically proficient but also ethically and contextually aware, catering to more nuanced and human-centric applications.\n\n*   **Integration of Human Feedback:** RLHF involves training models, particularly reinforcement learning models, using feedback derived from human interactions or evaluations. Instead of solely relying on pre-existing datasets or unstructured text, RLHF utilizes human-generated feedback to guide the learning process.\n*   **Fine-Tuning on Human Rankings:**\n    *   In this approach, the model is fine-tuned based on human judgments or rankings of its outputs. For example, humans may evaluate a set of responses or actions generated by the model and rank them according to their relevance, quality, or alignment with specific criteria.\n    *   The model then uses these rankings to adjust its parameters, essentially learning to prefer actions or outputs that are more highly ranked by humans.\n\n*   In this approach, the model is fine-tuned based on human judgments or rankings of its outputs. For example, humans may evaluate a set of responses or actions generated by the model and rank them according to their relevance, quality, or alignment with specific criteria.\n*   The model then uses these rankings to adjust its parameters, essentially learning to prefer actions or outputs that are more highly ranked by humans.\n\n*   **Better Human Alignment:**\n    *   RLHF allows for the creation of models that are better aligned with human values, preferences, and nuances of judgment; for e.g., safe, helpful, adheres to guidelines and constraints. This is particularly important in applications where ethical, cultural, or subjective considerations play a significant role.\n    *   Traditional models trained on uncurated text corpora may inadvertently learn and amplify biases, inaccuracies, or undesirable behaviors present in the training data.\n\n*   RLHF allows for the creation of models that are better aligned with human values, preferences, and nuances of judgment; for e.g., safe, helpful, adheres to guidelines and constraints. This is particularly important in applications where ethical, cultural, or subjective considerations play a significant role.\n*   Traditional models trained on uncurated text corpora may inadvertently learn and amplify biases, inaccuracies, or undesirable behaviors present in the training data.",
      "order": 109,
      "orderInChapter": 109,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "machine learning",
        "reinforcement learning",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 780,
        "contentLength": 6078
      },
      "nextCards": [
        "ai-interview-can-you-please-describe-the-structure-of-cnns-the--110",
        "ai-interview-what-are-some-differences-between-a-cnn-and-a-fcnn-111"
      ],
      "relatedCards": [
        "ai-top-30-papers-machine-super-intelligence-24",
        "ai-reinforcement-learning-value-based-methods-9",
        "ai-agentic-RL-key-equations-19",
        "ai-agentic-RL-practical-engineering-for-stable-multi-turn-tir-62",
        "ai-agentic-RL-scaling-tool-integrated-rl-from-base-models-63"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#at-a-high-level,-what-is-rlhf?-why-is-this-a-novel-paradigm-compared-to,-for-example,-self-supervised-learning-on-an-uncurated-text-corpus?-what-does-alignment-mean-in-the-context-of-llms?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-please-describe-the-structure-of-cnns-the--110",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Please Describe the Structure of CNNs? the Different Layers, Activation Functions? What are Some Key Properties of Activation Functions?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Convolutional Neural Networks (CNNs) are a class of deep neural networks widely used in processing data with a grid-like topology, such as images. They are known for their ability to detect hierarchical patterns in data. Here’s an overview of their structure, including layers and activation functions:</li>\n  <li><strong>Structure of CNNs</strong>\n    <ul>\n      <li><strong>Convolutional Layers:</strong> These layers apply a set of learnable filters (kernels) to the input. Each filter convolves across the width and height of the input volume, computing the dot product between the filter and input, producing a 2D activation map.</li>\n      <li><strong>Key Property:</strong> Convolutional layers are adept at capturing spatial hierarchies in images by learning from local regions (like edges, textures) in the early layers and more complex patterns (like objects, shapes) in deeper layers.</li>\n      <li><strong>Pooling Layers:</strong> Often placed after convolutional layers, pooling layers (such as max pooling or average pooling) reduce the spatial dimensions (width and height) of the input volume, leading to a reduction in the number of parameters and computation in the network.\n  Key Property: Pooling helps in making the detection of features invariant to scale and orientation changes.</li>\n      <li><strong>Fully Connected Layers:</strong> At the end of the network, one or more fully connected layers are used where each neuron is connected to all neurons in the previous layer. These layers are typically used for classifying the features learned by the convolutional layers into different classes.</li>\n      <li><strong>Key Property:</strong> Fully connected layers combine features to make final predictions.</li>\n      <li><strong>Dropout:</strong> Dropout is a regularization technique used in CNNs to prevent overfitting. It randomly “drops” a subset of neurons in a layer during training, forcing the network to learn redundant representations and enhancing its generalization capabilities.</li>\n      <li><strong>Batch Normalization:</strong> Batch normalization is a technique to stabilize and accelerate the training of deep networks. It normalizes the activations of a previous layer at each batch, i.e., it applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.</li>\n    </ul>\n  </li>\n  <li><strong>Activation Functions</strong>\n    <ul>\n      <li><strong>1. ReLU (Rectified Linear Unit):</strong>\n        <ul>\n          <li><strong>Formula:</strong> $f(x)=\\max (0, x)$</li>\n          <li><strong>Properties:</strong> Non-linear, allows models to account for complex data patterns; simple and efficient in computation.</li>\n          <li>Variants like Leaky ReLU or Parametric ReLU are used to address the “dying ReLU” problem where neurons can become inactive and stop contributing to the learning process.</li>\n        </ul>\n      </li>\n      <li><strong>2. Sigmoid:</strong>\n        <ul>\n          <li><strong>Formula:</strong> $\\sigma(x)=\\frac{1}{1+e^{-x}}$</li>\n          <li><strong>Properties:</strong> Smooth gradient, squashing values into a range between 0 and 1 . It’s often used in the output layer for binary classification.</li>\n        </ul>\n      </li>\n      <li><strong>3. Tanh (Hyperbolic Tangent):</strong>\n        <ul>\n          <li><strong>Formula:</strong> $\\tanh (x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}$</li>\n          <li><strong>Properties:</strong> Similar to sigmoid but squashes values into a range between -1 and 1 . It is zerocentered, making it easier to model inputs that have strongly negative, neutral, and strongly positive values.</li>\n        </ul>\n      </li>\n      <li><strong>Softmax:</strong> Used in the output layer of a CNN for multi-class classification; it turns logits into probabilities that sum to one.\n        <ul>\n          <li><strong>Properties:</strong> Softmax is non-linear and is able to handle multiple classes in a mutually exclusive scenario.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Key Properties of Activation Functions</strong>\n    <ul>\n      <li><strong>Nonlinearity:</strong> This allows CNNs to capture complex relationships in data. Without nonlinearity, the network would behave like a linear model.</li>\n      <li><strong>Differentiability:</strong> Essential for enabling backpropagation where gradients are computed during training.</li>\n      <li><strong>Computational Efficiency:</strong> Faster activation functions (like ReLU) lead to quicker training.</li>\n    </ul>\n  </li>\n  <li>In summary, the structure of CNNs, characterized by alternating convolutional and pooling layers followed by fully connected layers, combined with dropout for regularization and batch normalization for faster training, is optimized for feature detection and classification. The choice of activation function, critical for introducing nonlinearity, depends on the specific requirements of the task and the network architecture.</li>\n</ul>\n<ul>\n      <li><strong>Convolutional Layers:</strong> These layers apply a set of learnable filters (kernels) to the input. Each filter convolves across the width and height of the input volume, computing the dot product between the filter and input, producing a 2D activation map.</li>\n      <li><strong>Key Property:</strong> Convolutional layers are adept at capturing spatial hierarchies in images by learning from local regions (like edges, textures) in the early layers and more complex patterns (like objects, shapes) in deeper layers.</li>\n      <li><strong>Pooling Layers:</strong> Often placed after convolutional layers, pooling layers (such as max pooling or average pooling) reduce the spatial dimensions (width and height) of the input volume, leading to a reduction in the number of parameters and computation in the network.\n  Key Property: Pooling helps in making the detection of features invariant to scale and orientation changes.</li>\n      <li><strong>Fully Connected Layers:</strong> At the end of the network, one or more fully connected layers are used where each neuron is connected to all neurons in the previous layer. These layers are typically used for classifying the features learned by the convolutional layers into different classes.</li>\n      <li><strong>Key Property:</strong> Fully connected layers combine features to make final predictions.</li>\n      <li><strong>Dropout:</strong> Dropout is a regularization technique used in CNNs to prevent overfitting. It randomly “drops” a subset of neurons in a layer during training, forcing the network to learn redundant representations and enhancing its generalization capabilities.</li>\n      <li><strong>Batch Normalization:</strong> Batch normalization is a technique to stabilize and accelerate the training of deep networks. It normalizes the activations of a previous layer at each batch, i.e., it applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.</li>\n    </ul>\n<ul>\n      <li><strong>1. ReLU (Rectified Linear Unit):</strong>\n        <ul>\n          <li><strong>Formula:</strong> $f(x)=\\max (0, x)$</li>\n          <li><strong>Properties:</strong> Non-linear, allows models to account for complex data patterns; simple and efficient in computation.</li>\n          <li>Variants like Leaky ReLU or Parametric ReLU are used to address the “dying ReLU” problem where neurons can become inactive and stop contributing to the learning process.</li>\n        </ul>\n      </li>\n      <li><strong>2. Sigmoid:</strong>\n        <ul>\n          <li><strong>Formula:</strong> $\\sigma(x)=\\frac{1}{1+e^{-x}}$</li>\n          <li><strong>Properties:</strong> Smooth gradient, squashing values into a range between 0 and 1 . It’s often used in the output layer for binary classification.</li>\n        </ul>\n      </li>\n      <li><strong>3. Tanh (Hyperbolic Tangent):</strong>\n        <ul>\n          <li><strong>Formula:</strong> $\\tanh (x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}$</li>\n          <li><strong>Properties:</strong> Similar to sigmoid but squashes values into a range between -1 and 1 . It is zerocentered, making it easier to model inputs that have strongly negative, neutral, and strongly positive values.</li>\n        </ul>\n      </li>\n      <li><strong>Softmax:</strong> Used in the output layer of a CNN for multi-class classification; it turns logits into probabilities that sum to one.\n        <ul>\n          <li><strong>Properties:</strong> Softmax is non-linear and is able to handle multiple classes in a mutually exclusive scenario.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Formula:</strong> $f(x)=\\max (0, x)$</li>\n          <li><strong>Properties:</strong> Non-linear, allows models to account for complex data patterns; simple and efficient in computation.</li>\n          <li>Variants like Leaky ReLU or Parametric ReLU are used to address the “dying ReLU” problem where neurons can become inactive and stop contributing to the learning process.</li>\n        </ul>\n<ul>\n          <li><strong>Formula:</strong> $\\sigma(x)=\\frac{1}{1+e^{-x}}$</li>\n          <li><strong>Properties:</strong> Smooth gradient, squashing values into a range between 0 and 1 . It’s often used in the output layer for binary classification.</li>\n        </ul>\n<ul>\n          <li><strong>Formula:</strong> $\\tanh (x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}$</li>\n          <li><strong>Properties:</strong> Similar to sigmoid but squashes values into a range between -1 and 1 . It is zerocentered, making it easier to model inputs that have strongly negative, neutral, and strongly positive values.</li>\n        </ul>\n<ul>\n          <li><strong>Properties:</strong> Softmax is non-linear and is able to handle multiple classes in a mutually exclusive scenario.</li>\n        </ul>\n<ul>\n      <li><strong>Nonlinearity:</strong> This allows CNNs to capture complex relationships in data. Without nonlinearity, the network would behave like a linear model.</li>\n      <li><strong>Differentiability:</strong> Essential for enabling backpropagation where gradients are computed during training.</li>\n      <li><strong>Computational Efficiency:</strong> Faster activation functions (like ReLU) lead to quicker training.</li>\n    </ul>",
      "contentMarkdown": "*   Convolutional Neural Networks (CNNs) are a class of deep neural networks widely used in processing data with a grid-like topology, such as images. They are known for their ability to detect hierarchical patterns in data. Here’s an overview of their structure, including layers and activation functions:\n*   **Structure of CNNs**\n    *   **Convolutional Layers:** These layers apply a set of learnable filters (kernels) to the input. Each filter convolves across the width and height of the input volume, computing the dot product between the filter and input, producing a 2D activation map.\n    *   **Key Property:** Convolutional layers are adept at capturing spatial hierarchies in images by learning from local regions (like edges, textures) in the early layers and more complex patterns (like objects, shapes) in deeper layers.\n    *   **Pooling Layers:** Often placed after convolutional layers, pooling layers (such as max pooling or average pooling) reduce the spatial dimensions (width and height) of the input volume, leading to a reduction in the number of parameters and computation in the network. Key Property: Pooling helps in making the detection of features invariant to scale and orientation changes.\n    *   **Fully Connected Layers:** At the end of the network, one or more fully connected layers are used where each neuron is connected to all neurons in the previous layer. These layers are typically used for classifying the features learned by the convolutional layers into different classes.\n    *   **Key Property:** Fully connected layers combine features to make final predictions.\n    *   **Dropout:** Dropout is a regularization technique used in CNNs to prevent overfitting. It randomly “drops” a subset of neurons in a layer during training, forcing the network to learn redundant representations and enhancing its generalization capabilities.\n    *   **Batch Normalization:** Batch normalization is a technique to stabilize and accelerate the training of deep networks. It normalizes the activations of a previous layer at each batch, i.e., it applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.\n*   **Activation Functions**\n    *   **1\\. ReLU (Rectified Linear Unit):**\n        *   **Formula:** $f(x)=\\\\max (0, x)$\n        *   **Properties:** Non-linear, allows models to account for complex data patterns; simple and efficient in computation.\n        *   Variants like Leaky ReLU or Parametric ReLU are used to address the “dying ReLU” problem where neurons can become inactive and stop contributing to the learning process.\n    *   **2\\. Sigmoid:**\n        *   **Formula:** $\\\\sigma(x)=\\\\frac{1}{1+e^{-x}}$\n        *   **Properties:** Smooth gradient, squashing values into a range between 0 and 1 . It’s often used in the output layer for binary classification.\n    *   **3\\. Tanh (Hyperbolic Tangent):**\n        *   **Formula:** $\\\\tanh (x)=\\\\frac{e^x-e^{-x}}{e^x+e^{-x}}$\n        *   **Properties:** Similar to sigmoid but squashes values into a range between -1 and 1 . It is zerocentered, making it easier to model inputs that have strongly negative, neutral, and strongly positive values.\n    *   **Softmax:** Used in the output layer of a CNN for multi-class classification; it turns logits into probabilities that sum to one.\n        *   **Properties:** Softmax is non-linear and is able to handle multiple classes in a mutually exclusive scenario.\n*   **Key Properties of Activation Functions**\n    *   **Nonlinearity:** This allows CNNs to capture complex relationships in data. Without nonlinearity, the network would behave like a linear model.\n    *   **Differentiability:** Essential for enabling backpropagation where gradients are computed during training.\n    *   **Computational Efficiency:** Faster activation functions (like ReLU) lead to quicker training.\n*   In summary, the structure of CNNs, characterized by alternating convolutional and pooling layers followed by fully connected layers, combined with dropout for regularization and batch normalization for faster training, is optimized for feature detection and classification. The choice of activation function, critical for introducing nonlinearity, depends on the specific requirements of the task and the network architecture.\n\n*   **Convolutional Layers:** These layers apply a set of learnable filters (kernels) to the input. Each filter convolves across the width and height of the input volume, computing the dot product between the filter and input, producing a 2D activation map.\n*   **Key Property:** Convolutional layers are adept at capturing spatial hierarchies in images by learning from local regions (like edges, textures) in the early layers and more complex patterns (like objects, shapes) in deeper layers.\n*   **Pooling Layers:** Often placed after convolutional layers, pooling layers (such as max pooling or average pooling) reduce the spatial dimensions (width and height) of the input volume, leading to a reduction in the number of parameters and computation in the network. Key Property: Pooling helps in making the detection of features invariant to scale and orientation changes.\n*   **Fully Connected Layers:** At the end of the network, one or more fully connected layers are used where each neuron is connected to all neurons in the previous layer. These layers are typically used for classifying the features learned by the convolutional layers into different classes.\n*   **Key Property:** Fully connected layers combine features to make final predictions.\n*   **Dropout:** Dropout is a regularization technique used in CNNs to prevent overfitting. It randomly “drops” a subset of neurons in a layer during training, forcing the network to learn redundant representations and enhancing its generalization capabilities.\n*   **Batch Normalization:** Batch normalization is a technique to stabilize and accelerate the training of deep networks. It normalizes the activations of a previous layer at each batch, i.e., it applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.\n\n*   **1\\. ReLU (Rectified Linear Unit):**\n    *   **Formula:** $f(x)=\\\\max (0, x)$\n    *   **Properties:** Non-linear, allows models to account for complex data patterns; simple and efficient in computation.\n    *   Variants like Leaky ReLU or Parametric ReLU are used to address the “dying ReLU” problem where neurons can become inactive and stop contributing to the learning process.\n*   **2\\. Sigmoid:**\n    *   **Formula:** $\\\\sigma(x)=\\\\frac{1}{1+e^{-x}}$\n    *   **Properties:** Smooth gradient, squashing values into a range between 0 and 1 . It’s often used in the output layer for binary classification.\n*   **3\\. Tanh (Hyperbolic Tangent):**\n    *   **Formula:** $\\\\tanh (x)=\\\\frac{e^x-e^{-x}}{e^x+e^{-x}}$\n    *   **Properties:** Similar to sigmoid but squashes values into a range between -1 and 1 . It is zerocentered, making it easier to model inputs that have strongly negative, neutral, and strongly positive values.\n*   **Softmax:** Used in the output layer of a CNN for multi-class classification; it turns logits into probabilities that sum to one.\n    *   **Properties:** Softmax is non-linear and is able to handle multiple classes in a mutually exclusive scenario.\n\n*   **Formula:** $f(x)=\\\\max (0, x)$\n*   **Properties:** Non-linear, allows models to account for complex data patterns; simple and efficient in computation.\n*   Variants like Leaky ReLU or Parametric ReLU are used to address the “dying ReLU” problem where neurons can become inactive and stop contributing to the learning process.\n\n*   **Formula:** $\\\\sigma(x)=\\\\frac{1}{1+e^{-x}}$\n*   **Properties:** Smooth gradient, squashing values into a range between 0 and 1 . It’s often used in the output layer for binary classification.\n\n*   **Formula:** $\\\\tanh (x)=\\\\frac{e^x-e^{-x}}{e^x+e^{-x}}$\n*   **Properties:** Similar to sigmoid but squashes values into a range between -1 and 1 . It is zerocentered, making it easier to model inputs that have strongly negative, neutral, and strongly positive values.\n\n*   **Properties:** Softmax is non-linear and is able to handle multiple classes in a mutually exclusive scenario.\n\n*   **Nonlinearity:** This allows CNNs to capture complex relationships in data. Without nonlinearity, the network would behave like a linear model.\n*   **Differentiability:** Essential for enabling backpropagation where gradients are computed during training.\n*   **Computational Efficiency:** Faster activation functions (like ReLU) lead to quicker training.",
      "order": 110,
      "orderInChapter": 110,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "neural network",
        "convolution",
        "cnn",
        "backpropagation",
        "activation",
        "regularization",
        "dropout"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1231,
        "contentLength": 10299
      },
      "nextCards": [
        "ai-interview-what-are-some-differences-between-a-cnn-and-a-fcnn-111",
        "ai-interview-what-are-some-differences-between-a-cnn-and-a-ffnn-112"
      ],
      "relatedCards": [
        "ai-top-30-papers-stanfords-cs231n-convolutional-neural-networks-for-26",
        "ai-model-compression-weights-vs-activation-quantization-9",
        "ai-model-compression-device-and-operator-support-across-frameworks-15",
        "ai-dropout-use-a-weight-constraint-5",
        "ai-dropout-articles-9"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-please-describe-the-structure-of-cnns?-the-different-layers,-activation-functions?-what-are-some-key-properties-of-activation-functions?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-some-differences-between-a-cnn-and-a-fcnn-111",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Some Differences Between a CNN and a FCNN? Layers and Activation Functions? Why are They Structured Differently?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The terms CNN (Convolutional Neural Network) and FCNN (Fully Convolutional Neural Network) refer to specific architectures within the realm of neural networks, each with distinct characteristics tailored to different types of tasks.</li>\n  <li><strong>CNN (Convolutional Neural Network)</strong></li>\n  <li><strong>Structure:</strong>\n    <ul>\n      <li><strong>Convolutional Layers:</strong> CNNs use convolutional layers, where filters are applied to the input to create feature maps. These filters detect local features like edges, textures, etc.</li>\n      <li><strong>Pooling Layers (e.g., Max Pooling):</strong> Following convolutional layers, pooling layers reduce the spatial dimensions (width and height) of the feature maps, helping in achieving spatial invariance to input translations.</li>\n      <li><strong>Fully Connected Layers:</strong> Towards the end, CNNs typically have one or more fully connected layers. Here, neurons have connections to all activations in the previous layer, as seen in traditional neural networks.</li>\n    </ul>\n  </li>\n  <li><strong>Activation Functions:</strong> Commonly use ReLU or variants like Leaky ReLU; also employ softmax in the output layer for classification tasks.</li>\n  <li><strong>Parameter Sharing and Spatial Invariance:</strong>\n    <ul>\n      <li>The use of convolutional filters involves parameter sharing, reducing the total number of parameters and making the network efficient at learning spatial hierarchies.</li>\n      <li>Pooling layers contribute to spatial invariance, making the network robust to variations in the location of features in the input.</li>\n    </ul>\n  </li>\n  <li><strong>FCNN (Fully Convolutional Neural Network)</strong>\n    <ul>\n      <li><strong>Structure:</strong>\n        <ul>\n          <li><strong>Only Convolutional Layers:</strong> FCNNs, as the name suggests, are composed entirely of convolutional layers. They do not have any fully connected layers.</li>\n          <li><strong>Upsampling Layers:</strong> In tasks like semantic segmentation, FCNNs use upsampling techniques (like transposed convolutions) to increase the spatial resolution of feature maps.</li>\n        </ul>\n      </li>\n      <li><strong>Activation Functions:</strong> Similar to CNNs, FCNNs use activation functions like ReLU in convolutional layers.</li>\n      <li><strong>Designed for Spatial Data:</strong>\n        <ul>\n          <li>FCNNs are designed for tasks where the spatial dimension of the output is crucial, like in image segmentation, where an output pixel-wise map is needed.</li>\n          <li>They maintain spatial information throughout the network, which is lost in the fully connected layers of CNNs.</li>\n        </ul>\n      </li>\n      <li><strong>Differences and Structural Reasons</strong></li>\n      <li><strong>Max Pooling and Fully Connected Layers in CNNs:</strong>\n        <ul>\n          <li>These components are used in CNNs for classification tasks where the goal is to identify global features or patterns in the entire input (like identifying objects in images).</li>\n          <li>Max Pooling helps in reducing the dimensionality and provides translation invariance, beneficial for classification tasks.</li>\n        </ul>\n      </li>\n      <li><strong>Absence of Fully Connected Layers in FCNNs:</strong>\n        <ul>\n          <li>FCNNs are structured to maintain spatial information, which is essential for tasks like segmentation where the exact location of objects in an image is important.</li>\n          <li>The absence of fully connected layers allows FCNNs to accept inputs of any size and produce correspondingly-sized outputs.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Conclusion</strong>\n    <ul>\n      <li>CNNs are typically used for classification tasks. They leverage the spatial invariance property with max pooling and parameter sharing in filters, followed by fully connected layers for high-level reasoning.</li>\n      <li>FCNNs are used primarily for spatially-oriented tasks like segmentation. They maintain spatial dimensions throughout the network, allowing for precise, pixel-level predictions.</li>\n      <li>The choice between CNN and FCNN depends on the specific requirements of the task, particularly regarding the importance of preserving spatial information in the output.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Convolutional Layers:</strong> CNNs use convolutional layers, where filters are applied to the input to create feature maps. These filters detect local features like edges, textures, etc.</li>\n      <li><strong>Pooling Layers (e.g., Max Pooling):</strong> Following convolutional layers, pooling layers reduce the spatial dimensions (width and height) of the feature maps, helping in achieving spatial invariance to input translations.</li>\n      <li><strong>Fully Connected Layers:</strong> Towards the end, CNNs typically have one or more fully connected layers. Here, neurons have connections to all activations in the previous layer, as seen in traditional neural networks.</li>\n    </ul>\n<ul>\n      <li>The use of convolutional filters involves parameter sharing, reducing the total number of parameters and making the network efficient at learning spatial hierarchies.</li>\n      <li>Pooling layers contribute to spatial invariance, making the network robust to variations in the location of features in the input.</li>\n    </ul>\n<ul>\n      <li><strong>Structure:</strong>\n        <ul>\n          <li><strong>Only Convolutional Layers:</strong> FCNNs, as the name suggests, are composed entirely of convolutional layers. They do not have any fully connected layers.</li>\n          <li><strong>Upsampling Layers:</strong> In tasks like semantic segmentation, FCNNs use upsampling techniques (like transposed convolutions) to increase the spatial resolution of feature maps.</li>\n        </ul>\n      </li>\n      <li><strong>Activation Functions:</strong> Similar to CNNs, FCNNs use activation functions like ReLU in convolutional layers.</li>\n      <li><strong>Designed for Spatial Data:</strong>\n        <ul>\n          <li>FCNNs are designed for tasks where the spatial dimension of the output is crucial, like in image segmentation, where an output pixel-wise map is needed.</li>\n          <li>They maintain spatial information throughout the network, which is lost in the fully connected layers of CNNs.</li>\n        </ul>\n      </li>\n      <li><strong>Differences and Structural Reasons</strong></li>\n      <li><strong>Max Pooling and Fully Connected Layers in CNNs:</strong>\n        <ul>\n          <li>These components are used in CNNs for classification tasks where the goal is to identify global features or patterns in the entire input (like identifying objects in images).</li>\n          <li>Max Pooling helps in reducing the dimensionality and provides translation invariance, beneficial for classification tasks.</li>\n        </ul>\n      </li>\n      <li><strong>Absence of Fully Connected Layers in FCNNs:</strong>\n        <ul>\n          <li>FCNNs are structured to maintain spatial information, which is essential for tasks like segmentation where the exact location of objects in an image is important.</li>\n          <li>The absence of fully connected layers allows FCNNs to accept inputs of any size and produce correspondingly-sized outputs.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Only Convolutional Layers:</strong> FCNNs, as the name suggests, are composed entirely of convolutional layers. They do not have any fully connected layers.</li>\n          <li><strong>Upsampling Layers:</strong> In tasks like semantic segmentation, FCNNs use upsampling techniques (like transposed convolutions) to increase the spatial resolution of feature maps.</li>\n        </ul>\n<ul>\n          <li>FCNNs are designed for tasks where the spatial dimension of the output is crucial, like in image segmentation, where an output pixel-wise map is needed.</li>\n          <li>They maintain spatial information throughout the network, which is lost in the fully connected layers of CNNs.</li>\n        </ul>\n<ul>\n          <li>These components are used in CNNs for classification tasks where the goal is to identify global features or patterns in the entire input (like identifying objects in images).</li>\n          <li>Max Pooling helps in reducing the dimensionality and provides translation invariance, beneficial for classification tasks.</li>\n        </ul>\n<ul>\n          <li>FCNNs are structured to maintain spatial information, which is essential for tasks like segmentation where the exact location of objects in an image is important.</li>\n          <li>The absence of fully connected layers allows FCNNs to accept inputs of any size and produce correspondingly-sized outputs.</li>\n        </ul>\n<ul>\n      <li>CNNs are typically used for classification tasks. They leverage the spatial invariance property with max pooling and parameter sharing in filters, followed by fully connected layers for high-level reasoning.</li>\n      <li>FCNNs are used primarily for spatially-oriented tasks like segmentation. They maintain spatial dimensions throughout the network, allowing for precise, pixel-level predictions.</li>\n      <li>The choice between CNN and FCNN depends on the specific requirements of the task, particularly regarding the importance of preserving spatial information in the output.</li>\n    </ul>",
      "contentMarkdown": "*   The terms CNN (Convolutional Neural Network) and FCNN (Fully Convolutional Neural Network) refer to specific architectures within the realm of neural networks, each with distinct characteristics tailored to different types of tasks.\n*   **CNN (Convolutional Neural Network)**\n*   **Structure:**\n    *   **Convolutional Layers:** CNNs use convolutional layers, where filters are applied to the input to create feature maps. These filters detect local features like edges, textures, etc.\n    *   **Pooling Layers (e.g., Max Pooling):** Following convolutional layers, pooling layers reduce the spatial dimensions (width and height) of the feature maps, helping in achieving spatial invariance to input translations.\n    *   **Fully Connected Layers:** Towards the end, CNNs typically have one or more fully connected layers. Here, neurons have connections to all activations in the previous layer, as seen in traditional neural networks.\n*   **Activation Functions:** Commonly use ReLU or variants like Leaky ReLU; also employ softmax in the output layer for classification tasks.\n*   **Parameter Sharing and Spatial Invariance:**\n    *   The use of convolutional filters involves parameter sharing, reducing the total number of parameters and making the network efficient at learning spatial hierarchies.\n    *   Pooling layers contribute to spatial invariance, making the network robust to variations in the location of features in the input.\n*   **FCNN (Fully Convolutional Neural Network)**\n    *   **Structure:**\n        *   **Only Convolutional Layers:** FCNNs, as the name suggests, are composed entirely of convolutional layers. They do not have any fully connected layers.\n        *   **Upsampling Layers:** In tasks like semantic segmentation, FCNNs use upsampling techniques (like transposed convolutions) to increase the spatial resolution of feature maps.\n    *   **Activation Functions:** Similar to CNNs, FCNNs use activation functions like ReLU in convolutional layers.\n    *   **Designed for Spatial Data:**\n        *   FCNNs are designed for tasks where the spatial dimension of the output is crucial, like in image segmentation, where an output pixel-wise map is needed.\n        *   They maintain spatial information throughout the network, which is lost in the fully connected layers of CNNs.\n    *   **Differences and Structural Reasons**\n    *   **Max Pooling and Fully Connected Layers in CNNs:**\n        *   These components are used in CNNs for classification tasks where the goal is to identify global features or patterns in the entire input (like identifying objects in images).\n        *   Max Pooling helps in reducing the dimensionality and provides translation invariance, beneficial for classification tasks.\n    *   **Absence of Fully Connected Layers in FCNNs:**\n        *   FCNNs are structured to maintain spatial information, which is essential for tasks like segmentation where the exact location of objects in an image is important.\n        *   The absence of fully connected layers allows FCNNs to accept inputs of any size and produce correspondingly-sized outputs.\n*   **Conclusion**\n    *   CNNs are typically used for classification tasks. They leverage the spatial invariance property with max pooling and parameter sharing in filters, followed by fully connected layers for high-level reasoning.\n    *   FCNNs are used primarily for spatially-oriented tasks like segmentation. They maintain spatial dimensions throughout the network, allowing for precise, pixel-level predictions.\n    *   The choice between CNN and FCNN depends on the specific requirements of the task, particularly regarding the importance of preserving spatial information in the output.\n\n*   **Convolutional Layers:** CNNs use convolutional layers, where filters are applied to the input to create feature maps. These filters detect local features like edges, textures, etc.\n*   **Pooling Layers (e.g., Max Pooling):** Following convolutional layers, pooling layers reduce the spatial dimensions (width and height) of the feature maps, helping in achieving spatial invariance to input translations.\n*   **Fully Connected Layers:** Towards the end, CNNs typically have one or more fully connected layers. Here, neurons have connections to all activations in the previous layer, as seen in traditional neural networks.\n\n*   The use of convolutional filters involves parameter sharing, reducing the total number of parameters and making the network efficient at learning spatial hierarchies.\n*   Pooling layers contribute to spatial invariance, making the network robust to variations in the location of features in the input.\n\n*   **Structure:**\n    *   **Only Convolutional Layers:** FCNNs, as the name suggests, are composed entirely of convolutional layers. They do not have any fully connected layers.\n    *   **Upsampling Layers:** In tasks like semantic segmentation, FCNNs use upsampling techniques (like transposed convolutions) to increase the spatial resolution of feature maps.\n*   **Activation Functions:** Similar to CNNs, FCNNs use activation functions like ReLU in convolutional layers.\n*   **Designed for Spatial Data:**\n    *   FCNNs are designed for tasks where the spatial dimension of the output is crucial, like in image segmentation, where an output pixel-wise map is needed.\n    *   They maintain spatial information throughout the network, which is lost in the fully connected layers of CNNs.\n*   **Differences and Structural Reasons**\n*   **Max Pooling and Fully Connected Layers in CNNs:**\n    *   These components are used in CNNs for classification tasks where the goal is to identify global features or patterns in the entire input (like identifying objects in images).\n    *   Max Pooling helps in reducing the dimensionality and provides translation invariance, beneficial for classification tasks.\n*   **Absence of Fully Connected Layers in FCNNs:**\n    *   FCNNs are structured to maintain spatial information, which is essential for tasks like segmentation where the exact location of objects in an image is important.\n    *   The absence of fully connected layers allows FCNNs to accept inputs of any size and produce correspondingly-sized outputs.\n\n*   **Only Convolutional Layers:** FCNNs, as the name suggests, are composed entirely of convolutional layers. They do not have any fully connected layers.\n*   **Upsampling Layers:** In tasks like semantic segmentation, FCNNs use upsampling techniques (like transposed convolutions) to increase the spatial resolution of feature maps.\n\n*   FCNNs are designed for tasks where the spatial dimension of the output is crucial, like in image segmentation, where an output pixel-wise map is needed.\n*   They maintain spatial information throughout the network, which is lost in the fully connected layers of CNNs.\n\n*   These components are used in CNNs for classification tasks where the goal is to identify global features or patterns in the entire input (like identifying objects in images).\n*   Max Pooling helps in reducing the dimensionality and provides translation invariance, beneficial for classification tasks.\n\n*   FCNNs are structured to maintain spatial information, which is essential for tasks like segmentation where the exact location of objects in an image is important.\n*   The absence of fully connected layers allows FCNNs to accept inputs of any size and produce correspondingly-sized outputs.\n\n*   CNNs are typically used for classification tasks. They leverage the spatial invariance property with max pooling and parameter sharing in filters, followed by fully connected layers for high-level reasoning.\n*   FCNNs are used primarily for spatially-oriented tasks like segmentation. They maintain spatial dimensions throughout the network, allowing for precise, pixel-level predictions.\n*   The choice between CNN and FCNN depends on the specific requirements of the task, particularly regarding the importance of preserving spatial information in the output.",
      "order": 111,
      "orderInChapter": 111,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "convolution",
        "cnn",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1129,
        "contentLength": 9433
      },
      "nextCards": [
        "ai-interview-what-are-some-differences-between-a-cnn-and-a-ffnn-112",
        "ai-interview-imagine-you-are-designing-a-cnn-from-scratch-how-w-113"
      ],
      "relatedCards": [
        "ai-dl-comp-pros-of-cnns-compared-to-fcns-2",
        "ai-cnns-for-text-classification-1-d-convolutions-over-text-4",
        "ai-model-compression-device-and-operator-support-across-frameworks-15",
        "ai-loss-additive-angular-margin-loss-6",
        "ai-vit-why-does-vit-rely-on-1616161616-times-16-pixels-fo-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-differences-between-a-cnn-and-a-fcnn?-layers-and-activation-functions?-why-are-they-structured-differently?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-some-differences-between-a-cnn-and-a-ffnn-112",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Some Differences Between a CNN and a FFNN? Layers and Activation Functions? Why are They Structured Differently?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Convolutional Neural Networks (CNNs) and Fully Connected Neural Networks (FCNNs) differ significantly in their structures, purposes, and the specific tasks they are best suited for. Here are some of the key differences:\n    <ul>\n      <li><strong>CNN (Convolutional Neural Network)</strong>\n        <ul>\n          <li><strong>Structure:</strong> Convolutional Layers: CNNs primarily consist of convolutional layers, where filters or kernels are convolved with the input data to extract features.</li>\n          <li><strong>Pooling Layers (Max Pooling):</strong> Pooling layers, such as max pooling, are used to reduce the spatial dimensions of the feature maps. This operation helps in achieving spatial invariance to input translations and reducing the number of parameters.</li>\n          <li><strong>Parameter Sharing:</strong> In convolutional layers, the same filter is applied across different parts of the input, significantly reducing the number of parameters compared to a fully connected architecture.</li>\n          <li><strong>Spatial Invariance:</strong>\n            <ul>\n              <li>CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.</li>\n              <li>This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.</li>\n            </ul>\n          </li>\n          <li><strong>Activation Functions:</strong>\n            <ul>\n              <li>Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.</li>\n              <li>The output layer may use softmax for multi-class classification tasks.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>FCNN (Fully Connected Neural Network)</strong>\n        <ul>\n          <li><strong>Structure:</strong>\n            <ul>\n              <li><strong>Fully Connected Layers:</strong> In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.</li>\n              <li><strong>No Spatial Invariance:</strong> Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.</li>\n            </ul>\n          </li>\n          <li><strong>Use Cases:</strong> FCNNs are more general-purpose and can be used for a wide range of tasks, including classification and regression. However, they are not specialized for spatial data like images.</li>\n          <li><strong>Activation Functions:</strong> Similar to CNNs, FCNNs can use a variety of activation functions like ReLU, sigmoid, or tanh, depending on the specific application.</li>\n        </ul>\n      </li>\n      <li><strong>Key Differences and Rationale</strong>\n        <ul>\n          <li><strong>Max Pooling in CNNs:</strong> Max pooling reduces the spatial dimensions of feature maps, enhancing the network’s ability to capture important features regardless of their position. This is particularly useful for image data where nearby pixels are more related.</li>\n          <li><strong>Parameter Efficiency in CNNs:</strong> The use of convolutional layers with parameter sharing and pooling layers in CNNs minimizes the number of parameters needed, making them more efficient for image-related tasks.</li>\n          <li><strong>FC Layers in CNNs:</strong> While CNNs often end with one or more fully connected layers for classification, these come after convolutional and pooling layers have extracted spatial features.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>In summary, CNNs are structured to exploit the spatial relationships inherent in data like images, using fewer parameters through convolutional layers and achieving spatial invariance with pooling layers. In contrast, fully connected networks are more general-purpose and lack these spatial efficiencies, making them less suitable for tasks like image recognition but useful for other types of data-driven tasks.</li>\n</ul>\n<ul>\n      <li><strong>CNN (Convolutional Neural Network)</strong>\n        <ul>\n          <li><strong>Structure:</strong> Convolutional Layers: CNNs primarily consist of convolutional layers, where filters or kernels are convolved with the input data to extract features.</li>\n          <li><strong>Pooling Layers (Max Pooling):</strong> Pooling layers, such as max pooling, are used to reduce the spatial dimensions of the feature maps. This operation helps in achieving spatial invariance to input translations and reducing the number of parameters.</li>\n          <li><strong>Parameter Sharing:</strong> In convolutional layers, the same filter is applied across different parts of the input, significantly reducing the number of parameters compared to a fully connected architecture.</li>\n          <li><strong>Spatial Invariance:</strong>\n            <ul>\n              <li>CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.</li>\n              <li>This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.</li>\n            </ul>\n          </li>\n          <li><strong>Activation Functions:</strong>\n            <ul>\n              <li>Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.</li>\n              <li>The output layer may use softmax for multi-class classification tasks.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>FCNN (Fully Connected Neural Network)</strong>\n        <ul>\n          <li><strong>Structure:</strong>\n            <ul>\n              <li><strong>Fully Connected Layers:</strong> In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.</li>\n              <li><strong>No Spatial Invariance:</strong> Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.</li>\n            </ul>\n          </li>\n          <li><strong>Use Cases:</strong> FCNNs are more general-purpose and can be used for a wide range of tasks, including classification and regression. However, they are not specialized for spatial data like images.</li>\n          <li><strong>Activation Functions:</strong> Similar to CNNs, FCNNs can use a variety of activation functions like ReLU, sigmoid, or tanh, depending on the specific application.</li>\n        </ul>\n      </li>\n      <li><strong>Key Differences and Rationale</strong>\n        <ul>\n          <li><strong>Max Pooling in CNNs:</strong> Max pooling reduces the spatial dimensions of feature maps, enhancing the network’s ability to capture important features regardless of their position. This is particularly useful for image data where nearby pixels are more related.</li>\n          <li><strong>Parameter Efficiency in CNNs:</strong> The use of convolutional layers with parameter sharing and pooling layers in CNNs minimizes the number of parameters needed, making them more efficient for image-related tasks.</li>\n          <li><strong>FC Layers in CNNs:</strong> While CNNs often end with one or more fully connected layers for classification, these come after convolutional and pooling layers have extracted spatial features.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>Structure:</strong> Convolutional Layers: CNNs primarily consist of convolutional layers, where filters or kernels are convolved with the input data to extract features.</li>\n          <li><strong>Pooling Layers (Max Pooling):</strong> Pooling layers, such as max pooling, are used to reduce the spatial dimensions of the feature maps. This operation helps in achieving spatial invariance to input translations and reducing the number of parameters.</li>\n          <li><strong>Parameter Sharing:</strong> In convolutional layers, the same filter is applied across different parts of the input, significantly reducing the number of parameters compared to a fully connected architecture.</li>\n          <li><strong>Spatial Invariance:</strong>\n            <ul>\n              <li>CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.</li>\n              <li>This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.</li>\n            </ul>\n          </li>\n          <li><strong>Activation Functions:</strong>\n            <ul>\n              <li>Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.</li>\n              <li>The output layer may use softmax for multi-class classification tasks.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.</li>\n              <li>This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.</li>\n            </ul>\n<ul>\n              <li>Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.</li>\n              <li>The output layer may use softmax for multi-class classification tasks.</li>\n            </ul>\n<ul>\n          <li><strong>Structure:</strong>\n            <ul>\n              <li><strong>Fully Connected Layers:</strong> In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.</li>\n              <li><strong>No Spatial Invariance:</strong> Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.</li>\n            </ul>\n          </li>\n          <li><strong>Use Cases:</strong> FCNNs are more general-purpose and can be used for a wide range of tasks, including classification and regression. However, they are not specialized for spatial data like images.</li>\n          <li><strong>Activation Functions:</strong> Similar to CNNs, FCNNs can use a variety of activation functions like ReLU, sigmoid, or tanh, depending on the specific application.</li>\n        </ul>\n<ul>\n              <li><strong>Fully Connected Layers:</strong> In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.</li>\n              <li><strong>No Spatial Invariance:</strong> Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.</li>\n            </ul>\n<ul>\n          <li><strong>Max Pooling in CNNs:</strong> Max pooling reduces the spatial dimensions of feature maps, enhancing the network’s ability to capture important features regardless of their position. This is particularly useful for image data where nearby pixels are more related.</li>\n          <li><strong>Parameter Efficiency in CNNs:</strong> The use of convolutional layers with parameter sharing and pooling layers in CNNs minimizes the number of parameters needed, making them more efficient for image-related tasks.</li>\n          <li><strong>FC Layers in CNNs:</strong> While CNNs often end with one or more fully connected layers for classification, these come after convolutional and pooling layers have extracted spatial features.</li>\n        </ul>",
      "contentMarkdown": "*   Convolutional Neural Networks (CNNs) and Fully Connected Neural Networks (FCNNs) differ significantly in their structures, purposes, and the specific tasks they are best suited for. Here are some of the key differences:\n    *   **CNN (Convolutional Neural Network)**\n        *   **Structure:** Convolutional Layers: CNNs primarily consist of convolutional layers, where filters or kernels are convolved with the input data to extract features.\n        *   **Pooling Layers (Max Pooling):** Pooling layers, such as max pooling, are used to reduce the spatial dimensions of the feature maps. This operation helps in achieving spatial invariance to input translations and reducing the number of parameters.\n        *   **Parameter Sharing:** In convolutional layers, the same filter is applied across different parts of the input, significantly reducing the number of parameters compared to a fully connected architecture.\n        *   **Spatial Invariance:**\n            *   CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.\n            *   This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.\n        *   **Activation Functions:**\n            *   Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.\n            *   The output layer may use softmax for multi-class classification tasks.\n    *   **FCNN (Fully Connected Neural Network)**\n        *   **Structure:**\n            *   **Fully Connected Layers:** In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.\n            *   **No Spatial Invariance:** Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.\n        *   **Use Cases:** FCNNs are more general-purpose and can be used for a wide range of tasks, including classification and regression. However, they are not specialized for spatial data like images.\n        *   **Activation Functions:** Similar to CNNs, FCNNs can use a variety of activation functions like ReLU, sigmoid, or tanh, depending on the specific application.\n    *   **Key Differences and Rationale**\n        *   **Max Pooling in CNNs:** Max pooling reduces the spatial dimensions of feature maps, enhancing the network’s ability to capture important features regardless of their position. This is particularly useful for image data where nearby pixels are more related.\n        *   **Parameter Efficiency in CNNs:** The use of convolutional layers with parameter sharing and pooling layers in CNNs minimizes the number of parameters needed, making them more efficient for image-related tasks.\n        *   **FC Layers in CNNs:** While CNNs often end with one or more fully connected layers for classification, these come after convolutional and pooling layers have extracted spatial features.\n*   In summary, CNNs are structured to exploit the spatial relationships inherent in data like images, using fewer parameters through convolutional layers and achieving spatial invariance with pooling layers. In contrast, fully connected networks are more general-purpose and lack these spatial efficiencies, making them less suitable for tasks like image recognition but useful for other types of data-driven tasks.\n\n*   **CNN (Convolutional Neural Network)**\n    *   **Structure:** Convolutional Layers: CNNs primarily consist of convolutional layers, where filters or kernels are convolved with the input data to extract features.\n    *   **Pooling Layers (Max Pooling):** Pooling layers, such as max pooling, are used to reduce the spatial dimensions of the feature maps. This operation helps in achieving spatial invariance to input translations and reducing the number of parameters.\n    *   **Parameter Sharing:** In convolutional layers, the same filter is applied across different parts of the input, significantly reducing the number of parameters compared to a fully connected architecture.\n    *   **Spatial Invariance:**\n        *   CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.\n        *   This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.\n    *   **Activation Functions:**\n        *   Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.\n        *   The output layer may use softmax for multi-class classification tasks.\n*   **FCNN (Fully Connected Neural Network)**\n    *   **Structure:**\n        *   **Fully Connected Layers:** In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.\n        *   **No Spatial Invariance:** Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.\n    *   **Use Cases:** FCNNs are more general-purpose and can be used for a wide range of tasks, including classification and regression. However, they are not specialized for spatial data like images.\n    *   **Activation Functions:** Similar to CNNs, FCNNs can use a variety of activation functions like ReLU, sigmoid, or tanh, depending on the specific application.\n*   **Key Differences and Rationale**\n    *   **Max Pooling in CNNs:** Max pooling reduces the spatial dimensions of feature maps, enhancing the network’s ability to capture important features regardless of their position. This is particularly useful for image data where nearby pixels are more related.\n    *   **Parameter Efficiency in CNNs:** The use of convolutional layers with parameter sharing and pooling layers in CNNs minimizes the number of parameters needed, making them more efficient for image-related tasks.\n    *   **FC Layers in CNNs:** While CNNs often end with one or more fully connected layers for classification, these come after convolutional and pooling layers have extracted spatial features.\n\n*   **Structure:** Convolutional Layers: CNNs primarily consist of convolutional layers, where filters or kernels are convolved with the input data to extract features.\n*   **Pooling Layers (Max Pooling):** Pooling layers, such as max pooling, are used to reduce the spatial dimensions of the feature maps. This operation helps in achieving spatial invariance to input translations and reducing the number of parameters.\n*   **Parameter Sharing:** In convolutional layers, the same filter is applied across different parts of the input, significantly reducing the number of parameters compared to a fully connected architecture.\n*   **Spatial Invariance:**\n    *   CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.\n    *   This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.\n*   **Activation Functions:**\n    *   Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.\n    *   The output layer may use softmax for multi-class classification tasks.\n\n*   CNNs leverage the spatial invariance property, meaning they can detect features regardless of their spatial location in the input data.\n*   This property makes CNNs particularly suited for tasks like image recognition, where the exact location of a feature (like an edge or a shape) is less important than its presence.\n\n*   Commonly use ReLU (Rectified Linear Unit) or its variants like Leaky ReLU for introducing non-linearity.\n*   The output layer may use softmax for multi-class classification tasks.\n\n*   **Structure:**\n    *   **Fully Connected Layers:** In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.\n    *   **No Spatial Invariance:** Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.\n*   **Use Cases:** FCNNs are more general-purpose and can be used for a wide range of tasks, including classification and regression. However, they are not specialized for spatial data like images.\n*   **Activation Functions:** Similar to CNNs, FCNNs can use a variety of activation functions like ReLU, sigmoid, or tanh, depending on the specific application.\n\n*   **Fully Connected Layers:** In a fully connected neural network, every neuron in one layer is connected to every neuron in the next layer. This means the number of parameters can be quite large, especially for networks with many neurons.\n*   **No Spatial Invariance:** Fully connected layers do not inherently have spatial invariance. They treat input data as a flat vector of features without considering the spatial relationships between them.\n\n*   **Max Pooling in CNNs:** Max pooling reduces the spatial dimensions of feature maps, enhancing the network’s ability to capture important features regardless of their position. This is particularly useful for image data where nearby pixels are more related.\n*   **Parameter Efficiency in CNNs:** The use of convolutional layers with parameter sharing and pooling layers in CNNs minimizes the number of parameters needed, making them more efficient for image-related tasks.\n*   **FC Layers in CNNs:** While CNNs often end with one or more fully connected layers for classification, these come after convolutional and pooling layers have extracted spatial features.",
      "order": 112,
      "orderInChapter": 112,
      "difficulty": 4,
      "estimatedMinutes": 8,
      "tags": [
        "practice",
        "neural network",
        "convolution",
        "cnn",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1476,
        "contentLength": 12365
      },
      "nextCards": [
        "ai-interview-imagine-you-are-designing-a-cnn-from-scratch-how-w-113",
        "ai-interview-both-a-fully-connected-layer-and-a-self-attention--114"
      ],
      "relatedCards": [
        "ai-dl-comp-pros-of-cnns-compared-to-fcns-2",
        "ai-cnns-for-text-classification-1-d-convolutions-over-text-4",
        "ai-model-compression-device-and-operator-support-across-frameworks-15",
        "ai-loss-additive-angular-margin-loss-6",
        "ai-vit-why-does-vit-rely-on-1616161616-times-16-pixels-fo-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-differences-between-a-cnn-and-a-ffnn?-layers-and-activation-functions?-why-are-they-structured-differently?",
      "scrapedAt": "2025-12-28T11:58:12.842Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-imagine-you-are-designing-a-cnn-from-scratch-how-w-113",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Imagine You are Designing a CNN from Scratch. How Would You Think about Choosing the CNN Kernel Size? What are Some Considerations?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Designing a Convolutional Neural Network (CNN) from scratch involves several important decisions, one of which is choosing the kernel size for the convolutional layers. The kernel size can significantly impact the network’s performance, computational efficiency, and its ability to capture relevant features from the input data. Here are some considerations for choosing the CNN kernel size:\n    <ul>\n      <li><strong>Larger Kernels</strong>\n        <ul>\n          <li><strong>More Parameters and Computational Complexity:</strong> Larger kernels (e.g., 5x5, 7x7) have more parameters. This increases the computational complexity and the memory footprint of the model.</li>\n          <li><strong>Capturing Global Information:</strong> They are capable of capturing more global information in the input data. For example, a larger kernel can cover a larger area of the input image, thus encapsulating more global features at once.</li>\n          <li><strong>Suitability:</strong> Larger kernels might be more suitable for tasks where understanding broader patterns is important, such as in detecting general shapes or configurations in an image.</li>\n        </ul>\n      </li>\n      <li><strong>Smaller Kernels</strong>\n        <ul>\n          <li><strong>Fewer Parameters and Lower Computational Complexity:</strong> Smaller kernels (e.g., 3x3, 1x1) have fewer parameters, making the network computationally more efficient and reducing the risk of overfitting.</li>\n          <li><strong>Capturing Fine Details:</strong>\n            <ul>\n              <li>They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.</li>\n              <li>Stacking Layers for Larger Receptive Fields:</li>\n              <li>Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Task-Specific Considerations</strong>\n        <ul>\n          <li><strong>Type of Task - Broad Patterns vs. Fine Details:</strong> The choice of kernel size should align with the nature of the task. For instance, if the task requires understanding broad patterns (like in scene recognition), larger kernels may be more appropriate. Conversely, for tasks focusing on finer details (like in medical imaging for detecting small anomalies), smaller kernels could be more effective.</li>\n        </ul>\n      </li>\n      <li><strong>Computational Resources</strong>\n        <ul>\n          <li><strong>Resource Constraints:</strong> The availability of computational resources also plays a role. Larger kernels may not be feasible in resource-constrained environments due to their higher computational demands.</li>\n        </ul>\n      </li>\n      <li><strong>Combining Different Kernel Sizes</strong>\n        <ul>\n          <li><strong>Hybrid Approaches:</strong> Some advanced CNN architectures use a combination of different kernel sizes in parallel branches (like in Inception networks) to capture both local and global features effectively.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Conclusion:</strong> In summary, choosing the kernel size in a CNN is a balance between capturing broad/global patterns vs. fine-grained features, computational efficiency, and the specific requirements of the task at hand. Smaller kernels are generally preferred for their efficiency and ability to capture detailed features, especially when used in deeper architectures. However, larger kernels have their place in scenarios where broader feature extraction is crucial. Often, a combination of different kernel sizes, either sequentially or in parallel, can provide a comprehensive feature extraction mechanism suitable for a wide range of tasks.</li>\n</ul>\n<ul>\n      <li><strong>Larger Kernels</strong>\n        <ul>\n          <li><strong>More Parameters and Computational Complexity:</strong> Larger kernels (e.g., 5x5, 7x7) have more parameters. This increases the computational complexity and the memory footprint of the model.</li>\n          <li><strong>Capturing Global Information:</strong> They are capable of capturing more global information in the input data. For example, a larger kernel can cover a larger area of the input image, thus encapsulating more global features at once.</li>\n          <li><strong>Suitability:</strong> Larger kernels might be more suitable for tasks where understanding broader patterns is important, such as in detecting general shapes or configurations in an image.</li>\n        </ul>\n      </li>\n      <li><strong>Smaller Kernels</strong>\n        <ul>\n          <li><strong>Fewer Parameters and Lower Computational Complexity:</strong> Smaller kernels (e.g., 3x3, 1x1) have fewer parameters, making the network computationally more efficient and reducing the risk of overfitting.</li>\n          <li><strong>Capturing Fine Details:</strong>\n            <ul>\n              <li>They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.</li>\n              <li>Stacking Layers for Larger Receptive Fields:</li>\n              <li>Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Task-Specific Considerations</strong>\n        <ul>\n          <li><strong>Type of Task - Broad Patterns vs. Fine Details:</strong> The choice of kernel size should align with the nature of the task. For instance, if the task requires understanding broad patterns (like in scene recognition), larger kernels may be more appropriate. Conversely, for tasks focusing on finer details (like in medical imaging for detecting small anomalies), smaller kernels could be more effective.</li>\n        </ul>\n      </li>\n      <li><strong>Computational Resources</strong>\n        <ul>\n          <li><strong>Resource Constraints:</strong> The availability of computational resources also plays a role. Larger kernels may not be feasible in resource-constrained environments due to their higher computational demands.</li>\n        </ul>\n      </li>\n      <li><strong>Combining Different Kernel Sizes</strong>\n        <ul>\n          <li><strong>Hybrid Approaches:</strong> Some advanced CNN architectures use a combination of different kernel sizes in parallel branches (like in Inception networks) to capture both local and global features effectively.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li><strong>More Parameters and Computational Complexity:</strong> Larger kernels (e.g., 5x5, 7x7) have more parameters. This increases the computational complexity and the memory footprint of the model.</li>\n          <li><strong>Capturing Global Information:</strong> They are capable of capturing more global information in the input data. For example, a larger kernel can cover a larger area of the input image, thus encapsulating more global features at once.</li>\n          <li><strong>Suitability:</strong> Larger kernels might be more suitable for tasks where understanding broader patterns is important, such as in detecting general shapes or configurations in an image.</li>\n        </ul>\n<ul>\n          <li><strong>Fewer Parameters and Lower Computational Complexity:</strong> Smaller kernels (e.g., 3x3, 1x1) have fewer parameters, making the network computationally more efficient and reducing the risk of overfitting.</li>\n          <li><strong>Capturing Fine Details:</strong>\n            <ul>\n              <li>They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.</li>\n              <li>Stacking Layers for Larger Receptive Fields:</li>\n              <li>Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li>They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.</li>\n              <li>Stacking Layers for Larger Receptive Fields:</li>\n              <li>Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.</li>\n            </ul>\n<ul>\n          <li><strong>Type of Task - Broad Patterns vs. Fine Details:</strong> The choice of kernel size should align with the nature of the task. For instance, if the task requires understanding broad patterns (like in scene recognition), larger kernels may be more appropriate. Conversely, for tasks focusing on finer details (like in medical imaging for detecting small anomalies), smaller kernels could be more effective.</li>\n        </ul>\n<ul>\n          <li><strong>Resource Constraints:</strong> The availability of computational resources also plays a role. Larger kernels may not be feasible in resource-constrained environments due to their higher computational demands.</li>\n        </ul>\n<ul>\n          <li><strong>Hybrid Approaches:</strong> Some advanced CNN architectures use a combination of different kernel sizes in parallel branches (like in Inception networks) to capture both local and global features effectively.</li>\n        </ul>",
      "contentMarkdown": "*   Designing a Convolutional Neural Network (CNN) from scratch involves several important decisions, one of which is choosing the kernel size for the convolutional layers. The kernel size can significantly impact the network’s performance, computational efficiency, and its ability to capture relevant features from the input data. Here are some considerations for choosing the CNN kernel size:\n    *   **Larger Kernels**\n        *   **More Parameters and Computational Complexity:** Larger kernels (e.g., 5x5, 7x7) have more parameters. This increases the computational complexity and the memory footprint of the model.\n        *   **Capturing Global Information:** They are capable of capturing more global information in the input data. For example, a larger kernel can cover a larger area of the input image, thus encapsulating more global features at once.\n        *   **Suitability:** Larger kernels might be more suitable for tasks where understanding broader patterns is important, such as in detecting general shapes or configurations in an image.\n    *   **Smaller Kernels**\n        *   **Fewer Parameters and Lower Computational Complexity:** Smaller kernels (e.g., 3x3, 1x1) have fewer parameters, making the network computationally more efficient and reducing the risk of overfitting.\n        *   **Capturing Fine Details:**\n            *   They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.\n            *   Stacking Layers for Larger Receptive Fields:\n            *   Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.\n    *   **Task-Specific Considerations**\n        *   **Type of Task - Broad Patterns vs. Fine Details:** The choice of kernel size should align with the nature of the task. For instance, if the task requires understanding broad patterns (like in scene recognition), larger kernels may be more appropriate. Conversely, for tasks focusing on finer details (like in medical imaging for detecting small anomalies), smaller kernels could be more effective.\n    *   **Computational Resources**\n        *   **Resource Constraints:** The availability of computational resources also plays a role. Larger kernels may not be feasible in resource-constrained environments due to their higher computational demands.\n    *   **Combining Different Kernel Sizes**\n        *   **Hybrid Approaches:** Some advanced CNN architectures use a combination of different kernel sizes in parallel branches (like in Inception networks) to capture both local and global features effectively.\n*   **Conclusion:** In summary, choosing the kernel size in a CNN is a balance between capturing broad/global patterns vs. fine-grained features, computational efficiency, and the specific requirements of the task at hand. Smaller kernels are generally preferred for their efficiency and ability to capture detailed features, especially when used in deeper architectures. However, larger kernels have their place in scenarios where broader feature extraction is crucial. Often, a combination of different kernel sizes, either sequentially or in parallel, can provide a comprehensive feature extraction mechanism suitable for a wide range of tasks.\n\n*   **Larger Kernels**\n    *   **More Parameters and Computational Complexity:** Larger kernels (e.g., 5x5, 7x7) have more parameters. This increases the computational complexity and the memory footprint of the model.\n    *   **Capturing Global Information:** They are capable of capturing more global information in the input data. For example, a larger kernel can cover a larger area of the input image, thus encapsulating more global features at once.\n    *   **Suitability:** Larger kernels might be more suitable for tasks where understanding broader patterns is important, such as in detecting general shapes or configurations in an image.\n*   **Smaller Kernels**\n    *   **Fewer Parameters and Lower Computational Complexity:** Smaller kernels (e.g., 3x3, 1x1) have fewer parameters, making the network computationally more efficient and reducing the risk of overfitting.\n    *   **Capturing Fine Details:**\n        *   They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.\n        *   Stacking Layers for Larger Receptive Fields:\n        *   Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.\n*   **Task-Specific Considerations**\n    *   **Type of Task - Broad Patterns vs. Fine Details:** The choice of kernel size should align with the nature of the task. For instance, if the task requires understanding broad patterns (like in scene recognition), larger kernels may be more appropriate. Conversely, for tasks focusing on finer details (like in medical imaging for detecting small anomalies), smaller kernels could be more effective.\n*   **Computational Resources**\n    *   **Resource Constraints:** The availability of computational resources also plays a role. Larger kernels may not be feasible in resource-constrained environments due to their higher computational demands.\n*   **Combining Different Kernel Sizes**\n    *   **Hybrid Approaches:** Some advanced CNN architectures use a combination of different kernel sizes in parallel branches (like in Inception networks) to capture both local and global features effectively.\n\n*   **More Parameters and Computational Complexity:** Larger kernels (e.g., 5x5, 7x7) have more parameters. This increases the computational complexity and the memory footprint of the model.\n*   **Capturing Global Information:** They are capable of capturing more global information in the input data. For example, a larger kernel can cover a larger area of the input image, thus encapsulating more global features at once.\n*   **Suitability:** Larger kernels might be more suitable for tasks where understanding broader patterns is important, such as in detecting general shapes or configurations in an image.\n\n*   **Fewer Parameters and Lower Computational Complexity:** Smaller kernels (e.g., 3x3, 1x1) have fewer parameters, making the network computationally more efficient and reducing the risk of overfitting.\n*   **Capturing Fine Details:**\n    *   They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.\n    *   Stacking Layers for Larger Receptive Fields:\n    *   Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.\n\n*   They excel at capturing fine-grained details in the input. This is crucial for tasks where local features are important, such as in texture analysis or detecting small objects.\n*   Stacking Layers for Larger Receptive Fields:\n*   Stacking multiple layers of small kernels can effectively increase the receptive field, similar to a single layer of a larger kernel, but with fewer parameters and potentially better feature extraction due to the increased depth.\n\n*   **Type of Task - Broad Patterns vs. Fine Details:** The choice of kernel size should align with the nature of the task. For instance, if the task requires understanding broad patterns (like in scene recognition), larger kernels may be more appropriate. Conversely, for tasks focusing on finer details (like in medical imaging for detecting small anomalies), smaller kernels could be more effective.\n\n*   **Resource Constraints:** The availability of computational resources also plays a role. Larger kernels may not be feasible in resource-constrained environments due to their higher computational demands.\n\n*   **Hybrid Approaches:** Some advanced CNN architectures use a combination of different kernel sizes in parallel branches (like in Inception networks) to capture both local and global features effectively.",
      "order": 113,
      "orderInChapter": 113,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "neural network",
        "convolution",
        "cnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1191,
        "contentLength": 10025
      },
      "nextCards": [
        "ai-interview-both-a-fully-connected-layer-and-a-self-attention--114",
        "ai-interview-what-is-the-advantage-of-using-a-self-attention-ba-115"
      ],
      "relatedCards": [
        "ai-dl-comp-pros-of-cnns-compared-to-fcns-2",
        "ai-loss-additive-angular-margin-loss-6",
        "ai-vit-why-does-vit-rely-on-1616161616-times-16-pixels-fo-5",
        "ai-gnn-introductory-content-21",
        "ai-diffusion-models-patch-n-pack-navit-a-vision-transformer-for-any-as-62"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#imagine-you-are-designing-a-cnn-from-scratch.-how-would-you-think-about-choosing-the-cnn-kernel-size?-what-are-some-considerations?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-both-a-fully-connected-layer-and-a-self-attention--114",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Both a Fully-connected Layer and a Self-attention Layer Allow for All-to-all Interactions. What is the Advantage of a Self-attention Layer?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Fully connected layers and self-attention layers both enable all-to-all interactions among their inputs, but they do so in fundamentally different ways, each offering unique advantages. The self-attention layer, especially as used in Transformer models, has several key benefits:</li>\n  <li><strong>Advantages of Self-Attention Layer</strong>\n    <ul>\n      <li><strong>Interpretability via Attention Scores:</strong>\n        <ul>\n          <li><strong>Mechanism:</strong>Self-attention mechanisms compute attention scores representing the influence or ‘attention’ each input element should receive from other elements.</li>\n          <li><strong>Advantage:</strong> These attention scores provide a form of interpretability. By examining the attention scores, one can understand the relationships and dependencies the model is inferring between different parts of the input. For instance, in language models, this can show which words or phrases the model considers relevant when processing a given word.</li>\n        </ul>\n      </li>\n      <li><strong>Parameter Efficiency in Some Cases:</strong>\n        <ul>\n          <li><strong>Comparison with Fully Connected Layers:</strong> Fully connected layers have a separate parameter for each connection between neurons in adjacent layers. This can lead to a very high number of parameters, especially in large networks.</li>\n          <li><strong>Self-Attention Efficiency:</strong> In contrast, self-attention layers use query (Q), key (K), and value (V) matrices to compute attention scores. The number of parameters in these matrices does not directly depend on the input size but rather on the chosen embedding size (dimensionality of Q, K, and V). This can lead to fewer parameters when the embedding size is smaller than the input size.</li>\n        </ul>\n      </li>\n      <li><strong>Handling Variable-Length Input:</strong>\n        <ul>\n          <li><strong>Flexibility:</strong> Self-attention layers are inherently suited for variable-length input, such as sentences in natural language processing, which can vary in length.</li>\n          <li><strong>Implementation:</strong> Since attention is computed pairwise between elements (e.g., words in a sentence), it naturally adapts to the length of the input. In contrast, fully connected layers require a fixed-size input, and adapting them to variable-length data often involves additional mechanisms like padding or truncation.</li>\n        </ul>\n      </li>\n      <li><strong>Additional Considerations</strong>\n        <ul>\n          <li><strong>Computational Efficiency:</strong> While self-attention can be more parameter-efficient, it can also be computationally intensive, especially for very long sequences, as the computation grows quadratically with sequence length.</li>\n          <li><strong>Global Context:</strong> Self-attention layers can capture global dependencies in the input data, as each output element is a function of all input elements. This is particularly advantageous in tasks like language understanding, where context is crucial.</li>\n        </ul>\n      </li>\n      <li><strong>Conclusion</strong> Self-attention layers offer interpretability through attention scores, can be more parameter-efficient depending on the embedding size, and are naturally adaptable to variable-length inputs. These qualities make them particularly powerful in applications like language processing and sequence modeling, where context and relationships between input elements are key to effective modeling.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Interpretability via Attention Scores:</strong>\n        <ul>\n          <li><strong>Mechanism:</strong>Self-attention mechanisms compute attention scores representing the influence or ‘attention’ each input element should receive from other elements.</li>\n          <li><strong>Advantage:</strong> These attention scores provide a form of interpretability. By examining the attention scores, one can understand the relationships and dependencies the model is inferring between different parts of the input. For instance, in language models, this can show which words or phrases the model considers relevant when processing a given word.</li>\n        </ul>\n      </li>\n      <li><strong>Parameter Efficiency in Some Cases:</strong>\n        <ul>\n          <li><strong>Comparison with Fully Connected Layers:</strong> Fully connected layers have a separate parameter for each connection between neurons in adjacent layers. This can lead to a very high number of parameters, especially in large networks.</li>\n          <li><strong>Self-Attention Efficiency:</strong> In contrast, self-attention layers use query (Q), key (K), and value (V) matrices to compute attention scores. The number of parameters in these matrices does not directly depend on the input size but rather on the chosen embedding size (dimensionality of Q, K, and V). This can lead to fewer parameters when the embedding size is smaller than the input size.</li>\n        </ul>\n      </li>\n      <li><strong>Handling Variable-Length Input:</strong>\n        <ul>\n          <li><strong>Flexibility:</strong> Self-attention layers are inherently suited for variable-length input, such as sentences in natural language processing, which can vary in length.</li>\n          <li><strong>Implementation:</strong> Since attention is computed pairwise between elements (e.g., words in a sentence), it naturally adapts to the length of the input. In contrast, fully connected layers require a fixed-size input, and adapting them to variable-length data often involves additional mechanisms like padding or truncation.</li>\n        </ul>\n      </li>\n      <li><strong>Additional Considerations</strong>\n        <ul>\n          <li><strong>Computational Efficiency:</strong> While self-attention can be more parameter-efficient, it can also be computationally intensive, especially for very long sequences, as the computation grows quadratically with sequence length.</li>\n          <li><strong>Global Context:</strong> Self-attention layers can capture global dependencies in the input data, as each output element is a function of all input elements. This is particularly advantageous in tasks like language understanding, where context is crucial.</li>\n        </ul>\n      </li>\n      <li><strong>Conclusion</strong> Self-attention layers offer interpretability through attention scores, can be more parameter-efficient depending on the embedding size, and are naturally adaptable to variable-length inputs. These qualities make them particularly powerful in applications like language processing and sequence modeling, where context and relationships between input elements are key to effective modeling.</li>\n    </ul>\n<ul>\n          <li><strong>Mechanism:</strong>Self-attention mechanisms compute attention scores representing the influence or ‘attention’ each input element should receive from other elements.</li>\n          <li><strong>Advantage:</strong> These attention scores provide a form of interpretability. By examining the attention scores, one can understand the relationships and dependencies the model is inferring between different parts of the input. For instance, in language models, this can show which words or phrases the model considers relevant when processing a given word.</li>\n        </ul>\n<ul>\n          <li><strong>Comparison with Fully Connected Layers:</strong> Fully connected layers have a separate parameter for each connection between neurons in adjacent layers. This can lead to a very high number of parameters, especially in large networks.</li>\n          <li><strong>Self-Attention Efficiency:</strong> In contrast, self-attention layers use query (Q), key (K), and value (V) matrices to compute attention scores. The number of parameters in these matrices does not directly depend on the input size but rather on the chosen embedding size (dimensionality of Q, K, and V). This can lead to fewer parameters when the embedding size is smaller than the input size.</li>\n        </ul>\n<ul>\n          <li><strong>Flexibility:</strong> Self-attention layers are inherently suited for variable-length input, such as sentences in natural language processing, which can vary in length.</li>\n          <li><strong>Implementation:</strong> Since attention is computed pairwise between elements (e.g., words in a sentence), it naturally adapts to the length of the input. In contrast, fully connected layers require a fixed-size input, and adapting them to variable-length data often involves additional mechanisms like padding or truncation.</li>\n        </ul>\n<ul>\n          <li><strong>Computational Efficiency:</strong> While self-attention can be more parameter-efficient, it can also be computationally intensive, especially for very long sequences, as the computation grows quadratically with sequence length.</li>\n          <li><strong>Global Context:</strong> Self-attention layers can capture global dependencies in the input data, as each output element is a function of all input elements. This is particularly advantageous in tasks like language understanding, where context is crucial.</li>\n        </ul>",
      "contentMarkdown": "*   Fully connected layers and self-attention layers both enable all-to-all interactions among their inputs, but they do so in fundamentally different ways, each offering unique advantages. The self-attention layer, especially as used in Transformer models, has several key benefits:\n*   **Advantages of Self-Attention Layer**\n    *   **Interpretability via Attention Scores:**\n        *   **Mechanism:**Self-attention mechanisms compute attention scores representing the influence or ‘attention’ each input element should receive from other elements.\n        *   **Advantage:** These attention scores provide a form of interpretability. By examining the attention scores, one can understand the relationships and dependencies the model is inferring between different parts of the input. For instance, in language models, this can show which words or phrases the model considers relevant when processing a given word.\n    *   **Parameter Efficiency in Some Cases:**\n        *   **Comparison with Fully Connected Layers:** Fully connected layers have a separate parameter for each connection between neurons in adjacent layers. This can lead to a very high number of parameters, especially in large networks.\n        *   **Self-Attention Efficiency:** In contrast, self-attention layers use query (Q), key (K), and value (V) matrices to compute attention scores. The number of parameters in these matrices does not directly depend on the input size but rather on the chosen embedding size (dimensionality of Q, K, and V). This can lead to fewer parameters when the embedding size is smaller than the input size.\n    *   **Handling Variable-Length Input:**\n        *   **Flexibility:** Self-attention layers are inherently suited for variable-length input, such as sentences in natural language processing, which can vary in length.\n        *   **Implementation:** Since attention is computed pairwise between elements (e.g., words in a sentence), it naturally adapts to the length of the input. In contrast, fully connected layers require a fixed-size input, and adapting them to variable-length data often involves additional mechanisms like padding or truncation.\n    *   **Additional Considerations**\n        *   **Computational Efficiency:** While self-attention can be more parameter-efficient, it can also be computationally intensive, especially for very long sequences, as the computation grows quadratically with sequence length.\n        *   **Global Context:** Self-attention layers can capture global dependencies in the input data, as each output element is a function of all input elements. This is particularly advantageous in tasks like language understanding, where context is crucial.\n    *   **Conclusion** Self-attention layers offer interpretability through attention scores, can be more parameter-efficient depending on the embedding size, and are naturally adaptable to variable-length inputs. These qualities make them particularly powerful in applications like language processing and sequence modeling, where context and relationships between input elements are key to effective modeling.\n\n*   **Interpretability via Attention Scores:**\n    *   **Mechanism:**Self-attention mechanisms compute attention scores representing the influence or ‘attention’ each input element should receive from other elements.\n    *   **Advantage:** These attention scores provide a form of interpretability. By examining the attention scores, one can understand the relationships and dependencies the model is inferring between different parts of the input. For instance, in language models, this can show which words or phrases the model considers relevant when processing a given word.\n*   **Parameter Efficiency in Some Cases:**\n    *   **Comparison with Fully Connected Layers:** Fully connected layers have a separate parameter for each connection between neurons in adjacent layers. This can lead to a very high number of parameters, especially in large networks.\n    *   **Self-Attention Efficiency:** In contrast, self-attention layers use query (Q), key (K), and value (V) matrices to compute attention scores. The number of parameters in these matrices does not directly depend on the input size but rather on the chosen embedding size (dimensionality of Q, K, and V). This can lead to fewer parameters when the embedding size is smaller than the input size.\n*   **Handling Variable-Length Input:**\n    *   **Flexibility:** Self-attention layers are inherently suited for variable-length input, such as sentences in natural language processing, which can vary in length.\n    *   **Implementation:** Since attention is computed pairwise between elements (e.g., words in a sentence), it naturally adapts to the length of the input. In contrast, fully connected layers require a fixed-size input, and adapting them to variable-length data often involves additional mechanisms like padding or truncation.\n*   **Additional Considerations**\n    *   **Computational Efficiency:** While self-attention can be more parameter-efficient, it can also be computationally intensive, especially for very long sequences, as the computation grows quadratically with sequence length.\n    *   **Global Context:** Self-attention layers can capture global dependencies in the input data, as each output element is a function of all input elements. This is particularly advantageous in tasks like language understanding, where context is crucial.\n*   **Conclusion** Self-attention layers offer interpretability through attention scores, can be more parameter-efficient depending on the embedding size, and are naturally adaptable to variable-length inputs. These qualities make them particularly powerful in applications like language processing and sequence modeling, where context and relationships between input elements are key to effective modeling.\n\n*   **Mechanism:**Self-attention mechanisms compute attention scores representing the influence or ‘attention’ each input element should receive from other elements.\n*   **Advantage:** These attention scores provide a form of interpretability. By examining the attention scores, one can understand the relationships and dependencies the model is inferring between different parts of the input. For instance, in language models, this can show which words or phrases the model considers relevant when processing a given word.\n\n*   **Comparison with Fully Connected Layers:** Fully connected layers have a separate parameter for each connection between neurons in adjacent layers. This can lead to a very high number of parameters, especially in large networks.\n*   **Self-Attention Efficiency:** In contrast, self-attention layers use query (Q), key (K), and value (V) matrices to compute attention scores. The number of parameters in these matrices does not directly depend on the input size but rather on the chosen embedding size (dimensionality of Q, K, and V). This can lead to fewer parameters when the embedding size is smaller than the input size.\n\n*   **Flexibility:** Self-attention layers are inherently suited for variable-length input, such as sentences in natural language processing, which can vary in length.\n*   **Implementation:** Since attention is computed pairwise between elements (e.g., words in a sentence), it naturally adapts to the length of the input. In contrast, fully connected layers require a fixed-size input, and adapting them to variable-length data often involves additional mechanisms like padding or truncation.\n\n*   **Computational Efficiency:** While self-attention can be more parameter-efficient, it can also be computationally intensive, especially for very long sequences, as the computation grows quadratically with sequence length.\n*   **Global Context:** Self-attention layers can capture global dependencies in the input data, as each output element is a function of all input elements. This is particularly advantageous in tasks like language understanding, where context is crucial.",
      "order": 114,
      "orderInChapter": 114,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "embedding"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1094,
        "contentLength": 9194
      },
      "nextCards": [
        "ai-interview-what-is-the-advantage-of-using-a-self-attention-ba-115",
        "ai-interview-what-is-self-supervised-learning-can-you-give-some-116"
      ],
      "relatedCards": [
        "ai-architectures-how-does-a-transformer-work-internally-18",
        "ai-diffusion-models-in-the-context-of-diffusion-models-what-role-does--50",
        "ai-transformers-did-the-original-transformer-use-absolute-or-relat-56",
        "ai-state-space-models-samba-simple-hybrid-state-space-models-for-efficie-8",
        "ai-gemma-3n-alternating-updates-for-efficient-transformers-alt-9"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#both-a-fully-connected-layer-and-a-self-attention-layer-allow-for-all-to-all-interactions.-what-is-the-advantage-of-a-self-attention-layer?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-advantage-of-using-a-self-attention-ba-115",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Advantage of Using a Self-attention-based ViT Model Compared to Using Fully CNN Layers?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>ViT stands for Vision Transformer, a model that applies the Transformer architecture, typically used in natural language processing (NLP), to computer vision tasks. This model, introduced by researchers at Google, represents a significant shift in the approach to image processing tasks, traditionally dominated by Convolutional Neural Networks (CNNs).</li>\n  <li><strong>What’s Interesting About ViT?</strong>\n    <ul>\n      <li><strong>Application of Transformers to Images:</strong> ViT adapts the Transformer architecture, which was originally designed for sequence-to-sequence tasks like language translation, to handle image data. It treats images not as 2D grids of pixels but as sequences of flattened image patches.</li>\n      <li><strong>Patch-Based Image Processing:</strong> An image in ViT is divided into fixed-size patches, which are then linearly embedded (similar to word embeddings in NLP). These embedded patches are treated as tokens in a sequence, making the Transformer’s self-attention mechanism applicable to them.</li>\n      <li><strong>Global Context:</strong> Unlike CNNs, which process local receptive fields, the self-attention mechanism in ViT allows each patch to attend to all other patches. This enables the model to capture global context in the image, potentially leading to a richer understanding of the scene.</li>\n    </ul>\n  </li>\n  <li><strong>Advantages of Transformer-Based Self-Attention in Vision Models</strong>\n    <ul>\n      <li><strong>Capturing Long-Range Dependencies:</strong> Self-attention allows the model to capture relationships between distant parts of the image in a way that CNNs, with their local receptive fields, cannot easily achieve. This is beneficial for understanding complex scenes where the context is important.</li>\n      <li><strong>Flexibility and Scalability:</strong> The Transformer architecture is inherently scalable and can be effectively trained on large datasets. ViT, in particular, has shown impressive performance gains when trained on very large image datasets.</li>\n      <li><strong>Reduced Inductive Bias:</strong> CNNs come with a strong inductive bias towards spatial hierarchies and locality, which is generally beneficial for image data but can also limit their flexibility. Transformers, having less inductive bias, can learn different types of representations depending on the task and data.</li>\n      <li><strong>Efficiency with Larger Images:</strong> For large images, the ability of self-attention to process the entire image at once can be computationally more efficient than the sliding window approach of CNNs.</li>\n    </ul>\n  </li>\n  <li><strong>Considerations</strong>\n    <ul>\n      <li><strong>Data and Compute Intensive:</strong> ViT models tend to require significant amounts of data and computational resources to outperform CNNs, particularly on smaller datasets or less complex tasks where the inductive biases of CNNs are advantageous.</li>\n      <li><strong>Positional Encodings:</strong> Just like in NLP, positional encodings are used in ViT to retain information about the position of patches in the image.</li>\n    </ul>\n  </li>\n  <li>In summary, the Vision Transformer presents an innovative approach to image processing, leveraging the global receptive fields and scalability of the Transformer architecture. It has opened up new possibilities in computer vision, particularly for tasks where understanding the global context is crucial. However, the trade-offs in terms of data and computational requirements need to be considered when choosing between ViT and traditional CNN-based approaches.</li>\n</ul>\n<ul>\n      <li><strong>Application of Transformers to Images:</strong> ViT adapts the Transformer architecture, which was originally designed for sequence-to-sequence tasks like language translation, to handle image data. It treats images not as 2D grids of pixels but as sequences of flattened image patches.</li>\n      <li><strong>Patch-Based Image Processing:</strong> An image in ViT is divided into fixed-size patches, which are then linearly embedded (similar to word embeddings in NLP). These embedded patches are treated as tokens in a sequence, making the Transformer’s self-attention mechanism applicable to them.</li>\n      <li><strong>Global Context:</strong> Unlike CNNs, which process local receptive fields, the self-attention mechanism in ViT allows each patch to attend to all other patches. This enables the model to capture global context in the image, potentially leading to a richer understanding of the scene.</li>\n    </ul>\n<ul>\n      <li><strong>Capturing Long-Range Dependencies:</strong> Self-attention allows the model to capture relationships between distant parts of the image in a way that CNNs, with their local receptive fields, cannot easily achieve. This is beneficial for understanding complex scenes where the context is important.</li>\n      <li><strong>Flexibility and Scalability:</strong> The Transformer architecture is inherently scalable and can be effectively trained on large datasets. ViT, in particular, has shown impressive performance gains when trained on very large image datasets.</li>\n      <li><strong>Reduced Inductive Bias:</strong> CNNs come with a strong inductive bias towards spatial hierarchies and locality, which is generally beneficial for image data but can also limit their flexibility. Transformers, having less inductive bias, can learn different types of representations depending on the task and data.</li>\n      <li><strong>Efficiency with Larger Images:</strong> For large images, the ability of self-attention to process the entire image at once can be computationally more efficient than the sliding window approach of CNNs.</li>\n    </ul>\n<ul>\n      <li><strong>Data and Compute Intensive:</strong> ViT models tend to require significant amounts of data and computational resources to outperform CNNs, particularly on smaller datasets or less complex tasks where the inductive biases of CNNs are advantageous.</li>\n      <li><strong>Positional Encodings:</strong> Just like in NLP, positional encodings are used in ViT to retain information about the position of patches in the image.</li>\n    </ul>",
      "contentMarkdown": "*   ViT stands for Vision Transformer, a model that applies the Transformer architecture, typically used in natural language processing (NLP), to computer vision tasks. This model, introduced by researchers at Google, represents a significant shift in the approach to image processing tasks, traditionally dominated by Convolutional Neural Networks (CNNs).\n*   **What’s Interesting About ViT?**\n    *   **Application of Transformers to Images:** ViT adapts the Transformer architecture, which was originally designed for sequence-to-sequence tasks like language translation, to handle image data. It treats images not as 2D grids of pixels but as sequences of flattened image patches.\n    *   **Patch-Based Image Processing:** An image in ViT is divided into fixed-size patches, which are then linearly embedded (similar to word embeddings in NLP). These embedded patches are treated as tokens in a sequence, making the Transformer’s self-attention mechanism applicable to them.\n    *   **Global Context:** Unlike CNNs, which process local receptive fields, the self-attention mechanism in ViT allows each patch to attend to all other patches. This enables the model to capture global context in the image, potentially leading to a richer understanding of the scene.\n*   **Advantages of Transformer-Based Self-Attention in Vision Models**\n    *   **Capturing Long-Range Dependencies:** Self-attention allows the model to capture relationships between distant parts of the image in a way that CNNs, with their local receptive fields, cannot easily achieve. This is beneficial for understanding complex scenes where the context is important.\n    *   **Flexibility and Scalability:** The Transformer architecture is inherently scalable and can be effectively trained on large datasets. ViT, in particular, has shown impressive performance gains when trained on very large image datasets.\n    *   **Reduced Inductive Bias:** CNNs come with a strong inductive bias towards spatial hierarchies and locality, which is generally beneficial for image data but can also limit their flexibility. Transformers, having less inductive bias, can learn different types of representations depending on the task and data.\n    *   **Efficiency with Larger Images:** For large images, the ability of self-attention to process the entire image at once can be computationally more efficient than the sliding window approach of CNNs.\n*   **Considerations**\n    *   **Data and Compute Intensive:** ViT models tend to require significant amounts of data and computational resources to outperform CNNs, particularly on smaller datasets or less complex tasks where the inductive biases of CNNs are advantageous.\n    *   **Positional Encodings:** Just like in NLP, positional encodings are used in ViT to retain information about the position of patches in the image.\n*   In summary, the Vision Transformer presents an innovative approach to image processing, leveraging the global receptive fields and scalability of the Transformer architecture. It has opened up new possibilities in computer vision, particularly for tasks where understanding the global context is crucial. However, the trade-offs in terms of data and computational requirements need to be considered when choosing between ViT and traditional CNN-based approaches.\n\n*   **Application of Transformers to Images:** ViT adapts the Transformer architecture, which was originally designed for sequence-to-sequence tasks like language translation, to handle image data. It treats images not as 2D grids of pixels but as sequences of flattened image patches.\n*   **Patch-Based Image Processing:** An image in ViT is divided into fixed-size patches, which are then linearly embedded (similar to word embeddings in NLP). These embedded patches are treated as tokens in a sequence, making the Transformer’s self-attention mechanism applicable to them.\n*   **Global Context:** Unlike CNNs, which process local receptive fields, the self-attention mechanism in ViT allows each patch to attend to all other patches. This enables the model to capture global context in the image, potentially leading to a richer understanding of the scene.\n\n*   **Capturing Long-Range Dependencies:** Self-attention allows the model to capture relationships between distant parts of the image in a way that CNNs, with their local receptive fields, cannot easily achieve. This is beneficial for understanding complex scenes where the context is important.\n*   **Flexibility and Scalability:** The Transformer architecture is inherently scalable and can be effectively trained on large datasets. ViT, in particular, has shown impressive performance gains when trained on very large image datasets.\n*   **Reduced Inductive Bias:** CNNs come with a strong inductive bias towards spatial hierarchies and locality, which is generally beneficial for image data but can also limit their flexibility. Transformers, having less inductive bias, can learn different types of representations depending on the task and data.\n*   **Efficiency with Larger Images:** For large images, the ability of self-attention to process the entire image at once can be computationally more efficient than the sliding window approach of CNNs.\n\n*   **Data and Compute Intensive:** ViT models tend to require significant amounts of data and computational resources to outperform CNNs, particularly on smaller datasets or less complex tasks where the inductive biases of CNNs are advantageous.\n*   **Positional Encodings:** Just like in NLP, positional encodings are used in ViT to retain information about the position of patches in the image.",
      "order": 115,
      "orderInChapter": 115,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "neural network",
        "transformer",
        "attention",
        "embedding",
        "convolution",
        "cnn",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 807,
        "contentLength": 6212
      },
      "nextCards": [
        "ai-interview-what-is-self-supervised-learning-can-you-give-some-116",
        "ai-interview-did-the-original-transformer-use-absolute-or-relat-117"
      ],
      "relatedCards": [
        "ai-diffusion-models-patch-n-pack-navit-a-vision-transformer-for-any-as-62",
        "ai-transformers-transformer-core-5",
        "ai-transformers-gnns-build-representations-of-graphs-23",
        "ai-transformers-vision-2",
        "ai-vit-why-does-vit-use-linear-projections-of-flattened-p-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-advantage-of-using-a-self-attention-based-vit-model-compared-to-using-fully-cnn-layers?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-self-supervised-learning-can-you-give-some-116",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Self-supervised Learning? Can You Give Some Examples of Self-supervised Learning Paradigms?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Self-supervised learning is a subset of unsupervised learning, which has gained significant traction in machine learning, particularly in fields like natural language processing (NLP) and computer vision. This approach involves using the data itself to generate supervisory signals, effectively creating a learning task without the need for externally labeled data.</li>\n  <li><strong>Overview of Self-Supervised Learning</strong>\n    <ul>\n      <li><strong>Data as its Own Supervisor:</strong> In self-supervised learning, algorithms generate labels from the data itself. The model is tasked with predicting some part of the data using other parts of the same data as context, thus leveraging the inherent structure within the data for learning.</li>\n      <li><strong>Automatic Label Generation:</strong> The key aspect of this approach is that it doesn’t rely on human-annotated labels. Instead, it auto-generates labels, making it scalable and less reliant on often expensive and time-consuming manual labeling processes.</li>\n    </ul>\n  </li>\n  <li><strong>Examples of Self-Supervised Learning Paradigms</strong></li>\n  <li><strong>Contrastive Learning:</strong>\n    <ul>\n      <li><strong>SimCLR, MoCo:</strong> These are frameworks used primarily in computer vision. They involve creating positive pairs of augmented samples from the same original image and negative pairs from different images. The learning task is to bring the representations of positive pairs closer together while pushing the negative pairs apart. This approach helps the model learn robust feature representations that are invariant to the augmentations.</li>\n      <li><strong>Key Idea:</strong> By learning to identify which samples are similar or ‘positive’ (augmentations of the same image) and which are ‘negative’ (different images), the model develops an understanding of the essential features and patterns in the visual data.</li>\n    </ul>\n  </li>\n  <li><strong>Masked Language Modeling (MLM):</strong>\n    <ul>\n      <li><strong>BERT in NLP:</strong> In this paradigm, used in models like BERT, certain words in the input text are masked, and the model’s task is to predict these masked words. This forces the model to understand context and relationships between words.</li>\n      <li><strong>Vision Models:</strong> A similar approach can be applied to vision, where parts of an image are masked, and the model learns to predict these missing parts, thereby understanding the structure and content of the visual data.</li>\n    </ul>\n  </li>\n  <li><strong>Key Characteristics and Advantages</strong>\n    <ul>\n      <li><strong>Learning Rich Representations:</strong> Self-supervised learning enables models to learn rich representations of data, capturing underlying structures and relationships without explicit external labels.</li>\n      <li><strong>Scalability:</strong> Since it doesn’t require labeled data, self-supervised learning can be applied to much larger datasets, making it highly scalable.</li>\n      <li><strong>Versatility:</strong> It is versatile and can be applied to various types of data, including text, images, and audio.</li>\n    </ul>\n  </li>\n  <li><strong>Conclusion</strong>: Self-supervised learning represents a powerful paradigm in modern machine learning, particularly useful in situations where labeled data is scarce or expensive to obtain. By creatively using the data itself to generate learning tasks, self-supervised learning models can uncover complex patterns and relationships within the data, leading to robust and generalizable representations. This approach has been instrumental in recent advances in fields like NLP and computer vision, demonstrating the potential of learning from large amounts of unlabeled data.</li>\n</ul>\n<ul>\n      <li><strong>Data as its Own Supervisor:</strong> In self-supervised learning, algorithms generate labels from the data itself. The model is tasked with predicting some part of the data using other parts of the same data as context, thus leveraging the inherent structure within the data for learning.</li>\n      <li><strong>Automatic Label Generation:</strong> The key aspect of this approach is that it doesn’t rely on human-annotated labels. Instead, it auto-generates labels, making it scalable and less reliant on often expensive and time-consuming manual labeling processes.</li>\n    </ul>\n<ul>\n      <li><strong>SimCLR, MoCo:</strong> These are frameworks used primarily in computer vision. They involve creating positive pairs of augmented samples from the same original image and negative pairs from different images. The learning task is to bring the representations of positive pairs closer together while pushing the negative pairs apart. This approach helps the model learn robust feature representations that are invariant to the augmentations.</li>\n      <li><strong>Key Idea:</strong> By learning to identify which samples are similar or ‘positive’ (augmentations of the same image) and which are ‘negative’ (different images), the model develops an understanding of the essential features and patterns in the visual data.</li>\n    </ul>\n<ul>\n      <li><strong>BERT in NLP:</strong> In this paradigm, used in models like BERT, certain words in the input text are masked, and the model’s task is to predict these masked words. This forces the model to understand context and relationships between words.</li>\n      <li><strong>Vision Models:</strong> A similar approach can be applied to vision, where parts of an image are masked, and the model learns to predict these missing parts, thereby understanding the structure and content of the visual data.</li>\n    </ul>\n<ul>\n      <li><strong>Learning Rich Representations:</strong> Self-supervised learning enables models to learn rich representations of data, capturing underlying structures and relationships without explicit external labels.</li>\n      <li><strong>Scalability:</strong> Since it doesn’t require labeled data, self-supervised learning can be applied to much larger datasets, making it highly scalable.</li>\n      <li><strong>Versatility:</strong> It is versatile and can be applied to various types of data, including text, images, and audio.</li>\n    </ul>",
      "contentMarkdown": "*   Self-supervised learning is a subset of unsupervised learning, which has gained significant traction in machine learning, particularly in fields like natural language processing (NLP) and computer vision. This approach involves using the data itself to generate supervisory signals, effectively creating a learning task without the need for externally labeled data.\n*   **Overview of Self-Supervised Learning**\n    *   **Data as its Own Supervisor:** In self-supervised learning, algorithms generate labels from the data itself. The model is tasked with predicting some part of the data using other parts of the same data as context, thus leveraging the inherent structure within the data for learning.\n    *   **Automatic Label Generation:** The key aspect of this approach is that it doesn’t rely on human-annotated labels. Instead, it auto-generates labels, making it scalable and less reliant on often expensive and time-consuming manual labeling processes.\n*   **Examples of Self-Supervised Learning Paradigms**\n*   **Contrastive Learning:**\n    *   **SimCLR, MoCo:** These are frameworks used primarily in computer vision. They involve creating positive pairs of augmented samples from the same original image and negative pairs from different images. The learning task is to bring the representations of positive pairs closer together while pushing the negative pairs apart. This approach helps the model learn robust feature representations that are invariant to the augmentations.\n    *   **Key Idea:** By learning to identify which samples are similar or ‘positive’ (augmentations of the same image) and which are ‘negative’ (different images), the model develops an understanding of the essential features and patterns in the visual data.\n*   **Masked Language Modeling (MLM):**\n    *   **BERT in NLP:** In this paradigm, used in models like BERT, certain words in the input text are masked, and the model’s task is to predict these masked words. This forces the model to understand context and relationships between words.\n    *   **Vision Models:** A similar approach can be applied to vision, where parts of an image are masked, and the model learns to predict these missing parts, thereby understanding the structure and content of the visual data.\n*   **Key Characteristics and Advantages**\n    *   **Learning Rich Representations:** Self-supervised learning enables models to learn rich representations of data, capturing underlying structures and relationships without explicit external labels.\n    *   **Scalability:** Since it doesn’t require labeled data, self-supervised learning can be applied to much larger datasets, making it highly scalable.\n    *   **Versatility:** It is versatile and can be applied to various types of data, including text, images, and audio.\n*   **Conclusion**: Self-supervised learning represents a powerful paradigm in modern machine learning, particularly useful in situations where labeled data is scarce or expensive to obtain. By creatively using the data itself to generate learning tasks, self-supervised learning models can uncover complex patterns and relationships within the data, leading to robust and generalizable representations. This approach has been instrumental in recent advances in fields like NLP and computer vision, demonstrating the potential of learning from large amounts of unlabeled data.\n\n*   **Data as its Own Supervisor:** In self-supervised learning, algorithms generate labels from the data itself. The model is tasked with predicting some part of the data using other parts of the same data as context, thus leveraging the inherent structure within the data for learning.\n*   **Automatic Label Generation:** The key aspect of this approach is that it doesn’t rely on human-annotated labels. Instead, it auto-generates labels, making it scalable and less reliant on often expensive and time-consuming manual labeling processes.\n\n*   **SimCLR, MoCo:** These are frameworks used primarily in computer vision. They involve creating positive pairs of augmented samples from the same original image and negative pairs from different images. The learning task is to bring the representations of positive pairs closer together while pushing the negative pairs apart. This approach helps the model learn robust feature representations that are invariant to the augmentations.\n*   **Key Idea:** By learning to identify which samples are similar or ‘positive’ (augmentations of the same image) and which are ‘negative’ (different images), the model develops an understanding of the essential features and patterns in the visual data.\n\n*   **BERT in NLP:** In this paradigm, used in models like BERT, certain words in the input text are masked, and the model’s task is to predict these masked words. This forces the model to understand context and relationships between words.\n*   **Vision Models:** A similar approach can be applied to vision, where parts of an image are masked, and the model learns to predict these missing parts, thereby understanding the structure and content of the visual data.\n\n*   **Learning Rich Representations:** Self-supervised learning enables models to learn rich representations of data, capturing underlying structures and relationships without explicit external labels.\n*   **Scalability:** Since it doesn’t require labeled data, self-supervised learning can be applied to much larger datasets, making it highly scalable.\n*   **Versatility:** It is versatile and can be applied to various types of data, including text, images, and audio.",
      "order": 116,
      "orderInChapter": 116,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "machine learning",
        "bert",
        "nlp",
        "computer vision",
        "supervised learning",
        "unsupervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 806,
        "contentLength": 6227
      },
      "nextCards": [
        "ai-interview-did-the-original-transformer-use-absolute-or-relat-117",
        "ai-interview-how-does-the-choice-of-positional-encoding-method--118"
      ],
      "relatedCards": [
        "ai-model-compression-accuracy-results-18",
        "ai-ml-comp-model-ensembles-7",
        "ai-model-compression-distillation-in-practice-27",
        "ai-clustering-partitioning-clustering-1",
        "ai-encoder-vs-decoder-models-pros-and-cons-of-encoder-models-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-self-supervised-learning?-can-you-give-some-examples-of-self-supervised-learning-paradigms?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-did-the-original-transformer-use-absolute-or-relat-117",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Did the Original Transformer Use Absolute or Relative Positional Encoding?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The original Transformer model, as introduced by Vaswani et al. in their 2017 paper “Attention Is All You Need”, used absolute positional encoding. This design was a key feature to incorporate the notion of sequence order into the model’s architecture.</li>\n  <li><strong>Absolute Positional Encoding in the Original Transformer</strong>\n    <ul>\n      <li><strong>Mechanism:</strong>\n        <ul>\n          <li>The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.</li>\n          <li>Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.</li>\n        </ul>\n      </li>\n      <li><strong>Implementation:</strong> The positional encodings used were fixed (not learned) and were based on sine and cosine functions of different frequencies. This choice was intended to allow the model to easily learn to attend by relative positions since for any fixed offset <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-138-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>,</mo><mi>P</mi><msub><mi>E</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi><mi>o</mi><mi>s</mi><mo>+</mo><mi>k</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1104\" style=\"width: 4.846em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.013em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.01em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1105\"><span class=\"mi\" id=\"MathJax-Span-1106\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1107\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1108\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"msubsup\" id=\"MathJax-Span-1109\"><span style=\"display: inline-block; position: relative; width: 2.503em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1110\" style=\"font-family: STIXGeneral-Italic;\">E<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-1111\"><span class=\"mrow\" id=\"MathJax-Span-1112\"><span class=\"mi\" id=\"MathJax-Span-1113\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-1114\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">o</span><span class=\"mi\" id=\"MathJax-Span-1115\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-1116\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">+</span><span class=\"mi\" id=\"MathJax-Span-1117\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi><mo>,</mo><mi>P</mi><msub><mi>E</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>p</mi><mi>o</mi><mi>s</mi><mo>+</mo><mi>k</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-138\">k, PE_{pos + k}</script> could be represented as a linear function of <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-139-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><msub><mi>E</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi><mi>o</mi><mi>s</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1118\" style=\"width: 2.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.242em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1119\"><span class=\"mi\" id=\"MathJax-Span-1120\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"msubsup\" id=\"MathJax-Span-1121\"><span style=\"display: inline-block; position: relative; width: 1.669em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1122\" style=\"font-family: STIXGeneral-Italic;\">E<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-1123\"><span class=\"mrow\" id=\"MathJax-Span-1124\"><span class=\"mi\" id=\"MathJax-Span-1125\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-1126\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">o</span><span class=\"mi\" id=\"MathJax-Span-1127\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">s</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><msub><mi>E</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>p</mi><mi>o</mi><mi>s</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-139\">PE_{pos}</script>.</li>\n    </ul>\n  </li>\n  <li><strong>Importance:</strong> This approach to positional encoding was crucial for enabling the model to understand the order of tokens in a sequence, a fundamental aspect of processing sequential data like text.</li>\n  <li><strong>Relative and Rotary Positional Encoding in Later Models</strong>\n    <ul>\n      <li>After the introduction of the original Transformer, subsequent research explored alternative ways to incorporate positional information. One such development was the use of relative positional encoding, which, instead of assigning a unique encoding to each absolute position, encodes the relative positions of tokens with respect to each other. This method has been found to be effective in certain contexts and has been adopted in various Transformer-based models developed after the original Transformer. Rotary positional encoding methods (such as RoPE) were also presented after relative positional encoding methods.</li>\n    </ul>\n  </li>\n  <li><strong>Conclusion:</strong> In summary, the original Transformer model utilized absolute positional encoding to integrate sequence order into its architecture. This approach was foundational in the development of Transformer models, while later variations and improvements, including relative positional encoding, have been explored in subsequent research to further enhance the model’s capabilities.</li>\n</ul>\n<ul>\n      <li><strong>Mechanism:</strong>\n        <ul>\n          <li>The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.</li>\n          <li>Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.</li>\n        </ul>\n      </li>\n      <li><strong>Implementation:</strong> The positional encodings used were fixed (not learned) and were based on sine and cosine functions of different frequencies. This choice was intended to allow the model to easily learn to attend by relative positions since for any fixed offset <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-138-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>,</mo><mi>P</mi><msub><mi>E</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi><mi>o</mi><mi>s</mi><mo>+</mo><mi>k</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1104\" style=\"width: 4.846em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.013em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.01em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1105\"><span class=\"mi\" id=\"MathJax-Span-1106\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1107\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1108\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"msubsup\" id=\"MathJax-Span-1109\"><span style=\"display: inline-block; position: relative; width: 2.503em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1110\" style=\"font-family: STIXGeneral-Italic;\">E<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-1111\"><span class=\"mrow\" id=\"MathJax-Span-1112\"><span class=\"mi\" id=\"MathJax-Span-1113\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-1114\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">o</span><span class=\"mi\" id=\"MathJax-Span-1115\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-1116\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">+</span><span class=\"mi\" id=\"MathJax-Span-1117\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi><mo>,</mo><mi>P</mi><msub><mi>E</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>p</mi><mi>o</mi><mi>s</mi><mo>+</mo><mi>k</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-138\">k, PE_{pos + k}</script> could be represented as a linear function of <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-139-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><msub><mi>E</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi><mi>o</mi><mi>s</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1118\" style=\"width: 2.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.242em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1119\"><span class=\"mi\" id=\"MathJax-Span-1120\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"msubsup\" id=\"MathJax-Span-1121\"><span style=\"display: inline-block; position: relative; width: 1.669em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1122\" style=\"font-family: STIXGeneral-Italic;\">E<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-1123\"><span class=\"mrow\" id=\"MathJax-Span-1124\"><span class=\"mi\" id=\"MathJax-Span-1125\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-1126\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">o</span><span class=\"mi\" id=\"MathJax-Span-1127\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">s</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><msub><mi>E</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>p</mi><mi>o</mi><mi>s</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-139\">PE_{pos}</script>.</li>\n    </ul>\n<ul>\n          <li>The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.</li>\n          <li>Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.</li>\n        </ul>\n<ul>\n      <li>After the introduction of the original Transformer, subsequent research explored alternative ways to incorporate positional information. One such development was the use of relative positional encoding, which, instead of assigning a unique encoding to each absolute position, encodes the relative positions of tokens with respect to each other. This method has been found to be effective in certain contexts and has been adopted in various Transformer-based models developed after the original Transformer. Rotary positional encoding methods (such as RoPE) were also presented after relative positional encoding methods.</li>\n    </ul>",
      "contentMarkdown": "*   The original Transformer model, as introduced by Vaswani et al. in their 2017 paper “Attention Is All You Need”, used absolute positional encoding. This design was a key feature to incorporate the notion of sequence order into the model’s architecture.\n*   **Absolute Positional Encoding in the Original Transformer**\n    *   **Mechanism:**\n        *   The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.\n        *   Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.\n    *   **Implementation:** The positional encodings used were fixed (not learned) and were based on sine and cosine functions of different frequencies. This choice was intended to allow the model to easily learn to attend by relative positions since for any fixed offset k,PEpos+kk,PEpos+kk, PE\\_{pos + k} could be represented as a linear function of PEposPEposPE\\_{pos}.\n*   **Importance:** This approach to positional encoding was crucial for enabling the model to understand the order of tokens in a sequence, a fundamental aspect of processing sequential data like text.\n*   **Relative and Rotary Positional Encoding in Later Models**\n    *   After the introduction of the original Transformer, subsequent research explored alternative ways to incorporate positional information. One such development was the use of relative positional encoding, which, instead of assigning a unique encoding to each absolute position, encodes the relative positions of tokens with respect to each other. This method has been found to be effective in certain contexts and has been adopted in various Transformer-based models developed after the original Transformer. Rotary positional encoding methods (such as RoPE) were also presented after relative positional encoding methods.\n*   **Conclusion:** In summary, the original Transformer model utilized absolute positional encoding to integrate sequence order into its architecture. This approach was foundational in the development of Transformer models, while later variations and improvements, including relative positional encoding, have been explored in subsequent research to further enhance the model’s capabilities.\n\n*   **Mechanism:**\n    *   The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.\n    *   Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.\n*   **Implementation:** The positional encodings used were fixed (not learned) and were based on sine and cosine functions of different frequencies. This choice was intended to allow the model to easily learn to attend by relative positions since for any fixed offset k,PEpos+kk,PEpos+kk, PE\\_{pos + k} could be represented as a linear function of PEposPEposPE\\_{pos}.\n\n*   The Transformer model does not inherently capture the sequential order of the input data in its self-attention mechanism. To address this, the authors introduced absolute positional encoding.\n*   Each position in the sequence was assigned a unique positional encoding vector, which was added to the input embeddings before they were fed into the attention layers.\n\n*   After the introduction of the original Transformer, subsequent research explored alternative ways to incorporate positional information. One such development was the use of relative positional encoding, which, instead of assigning a unique encoding to each absolute position, encodes the relative positions of tokens with respect to each other. This method has been found to be effective in certain contexts and has been adopted in various Transformer-based models developed after the original Transformer. Rotary positional encoding methods (such as RoPE) were also presented after relative positional encoding methods.",
      "order": 117,
      "orderInChapter": 117,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "embedding"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 597,
        "contentLength": 15700
      },
      "nextCards": [
        "ai-interview-how-does-the-choice-of-positional-encoding-method--118",
        "ai-interview-in-llms-why-is-rope-required-for-context-length-ex-119"
      ],
      "relatedCards": [
        "ai-diffusion-models-in-the-context-of-diffusion-models-what-role-does--50",
        "ai-transformers-did-the-original-transformer-use-absolute-or-relat-56",
        "ai-state-space-models-samba-simple-hybrid-state-space-models-for-efficie-8",
        "ai-ml-runtimes-architecture-40",
        "ai-diffusion-models-deepfloyd-if-57"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#did-the-original-transformer-use-absolute-or-relative-positional-encoding?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-the-choice-of-positional-encoding-method--118",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Does the Choice of Positional Encoding Method Can Influence the Number of Parameters Added to the Model? Consinder Absolute, Relative, and Rotary Positional Encoding Mechanisms.",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In Large Language Models (LLMs), the choice of positional encoding method can influence the number of parameters added to the model. Let’s compare absolute, relative, and rotary (RoPE) positional encoding in this context:</li>\n  <li><strong>Absolute Positional Encoding</strong>\n    <ul>\n      <li><strong>Parameter Addition:</strong>\n        <ul>\n          <li>Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.</li>\n          <li>Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-140-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1128\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1129\"><span class=\"mi\" id=\"MathJax-Span-1130\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-140\">N</script> and the model dimension is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-141-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1131\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.73em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1132\"><span class=\"mi\" id=\"MathJax-Span-1133\" style=\"font-family: STIXGeneral-Italic;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-141\">D</script>, the total number of added parameters for absolute positional encoding is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-142-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1134\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1135\"><span class=\"mi\" id=\"MathJax-Span-1136\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1137\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1138\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-142\">N \\times D</script>.</li>\n        </ul>\n      </li>\n      <li><strong>Fixed and Non-Learnable:</strong> In many implementations (like the original Transformer), these positional encodings are fixed (based on sine and cosine functions) and not learnable, meaning they don’t add to the total count of trainable parameters.</li>\n    </ul>\n  </li>\n  <li><strong>Relative Positional Encoding</strong>\n    <ul>\n      <li><strong>Parameter Addition:</strong>\n        <ul>\n          <li>Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.</li>\n          <li>The exact number of added parameters can vary based on the implementation but is generally smaller than the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-143-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1139\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1140\"><span class=\"mi\" id=\"MathJax-Span-1141\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1142\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1143\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-143\">N \\times D</script> parameters required for absolute encoding.</li>\n        </ul>\n      </li>\n      <li><strong>Learnable or Fixed:</strong> Depending on the model, relative positional encodings can be either learnable or fixed, which would affect whether they contribute to the model’s total trainable parameters.</li>\n    </ul>\n  </li>\n  <li><strong>Rotary Positional Encoding (RoPE)</strong>\n    <ul>\n      <li><strong>Parameter Addition:</strong>\n        <ul>\n          <li>RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.</li>\n          <li>The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.</li>\n        </ul>\n      </li>\n      <li><strong>Efficiency:</strong> The major advantage of RoPE is its efficiency in terms of parameter count. It enables the model to capture relative positional information without increasing the number of trainable parameters.</li>\n    </ul>\n  </li>\n  <li><strong>Summary</strong>:\n    <ul>\n      <li><strong>Absolute Positional Encoding:</strong> Adds <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-144-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1144\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1145\"><span class=\"mi\" id=\"MathJax-Span-1146\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1147\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1148\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-144\">N \\times D</script> parameters, usually fixed and non-learnable.</li>\n      <li><strong>Relative Positional Encoding:</strong> Adds fewer parameters than absolute encoding, can be learnable, but the exact count varies with implementation.</li>\n      <li><strong>Rotary Positional Encoding (RoPE):</strong> Adds no additional learnable parameters, efficiently integrating positional information.</li>\n    </ul>\n  </li>\n  <li>In terms of parameter efficiency, RoPE stands out as it enriches the model with positional awareness without increasing the trainable parameter count, a significant advantage in the context of LLMs where managing the scale of parameters is crucial.</li>\n</ul>\n<ul>\n      <li><strong>Parameter Addition:</strong>\n        <ul>\n          <li>Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.</li>\n          <li>Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-140-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1128\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1129\"><span class=\"mi\" id=\"MathJax-Span-1130\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-140\">N</script> and the model dimension is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-141-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1131\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.73em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1132\"><span class=\"mi\" id=\"MathJax-Span-1133\" style=\"font-family: STIXGeneral-Italic;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-141\">D</script>, the total number of added parameters for absolute positional encoding is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-142-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1134\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1135\"><span class=\"mi\" id=\"MathJax-Span-1136\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1137\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1138\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-142\">N \\times D</script>.</li>\n        </ul>\n      </li>\n      <li><strong>Fixed and Non-Learnable:</strong> In many implementations (like the original Transformer), these positional encodings are fixed (based on sine and cosine functions) and not learnable, meaning they don’t add to the total count of trainable parameters.</li>\n    </ul>\n<ul>\n          <li>Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.</li>\n          <li>Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-140-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1128\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1129\"><span class=\"mi\" id=\"MathJax-Span-1130\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-140\">N</script> and the model dimension is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-141-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1131\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.73em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1132\"><span class=\"mi\" id=\"MathJax-Span-1133\" style=\"font-family: STIXGeneral-Italic;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-141\">D</script>, the total number of added parameters for absolute positional encoding is <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-142-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1134\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1135\"><span class=\"mi\" id=\"MathJax-Span-1136\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1137\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1138\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-142\">N \\times D</script>.</li>\n        </ul>\n<ul>\n      <li><strong>Parameter Addition:</strong>\n        <ul>\n          <li>Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.</li>\n          <li>The exact number of added parameters can vary based on the implementation but is generally smaller than the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-143-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1139\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1140\"><span class=\"mi\" id=\"MathJax-Span-1141\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1142\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1143\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-143\">N \\times D</script> parameters required for absolute encoding.</li>\n        </ul>\n      </li>\n      <li><strong>Learnable or Fixed:</strong> Depending on the model, relative positional encodings can be either learnable or fixed, which would affect whether they contribute to the model’s total trainable parameters.</li>\n    </ul>\n<ul>\n          <li>Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.</li>\n          <li>The exact number of added parameters can vary based on the implementation but is generally smaller than the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-143-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1139\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1140\"><span class=\"mi\" id=\"MathJax-Span-1141\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1142\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1143\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-143\">N \\times D</script> parameters required for absolute encoding.</li>\n        </ul>\n<ul>\n      <li><strong>Parameter Addition:</strong>\n        <ul>\n          <li>RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.</li>\n          <li>The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.</li>\n        </ul>\n      </li>\n      <li><strong>Efficiency:</strong> The major advantage of RoPE is its efficiency in terms of parameter count. It enables the model to capture relative positional information without increasing the number of trainable parameters.</li>\n    </ul>\n<ul>\n          <li>RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.</li>\n          <li>The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.</li>\n        </ul>\n<ul>\n      <li><strong>Absolute Positional Encoding:</strong> Adds <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-144-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x00D7;</mo><mi>D</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1144\" style=\"width: 3.128em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.61em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1145\"><span class=\"mi\" id=\"MathJax-Span-1146\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1147\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">×</span><span class=\"mi\" id=\"MathJax-Span-1148\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">D</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>×</mo><mi>D</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-144\">N \\times D</script> parameters, usually fixed and non-learnable.</li>\n      <li><strong>Relative Positional Encoding:</strong> Adds fewer parameters than absolute encoding, can be learnable, but the exact count varies with implementation.</li>\n      <li><strong>Rotary Positional Encoding (RoPE):</strong> Adds no additional learnable parameters, efficiently integrating positional information.</li>\n    </ul>",
      "contentMarkdown": "*   In Large Language Models (LLMs), the choice of positional encoding method can influence the number of parameters added to the model. Let’s compare absolute, relative, and rotary (RoPE) positional encoding in this context:\n*   **Absolute Positional Encoding**\n    *   **Parameter Addition:**\n        *   Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.\n        *   Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is NNN and the model dimension is DDD, the total number of added parameters for absolute positional encoding is N×DN×DN \\\\times D.\n    *   **Fixed and Non-Learnable:** In many implementations (like the original Transformer), these positional encodings are fixed (based on sine and cosine functions) and not learnable, meaning they don’t add to the total count of trainable parameters.\n*   **Relative Positional Encoding**\n    *   **Parameter Addition:**\n        *   Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.\n        *   The exact number of added parameters can vary based on the implementation but is generally smaller than the N×DN×DN \\\\times D parameters required for absolute encoding.\n    *   **Learnable or Fixed:** Depending on the model, relative positional encodings can be either learnable or fixed, which would affect whether they contribute to the model’s total trainable parameters.\n*   **Rotary Positional Encoding (RoPE)**\n    *   **Parameter Addition:**\n        *   RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.\n        *   The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.\n    *   **Efficiency:** The major advantage of RoPE is its efficiency in terms of parameter count. It enables the model to capture relative positional information without increasing the number of trainable parameters.\n*   **Summary**:\n    *   **Absolute Positional Encoding:** Adds N×DN×DN \\\\times D parameters, usually fixed and non-learnable.\n    *   **Relative Positional Encoding:** Adds fewer parameters than absolute encoding, can be learnable, but the exact count varies with implementation.\n    *   **Rotary Positional Encoding (RoPE):** Adds no additional learnable parameters, efficiently integrating positional information.\n*   In terms of parameter efficiency, RoPE stands out as it enriches the model with positional awareness without increasing the trainable parameter count, a significant advantage in the context of LLMs where managing the scale of parameters is crucial.\n\n*   **Parameter Addition:**\n    *   Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.\n    *   Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is NNN and the model dimension is DDD, the total number of added parameters for absolute positional encoding is N×DN×DN \\\\times D.\n*   **Fixed and Non-Learnable:** In many implementations (like the original Transformer), these positional encodings are fixed (based on sine and cosine functions) and not learnable, meaning they don’t add to the total count of trainable parameters.\n\n*   Absolute positional encodings typically add a fixed number of parameters to the model, depending on the maximum sequence length the model can handle.\n*   Each position in the sequence has a unique positional encoding vector. If the maximum sequence length is NNN and the model dimension is DDD, the total number of added parameters for absolute positional encoding is N×DN×DN \\\\times D.\n\n*   **Parameter Addition:**\n    *   Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.\n    *   The exact number of added parameters can vary based on the implementation but is generally smaller than the N×DN×DN \\\\times D parameters required for absolute encoding.\n*   **Learnable or Fixed:** Depending on the model, relative positional encodings can be either learnable or fixed, which would affect whether they contribute to the model’s total trainable parameters.\n\n*   Relative positional encoding often adds fewer parameters than absolute encoding, as it typically uses a set of parameters that represent relative positions rather than unique encodings for each absolute position.\n*   The exact number of added parameters can vary based on the implementation but is generally smaller than the N×DN×DN \\\\times D parameters required for absolute encoding.\n\n*   **Parameter Addition:**\n    *   RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.\n    *   The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.\n*   **Efficiency:** The major advantage of RoPE is its efficiency in terms of parameter count. It enables the model to capture relative positional information without increasing the number of trainable parameters.\n\n*   RoPE does not add any additional learnable parameters to the model. It integrates positional information through a rotation operation applied to the query and key vectors in the self-attention mechanism.\n*   The rotation is based on the position but is calculated using fixed, non-learnable trigonometric functions, similar to absolute positional encoding.\n\n*   **Absolute Positional Encoding:** Adds N×DN×DN \\\\times D parameters, usually fixed and non-learnable.\n*   **Relative Positional Encoding:** Adds fewer parameters than absolute encoding, can be learnable, but the exact count varies with implementation.\n*   **Rotary Positional Encoding (RoPE):** Adds no additional learnable parameters, efficiently integrating positional information.",
      "order": 118,
      "orderInChapter": 118,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "llm"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 911,
        "contentLength": 27229
      },
      "nextCards": [
        "ai-interview-in-llms-why-is-rope-required-for-context-length-ex-119",
        "ai-interview-is-multicollinearity-and-correlation-the-same-120"
      ],
      "relatedCards": [
        "ai-attention-sliding-window-multi-query-attention-16",
        "ai-attention-grouped-query-attention-17",
        "ai-transformers-how-does-the-choice-of-positional-encoding-method--57",
        "ai-mixture-of-experts-joint-moe-architectures-49",
        "ai-mixture-of-experts-branch-train-mix-mixing-expert-llms-into-a-mixture-86"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-the-choice-of-positional-encoding-method-can-influence-the-number-of-parameters-added-to-the-model?-consinder-absolute,-relative,-and-rotary-positional-encoding-mechanisms.",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-in-llms-why-is-rope-required-for-context-length-ex-119",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "In LLMs, Why is RoPE Required for Context Length Extension?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>RoPE, or Rotary Positional Embedding, is a technique used in some language models, particularly Transformers, for handling positional information. The need for RoPE or similar techniques becomes apparent when dealing with long context lengths in Large Language Models (LLMs).</li>\n  <li><strong>Context Length Extension in LLMs</strong>\n    <ul>\n      <li><strong>Positional Encoding in Transformers:</strong></li>\n      <li>Traditional Transformer models use positional encodings to add information about the position of tokens in a sequence. This is crucial because the self-attention mechanism is, by default, permutation-invariant (i.e., it doesn’t consider the order of tokens).</li>\n      <li>In standard implementations like the original Transformer, positional encodings are added to the token embeddings and are typically fixed (not learned) and based on sine and cosine functions of different frequencies.</li>\n      <li><strong>Challenges with Long Sequences:</strong> As the context length (number of tokens in a sequence) increases, maintaining effective positional information becomes challenging. This is especially true for fixed positional encodings, which may not scale well or capture relative positions effectively in very long sequences.</li>\n    </ul>\n  </li>\n  <li><strong>Role and Advantages of RoPE</strong>\n    <ul>\n      <li><strong>Rotary Positional Embedding:</strong> RoPE is designed to provide rotational equivariance to self-attention. It essentially encodes the absolute position and then rotates the positional encoding of keys and queries differently based on their position. This allows the model to implicitly capture relative positional information through the self-attention mechanism.</li>\n      <li><strong>Effectiveness in Long Contexts:</strong> RoPE scales effectively with sequence length, making it suitable for LLMs that need to handle long contexts or documents. This is particularly important in tasks like document summarization or question-answering over long passages.</li>\n      <li><strong>Preserving Relative Positional Information:</strong> RoPE allows the model to understand the relative positioning of tokens effectively, which is crucial in understanding the structure and meaning of sentences, especially in languages with less rigid syntax.</li>\n      <li><strong>Computational Efficiency:</strong> Compared to other methods of handling positional information in long sequences, RoPE can be more computationally efficient, as it doesn’t significantly increase the model’s complexity or the number of parameters.</li>\n    </ul>\n  </li>\n  <li><strong>Conclusion</strong>: In summary, RoPE is required for effectively extending the context length in LLMs due to its ability to handle long sequences while preserving crucial relative positional information. It offers a scalable and computationally efficient solution to one of the challenges posed by the self-attention mechanism in Transformers, particularly in scenarios where understanding the order and relationship of tokens in long sequences is essential.</li>\n</ul>\n<ul>\n      <li><strong>Positional Encoding in Transformers:</strong></li>\n      <li>Traditional Transformer models use positional encodings to add information about the position of tokens in a sequence. This is crucial because the self-attention mechanism is, by default, permutation-invariant (i.e., it doesn’t consider the order of tokens).</li>\n      <li>In standard implementations like the original Transformer, positional encodings are added to the token embeddings and are typically fixed (not learned) and based on sine and cosine functions of different frequencies.</li>\n      <li><strong>Challenges with Long Sequences:</strong> As the context length (number of tokens in a sequence) increases, maintaining effective positional information becomes challenging. This is especially true for fixed positional encodings, which may not scale well or capture relative positions effectively in very long sequences.</li>\n    </ul>\n<ul>\n      <li><strong>Rotary Positional Embedding:</strong> RoPE is designed to provide rotational equivariance to self-attention. It essentially encodes the absolute position and then rotates the positional encoding of keys and queries differently based on their position. This allows the model to implicitly capture relative positional information through the self-attention mechanism.</li>\n      <li><strong>Effectiveness in Long Contexts:</strong> RoPE scales effectively with sequence length, making it suitable for LLMs that need to handle long contexts or documents. This is particularly important in tasks like document summarization or question-answering over long passages.</li>\n      <li><strong>Preserving Relative Positional Information:</strong> RoPE allows the model to understand the relative positioning of tokens effectively, which is crucial in understanding the structure and meaning of sentences, especially in languages with less rigid syntax.</li>\n      <li><strong>Computational Efficiency:</strong> Compared to other methods of handling positional information in long sequences, RoPE can be more computationally efficient, as it doesn’t significantly increase the model’s complexity or the number of parameters.</li>\n    </ul>",
      "contentMarkdown": "*   RoPE, or Rotary Positional Embedding, is a technique used in some language models, particularly Transformers, for handling positional information. The need for RoPE or similar techniques becomes apparent when dealing with long context lengths in Large Language Models (LLMs).\n*   **Context Length Extension in LLMs**\n    *   **Positional Encoding in Transformers:**\n    *   Traditional Transformer models use positional encodings to add information about the position of tokens in a sequence. This is crucial because the self-attention mechanism is, by default, permutation-invariant (i.e., it doesn’t consider the order of tokens).\n    *   In standard implementations like the original Transformer, positional encodings are added to the token embeddings and are typically fixed (not learned) and based on sine and cosine functions of different frequencies.\n    *   **Challenges with Long Sequences:** As the context length (number of tokens in a sequence) increases, maintaining effective positional information becomes challenging. This is especially true for fixed positional encodings, which may not scale well or capture relative positions effectively in very long sequences.\n*   **Role and Advantages of RoPE**\n    *   **Rotary Positional Embedding:** RoPE is designed to provide rotational equivariance to self-attention. It essentially encodes the absolute position and then rotates the positional encoding of keys and queries differently based on their position. This allows the model to implicitly capture relative positional information through the self-attention mechanism.\n    *   **Effectiveness in Long Contexts:** RoPE scales effectively with sequence length, making it suitable for LLMs that need to handle long contexts or documents. This is particularly important in tasks like document summarization or question-answering over long passages.\n    *   **Preserving Relative Positional Information:** RoPE allows the model to understand the relative positioning of tokens effectively, which is crucial in understanding the structure and meaning of sentences, especially in languages with less rigid syntax.\n    *   **Computational Efficiency:** Compared to other methods of handling positional information in long sequences, RoPE can be more computationally efficient, as it doesn’t significantly increase the model’s complexity or the number of parameters.\n*   **Conclusion**: In summary, RoPE is required for effectively extending the context length in LLMs due to its ability to handle long sequences while preserving crucial relative positional information. It offers a scalable and computationally efficient solution to one of the challenges posed by the self-attention mechanism in Transformers, particularly in scenarios where understanding the order and relationship of tokens in long sequences is essential.\n\n*   **Positional Encoding in Transformers:**\n*   Traditional Transformer models use positional encodings to add information about the position of tokens in a sequence. This is crucial because the self-attention mechanism is, by default, permutation-invariant (i.e., it doesn’t consider the order of tokens).\n*   In standard implementations like the original Transformer, positional encodings are added to the token embeddings and are typically fixed (not learned) and based on sine and cosine functions of different frequencies.\n*   **Challenges with Long Sequences:** As the context length (number of tokens in a sequence) increases, maintaining effective positional information becomes challenging. This is especially true for fixed positional encodings, which may not scale well or capture relative positions effectively in very long sequences.\n\n*   **Rotary Positional Embedding:** RoPE is designed to provide rotational equivariance to self-attention. It essentially encodes the absolute position and then rotates the positional encoding of keys and queries differently based on their position. This allows the model to implicitly capture relative positional information through the self-attention mechanism.\n*   **Effectiveness in Long Contexts:** RoPE scales effectively with sequence length, making it suitable for LLMs that need to handle long contexts or documents. This is particularly important in tasks like document summarization or question-answering over long passages.\n*   **Preserving Relative Positional Information:** RoPE allows the model to understand the relative positioning of tokens effectively, which is crucial in understanding the structure and meaning of sentences, especially in languages with less rigid syntax.\n*   **Computational Efficiency:** Compared to other methods of handling positional information in long sequences, RoPE can be more computationally efficient, as it doesn’t significantly increase the model’s complexity or the number of parameters.",
      "order": 119,
      "orderInChapter": 119,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "transformer",
        "attention",
        "embedding",
        "llm"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 661,
        "contentLength": 5279
      },
      "nextCards": [
        "ai-interview-is-multicollinearity-and-correlation-the-same-120",
        "ai-interview-do-you-need-a-non-linearity-such-as-relu-or-sigmoi-121"
      ],
      "relatedCards": [
        "ai-transformers-in-transformer-based-models-how-does-rope-enable-c-58",
        "ai-LLM-summary-of-tricks-to-optimize-attentionmemory-usag-39",
        "ai-model-acceleration-flashattention-and-efficient-attention-kernels-14",
        "ai-RAG-response-generation-synthesis-5",
        "ai-on-device-transformers-tokenizer-and-vocabulary-size-22"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#in-llms,-why-is-rope-required-for-context-length-extension?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-multicollinearity-and-correlation-the-same-120",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Is Multicollinearity and Correlation the Same?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Multicollinearity and correlation, while related concepts, are not the same. They both deal with relationships between variables in statistical analyses, but they differ in their specific focus and implications:\n    <ol>\n      <li><strong>Correlation:</strong>\n        <ul>\n          <li>Correlation refers to any of a broad class of statistical relationships involving dependence between two variables.</li>\n          <li>The most common measure of correlation is the Pearson correlation coefficient, which assesses the linear relationship between two variables.</li>\n          <li>Correlation can be positive (both variables increase or decrease together), negative (one variable increases while the other decreases), or zero (no linear relationship).</li>\n          <li>Correlation is a bivariate (two-variable) concept.</li>\n        </ul>\n      </li>\n      <li><strong>Multicollinearity:</strong>\n        <ul>\n          <li>Multicollinearity refers specifically to a situation in regression analysis where two or more predictors (independent variables) are highly correlated.</li>\n          <li>This means that one predictor variable in a multiple regression model can be linearly predicted from the others with a substantial degree of accuracy.</li>\n          <li>Multicollinearity can make it difficult to ascertain the effect of each predictor on the dependent variable, as changes in one predictor are associated with changes in another.</li>\n          <li>It is a problem in multiple regression models, as it undermines the statistical significance of an independent variable.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>In summary, while correlation is a broader concept that describes the linear relationship between two variables, multicollinearity is a more specific situation where two or more variables in a regression model are highly correlated, potentially causing issues in interpreting the model results.</li>\n</ul>\n<ol>\n      <li><strong>Correlation:</strong>\n        <ul>\n          <li>Correlation refers to any of a broad class of statistical relationships involving dependence between two variables.</li>\n          <li>The most common measure of correlation is the Pearson correlation coefficient, which assesses the linear relationship between two variables.</li>\n          <li>Correlation can be positive (both variables increase or decrease together), negative (one variable increases while the other decreases), or zero (no linear relationship).</li>\n          <li>Correlation is a bivariate (two-variable) concept.</li>\n        </ul>\n      </li>\n      <li><strong>Multicollinearity:</strong>\n        <ul>\n          <li>Multicollinearity refers specifically to a situation in regression analysis where two or more predictors (independent variables) are highly correlated.</li>\n          <li>This means that one predictor variable in a multiple regression model can be linearly predicted from the others with a substantial degree of accuracy.</li>\n          <li>Multicollinearity can make it difficult to ascertain the effect of each predictor on the dependent variable, as changes in one predictor are associated with changes in another.</li>\n          <li>It is a problem in multiple regression models, as it undermines the statistical significance of an independent variable.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Correlation refers to any of a broad class of statistical relationships involving dependence between two variables.</li>\n          <li>The most common measure of correlation is the Pearson correlation coefficient, which assesses the linear relationship between two variables.</li>\n          <li>Correlation can be positive (both variables increase or decrease together), negative (one variable increases while the other decreases), or zero (no linear relationship).</li>\n          <li>Correlation is a bivariate (two-variable) concept.</li>\n        </ul>\n<ul>\n          <li>Multicollinearity refers specifically to a situation in regression analysis where two or more predictors (independent variables) are highly correlated.</li>\n          <li>This means that one predictor variable in a multiple regression model can be linearly predicted from the others with a substantial degree of accuracy.</li>\n          <li>Multicollinearity can make it difficult to ascertain the effect of each predictor on the dependent variable, as changes in one predictor are associated with changes in another.</li>\n          <li>It is a problem in multiple regression models, as it undermines the statistical significance of an independent variable.</li>\n        </ul>",
      "contentMarkdown": "*   Multicollinearity and correlation, while related concepts, are not the same. They both deal with relationships between variables in statistical analyses, but they differ in their specific focus and implications:\n    1.  **Correlation:**\n        *   Correlation refers to any of a broad class of statistical relationships involving dependence between two variables.\n        *   The most common measure of correlation is the Pearson correlation coefficient, which assesses the linear relationship between two variables.\n        *   Correlation can be positive (both variables increase or decrease together), negative (one variable increases while the other decreases), or zero (no linear relationship).\n        *   Correlation is a bivariate (two-variable) concept.\n    2.  **Multicollinearity:**\n        *   Multicollinearity refers specifically to a situation in regression analysis where two or more predictors (independent variables) are highly correlated.\n        *   This means that one predictor variable in a multiple regression model can be linearly predicted from the others with a substantial degree of accuracy.\n        *   Multicollinearity can make it difficult to ascertain the effect of each predictor on the dependent variable, as changes in one predictor are associated with changes in another.\n        *   It is a problem in multiple regression models, as it undermines the statistical significance of an independent variable.\n*   In summary, while correlation is a broader concept that describes the linear relationship between two variables, multicollinearity is a more specific situation where two or more variables in a regression model are highly correlated, potentially causing issues in interpreting the model results.\n\n1.  **Correlation:**\n    *   Correlation refers to any of a broad class of statistical relationships involving dependence between two variables.\n    *   The most common measure of correlation is the Pearson correlation coefficient, which assesses the linear relationship between two variables.\n    *   Correlation can be positive (both variables increase or decrease together), negative (one variable increases while the other decreases), or zero (no linear relationship).\n    *   Correlation is a bivariate (two-variable) concept.\n2.  **Multicollinearity:**\n    *   Multicollinearity refers specifically to a situation in regression analysis where two or more predictors (independent variables) are highly correlated.\n    *   This means that one predictor variable in a multiple regression model can be linearly predicted from the others with a substantial degree of accuracy.\n    *   Multicollinearity can make it difficult to ascertain the effect of each predictor on the dependent variable, as changes in one predictor are associated with changes in another.\n    *   It is a problem in multiple regression models, as it undermines the statistical significance of an independent variable.\n\n*   Correlation refers to any of a broad class of statistical relationships involving dependence between two variables.\n*   The most common measure of correlation is the Pearson correlation coefficient, which assesses the linear relationship between two variables.\n*   Correlation can be positive (both variables increase or decrease together), negative (one variable increases while the other decreases), or zero (no linear relationship).\n*   Correlation is a bivariate (two-variable) concept.\n\n*   Multicollinearity refers specifically to a situation in regression analysis where two or more predictors (independent variables) are highly correlated.\n*   This means that one predictor variable in a multiple regression model can be linearly predicted from the others with a substantial degree of accuracy.\n*   Multicollinearity can make it difficult to ascertain the effect of each predictor on the dependent variable, as changes in one predictor are associated with changes in another.\n*   It is a problem in multiple regression models, as it undermines the statistical significance of an independent variable.",
      "order": 120,
      "orderInChapter": 120,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 561,
        "contentLength": 4638
      },
      "nextCards": [
        "ai-interview-do-you-need-a-non-linearity-such-as-relu-or-sigmoi-121",
        "ai-interview-explain-the-concept-of-temperature-in-deep-learnin-122"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-multicollinearity-and-correlation-the-same?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-do-you-need-a-non-linearity-such-as-relu-or-sigmoi-121",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Do You Need a Non-linearity Such As ReLU or Sigmoid at the Last Layer of a Neural Network?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Suppose you have <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-145-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1149\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1150\"><span class=\"mi\" id=\"MathJax-Span-1151\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-145\">N</script> hidden layers, and the output layer is just a softmax layer over a set of neurons representing classes (so the expected output is the probability that the input data belongs to each class). Assuming the first <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-146-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1152\" style=\"width: 2.815em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.346em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.24em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1153\"><span class=\"mi\" id=\"MathJax-Span-1154\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1155\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">−</span><span class=\"mn\" id=\"MathJax-Span-1156\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">1</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi><mo>−</mo><mn>1</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-146\">N-1</script> layers have nonlinear neurons, should you use a non-linearity in the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-147-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>N</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>h</mi></mrow></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1157\" style=\"width: 1.773em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.461em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.148em, 1001.46em, 2.294em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1158\"><span class=\"msubsup\" id=\"MathJax-Span-1159\"><span style=\"display: inline-block; position: relative; width: 1.461em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.73em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1160\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.784em;\"><span class=\"texatom\" id=\"MathJax-Span-1161\"><span class=\"mrow\" id=\"MathJax-Span-1162\"><span class=\"mi\" id=\"MathJax-Span-1163\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1164\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">h</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mi>N</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>h</mi></mrow></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-147\">N^{th}</script> hidden layer.</li>\n  <li>You should not use a non-linearity for the last layer before the softmax classification. The ReLU non-linearity (used now almost exclusively) will in this case simply throw away information without adding any additional benefit. You can look at the <a href=\"https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/deploy.prototxt\">caffe implementation</a> of the well-known AlexNet for a reference of what’s done in practice.</li>\n  <li>Note that the softmax function is already non-linear. The softmax function converts a vector of real numbers into a probability distribution. The output probabilities of the softmax function are computed by exponentiating each input value, making it non-negative, and then normalizing by the sum of these exponentiated values across the vector. This non-linearity is particularly useful in classification problems where it helps to distinguish between different classes by amplifying the differences in the input values, thus making the output more distinct for each class.</li>\n  <li>Credit for this answer go to <a href=\"https://stats.stackexchange.com/questions/163695/non-linearity-before-final-softmax-layer-in-a-convolutional-neural-network\">Non-linearity before final Softmax layer in a convolutional neural network</a>.</li>\n</ul>",
      "contentMarkdown": "*   Suppose you have NNN hidden layers, and the output layer is just a softmax layer over a set of neurons representing classes (so the expected output is the probability that the input data belongs to each class). Assuming the first N−1N−1N-1 layers have nonlinear neurons, should you use a non-linearity in the NthNthN^{th} hidden layer.\n*   You should not use a non-linearity for the last layer before the softmax classification. The ReLU non-linearity (used now almost exclusively) will in this case simply throw away information without adding any additional benefit. You can look at the [caffe implementation](https://github.com/BVLC/caffe/blob/master/models/bvlc_alexnet/deploy.prototxt) of the well-known AlexNet for a reference of what’s done in practice.\n*   Note that the softmax function is already non-linear. The softmax function converts a vector of real numbers into a probability distribution. The output probabilities of the softmax function are computed by exponentiating each input value, making it non-negative, and then normalizing by the sum of these exponentiated values across the vector. This non-linearity is particularly useful in classification problems where it helps to distinguish between different classes by amplifying the differences in the input values, thus making the output more distinct for each class.\n*   Credit for this answer go to [Non-linearity before final Softmax layer in a convolutional neural network](https://stats.stackexchange.com/questions/163695/non-linearity-before-final-softmax-layer-in-a-convolutional-neural-network).",
      "order": 121,
      "orderInChapter": 121,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "convolution"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 212,
        "contentLength": 6761
      },
      "nextCards": [
        "ai-interview-explain-the-concept-of-temperature-in-deep-learnin-122",
        "ai-interview-what-is-the-difference-between-logits-soft-and-har-123"
      ],
      "relatedCards": [
        "ai-gnn-graph-convolutional-networks-2",
        "ai-gnn-introductory-content-21",
        "ai-receptive-field-add-more-convolutional-layers-1",
        "ai-receptive-field-depth-wise-convolutions-3",
        "ai-gnn-edge-embeddings-in-specific-gnn-architectures-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#do-you-need-a-non-linearity-such-as-relu-or-sigmoid-at-the-last-layer-of-a-neural-network?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-concept-of-temperature-in-deep-learnin-122",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain the Concept of Temperature in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>\n    <p>In deep learning, the concept of “temperature” is often associated with the Softmax function and is used to control the degree of confidence or uncertainty in the model’s predictions. It’s primarily applied in the context of classification tasks, such as image recognition or natural language processing, where the model assigns probabilities to different classes.</p>\n  </li>\n  <li>\n    <p>The Softmax function is used to convert raw model scores or logits into a probability distribution over the classes. Each class is assigned a probability score, and the class with the highest probability is typically selected as the predicted class.</p>\n  </li>\n  <li>\n    <p>The Softmax function is defined as follows for a class “i”:</p>\n  </li>\n</ul>\n<p>In deep learning, the concept of “temperature” is often associated with the Softmax function and is used to control the degree of confidence or uncertainty in the model’s predictions. It’s primarily applied in the context of classification tasks, such as image recognition or natural language processing, where the model assigns probabilities to different classes.</p>\n<p>The Softmax function is used to convert raw model scores or logits into a probability distribution over the classes. Each class is assigned a probability score, and the class with the highest probability is typically selected as the predicted class.</p>\n<p>The Softmax function is defined as follows for a class “i”:</p>\n<div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-148-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mfrac><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>z</mi><mi>i</mi></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>&amp;#x03C4;</mi></mrow></msup><mrow><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi></mrow></munder><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>z</mi><mi>j</mi></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>&amp;#x03C4;</mi></mrow></msup></mrow></mfrac></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1165\" style=\"width: 7.138em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 5.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.523em, 1005.94em, 3.544em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1166\"><span class=\"mi\" id=\"MathJax-Span-1167\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1168\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1169\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-1170\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1171\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1172\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 3.023em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.023em, 1001.46em, 4.169em, -999.997em); top: -4.685em; left: 50%; margin-left: -0.727em;\"><span class=\"msubsup\" id=\"MathJax-Span-1173\"><span style=\"display: inline-block; position: relative; width: 1.461em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1174\" style=\"font-family: STIXGeneral-Italic;\">e</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1175\"><span class=\"mrow\" id=\"MathJax-Span-1176\"><span class=\"msubsup\" id=\"MathJax-Span-1177\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.26em, 4.221em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1178\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">z</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.263em;\"><span class=\"mi\" id=\"MathJax-Span-1179\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-1180\"><span class=\"mrow\" id=\"MathJax-Span-1181\"><span class=\"mo\" id=\"MathJax-Span-1182\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mi\" id=\"MathJax-Span-1183\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.076em, 1002.87em, 4.638em, -999.997em); top: -3.227em; left: 50%; margin-left: -1.456em;\"><span class=\"mrow\" id=\"MathJax-Span-1184\"><span class=\"munderover\" id=\"MathJax-Span-1185\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1186\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1187\"><span class=\"mrow\" id=\"MathJax-Span-1188\"><span class=\"mi\" id=\"MathJax-Span-1189\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1190\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.513em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1191\" style=\"font-family: STIXGeneral-Italic;\">e</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.32em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1192\"><span class=\"mrow\" id=\"MathJax-Span-1193\"><span class=\"msubsup\" id=\"MathJax-Span-1194\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.544em, 1000.26em, 4.221em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1195\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">z</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.263em;\"><span class=\"mi\" id=\"MathJax-Span-1196\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-1197\"><span class=\"mrow\" id=\"MathJax-Span-1198\"><span class=\"mo\" id=\"MathJax-Span-1199\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mi\" id=\"MathJax-Span-1200\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1003.02em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 3.023em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -1.497em; border-left: 0px solid; width: 0px; height: 3.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><msup><mi>e</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>z</mi><mi>i</mi></msub><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mi>τ</mi></mrow></msup><mrow><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>j</mi></mrow></munder><msup><mi>e</mi><mrow class=\"MJX-TeXAtom-ORD\"><msub><mi>z</mi><mi>j</mi></msub><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mi>τ</mi></mrow></msup></mrow></mfrac></math></span></span></div>\n<ul>\n  <li>\n    <p>Where:</p>\n  </li>\n  <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-149-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1201\" style=\"width: 1.826em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1001.46em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1202\"><span class=\"mi\" id=\"MathJax-Span-1203\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1204\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1205\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-1206\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-149\">P(i)</script> is the probability of class “i.”</li>\n  <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-150-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>z</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1207\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1208\"><span class=\"msubsup\" id=\"MathJax-Span-1209\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.273em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1210\" style=\"font-family: STIXGeneral-Italic;\">z</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1211\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>z</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-150\">z_i</script> is the raw score or logit for class “i.”</li>\n  <li>\n    <p><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-151-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1212\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1213\"><span class=\"mi\" id=\"MathJax-Span-1214\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-151\">\\tau</script>, known as the “temperature,” is a positive scalar parameter.</p>\n  </li>\n  <li>\n    <p>The temperature parameter, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-152-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1215\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1216\"><span class=\"mi\" id=\"MathJax-Span-1217\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-152\">\\tau</script>, affects the shape of the probability distribution. When <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-153-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1218\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1219\"><span class=\"mi\" id=\"MathJax-Span-1220\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-153\">\\tau</script> is high, the distribution becomes “soft,” meaning that the probabilities are more evenly spread among the classes. A lower temperature results in a “harder” distribution, with one or a few classes having much higher probabilities.</p>\n  </li>\n  <li>\n    <p>Here’s how temperature impacts the Softmax function:</p>\n\n    <ul>\n      <li>High <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-154-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1221\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1222\"><span class=\"mi\" id=\"MathJax-Span-1223\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-154\">\\tau</script>: The model is more uncertain, and the probability distribution is more uniform, which can be useful when exploring diverse options or when dealing with noisy data.</li>\n      <li>Low <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-155-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1224\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1225\"><span class=\"mi\" id=\"MathJax-Span-1226\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-155\">\\tau</script>: The model becomes more confident, and the predicted class will have a much higher probability. This is useful when you want to make decisive predictions.</li>\n    </ul>\n  </li>\n  <li>Temperature allows you to control the trade-off between exploration and exploitation in the model’s predictions. It’s a hyperparameter that can be adjusted during training or inference to achieve the desired level of certainty in the model’s output, depending on the specific requirements of your application.</li>\n</ul>\n<p>Where:</p>\n<p><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-151-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1212\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1213\"><span class=\"mi\" id=\"MathJax-Span-1214\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-151\">\\tau</script>, known as the “temperature,” is a positive scalar parameter.</p>\n<p>The temperature parameter, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-152-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1215\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1216\"><span class=\"mi\" id=\"MathJax-Span-1217\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-152\">\\tau</script>, affects the shape of the probability distribution. When <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-153-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1218\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1219\"><span class=\"mi\" id=\"MathJax-Span-1220\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-153\">\\tau</script> is high, the distribution becomes “soft,” meaning that the probabilities are more evenly spread among the classes. A lower temperature results in a “harder” distribution, with one or a few classes having much higher probabilities.</p>\n<p>Here’s how temperature impacts the Softmax function:</p>\n<ul>\n      <li>High <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-154-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1221\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1222\"><span class=\"mi\" id=\"MathJax-Span-1223\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-154\">\\tau</script>: The model is more uncertain, and the probability distribution is more uniform, which can be useful when exploring diverse options or when dealing with noisy data.</li>\n      <li>Low <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-155-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C4;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1224\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1225\"><span class=\"mi\" id=\"MathJax-Span-1226\" style=\"font-family: STIXGeneral-Italic;\">τ<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>τ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-155\">\\tau</script>: The model becomes more confident, and the predicted class will have a much higher probability. This is useful when you want to make decisive predictions.</li>\n    </ul>",
      "contentMarkdown": "*   In deep learning, the concept of “temperature” is often associated with the Softmax function and is used to control the degree of confidence or uncertainty in the model’s predictions. It’s primarily applied in the context of classification tasks, such as image recognition or natural language processing, where the model assigns probabilities to different classes.\n    \n*   The Softmax function is used to convert raw model scores or logits into a probability distribution over the classes. Each class is assigned a probability score, and the class with the highest probability is typically selected as the predicted class.\n    \n*   The Softmax function is defined as follows for a class “i”:\n    \n\nIn deep learning, the concept of “temperature” is often associated with the Softmax function and is used to control the degree of confidence or uncertainty in the model’s predictions. It’s primarily applied in the context of classification tasks, such as image recognition or natural language processing, where the model assigns probabilities to different classes.\n\nThe Softmax function is used to convert raw model scores or logits into a probability distribution over the classes. Each class is assigned a probability score, and the class with the highest probability is typically selected as the predicted class.\n\nThe Softmax function is defined as follows for a class “i”:\n\nP(i)\\=ezi/τ∑jezj/τP(i)\\=ezi/τ∑jezj/τ\n\n*   Where:\n    \n*   P(i)P(i)P(i) is the probability of class “i.”\n*   ziziz\\_i is the raw score or logit for class “i.”\n*   ττ\\\\tau, known as the “temperature,” is a positive scalar parameter.\n    \n*   The temperature parameter, ττ\\\\tau, affects the shape of the probability distribution. When ττ\\\\tau is high, the distribution becomes “soft,” meaning that the probabilities are more evenly spread among the classes. A lower temperature results in a “harder” distribution, with one or a few classes having much higher probabilities.\n    \n*   Here’s how temperature impacts the Softmax function:\n    \n    *   High ττ\\\\tau: The model is more uncertain, and the probability distribution is more uniform, which can be useful when exploring diverse options or when dealing with noisy data.\n    *   Low ττ\\\\tau: The model becomes more confident, and the predicted class will have a much higher probability. This is useful when you want to make decisive predictions.\n*   Temperature allows you to control the trade-off between exploration and exploitation in the model’s predictions. It’s a hyperparameter that can be adjusted during training or inference to achieve the desired level of certainty in the model’s output, depending on the specific requirements of your application.\n\nWhere:\n\nττ\\\\tau, known as the “temperature,” is a positive scalar parameter.\n\nThe temperature parameter, ττ\\\\tau, affects the shape of the probability distribution. When ττ\\\\tau is high, the distribution becomes “soft,” meaning that the probabilities are more evenly spread among the classes. A lower temperature results in a “harder” distribution, with one or a few classes having much higher probabilities.\n\nHere’s how temperature impacts the Softmax function:\n\n*   High ττ\\\\tau: The model is more uncertain, and the probability distribution is more uniform, which can be useful when exploring diverse options or when dealing with noisy data.\n*   Low ττ\\\\tau: The model becomes more confident, and the predicted class will have a much higher probability. This is useful when you want to make decisive predictions.",
      "order": 122,
      "orderInChapter": 122,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "deep learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 529,
        "contentLength": 28193
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-logits-soft-and-har-123",
        "ai-interview-what-is-deep-learning-and-how-is-it-different-from-124"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-summary-31",
        "ai-reinforcement-learning-challenges-of-reinforcement-learning-31",
        "ai-mixture-of-experts-implementation-and-integration-43",
        "ai-mixture-of-experts-limitations-44",
        "ai-mixture-of-experts-switch-transformers-78"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-concept-of-temperature-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-logits-soft-and-har-123",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Logits, Soft and Hard Targets?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Let us understand each of the terms one by one. For better understanding, let’s take a dog vs cat image classification as an example.\n    <ul>\n      <li><strong>Logits</strong> are the un-normalized output of the model. In our cat vs dog example, logits will be, say, <code class=\"language-plaintext highlighter-rouge\">10.1</code> for cat and <code class=\"language-plaintext highlighter-rouge\">5.6</code> for dog for an image with cat. <a href=\"(https://datascience.stackexchange.com/questions/31041/what-does-logits-in-machine-learning-mean)\">Refer this SE question</a>.</li>\n      <li><strong>Soft target</strong>: are normalized logits by applying a softmax function [(without a non-linearity such as ReLU or sigmoid)]](https://stats.stackexchange.com/questions/163695/non-linearity-before-final-softmax-layer-in-a-convolutional-neural-network). In our example, if we use softmax to the logits we get <code class=\"language-plaintext highlighter-rouge\">0.99</code> for cat and <code class=\"language-plaintext highlighter-rouge\">0.1</code> for dog.</li>\n      <li><strong>Hard targets</strong>: are the encoding of the soft targets. In our example, as the model predicted (here correctly) the image as of cat, the hard targets be <code class=\"language-plaintext highlighter-rouge\">1</code> for cat and <code class=\"language-plaintext highlighter-rouge\">0</code> for dog.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Logits</strong> are the un-normalized output of the model. In our cat vs dog example, logits will be, say, <code class=\"language-plaintext highlighter-rouge\">10.1</code> for cat and <code class=\"language-plaintext highlighter-rouge\">5.6</code> for dog for an image with cat. <a href=\"(https://datascience.stackexchange.com/questions/31041/what-does-logits-in-machine-learning-mean)\">Refer this SE question</a>.</li>\n      <li><strong>Soft target</strong>: are normalized logits by applying a softmax function [(without a non-linearity such as ReLU or sigmoid)]](https://stats.stackexchange.com/questions/163695/non-linearity-before-final-softmax-layer-in-a-convolutional-neural-network). In our example, if we use softmax to the logits we get <code class=\"language-plaintext highlighter-rouge\">0.99</code> for cat and <code class=\"language-plaintext highlighter-rouge\">0.1</code> for dog.</li>\n      <li><strong>Hard targets</strong>: are the encoding of the soft targets. In our example, as the model predicted (here correctly) the image as of cat, the hard targets be <code class=\"language-plaintext highlighter-rouge\">1</code> for cat and <code class=\"language-plaintext highlighter-rouge\">0</code> for dog.</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/logits.jpg\" alt=\"\"></p>",
      "contentMarkdown": "*   Let us understand each of the terms one by one. For better understanding, let’s take a dog vs cat image classification as an example.\n    *   **Logits** are the un-normalized output of the model. In our cat vs dog example, logits will be, say, `10.1` for cat and `5.6` for dog for an image with cat. [Refer this SE question](\\(https://datascience.stackexchange.com/questions/31041/what-does-logits-in-machine-learning-mean\\)).\n    *   **Soft target**: are normalized logits by applying a softmax function \\[(without a non-linearity such as ReLU or sigmoid)\\]\\](https://stats.stackexchange.com/questions/163695/non-linearity-before-final-softmax-layer-in-a-convolutional-neural-network). In our example, if we use softmax to the logits we get `0.99` for cat and `0.1` for dog.\n    *   **Hard targets**: are the encoding of the soft targets. In our example, as the model predicted (here correctly) the image as of cat, the hard targets be `1` for cat and `0` for dog.\n\n*   **Logits** are the un-normalized output of the model. In our cat vs dog example, logits will be, say, `10.1` for cat and `5.6` for dog for an image with cat. [Refer this SE question](\\(https://datascience.stackexchange.com/questions/31041/what-does-logits-in-machine-learning-mean\\)).\n*   **Soft target**: are normalized logits by applying a softmax function \\[(without a non-linearity such as ReLU or sigmoid)\\]\\](https://stats.stackexchange.com/questions/163695/non-linearity-before-final-softmax-layer-in-a-convolutional-neural-network). In our example, if we use softmax to the logits we get `0.99` for cat and `0.1` for dog.\n*   **Hard targets**: are the encoding of the soft targets. In our example, as the model predicted (here correctly) the image as of cat, the hard targets be `1` for cat and `0` for dog.\n\n![](/primers/ai/assets/interview/logits.jpg)",
      "order": 123,
      "orderInChapter": 123,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "convolution"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 242,
        "contentLength": 2726
      },
      "nextCards": [
        "ai-interview-what-is-deep-learning-and-how-is-it-different-from-124",
        "ai-interview-how-does-backpropagation-work-in-a-neural-network-125"
      ],
      "relatedCards": [
        "ai-document-intelligence-mplug-docowl-15-17",
        "ai-model-compression-compute-vs-memory-bottlenecks-30",
        "ai-model-compression-compute-vs-memory-bottlenecks-36",
        "ai-diffusion-models-summary-22",
        "ai-ml-runtimes-xnnpack-by-google-both-server-and-mobile-cpus-65"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-logits,-soft-and-hard-targets?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-deep-learning-and-how-is-it-different-from-124",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Deep Learning and How is It Different from Traditional Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Deep Learning is a specialized subfield of machine learning focusing on neural networks with multiple layers, aptly termed deep neural networks.</li>\n  <li>These networks excel in learning and making predictions by autonomously identifying hierarchical data representations, distinguishing them from traditional machine learning, which relies more on manual feature engineering.</li>\n  <li>Deep learning models are particularly adept at handling unstructured data like images and text, making them suitable for complex tasks like image recognition and natural language processing.</li>\n</ul>",
      "contentMarkdown": "*   Deep Learning is a specialized subfield of machine learning focusing on neural networks with multiple layers, aptly termed deep neural networks.\n*   These networks excel in learning and making predictions by autonomously identifying hierarchical data representations, distinguishing them from traditional machine learning, which relies more on manual feature engineering.\n*   Deep learning models are particularly adept at handling unstructured data like images and text, making them suitable for complex tasks like image recognition and natural language processing.",
      "order": 124,
      "orderInChapter": 124,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "deep learning",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 78,
        "contentLength": 602
      },
      "nextCards": [
        "ai-interview-how-does-backpropagation-work-in-a-neural-network-125",
        "ai-interview-why-do-we-prefer-training-on-mini-batches-rather-t-126"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-conditional-computation-as-a-principled-solution-3",
        "ai-speech-processing-architectural-overview-17",
        "ai-online-testing-why-is-online-testing-necessary-despite-offline-ev-80",
        "ai-drift-tests-and-techniques-5",
        "ai-mlops-tooling-simplification-tools-18"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-deep-learning-and-how-is-it-different-from-traditional-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-backpropagation-work-in-a-neural-network-125",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Does Backpropagation Work in a Neural Network?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Backpropagation is a cornerstone algorithm in training neural networks, pivotal for their ability to learn and adjust.</li>\n  <li>It begins by forwarding the input through the network to compute the output.</li>\n  <li>The algorithm then assesses the output against the expected result, calculating the error.</li>\n  <li>This error is propagated backward through the network, adjusting the weights to minimize this error.</li>\n  <li>The process iteratively repeats, refining the network’s performance by reducing the error.</li>\n</ul>",
      "contentMarkdown": "*   Backpropagation is a cornerstone algorithm in training neural networks, pivotal for their ability to learn and adjust.\n*   It begins by forwarding the input through the network to compute the output.\n*   The algorithm then assesses the output against the expected result, calculating the error.\n*   This error is propagated backward through the network, adjusting the weights to minimize this error.\n*   The process iteratively repeats, refining the network’s performance by reducing the error.",
      "order": 125,
      "orderInChapter": 125,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "backpropagation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 75,
        "contentLength": 544
      },
      "nextCards": [
        "ai-interview-why-do-we-prefer-training-on-mini-batches-rather-t-126",
        "ai-interview-what-are-the-benefits-of-using-batch-normalization-127"
      ],
      "relatedCards": [
        "ai-architectures-how-do-resnets-work-23",
        "ai-architectures-residual-connectionsskip-connections-28",
        "ai-skip-connections-chain-rule-1",
        "ai-gan-random-input-1",
        "ai-architectures-vanishing-gradients-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-backpropagation-work-in-a-neural-network?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-do-we-prefer-training-on-mini-batches-rather-t-126",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why Do We Prefer Training on Mini-Batches Rather Than Individual Samples in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Mini-batch training strikes a balance between computational efficiency and estimation quality.</li>\n  <li>The gradient calculated over a mini-batch is an estimation of the gradient over the entire training set, improving with larger batch sizes.</li>\n  <li>Moreover, processing a batch of data simultaneously leverages modern computing architectures’ parallelism, offering significant efficiency over handling each data point separately.</li>\n</ul>",
      "contentMarkdown": "*   Mini-batch training strikes a balance between computational efficiency and estimation quality.\n*   The gradient calculated over a mini-batch is an estimation of the gradient over the entire training set, improving with larger batch sizes.\n*   Moreover, processing a batch of data simultaneously leverages modern computing architectures’ parallelism, offering significant efficiency over handling each data point separately.",
      "order": 126,
      "orderInChapter": 126,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 57,
        "contentLength": 459
      },
      "nextCards": [
        "ai-interview-what-are-the-benefits-of-using-batch-normalization-127",
        "ai-interview-what-is-entropy-in-information-theory-128"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-do-we-prefer-training-on-mini-batches-rather-than-individual-samples-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-benefits-of-using-batch-normalization-127",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are the Benefits of Using Batch Normalization?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Batch Normalization significantly impacts the gradient flow within a network, reducing dependency on the parameters’ scale or their initial values.</li>\n  <li>This feature enables the use of higher learning rates without risking divergence.</li>\n  <li>Additionally, it acts as a regularizer, reducing the need for Dropout, and facilitates the use of saturating nonlinearities by preventing the network from getting stuck in saturated modes.</li>\n</ul>",
      "contentMarkdown": "*   Batch Normalization significantly impacts the gradient flow within a network, reducing dependency on the parameters’ scale or their initial values.\n*   This feature enables the use of higher learning rates without risking divergence.\n*   Additionally, it acts as a regularizer, reducing the need for Dropout, and facilitates the use of saturating nonlinearities by preventing the network from getting stuck in saturated modes.",
      "order": 127,
      "orderInChapter": 127,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "dropout",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 63,
        "contentLength": 462
      },
      "nextCards": [
        "ai-interview-what-is-entropy-in-information-theory-128",
        "ai-interview-why-is-logistic-regression-considered-a-linear-cla-129"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-what-are-the-biggest-advantages-of-using-gbdts-com-22",
        "ai-diffusion-models-how-classifier-free-guidance-works-28",
        "ai-bias-variance-tradeoff-techniques-to-prevent-overfitting-10",
        "ai-decision-trees-and-ensemble-methods-regularization-in-ensemble-methods-14",
        "ai-flashattention-cuda-kernel-fusion-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-benefits-of-using-batch-normalization?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-entropy-in-information-theory-128",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Entropy in Information Theory?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>In information theory, entropy quantifies a system’s uncertainty or randomness.</li>\n  <li>It represents the necessary information amount to eliminate uncertainty in a system.</li>\n  <li>The entropy of a probability distribution for various system states is computed using the formula: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-156-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><msub><mi>p</mi><mi>i</mi></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1227\" style=\"width: 6.565em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 5.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1005.47em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1228\"><span class=\"mo\" id=\"MathJax-Span-1229\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"munderover\" id=\"MathJax-Span-1230\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1231\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1232\"><span class=\"mrow\" id=\"MathJax-Span-1233\"><span class=\"mi\" id=\"MathJax-Span-1234\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1235\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1236\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-1237\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1238\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1239\"></span><span class=\"msubsup\" id=\"MathJax-Span-1240\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1241\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-1242\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>−</mo><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><msub><mi>p</mi><mi>i</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-156\">-\\sum_{i} p_i \\log p_i</script>, where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-157-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1243\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.78em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1244\"><span class=\"msubsup\" id=\"MathJax-Span-1245\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1246\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-1247\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>p</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-157\">p_i</script> is the probability of each state.</li>\n</ul>",
      "contentMarkdown": "*   In information theory, entropy quantifies a system’s uncertainty or randomness.\n*   It represents the necessary information amount to eliminate uncertainty in a system.\n*   The entropy of a probability distribution for various system states is computed using the formula: −∑ipilogpi−∑ipilog⁡pi\\-\\\\sum\\_{i} p\\_i \\\\log p\\_i, where pipip\\_i is the probability of each state.",
      "order": 128,
      "orderInChapter": 128,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 52,
        "contentLength": 6158
      },
      "nextCards": [
        "ai-interview-why-is-logistic-regression-considered-a-linear-cla-129",
        "ai-interview-how-do-you-handle-overfitting-in-deep-learning-mod-130"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-entropy-in-information-theory?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-is-logistic-regression-considered-a-linear-cla-129",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Why is Logistic Regression Considered a Linear Classifier Despite Using the Non-Linear Sigmoid Function?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Logistic regression, despite utilizing the non-linear sigmoid function, is categorized as a linear classifier because it models the relationship between input features and the log-odds (logit) of the target variable linearly.</li>\n  <li>Its linearity stems from its ability to create a linear decision boundary in the feature space, essentially a hyperplane, which separates different classes linearly.</li>\n</ul>",
      "contentMarkdown": "*   Logistic regression, despite utilizing the non-linear sigmoid function, is categorized as a linear classifier because it models the relationship between input features and the log-odds (logit) of the target variable linearly.\n*   Its linearity stems from its ability to create a linear decision boundary in the feature space, essentially a hyperplane, which separates different classes linearly.",
      "order": 129,
      "orderInChapter": 129,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 57,
        "contentLength": 424
      },
      "nextCards": [
        "ai-interview-how-do-you-handle-overfitting-in-deep-learning-mod-130",
        "ai-interview-can-you-explain-the-concept-of-convolutional-neura-131"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-is-logistic-regression-considered-a-linear-classifier-despite-using-the-non-linear-sigmoid-function?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-handle-overfitting-in-deep-learning-mod-130",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Handle Overfitting in Deep Learning Models?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Overfitting, where a model fits training data noise rather than the underlying pattern, can be mitigated through:\n    <ul>\n      <li><strong>Regularization Techniques</strong> (L1, L2): These add penalty terms to the loss function, discouraging large weights.</li>\n      <li><strong>Early Stopping</strong>: Halts training before the model overfits the data.</li>\n      <li><strong>Dropout</strong>: Randomly drops neurons during training to reduce co-adaptation.</li>\n      <li><strong>Adding More Data</strong>: Expands the training dataset to improve generalization.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Regularization Techniques</strong> (L1, L2): These add penalty terms to the loss function, discouraging large weights.</li>\n      <li><strong>Early Stopping</strong>: Halts training before the model overfits the data.</li>\n      <li><strong>Dropout</strong>: Randomly drops neurons during training to reduce co-adaptation.</li>\n      <li><strong>Adding More Data</strong>: Expands the training dataset to improve generalization.</li>\n    </ul>",
      "contentMarkdown": "*   Overfitting, where a model fits training data noise rather than the underlying pattern, can be mitigated through:\n    *   **Regularization Techniques** (L1, L2): These add penalty terms to the loss function, discouraging large weights.\n    *   **Early Stopping**: Halts training before the model overfits the data.\n    *   **Dropout**: Randomly drops neurons during training to reduce co-adaptation.\n    *   **Adding More Data**: Expands the training dataset to improve generalization.\n\n*   **Regularization Techniques** (L1, L2): These add penalty terms to the loss function, discouraging large weights.\n*   **Early Stopping**: Halts training before the model overfits the data.\n*   **Dropout**: Randomly drops neurons during training to reduce co-adaptation.\n*   **Adding More Data**: Expands the training dataset to improve generalization.",
      "order": 130,
      "orderInChapter": 130,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "loss function",
        "regularization",
        "dropout"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 114,
        "contentLength": 1076
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-convolutional-neura-131",
        "ai-interview-how-do-you-handle-missing-data-in-deep-learning-132"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-regularization-in-ensemble-methods-14",
        "ai-diffusion-models-integration-with-mse-46",
        "ai-loss-mean-absolute-error-mae-l1-loss-9",
        "ai-regularization-graphical-treatment-6",
        "ai-regularization-l2l2l2-regularization-weight-shrinkage-ie-uniform--8"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-handle-overfitting-in-deep-learning-models?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-convolutional-neura-131",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Explain the Concept of Convolutional Neural Networks (CNN)?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Convolutional Neural Networks (CNNs) are designed for pattern recognition in images and videos.</li>\n  <li>They learn spatial hierarchies of features through minimal preprocessing, unlike traditional multi-layer perceptrons.</li>\n  <li>CNNs distinguish themselves by learning features directly from data via convolution processes, rather than relying on hand-engineered features.</li>\n</ul>",
      "contentMarkdown": "*   Convolutional Neural Networks (CNNs) are designed for pattern recognition in images and videos.\n*   They learn spatial hierarchies of features through minimal preprocessing, unlike traditional multi-layer perceptrons.\n*   CNNs distinguish themselves by learning features directly from data via convolution processes, rather than relying on hand-engineered features.",
      "order": 131,
      "orderInChapter": 131,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "convolution",
        "cnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 47,
        "contentLength": 401
      },
      "nextCards": [
        "ai-interview-how-do-you-handle-missing-data-in-deep-learning-132",
        "ai-interview-can-you-explain-the-concept-of-transfer-learning-i-133"
      ],
      "relatedCards": [
        "ai-dl-comp-pros-of-cnns-compared-to-fcns-2",
        "ai-loss-additive-angular-margin-loss-6",
        "ai-vit-why-does-vit-rely-on-1616161616-times-16-pixels-fo-5",
        "ai-gnn-introductory-content-21",
        "ai-diffusion-models-patch-n-pack-navit-a-vision-transformer-for-any-as-62"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-convolutional-neural-networks-(cnn)?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-handle-missing-data-in-deep-learning-132",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Handle Missing Data in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Managing missing data in deep learning can be approached through:\n    <ul>\n      <li>Removing data rows or columns that contain missing values.</li>\n      <li>Interpolating or imputing missing values.</li>\n      <li>Utilizing masking techniques, enabling the model to overlook missing values during predictions.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Removing data rows or columns that contain missing values.</li>\n      <li>Interpolating or imputing missing values.</li>\n      <li>Utilizing masking techniques, enabling the model to overlook missing values during predictions.</li>\n    </ul>",
      "contentMarkdown": "*   Managing missing data in deep learning can be approached through:\n    *   Removing data rows or columns that contain missing values.\n    *   Interpolating or imputing missing values.\n    *   Utilizing masking techniques, enabling the model to overlook missing values during predictions.\n\n*   Removing data rows or columns that contain missing values.\n*   Interpolating or imputing missing values.\n*   Utilizing masking techniques, enabling the model to overlook missing values during predictions.",
      "order": 132,
      "orderInChapter": 132,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "deep learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 69,
        "contentLength": 608
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-transfer-learning-i-133",
        "ai-interview-what-is-gradient-descent-in-deep-learning-134"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-concept-16",
        "ai-distributed-training-parallelism-conclusion-22",
        "ai-distributed-training-parallelism-concept-24",
        "ai-distributed-training-parallelism-conclusion-30",
        "ai-distributed-training-parallelism-summary-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-handle-missing-data-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-transfer-learning-i-133",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Explain the Concept of Transfer Learning in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Transfer learning leverages a model trained on one task as a foundation for a model on a related task.</li>\n  <li>It capitalizes on the first task’s learned features, enhancing training efficiency and performance for the second task.</li>\n  <li>Methods include using a pre-trained model as a feature extractor or fine-tuning it with new data.</li>\n</ul>",
      "contentMarkdown": "*   Transfer learning leverages a model trained on one task as a foundation for a model on a related task.\n*   It capitalizes on the first task’s learned features, enhancing training efficiency and performance for the second task.\n*   Methods include using a pre-trained model as a feature extractor or fine-tuning it with new data.",
      "order": 133,
      "orderInChapter": 133,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "fine-tuning",
        "transfer learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 55,
        "contentLength": 364
      },
      "nextCards": [
        "ai-interview-what-is-gradient-descent-in-deep-learning-134",
        "ai-interview-what-is-representation-learning-135"
      ],
      "relatedCards": [
        "ai-nlp-tasks-future-directions-39",
        "ai-prompt-engineering-zero-shot-cot-1",
        "ai-reinforcement-learning-practical-considerations-21",
        "ai-agents-llama-stack-50",
        "ai-agentic-RL-integration-of-search-with-reinforcement-learning--39"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-transfer-learning-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-gradient-descent-in-deep-learning-134",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Gradient Descent in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Gradient Descent is an optimization algorithm central to minimizing a neural network’s loss function.</li>\n  <li>It adjusts the network’s weights in the opposite direction of the loss function’s gradient.</li>\n  <li>The update magnitude is governed by the learning rate.</li>\n  <li>Variants include batch gradient descent, stochastic gradient descent, and mini-batch gradient descent.</li>\n</ul>",
      "contentMarkdown": "*   Gradient Descent is an optimization algorithm central to minimizing a neural network’s loss function.\n*   It adjusts the network’s weights in the opposite direction of the loss function’s gradient.\n*   The update magnitude is governed by the learning rate.\n*   Variants include batch gradient descent, stochastic gradient descent, and mini-batch gradient descent.",
      "order": 134,
      "orderInChapter": 134,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "optimization",
        "gradient descent",
        "loss function"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 53,
        "contentLength": 406
      },
      "nextCards": [
        "ai-interview-what-is-representation-learning-135",
        "ai-interview-explain-label-smoothing-136"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-model-debugging-weight-initialization-11",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27",
        "ai-decision-trees-and-ensemble-methods-what-role-does-the-learning-rate-play-in-training--30"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-gradient-descent-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-representation-learning-135",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Representation Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Representation learning in AI signifies the system’s capability to autonomously learn data representations at multiple abstraction levels.</li>\n  <li>These learned representations, stored within neurons, are utilized for decision-making and predictions.</li>\n</ul>",
      "contentMarkdown": "*   Representation learning in AI signifies the system’s capability to autonomously learn data representations at multiple abstraction levels.\n*   These learned representations, stored within neurons, are utilized for decision-making and predictions.",
      "order": 135,
      "orderInChapter": 135,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 31,
        "contentLength": 275
      },
      "nextCards": [
        "ai-interview-explain-label-smoothing-136",
        "ai-interview-please-explain-what-is-dropout-in-deep-learning-137"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-representation-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-label-smoothing-136",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Label Smoothing",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Label smoothing is a strategy to prevent overfitting by introducing noise into training data labels.</li>\n  <li>It creates soft labels through a weighted average between the uniform distribution and the hard label, reducing the model’s likelihood of overfitting to training data.</li>\n</ul>",
      "contentMarkdown": "*   Label smoothing is a strategy to prevent overfitting by introducing noise into training data labels.\n*   It creates soft labels through a weighted average between the uniform distribution and the hard label, reducing the model’s likelihood of overfitting to training data.",
      "order": 136,
      "orderInChapter": 136,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 42,
        "contentLength": 301
      },
      "nextCards": [
        "ai-interview-please-explain-what-is-dropout-in-deep-learning-137",
        "ai-interview-what-are-autoencoders-138"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-label-smoothing",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-please-explain-what-is-dropout-in-deep-learning-137",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Please Explain What is Dropout in Deep Learning",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Dropout is a regularization technique in deep learning to avert overfitting.</li>\n  <li>It randomly omits a set percentage of neurons during training, thereby diminishing the network’s capacity.</li>\n  <li>This compels the network to learn diverse data representations, enhancing its generalization ability.</li>\n</ul>",
      "contentMarkdown": "*   Dropout is a regularization technique in deep learning to avert overfitting.\n*   It randomly omits a set percentage of neurons during training, thereby diminishing the network’s capacity.\n*   This compels the network to learn diverse data representations, enhancing its generalization ability.",
      "order": 137,
      "orderInChapter": 137,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "deep learning",
        "regularization",
        "dropout"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 42,
        "contentLength": 329
      },
      "nextCards": [
        "ai-interview-what-are-autoencoders-138",
        "ai-interview-can-you-explain-the-concept-of-attention-mechanism-139"
      ],
      "relatedCards": [
        "ai-dropout-use-with-smaller-datasets-6",
        "ai-decision-trees-and-ensemble-methods-regularization-in-ensemble-methods-14",
        "ai-mixture-of-experts-limitations-44",
        "ai-decision-trees-and-ensemble-methods-what-are-the-biggest-advantages-of-using-gbdts-com-22",
        "ai-dropout-use-a-larger-network-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#please-explain-what-is-dropout-in-deep-learning",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-autoencoders-138",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Autoencoders?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Autoencoders are neural networks trained to replicate their input.</li>\n  <li>They consist of an encoder, which compresses the input into a lower-dimensional representation (bottleneck or latent code), and a decoder, which reconstructs the input from this code.</li>\n  <li>Applications include dimensionality reduction, anomaly detection, and generative modeling.</li>\n</ul>",
      "contentMarkdown": "*   Autoencoders are neural networks trained to replicate their input.\n*   They consist of an encoder, which compresses the input into a lower-dimensional representation (bottleneck or latent code), and a decoder, which reconstructs the input from this code.\n*   Applications include dimensionality reduction, anomaly detection, and generative modeling.",
      "order": 138,
      "orderInChapter": 138,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 48,
        "contentLength": 385
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-attention-mechanism-139",
        "ai-interview-what-are-generative-adversarial-networks-gans-140"
      ],
      "relatedCards": [
        "ai-support-vector-machines-linear-vs-non-linear-separability-6",
        "ai-diffusion-models-latent-space-diffusion-models-7",
        "ai-diffusion-models-casting-lvlblvlblvlb-in-terms-of-kl-divergences-11",
        "ai-diffusion-models-stable-diffusion-38",
        "ai-diffusion-models-what-is-the-difference-between-ddpm-and-ddims-mode-43"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-autoencoders?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-attention-mechanism-139",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Explain the Concept of Attention Mechanism in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The attention mechanism in neural networks emphasizes varying input parts differently, prioritizing certain features.</li>\n  <li>It’s crucial in tasks like machine translation, where the model needs to focus on specific input segments at different stages.</li>\n  <li>Attention mechanisms come in various forms, including additive attention, dot-product attention, and multi-head attention.</li>\n</ul>",
      "contentMarkdown": "*   The attention mechanism in neural networks emphasizes varying input parts differently, prioritizing certain features.\n*   It’s crucial in tasks like machine translation, where the model needs to focus on specific input segments at different stages.\n*   Attention mechanisms come in various forms, including additive attention, dot-product attention, and multi-head attention.",
      "order": 139,
      "orderInChapter": 139,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "attention"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 51,
        "contentLength": 411
      },
      "nextCards": [
        "ai-interview-what-are-generative-adversarial-networks-gans-140",
        "ai-interview-can-you-explain-the-concept-of-memory-networks-in--141"
      ],
      "relatedCards": [
        "ai-attention-origins-and-definitions-7",
        "ai-mixture-of-experts-motivation-45",
        "ai-padding-and-packing-summary-5",
        "ai-model-compression-practical-considerations-37",
        "ai-gnn-graph-attention-networks-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-attention-mechanism-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-generative-adversarial-networks-gans-140",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What are Generative Adversarial Networks (GANs)?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Generative Adversarial Networks (GANs) consist of two parts: a generator and a discriminator.</li>\n  <li>The generator creates new data resembling training data, while the discriminator differentiates between generated and real data.</li>\n  <li>Trained in a game-theoretic manner, the generator aims to produce data that can deceive the discriminator, which strives to accurately identify generated data.</li>\n</ul>",
      "contentMarkdown": "*   Generative Adversarial Networks (GANs) consist of two parts: a generator and a discriminator.\n*   The generator creates new data resembling training data, while the discriminator differentiates between generated and real data.\n*   Trained in a game-theoretic manner, the generator aims to produce data that can deceive the discriminator, which strives to accurately identify generated data.",
      "order": 140,
      "orderInChapter": 140,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 56,
        "contentLength": 426
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-memory-networks-in--141",
        "ai-interview-explain-capsule-networks-in-deep-learning-142"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-generative-adversarial-networks-(gans)?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-memory-networks-in--141",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Explain the Concept of Memory Networks in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Memory networks incorporate an external memory matrix, enabling models to store and utilize past information for future predictions.</li>\n  <li>They’re effective in language understanding and question-answering tasks, offering a mechanism for reasoning about past events.</li>\n</ul>",
      "contentMarkdown": "*   Memory networks incorporate an external memory matrix, enabling models to store and utilize past information for future predictions.\n*   They’re effective in language understanding and question-answering tasks, offering a mechanism for reasoning about past events.",
      "order": 141,
      "orderInChapter": 141,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 36,
        "contentLength": 293
      },
      "nextCards": [
        "ai-interview-explain-capsule-networks-in-deep-learning-142",
        "ai-interview-can-you-explain-the-concept-of-generative-models-i-143"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-memory-networks-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-capsule-networks-in-deep-learning-142",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Capsule Networks in Deep Learning",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Capsule networks aim to surpass traditional CNN limitations by utilizing capsules, multi-neuron entities representing objects or object parts.</li>\n  <li>These capsules encode object properties like position, size, and orientation, facilitating tasks like image classification and object detection.</li>\n</ul>",
      "contentMarkdown": "*   Capsule networks aim to surpass traditional CNN limitations by utilizing capsules, multi-neuron entities representing objects or object parts.\n*   These capsules encode object properties like position, size, and orientation, facilitating tasks like image classification and object detection.",
      "order": 142,
      "orderInChapter": 142,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "cnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 38,
        "contentLength": 320
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-generative-models-i-143",
        "ai-interview-what-is-the-concept-of-adversarial-training-in-dee-144"
      ],
      "relatedCards": [
        "ai-ml-runtimes-example-pseudocode-flow-36",
        "ai-state-space-models-scalable-diffusion-models-with-state-space-backbon-6",
        "ai-activation-functions-softmax-2",
        "ai-distributed-training-parallelism-dataparallel-dp-6",
        "ai-distributed-training-parallelism-distributed-data-parallel-ddp-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-capsule-networks-in-deep-learning",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-generative-models-i-143",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Can You Explain the Concept of Generative Models in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Generative models in deep learning create new data mirroring training data.</li>\n  <li>By learning the data’s underlying probability distribution, these models generate unseen, fitting data.</li>\n  <li>Examples include Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs).</li>\n</ul>",
      "contentMarkdown": "*   Generative models in deep learning create new data mirroring training data.\n*   By learning the data’s underlying probability distribution, these models generate unseen, fitting data.\n*   Examples include Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs).",
      "order": 143,
      "orderInChapter": 143,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "deep learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 37,
        "contentLength": 316
      },
      "nextCards": [
        "ai-interview-what-is-the-concept-of-adversarial-training-in-dee-144",
        "ai-interview-what-is-weight-initialization-in-deep-learning-145"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-concept-16",
        "ai-distributed-training-parallelism-conclusion-22",
        "ai-distributed-training-parallelism-concept-24",
        "ai-distributed-training-parallelism-conclusion-30",
        "ai-distributed-training-parallelism-summary-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-generative-models-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.843Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-concept-of-adversarial-training-in-dee-144",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Concept of Adversarial Training in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Adversarial training enhances model robustness by training on adversarial examples - slightly altered inputs causing model errors.</li>\n  <li>This method increases resilience to similar real-world perturbations.</li>\n</ul>",
      "contentMarkdown": "*   Adversarial training enhances model robustness by training on adversarial examples - slightly altered inputs causing model errors.\n*   This method increases resilience to similar real-world perturbations.",
      "order": 144,
      "orderInChapter": 144,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 27,
        "contentLength": 233
      },
      "nextCards": [
        "ai-interview-what-is-weight-initialization-in-deep-learning-145",
        "ai-interview-explain-data-augmentation-146"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-concept-of-adversarial-training-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-weight-initialization-in-deep-learning-145",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Weight Initialization in Deep Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Weight initialization sets the initial values of a neural network’s weights, significantly impacting performance and training duration.</li>\n  <li>Methods include random initialization, Glorot initialization, and He initialization, each suited for different problem types.</li>\n</ul>",
      "contentMarkdown": "*   Weight initialization sets the initial values of a neural network’s weights, significantly impacting performance and training duration.\n*   Methods include random initialization, Glorot initialization, and He initialization, each suited for different problem types.",
      "order": 145,
      "orderInChapter": 145,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 34,
        "contentLength": 294
      },
      "nextCards": [
        "ai-interview-explain-data-augmentation-146",
        "ai-interview-what-is-the-difference-between-standardization-and-147"
      ],
      "relatedCards": [
        "ai-support-vector-machines-linear-vs-non-linear-separability-6",
        "ai-diffusion-models-latent-space-diffusion-models-7",
        "ai-diffusion-models-casting-lvlblvlblvlb-in-terms-of-kl-divergences-11",
        "ai-diffusion-models-stable-diffusion-38",
        "ai-diffusion-models-what-is-the-difference-between-ddpm-and-ddims-mode-43"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-weight-initialization-in-deep-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-data-augmentation-146",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Data Augmentation",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Data augmentation expands training data for deep learning models by creating new examples through random transformations of original data, like cropping, flipping, or rotating.</li>\n  <li>This helps prevent overfitting and improves model generalization.</li>\n</ul>",
      "contentMarkdown": "*   Data augmentation expands training data for deep learning models by creating new examples through random transformations of original data, like cropping, flipping, or rotating.\n*   This helps prevent overfitting and improves model generalization.",
      "order": 146,
      "orderInChapter": 146,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "deep learning",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 34,
        "contentLength": 275
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-standardization-and-147",
        "ai-interview-is-it-possible-that-during-ml-training-both-valida-148"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-concept-16",
        "ai-distributed-training-parallelism-conclusion-22",
        "ai-distributed-training-parallelism-concept-24",
        "ai-distributed-training-parallelism-conclusion-30",
        "ai-distributed-training-parallelism-summary-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-data-augmentation",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-standardization-and-147",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Standardization and Normalization?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li><strong>Normalization</strong>: Scales data to a common range, like [0, 1] or [-1, 1], using the formula <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-158-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>X</mi><mo>&amp;#x2212;</mo><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>&amp;#x2212;</mo><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1248\" style=\"width: 7.711em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 6.409em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.044em, 1006.41em, 2.815em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1249\"><span class=\"msubsup\" id=\"MathJax-Span-1250\"><span style=\"display: inline-block; position: relative; width: 1.826em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1251\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-1252\"><span class=\"mrow\" id=\"MathJax-Span-1253\"><span class=\"mi\" id=\"MathJax-Span-1254\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-1255\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-1256\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">w</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1257\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1258\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 3.18em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1002.19em, 4.273em, -999.997em); top: -4.529em; left: 50%; margin-left: -1.091em;\"><span class=\"mrow\" id=\"MathJax-Span-1259\"><span class=\"mi\" id=\"MathJax-Span-1260\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1261\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-1262\"><span style=\"display: inline-block; position: relative; width: 1.253em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.388em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1263\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.419em;\"><span class=\"texatom\" id=\"MathJax-Span-1264\"><span class=\"mrow\" id=\"MathJax-Span-1265\"><span class=\"mi\" id=\"MathJax-Span-1266\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">m</span><span class=\"mi\" id=\"MathJax-Span-1267\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">i</span><span class=\"mi\" id=\"MathJax-Span-1268\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">n</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1003.02em, 4.273em, -999.997em); top: -3.643em; left: 50%; margin-left: -1.508em;\"><span class=\"mrow\" id=\"MathJax-Span-1269\"><span class=\"msubsup\" id=\"MathJax-Span-1270\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.388em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1271\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.419em;\"><span class=\"texatom\" id=\"MathJax-Span-1272\"><span class=\"mrow\" id=\"MathJax-Span-1273\"><span class=\"mi\" id=\"MathJax-Span-1274\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">m</span><span class=\"mi\" id=\"MathJax-Span-1275\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">a</span><span class=\"mi\" id=\"MathJax-Span-1276\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1277\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">−</span><span class=\"msubsup\" id=\"MathJax-Span-1278\"><span style=\"display: inline-block; position: relative; width: 1.253em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.388em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1279\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.904em; left: 0.419em;\"><span class=\"texatom\" id=\"MathJax-Span-1280\"><span class=\"mrow\" id=\"MathJax-Span-1281\"><span class=\"mi\" id=\"MathJax-Span-1282\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">m</span><span class=\"mi\" id=\"MathJax-Span-1283\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">i</span><span class=\"mi\" id=\"MathJax-Span-1284\" style=\"font-size: 50%; font-family: STIXGeneral-Italic;\">n</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1003.18em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 3.18em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.622em; border-left: 0px solid; width: 0px; height: 1.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mrow><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mfrac></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-158\">X_{new} = \\frac{X - X_{min}}{X_{max} - X_{min}}</script>.</li>\n  <li><strong>Standardization</strong>: Scales data to zero mean and unit variance, following <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-159-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>X</mi><mo>&amp;#x2212;</mo><mtext>mean</mtext></mrow><mtext>Std</mtext></mfrac></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1285\" style=\"width: 7.034em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 5.836em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.044em, 1005.84em, 2.763em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1286\"><span class=\"msubsup\" id=\"MathJax-Span-1287\"><span style=\"display: inline-block; position: relative; width: 1.826em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1288\" style=\"font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.628em;\"><span class=\"texatom\" id=\"MathJax-Span-1289\"><span class=\"mrow\" id=\"MathJax-Span-1290\"><span class=\"mi\" id=\"MathJax-Span-1291\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span><span class=\"mi\" id=\"MathJax-Span-1292\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-1293\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">w</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1294\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1295\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 2.607em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1002.45em, 4.273em, -999.997em); top: -4.529em; left: 50%; margin-left: -1.247em;\"><span class=\"mrow\" id=\"MathJax-Span-1296\"><span class=\"mi\" id=\"MathJax-Span-1297\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">X<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1298\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">−</span><span class=\"mtext\" id=\"MathJax-Span-1299\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">mean</span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.94em, 4.169em, -999.997em); top: -3.643em; left: 50%; margin-left: -0.466em;\"><span class=\"mtext\" id=\"MathJax-Span-1300\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">Std</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1002.61em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 2.607em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.559em; border-left: 0px solid; width: 0px; height: 1.753em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>X</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>X</mi><mo>−</mo><mtext>mean</mtext></mrow><mtext>Std</mtext></mfrac></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-159\">X_{new} = \\frac{X - \\text{mean}}{\\text{Std}}</script>.</li>\n</ul>",
      "contentMarkdown": "*   **Normalization**: Scales data to a common range, like \\[0, 1\\] or \\[-1, 1\\], using the formula Xnew\\=X−XminXmax−XminXnew\\=X−XminXmax−XminX\\_{new} = \\\\frac{X - X\\_{min}}{X\\_{max} - X\\_{min}}.\n*   **Standardization**: Scales data to zero mean and unit variance, following Xnew\\=X−meanStdXnew\\=X−meanStdX\\_{new} = \\\\frac{X - \\\\text{mean}}{\\\\text{Std}}.",
      "order": 147,
      "orderInChapter": 147,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 40,
        "contentLength": 12628
      },
      "nextCards": [
        "ai-interview-is-it-possible-that-during-ml-training-both-valida-148",
        "ai-interview-is-k-means-clustering-algorithm-guaranteed-to-conv-149"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-standardization-and-normalization?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-it-possible-that-during-ml-training-both-valida-148",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Is It possible That During ML Training, Both Validation (or Test) Loss and Accuracy are Increasing?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Yes, as accuracy and loss are not perfectly (inversely) correlated. Loss reflects the difference between raw predictions and classes, while accuracy measures the discrepancy between thresholded predictions and classes. Changes in raw predictions alter loss, but accuracy remains more resilient until predictions cross a threshold.</li>\n</ul>",
      "contentMarkdown": "*   Yes, as accuracy and loss are not perfectly (inversely) correlated. Loss reflects the difference between raw predictions and classes, while accuracy measures the discrepancy between thresholded predictions and classes. Changes in raw predictions alter loss, but accuracy remains more resilient until predictions cross a threshold.",
      "order": 148,
      "orderInChapter": 148,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 46,
        "contentLength": 352
      },
      "nextCards": [
        "ai-interview-is-k-means-clustering-algorithm-guaranteed-to-conv-149",
        "ai-interview-in-k-means-clustering-is-it-possible-that-a-centro-150"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-it-possible-that-during-ml-training,-both-validation-(or-test)-loss-and-accuracy-are-increasing?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-k-means-clustering-algorithm-guaranteed-to-conv-149",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Is K-means Clustering Algorithm Guaranteed to Converge with a Unique Result?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>K-means clustering algorithm is guaranteed to converge, but the final result can vary based on centroid initialization.</li>\n  <li>Multiple initialization strategies are recommended to achieve the best clustering outcome.</li>\n  <li>Convergence is assured as each iteration strictly decreases the sum of squared distances between points and their centroids.</li>\n  <li>K-means runs efficiently in practice, with a practically linear runtime.</li>\n</ul>",
      "contentMarkdown": "*   K-means clustering algorithm is guaranteed to converge, but the final result can vary based on centroid initialization.\n*   Multiple initialization strategies are recommended to achieve the best clustering outcome.\n*   Convergence is assured as each iteration strictly decreases the sum of squared distances between points and their centroids.\n*   K-means runs efficiently in practice, with a practically linear runtime.",
      "order": 149,
      "orderInChapter": 149,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 60,
        "contentLength": 463
      },
      "nextCards": [
        "ai-interview-in-k-means-clustering-is-it-possible-that-a-centro-150",
        "ai-interview-what-is-entropy-in-information-theory-151"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-k-means-clustering-algorithm-guaranteed-to-converge-with-a-unique-result?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-in-k-means-clustering-is-it-possible-that-a-centro-150",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "In K-means Clustering, is It possible That a Centroid Has No Data Points Assigned to It?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Yes, a centroid can end up with no data points assigned, particularly in cases like a centroid placed amidst a ring of other centroids.</li>\n  <li>Implementations often address this by removing or repositioning the centroid randomly within the data space.</li>\n</ul>",
      "contentMarkdown": "*   Yes, a centroid can end up with no data points assigned, particularly in cases like a centroid placed amidst a ring of other centroids.\n*   Implementations often address this by removing or repositioning the centroid randomly within the data space.",
      "order": 150,
      "orderInChapter": 150,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 41,
        "contentLength": 277
      },
      "nextCards": [
        "ai-interview-what-is-entropy-in-information-theory-151",
        "ai-interview-what-is-the-difference-between-supervised-and-unsu-152"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#in-k-means-clustering,-is-it-possible-that-a-centroid-has-no-data-points-assigned-to-it?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-entropy-in-information-theory-151",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Entropy in Information Theory?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Entropy measures a system’s unpredictability or the information amount required to describe its randomness.</li>\n  <li>It’s widely used in fields like information theory and statistical mechanics.</li>\n</ul>",
      "contentMarkdown": "*   Entropy measures a system’s unpredictability or the information amount required to describe its randomness.\n*   It’s widely used in fields like information theory and statistical mechanics.",
      "order": 151,
      "orderInChapter": 151,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 27,
        "contentLength": 218
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-supervised-and-unsu-152",
        "ai-interview-how-do-you-evaluate-the-performance-of-a-machine-l-153"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-entropy-in-information-theory?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-supervised-and-unsu-152",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Supervised and Unsupervised Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Supervised learning involves training models on labeled data for predictive tasks, whereas unsupervised learning uses unlabeled data to identify patterns or structures.</li>\n</ul>",
      "contentMarkdown": "*   Supervised learning involves training models on labeled data for predictive tasks, whereas unsupervised learning uses unlabeled data to identify patterns or structures.",
      "order": 152,
      "orderInChapter": 152,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "supervised learning",
        "unsupervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 23,
        "contentLength": 190
      },
      "nextCards": [
        "ai-interview-how-do-you-evaluate-the-performance-of-a-machine-l-153",
        "ai-interview-what-is-overfitting-in-machine-learning-and-how-ca-154"
      ],
      "relatedCards": [
        "ai-clustering-partitioning-clustering-1",
        "ai-ann-similarity-search-clustering-based-methods-6",
        "ai-ml-comp-model-ensembles-7",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-ml-comp-naive-bayes-classifier-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-supervised-and-unsupervised-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-evaluate-the-performance-of-a-machine-l-153",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "How Do You Evaluate the Performance of a Machine Learning Model?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Performance evaluation typically involves splitting data into training and test sets, employing metrics like accuracy, precision, recall, and F1 score on the test set.</li>\n</ul>",
      "contentMarkdown": "*   Performance evaluation typically involves splitting data into training and test sets, employing metrics like accuracy, precision, recall, and F1 score on the test set.",
      "order": 153,
      "orderInChapter": 153,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 25,
        "contentLength": 189
      },
      "nextCards": [
        "ai-interview-what-is-overfitting-in-machine-learning-and-how-ca-154",
        "ai-interview-what-is-the-difference-between-a-decision-tree-and-155"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-evaluate-the-performance-of-a-machine-learning-model?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-overfitting-in-machine-learning-and-how-ca-154",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Overfitting in Machine Learning and How Can It be Prevented?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Overfitting occurs when a model fits training data noise instead of the underlying pattern, leading to poor performance on new data.</li>\n  <li>Prevention strategies include cross-validation, regularization, and early stopping.</li>\n</ul>",
      "contentMarkdown": "*   Overfitting occurs when a model fits training data noise instead of the underlying pattern, leading to poor performance on new data.\n*   Prevention strategies include cross-validation, regularization, and early stopping.",
      "order": 154,
      "orderInChapter": 154,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "regularization",
        "cross-validation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 31,
        "contentLength": 249
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-a-decision-tree-and-155",
        "ai-interview-what-is-the-bias-variance-trade-off-in-machine-lea-156"
      ],
      "relatedCards": [
        "ai-ml-comp-support-vector-machines-5",
        "ai-model-debugging-overfitting-8",
        "ai-bias-variance-tradeoff-overfitting-and-underfitting-common-challenges-in--13",
        "ai-k-nearest-neighbors-parameters-4",
        "ai-decision-trees-and-ensemble-methods-regularization-in-decision-trees-13"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-overfitting-in-machine-learning-and-how-can-it-be-prevented?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-a-decision-tree-and-155",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between a Decision Tree and Random Forest?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>A decision tree is a singular model making predictions by traversing from root to leaf node.</li>\n  <li>In contrast, a random forest is an ensemble of decision trees, with the final prediction being an average of all trees’ predictions.</li>\n</ul>",
      "contentMarkdown": "*   A decision tree is a singular model making predictions by traversing from root to leaf node.\n*   In contrast, a random forest is an ensemble of decision trees, with the final prediction being an average of all trees’ predictions.",
      "order": 155,
      "orderInChapter": 155,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 40,
        "contentLength": 258
      },
      "nextCards": [
        "ai-interview-what-is-the-bias-variance-trade-off-in-machine-lea-156",
        "ai-interview-what-is-the-difference-between-batch-and-online-le-157"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-a-decision-tree-and-random-forest?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-bias-variance-trade-off-in-machine-lea-156",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Bias-Variance Trade-off in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The Bias-Variance trade-off balances a model’s fit on training data (low bias) against its generalization to new data (low variance).</li>\n  <li>High bias leads to underfitting, while high variance results in overfitting.</li>\n</ul>",
      "contentMarkdown": "*   The Bias-Variance trade-off balances a model’s fit on training data (low bias) against its generalization to new data (low variance).\n*   High bias leads to underfitting, while high variance results in overfitting.",
      "order": 156,
      "orderInChapter": 156,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 33,
        "contentLength": 243
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-batch-and-online-le-157",
        "ai-interview-what-is-the-difference-between-a-decision-boundary-158"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-bias-variance-trade-off-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-batch-and-online-le-157",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between Batch and Online Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Batch learning trains models on a fixed dataset, updating parameters after processing the entire dataset.</li>\n  <li>Online learning continuously updates model parameters incrementally with each new data example.</li>\n</ul>",
      "contentMarkdown": "*   Batch learning trains models on a fixed dataset, updating parameters after processing the entire dataset.\n*   Online learning continuously updates model parameters incrementally with each new data example.",
      "order": 157,
      "orderInChapter": 157,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 29,
        "contentLength": 234
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-a-decision-boundary-158",
        "ai-interview-what-is-the-use-of-principal-component-analysis-pc-159"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-batch-and-online-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-a-decision-boundary-158",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between a Decision Boundary and a Decision Surface in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>A decision boundary is a line or hyperplane separating classes in a dataset.</li>\n  <li>A decision surface is a multi-dimensional space’s surface doing the same task.</li>\n  <li>Essentially, a decision boundary is a one-dimensional representation of a decision surface.</li>\n</ul>",
      "contentMarkdown": "*   A decision boundary is a line or hyperplane separating classes in a dataset.\n*   A decision surface is a multi-dimensional space’s surface doing the same task.\n*   Essentially, a decision boundary is a one-dimensional representation of a decision surface.",
      "order": 158,
      "orderInChapter": 158,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 40,
        "contentLength": 291
      },
      "nextCards": [
        "ai-interview-what-is-the-use-of-principal-component-analysis-pc-159",
        "ai-interview-what-is-the-use-of-the-random-forest-algorithm-in--160"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-a-decision-boundary-and-a-decision-surface-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-use-of-principal-component-analysis-pc-159",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Use of Principal Component Analysis (PCA) in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Principal component analysis (PCA) is a statistical technique used in the field of machine learning to simplify the complexity in high-dimensional data while retaining trends and patterns.</li>\n  <li>It does this by transforming the original data into a new set of variables, the principal components, which are uncorrelated, and which are ordered so that the first few retain most of the variation present in all of the original variables.</li>\n  <li>The process involves calculating the eigenvalues and eigenvectors of a covariance matrix to identify the principal components.</li>\n  <li>PCA is particularly useful in processing data for machine learning algorithms, reducing the dimensionality of data, visualizing high-dimensional data, and can also help in improving algorithm performance by eliminating redundant features.</li>\n  <li>By reducing the number of features, PCA can help in mitigating problems like overfitting in machine learning models and can enhance the interpretability of the data while minimizing information loss.</li>\n</ul>",
      "contentMarkdown": "*   Principal component analysis (PCA) is a statistical technique used in the field of machine learning to simplify the complexity in high-dimensional data while retaining trends and patterns.\n*   It does this by transforming the original data into a new set of variables, the principal components, which are uncorrelated, and which are ordered so that the first few retain most of the variation present in all of the original variables.\n*   The process involves calculating the eigenvalues and eigenvectors of a covariance matrix to identify the principal components.\n*   PCA is particularly useful in processing data for machine learning algorithms, reducing the dimensionality of data, visualizing high-dimensional data, and can also help in improving algorithm performance by eliminating redundant features.\n*   By reducing the number of features, PCA can help in mitigating problems like overfitting in machine learning models and can enhance the interpretability of the data while minimizing information loss.",
      "order": 159,
      "orderInChapter": 159,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 151,
        "contentLength": 1061
      },
      "nextCards": [
        "ai-interview-what-is-the-use-of-the-random-forest-algorithm-in--160",
        "ai-interview-what-is-the-difference-between-a-generative-model--161"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-use-of-principal-component-analysis-(pca)-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-use-of-the-random-forest-algorithm-in--160",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Use of the Random Forest Algorithm in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Random Forest is an ensemble learning method, which operates by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees.</li>\n  <li>It is known for its simplicity and diversity since it combines the predictions of several decision trees, each built on a random subset of the training data and features, to produce more accurate and stable predictions.</li>\n  <li>The algorithm is highly versatile, capable of performing both classification and regression tasks. It is also used for feature selection and can handle missing values and maintain accuracy even with large datasets.</li>\n  <li>Random Forest is particularly effective in cases where the data contains a large number of features and complex relationships, as it can capture interactions between variables.</li>\n  <li>The algorithm is robust to overfitting, especially in cases where the number of trees in the forest is high. Each tree in the forest makes an independent prediction, and the final output is decided based on the majority voting principle, leading to better generalization on unseen data.</li>\n</ul>",
      "contentMarkdown": "*   Random Forest is an ensemble learning method, which operates by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees.\n*   It is known for its simplicity and diversity since it combines the predictions of several decision trees, each built on a random subset of the training data and features, to produce more accurate and stable predictions.\n*   The algorithm is highly versatile, capable of performing both classification and regression tasks. It is also used for feature selection and can handle missing values and maintain accuracy even with large datasets.\n*   Random Forest is particularly effective in cases where the data contains a large number of features and complex relationships, as it can capture interactions between variables.\n*   The algorithm is robust to overfitting, especially in cases where the number of trees in the forest is high. Each tree in the forest makes an independent prediction, and the final output is decided based on the majority voting principle, leading to better generalization on unseen data.",
      "order": 160,
      "orderInChapter": 160,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 185,
        "contentLength": 1219
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-a-generative-model--161",
        "ai-interview-what-is-the-difference-between-an-autoencoder-and--162"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-use-of-the-random-forest-algorithm-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-a-generative-model--161",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between a Generative Model and a Discriminative Model?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Generative models, such as Gaussian Mixture Models and Hidden Markov Models, aim to model the distribution of individual classes. They learn the joint probability distribution <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-160-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1301\" style=\"width: 3.284em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.711em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1002.66em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1302\"><span class=\"mi\" id=\"MathJax-Span-1303\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1304\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1305\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1306\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1307\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">y</span><span class=\"mo\" id=\"MathJax-Span-1308\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-160\">P(x, y)</script> and can be used to generate new instances of data.</li>\n  <li>\n    <table>\n      <tbody>\n        <tr>\n          <td>Discriminative models like Logistic Regression and Support Vector Machines, on the other hand, learn the boundary between classes in the feature space. They directly learn the conditional probability $$P(y</td>\n          <td>x)$$ and are typically used for classification tasks.</td>\n        </tr>\n      </tbody>\n    </table>\n  </li>\n  <li>Generative models are useful for tasks where we need to understand the underlying data distribution, such as in unsupervised learning, anomaly detection, and data generation tasks.</li>\n  <li>Discriminative models are often preferred when the goal is to make predictions on unseen data, as they generally provide better performance on classification tasks.</li>\n  <li>The choice between generative and discriminative models depends on the specific requirements of the task at hand, including the nature of the data, the goal of the analysis, and computational considerations.</li>\n</ul>\n<table>\n      <tbody>\n        <tr>\n          <td>Discriminative models like Logistic Regression and Support Vector Machines, on the other hand, learn the boundary between classes in the feature space. They directly learn the conditional probability $$P(y</td>\n          <td>x)$$ and are typically used for classification tasks.</td>\n        </tr>\n      </tbody>\n    </table>",
      "contentMarkdown": "*   Generative models, such as Gaussian Mixture Models and Hidden Markov Models, aim to model the distribution of individual classes. They learn the joint probability distribution P(x,y)P(x,y)P(x, y) and can be used to generate new instances of data.\n*   Discriminative models like Logistic Regression and Support Vector Machines, on the other hand, learn the boundary between classes in the feature space. They directly learn the conditional probability $$P(y\n    \n    x)$$ and are typically used for classification tasks.\n    \n*   Generative models are useful for tasks where we need to understand the underlying data distribution, such as in unsupervised learning, anomaly detection, and data generation tasks.\n*   Discriminative models are often preferred when the goal is to make predictions on unseen data, as they generally provide better performance on classification tasks.\n*   The choice between generative and discriminative models depends on the specific requirements of the task at hand, including the nature of the data, the goal of the analysis, and computational considerations.\n\nDiscriminative models like Logistic Regression and Support Vector Machines, on the other hand, learn the boundary between classes in the feature space. They directly learn the conditional probability $$P(y\n\nx)$$ and are typically used for classification tasks.",
      "order": 161,
      "orderInChapter": 161,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "supervised learning",
        "unsupervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 197,
        "contentLength": 3545
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-an-autoencoder-and--162",
        "ai-interview-what-is-expectation-maximization-em-algorithm-163"
      ],
      "relatedCards": [
        "ai-clustering-partitioning-clustering-1",
        "ai-transformers-in-transformers-how-does-categorical-cross-entropy-53",
        "ai-reinforcement-learning-direct-method-dm-26",
        "ai-ann-similarity-search-clustering-based-methods-6",
        "ai-reinforcement-learning-generalization-and-transfer-learning-39"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-a-generative-model-and-a-discriminative-model?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-an-autoencoder-and--162",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between an Autoencoder and a Variational Autoencoder?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>An autoencoder is a type of neural network used for unsupervised learning of efficient codings. The aim of an autoencoder is to learn a representation (encoding) for a set of data, typically for dimensionality reduction, by training the network to ignore signal “noise”.</li>\n  <li>A variational autoencoder (VAE), on the other hand, is a more sophisticated model that not only learns the encoding but also the distribution of the data. It is a generative model that is capable of producing new instances that resemble the input data.</li>\n  <li>While traditional autoencoders simply encode and decode the input data, VAEs add a probabilistic twist: they produce a distribution over the possible values of the latent variables, which can then be sampled to generate new data.</li>\n  <li>The key difference lies in how they treat their latent space. In a VAE, the latent space has well-defined properties that allow for controlled manipulation. This makes VAEs particularly useful for tasks like image generation and manipulation.</li>\n  <li>VAEs are more complex and require more computational resources than simple autoencoders, but they offer greater flexibility and power in modeling complex data distributions.</li>\n</ul>",
      "contentMarkdown": "*   An autoencoder is a type of neural network used for unsupervised learning of efficient codings. The aim of an autoencoder is to learn a representation (encoding) for a set of data, typically for dimensionality reduction, by training the network to ignore signal “noise”.\n*   A variational autoencoder (VAE), on the other hand, is a more sophisticated model that not only learns the encoding but also the distribution of the data. It is a generative model that is capable of producing new instances that resemble the input data.\n*   While traditional autoencoders simply encode and decode the input data, VAEs add a probabilistic twist: they produce a distribution over the possible values of the latent variables, which can then be sampled to generate new data.\n*   The key difference lies in how they treat their latent space. In a VAE, the latent space has well-defined properties that allow for controlled manipulation. This makes VAEs particularly useful for tasks like image generation and manipulation.\n*   VAEs are more complex and require more computational resources than simple autoencoders, but they offer greater flexibility and power in modeling complex data distributions.",
      "order": 162,
      "orderInChapter": 162,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "supervised learning",
        "unsupervised learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 188,
        "contentLength": 1236
      },
      "nextCards": [
        "ai-interview-what-is-expectation-maximization-em-algorithm-163",
        "ai-interview-what-is-the-difference-between-l1-and-l2-regulariz-164"
      ],
      "relatedCards": [
        "ai-clustering-partitioning-clustering-1",
        "ai-gnn-survey-papers-on-gnns-22",
        "ai-top-30-papers-neural-message-passing-for-quantum-chemistry-12",
        "ai-ann-similarity-search-clustering-based-methods-6",
        "ai-ml-comp-model-ensembles-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-an-autoencoder-and-a-variational-autoencoder?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-expectation-maximization-em-algorithm-163",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is Expectation-Maximization (EM) Algorithm?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The Expectation-Maximization (EM) algorithm is a statistical method for finding maximum likelihood estimates of parameters in probabilistic models, especially models with latent variables.</li>\n  <li>It is particularly useful in scenarios where the data is incomplete or has missing parts, as EM can handle hidden or latent variables efficiently.</li>\n  <li>The EM algorithm works in two steps: the Expectation step (E step) and the Maximization step (M step). In the E step, the algorithm estimates the missing data, and in the M step, it maximizes the likelihood function with respect to the parameters using the estimated data.</li>\n  <li>EM is an iterative process that alternates between performing an expectation (E) step, which creates a function for the expectation of the log-likelihood evaluated using the current estimate for the parameters, and a maximization (M) step, which computes parameters maximizing the expected log-likelihood found on the E step.</li>\n  <li>The algorithm is widely used in various fields such as data mining, computer vision, and bioinformatics, for tasks like clustering, image segmentation, and dealing with incomplete datasets.</li>\n</ul>",
      "contentMarkdown": "*   The Expectation-Maximization (EM) algorithm is a statistical method for finding maximum likelihood estimates of parameters in probabilistic models, especially models with latent variables.\n*   It is particularly useful in scenarios where the data is incomplete or has missing parts, as EM can handle hidden or latent variables efficiently.\n*   The EM algorithm works in two steps: the Expectation step (E step) and the Maximization step (M step). In the E step, the algorithm estimates the missing data, and in the M step, it maximizes the likelihood function with respect to the parameters using the estimated data.\n*   EM is an iterative process that alternates between performing an expectation (E) step, which creates a function for the expectation of the log-likelihood evaluated using the current estimate for the parameters, and a maximization (M) step, which computes parameters maximizing the expected log-likelihood found on the E step.\n*   The algorithm is widely used in various fields such as data mining, computer vision, and bioinformatics, for tasks like clustering, image segmentation, and dealing with incomplete datasets.",
      "order": 163,
      "orderInChapter": 163,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "computer vision"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 174,
        "contentLength": 1190
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-l1-and-l2-regulariz-164",
        "ai-interview-explain-support-vector-machine-svm-165"
      ],
      "relatedCards": [
        "ai-loss-dice-loss-7",
        "ai-distributed-training-parallelism-summary-23",
        "ai-ann-similarity-search-tree-based-methods-4",
        "ai-nlp-tasks-faqs-33",
        "ai-federated-learning-transportation-self-driving-cars-24"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-expectation-maximization-(em)-algorithm?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-l1-and-l2-regulariz-164",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Difference Between L1 and L2 Regularization in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>L1 regularization, also known as Lasso (Least Absolute Shrinkage and Selection Operator) regularization, adds a penalty equal to the absolute value of the magnitude of coefficients. This can lead to sparse models where some coefficients can become zero, thus performing feature selection.</li>\n  <li>L2 regularization, also known as Ridge regularization, adds a penalty equal to the square of the magnitude of coefficients. This tends to drive the values of the coefficients to small numbers rather than zero and encourages the minimization of the coefficients but does not perform feature selection.</li>\n  <li>L1 regularization is useful when trying to identify which features are important for predicting the target variable, as it can completely eliminate some features by setting their coefficients to zero.</li>\n  <li>L2 regularization is beneficial when all features need to be included to understand their influence on the target variable. It is effective in preventing overfitting but does not automatically select features.</li>\n  <li>In practice, the choice between L1 and L2 regularization depends on the dataset and the specific goals of the model. Sometimes a combination of both, known as Elastic Net regularization, is used to balance between feature selection and coefficient shrinkage.</li>\n</ul>",
      "contentMarkdown": "*   L1 regularization, also known as Lasso (Least Absolute Shrinkage and Selection Operator) regularization, adds a penalty equal to the absolute value of the magnitude of coefficients. This can lead to sparse models where some coefficients can become zero, thus performing feature selection.\n*   L2 regularization, also known as Ridge regularization, adds a penalty equal to the square of the magnitude of coefficients. This tends to drive the values of the coefficients to small numbers rather than zero and encourages the minimization of the coefficients but does not perform feature selection.\n*   L1 regularization is useful when trying to identify which features are important for predicting the target variable, as it can completely eliminate some features by setting their coefficients to zero.\n*   L2 regularization is beneficial when all features need to be included to understand their influence on the target variable. It is effective in preventing overfitting but does not automatically select features.\n*   In practice, the choice between L1 and L2 regularization depends on the dataset and the specific goals of the model. Sometimes a combination of both, known as Elastic Net regularization, is used to balance between feature selection and coefficient shrinkage.",
      "order": 164,
      "orderInChapter": 164,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 195,
        "contentLength": 1325
      },
      "nextCards": [
        "ai-interview-explain-support-vector-machine-svm-165",
        "ai-interview-what-is-the-use-of-the-k-nearest-neighbors-k-nn-al-166"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-regularization-in-decision-trees-13",
        "ai-decision-trees-and-ensemble-methods-summary-of-regularization-parameters-15",
        "ai-decision-trees-and-ensemble-methods-why-are-decision-trees-rarely-used-by-themselves-w-20",
        "ai-decision-trees-and-ensemble-methods-does-boosting-reduce-bias-and-variance-both-compar-24",
        "ai-decision-trees-and-ensemble-methods-is-an-occasional-side-effect-of-boosting-an-increa-28"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-l1-and-l2-regularization-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-support-vector-machine-svm-165",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Support Vector Machine (SVM).",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Support Vector Machine (SVM) is a powerful and versatile supervised machine learning algorithm, used for both classification and regression tasks, but primarily known for its use in classification.</li>\n  <li>The goal of the SVM algorithm is to find a hyperplane in an N-dimensional space (N — the number of features) that distinctly classifies the data points. The optimal hyperplane is the one with the largest margin, i.e., the maximum distance between data points of both classes.</li>\n  <li>SVMs can be used in both linear and non-linear classification. For non-linear classification, kernels are used to transform the input data into a higher-dimensional space where a linear separator can be found.</li>\n  <li>One of the key features of SVM is its use of the kernel trick, a method that enables it to solve non-linear classification problems by transforming the data into a</li>\n</ul>\n<p>higher-dimensional space where a linear separator can be found.</p>\n<ul>\n  <li>SVMs are known for their robustness, especially in high-dimensional spaces, and are relatively unaffected by overfitting, particularly in cases where the number of dimensions is greater than the number of samples.</li>\n</ul>",
      "contentMarkdown": "*   Support Vector Machine (SVM) is a powerful and versatile supervised machine learning algorithm, used for both classification and regression tasks, but primarily known for its use in classification.\n*   The goal of the SVM algorithm is to find a hyperplane in an N-dimensional space (N — the number of features) that distinctly classifies the data points. The optimal hyperplane is the one with the largest margin, i.e., the maximum distance between data points of both classes.\n*   SVMs can be used in both linear and non-linear classification. For non-linear classification, kernels are used to transform the input data into a higher-dimensional space where a linear separator can be found.\n*   One of the key features of SVM is its use of the kernel trick, a method that enables it to solve non-linear classification problems by transforming the data into a\n\nhigher-dimensional space where a linear separator can be found.\n\n*   SVMs are known for their robustness, especially in high-dimensional spaces, and are relatively unaffected by overfitting, particularly in cases where the number of dimensions is greater than the number of samples.",
      "order": 165,
      "orderInChapter": 165,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 182,
        "contentLength": 1209
      },
      "nextCards": [
        "ai-interview-what-is-the-use-of-the-k-nearest-neighbors-k-nn-al-166",
        "ai-interview-what-is-the-use-of-the-random-sampling-method-for--167"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-support-vector-machine-(svm).",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-use-of-the-k-nearest-neighbors-k-nn-al-166",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Use of the K-nearest Neighbors (k-NN) Algorithm?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>The k-nearest neighbors (k-NN) algorithm is a type of instance-based learning, or lazy learning, where the function is only approximated locally and all computation is deferred until classification.</li>\n  <li>The k-NN algorithm works by finding the k closest training data points (where k is a user-defined constant) to a new data point and then assigning the new data point to the most common class among those k neighbors.</li>\n  <li>It’s a simple algorithm that stores all available cases and classifies new cases based on a similarity measure (e.g., distance functions).</li>\n  <li>k-NN has been used in statistical estimation and pattern recognition as a non-parametric technique.</li>\n  <li>While the algorithm is simple and straightforward, it can become significantly slower as the size of the data in use grows, and its accuracy can be severely degraded with high-dimensional data.</li>\n</ul>",
      "contentMarkdown": "*   The k-nearest neighbors (k-NN) algorithm is a type of instance-based learning, or lazy learning, where the function is only approximated locally and all computation is deferred until classification.\n*   The k-NN algorithm works by finding the k closest training data points (where k is a user-defined constant) to a new data point and then assigning the new data point to the most common class among those k neighbors.\n*   It’s a simple algorithm that stores all available cases and classifies new cases based on a similarity measure (e.g., distance functions).\n*   k-NN has been used in statistical estimation and pattern recognition as a non-parametric technique.\n*   While the algorithm is simple and straightforward, it can become significantly slower as the size of the data in use grows, and its accuracy can be severely degraded with high-dimensional data.",
      "order": 166,
      "orderInChapter": 166,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 138,
        "contentLength": 913
      },
      "nextCards": [
        "ai-interview-what-is-the-use-of-the-random-sampling-method-for--167",
        "ai-interview-explain-bagging-method-in-ensemble-learning-168"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-use-of-the-k-nearest-neighbors-(k-nn)-algorithm?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-use-of-the-random-sampling-method-for--167",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "What is the Use of the Random Sampling Method for Feature Selection in Machine Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Random Sampling in feature selection involves randomly selecting a subset of features from the dataset and evaluating the performance of a model trained with this subset. This process is repeated multiple times to determine the most effective subset of features.</li>\n  <li>This method is particularly useful in scenarios with a large number of features, as it can significantly reduce the dimensionality of the dataset without relying on assumptions about the data.</li>\n  <li>By evaluating different random subsets, this approach can give insights into which features are most relevant for the model and can sometimes lead to surprising discoveries of effective feature combinations.</li>\n  <li>Random Sampling is a simple yet effective method for feature selection, especially in cases where computational resources are limited and a quick approximation of feature relevance is needed.</li>\n  <li>However, it’s important to note that the performance of the Random Sampling method can vary greatly, and it might miss important features that are only effective in combination with others.</li>\n</ul>",
      "contentMarkdown": "*   Random Sampling in feature selection involves randomly selecting a subset of features from the dataset and evaluating the performance of a model trained with this subset. This process is repeated multiple times to determine the most effective subset of features.\n*   This method is particularly useful in scenarios with a large number of features, as it can significantly reduce the dimensionality of the dataset without relying on assumptions about the data.\n*   By evaluating different random subsets, this approach can give insights into which features are most relevant for the model and can sometimes lead to surprising discoveries of effective feature combinations.\n*   Random Sampling is a simple yet effective method for feature selection, especially in cases where computational resources are limited and a quick approximation of feature relevance is needed.\n*   However, it’s important to note that the performance of the Random Sampling method can vary greatly, and it might miss important features that are only effective in combination with others.",
      "order": 167,
      "orderInChapter": 167,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 163,
        "contentLength": 1111
      },
      "nextCards": [
        "ai-interview-explain-bagging-method-in-ensemble-learning-168",
        "ai-interview-explain-adaboost-method-in-ensemble-learning-169"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-use-of-the-random-sampling-method-for-feature-selection-in-machine-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-bagging-method-in-ensemble-learning-168",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Bagging Method in Ensemble Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Bagging, or Bootstrap Aggregating, is an ensemble learning technique used to improve the stability and accuracy of machine learning algorithms.</li>\n  <li>It involves training multiple models (usually of the same type) on different subsets of the training dataset. These subsets are created by randomly sampling the original dataset with replacement (bootstrap samples).</li>\n  <li>Each model in the bagging technique runs independently, and their outputs are combined, usually by averaging (for regression problems) or majority voting (for classification problems).</li>\n  <li>Bagging is particularly effective in reducing variance, avoiding overfitting, and improving the accuracy of unstable models like decision trees.</li>\n  <li>Random Forest is a well-known example of the bagging technique, where decision trees are used as the base learners.</li>\n</ul>",
      "contentMarkdown": "*   Bagging, or Bootstrap Aggregating, is an ensemble learning technique used to improve the stability and accuracy of machine learning algorithms.\n*   It involves training multiple models (usually of the same type) on different subsets of the training dataset. These subsets are created by randomly sampling the original dataset with replacement (bootstrap samples).\n*   Each model in the bagging technique runs independently, and their outputs are combined, usually by averaging (for regression problems) or majority voting (for classification problems).\n*   Bagging is particularly effective in reducing variance, avoiding overfitting, and improving the accuracy of unstable models like decision trees.\n*   Random Forest is a well-known example of the bagging technique, where decision trees are used as the base learners.",
      "order": 168,
      "orderInChapter": 168,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 119,
        "contentLength": 871
      },
      "nextCards": [
        "ai-interview-explain-adaboost-method-in-ensemble-learning-169",
        "ai-interview-explain-gradient-boosting-method-in-ensemble-learn-170"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-bagging-method-in-ensemble-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-adaboost-method-in-ensemble-learning-169",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain AdaBoost Method in Ensemble Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>AdaBoost, short for Adaptive Boosting, is an ensemble learning technique that works by combining multiple weak learners to create a strong learner.</li>\n  <li>In AdaBoost, each subsequent model in the sequence focuses more on the data points that were incorrectly classified by the previous models. It does this by adjusting the weights of training data points; misclassified data points gain weight and correctly classified data points lose weight.</li>\n  <li>AdaBoost algorithms can be used with any type of classifier, but they are typically used with short decision trees, which are the weak learners.</li>\n  <li>The final prediction is made based on the weighted majority vote (for classification) or weighted sum (for regression) of the predictions from all models.</li>\n  <li>AdaBoost is particularly effective in increasing the accuracy of the model, as it focuses on the difficult cases where the base learners perform poorly.</li>\n</ul>",
      "contentMarkdown": "*   AdaBoost, short for Adaptive Boosting, is an ensemble learning technique that works by combining multiple weak learners to create a strong learner.\n*   In AdaBoost, each subsequent model in the sequence focuses more on the data points that were incorrectly classified by the previous models. It does this by adjusting the weights of training data points; misclassified data points gain weight and correctly classified data points lose weight.\n*   AdaBoost algorithms can be used with any type of classifier, but they are typically used with short decision trees, which are the weak learners.\n*   The final prediction is made based on the weighted majority vote (for classification) or weighted sum (for regression) of the predictions from all models.\n*   AdaBoost is particularly effective in increasing the accuracy of the model, as it focuses on the difficult cases where the base learners perform poorly.",
      "order": 169,
      "orderInChapter": 169,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 144,
        "contentLength": 957
      },
      "nextCards": [
        "ai-interview-explain-gradient-boosting-method-in-ensemble-learn-170",
        "ai-interview-explain-xgboost-method-in-ensemble-learning-171"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-adaboost-method-in-ensemble-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-gradient-boosting-method-in-ensemble-learn-170",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain Gradient Boosting Method in Ensemble Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>Gradient Boosting is an ensemble learning technique used for both classification and regression tasks. It builds the model in a stage-wise fashion like other boosting methods do, but it generalizes them by allowing optimization of an arbitrary differentiable loss function.</li>\n  <li>In Gradient Boosting, each new model is built to correct the errors made by the previous ones. The method involves training decision trees sequentially, each trying to correct its predecessor.</li>\n  <li>The algorithm builds the model in a step-wise additive manner; it uses a gradient descent algorithm to minimize the loss when adding new models.</li>\n  <li>This method is known for its effectiveness, especially with complex datasets where relationships between features are not easily captured by simpler models.</li>\n  <li>Gradient Boosting has been successful in numerous machine learning competitions and is widely used in industry due to its flexibility and high performance.</li>\n</ul>",
      "contentMarkdown": "*   Gradient Boosting is an ensemble learning technique used for both classification and regression tasks. It builds the model in a stage-wise fashion like other boosting methods do, but it generalizes them by allowing optimization of an arbitrary differentiable loss function.\n*   In Gradient Boosting, each new model is built to correct the errors made by the previous ones. The method involves training decision trees sequentially, each trying to correct its predecessor.\n*   The algorithm builds the model in a step-wise additive manner; it uses a gradient descent algorithm to minimize the loss when adding new models.\n*   This method is known for its effectiveness, especially with complex datasets where relationships between features are not easily captured by simpler models.\n*   Gradient Boosting has been successful in numerous machine learning competitions and is widely used in industry due to its flexibility and high performance.",
      "order": 170,
      "orderInChapter": 170,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning",
        "optimization",
        "gradient descent",
        "loss function"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 144,
        "contentLength": 990
      },
      "nextCards": [
        "ai-interview-explain-xgboost-method-in-ensemble-learning-171",
        "ai-interview-what-are-the-different-types-of-reasoning-tasks-in-172"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-decision-trees-and-ensemble-methods-boosting-9",
        "ai-decision-trees-and-ensemble-methods-is-adaboost-higher-bias-than-other-types-of-gradie-27",
        "ai-decision-trees-and-ensemble-methods-what-role-does-the-learning-rate-play-in-training--30",
        "ai-regularization-l1l1l1-regularization-feature-selection-and-weight-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-gradient-boosting-method-in-ensemble-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-xgboost-method-in-ensemble-learning-171",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Deep Learning",
      "title": "Explain XGBoost Method in Ensemble Learning?",
      "subtitle": "Deep Learning",
      "contentHtml": "<ul>\n  <li>XGBoost, which stands for Extreme Gradient Boosting, is an advanced and more efficient implementation of the Gradient Boosting algorithm.</li>\n  <li>It provides a scalable, distributed, and optimized version of Gradient Boosting, which makes it extremely fast and effective, particularly with large and complex datasets.</li>\n  <li>XGBoost includes several key features such as handling missing values, pruning trees, and regularization to avoid overfitting, which improves its overall performance and accuracy.</li>\n  <li>It is highly customizable, allowing users to define their own optimization objectives and evaluation criteria, adding to its flexibility.</li>\n  <li>XGBoost has gained immense popularity and is widely used in machine learning competitions due to its performance, speed, and scalability. It’s a go-to algorithm for many predictive modeling tasks.</li>\n</ul>",
      "contentMarkdown": "*   XGBoost, which stands for Extreme Gradient Boosting, is an advanced and more efficient implementation of the Gradient Boosting algorithm.\n*   It provides a scalable, distributed, and optimized version of Gradient Boosting, which makes it extremely fast and effective, particularly with large and complex datasets.\n*   XGBoost includes several key features such as handling missing values, pruning trees, and regularization to avoid overfitting, which improves its overall performance and accuracy.\n*   It is highly customizable, allowing users to define their own optimization objectives and evaluation criteria, adding to its flexibility.\n*   XGBoost has gained immense popularity and is widely used in machine learning competitions due to its performance, speed, and scalability. It’s a go-to algorithm for many predictive modeling tasks.",
      "order": 171,
      "orderInChapter": 171,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning",
        "optimization",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 120,
        "contentLength": 890
      },
      "nextCards": [
        "ai-interview-what-are-the-different-types-of-reasoning-tasks-in-172",
        "ai-interview-how-much-vram-is-required-to-load-a-7b-llm-173"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-for-practical-deployments-why-is-boosting-preferre-23",
        "ai-agentic-RL-foundations-and-theoretical-advancements-in-tir-61",
        "ai-deepseek-R1-in-the-equation-for-grpo-what-is-the-role-of-the-o-24",
        "ai-federated-learning-feddyn-10",
        "ai-conditional-random-fields-parameter-estimation-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-xgboost-method-in-ensemble-learning?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-different-types-of-reasoning-tasks-in-172",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What are the Different Types of Reasoning Tasks in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>\n    <p><strong>Arithmetic Reasoning:</strong> This involves an NLP system’s capability to process and compute mathematical data. It encompasses a range of operations, from simple arithmetic like addition and subtraction to more intricate mathematical tasks like solving algebraic equations or calculus problems. For example, it could involve determining the sum of numbers in a text or solving more complex mathematical expressions presented in natural language.</p>\n  </li>\n  <li>\n    <p><strong>Commonsense Reasoning:</strong> This type of reasoning is about the NLP system’s ability to interpret and make sense of information that is generally known or assumed by humans. It includes understanding social norms, cultural implications, and everyday experiences. For instance, an NLP system employing commonsense reasoning can discern the implausibility of historical figures using modern technology. A relevant dataset in this context is <a href=\"https://allenai.org/data/strategyqa\">StrategyQA</a>, which includes True/False questions like “Did Aristotle use a laptop?”</p>\n  </li>\n  <li>\n    <p><strong>Symbolic Reasoning:</strong> This involves the manipulation and interpretation of symbolic information by an NLP system. Key tasks include parsing sentences, executing string operations, and identifying semantic roles and entities within a text. An example task could involve analyzing and concatenating specific parts of words or phrases, as seen in datasets like Last Letter Concatenation, which includes challenges like “Take the last letters of the words in ‘Lady Gaga’ and concatenate them.”</p>\n  </li>\n  <li>\n    <p><strong>Logic Reasoning:</strong> In logic reasoning, an NLP system is tasked with drawing logical inferences based on established rules and principles. This includes identifying fallacies, assessing the validity of arguments, and making deductions through deductive reasoning. For example, understanding and interpreting dates and their significance in context, as seen in datasets with questions like “Today is Christmas Eve 1937, what is the date tomorrow in MM/DD/YYYY?”</p>\n  </li>\n</ul>\n<p><strong>Arithmetic Reasoning:</strong> This involves an NLP system’s capability to process and compute mathematical data. It encompasses a range of operations, from simple arithmetic like addition and subtraction to more intricate mathematical tasks like solving algebraic equations or calculus problems. For example, it could involve determining the sum of numbers in a text or solving more complex mathematical expressions presented in natural language.</p>\n<p><strong>Commonsense Reasoning:</strong> This type of reasoning is about the NLP system’s ability to interpret and make sense of information that is generally known or assumed by humans. It includes understanding social norms, cultural implications, and everyday experiences. For instance, an NLP system employing commonsense reasoning can discern the implausibility of historical figures using modern technology. A relevant dataset in this context is <a href=\"https://allenai.org/data/strategyqa\">StrategyQA</a>, which includes True/False questions like “Did Aristotle use a laptop?”</p>\n<p><strong>Symbolic Reasoning:</strong> This involves the manipulation and interpretation of symbolic information by an NLP system. Key tasks include parsing sentences, executing string operations, and identifying semantic roles and entities within a text. An example task could involve analyzing and concatenating specific parts of words or phrases, as seen in datasets like Last Letter Concatenation, which includes challenges like “Take the last letters of the words in ‘Lady Gaga’ and concatenate them.”</p>\n<p><strong>Logic Reasoning:</strong> In logic reasoning, an NLP system is tasked with drawing logical inferences based on established rules and principles. This includes identifying fallacies, assessing the validity of arguments, and making deductions through deductive reasoning. For example, understanding and interpreting dates and their significance in context, as seen in datasets with questions like “Today is Christmas Eve 1937, what is the date tomorrow in MM/DD/YYYY?”</p>",
      "contentMarkdown": "*   **Arithmetic Reasoning:** This involves an NLP system’s capability to process and compute mathematical data. It encompasses a range of operations, from simple arithmetic like addition and subtraction to more intricate mathematical tasks like solving algebraic equations or calculus problems. For example, it could involve determining the sum of numbers in a text or solving more complex mathematical expressions presented in natural language.\n    \n*   **Commonsense Reasoning:** This type of reasoning is about the NLP system’s ability to interpret and make sense of information that is generally known or assumed by humans. It includes understanding social norms, cultural implications, and everyday experiences. For instance, an NLP system employing commonsense reasoning can discern the implausibility of historical figures using modern technology. A relevant dataset in this context is [StrategyQA](https://allenai.org/data/strategyqa), which includes True/False questions like “Did Aristotle use a laptop?”\n    \n*   **Symbolic Reasoning:** This involves the manipulation and interpretation of symbolic information by an NLP system. Key tasks include parsing sentences, executing string operations, and identifying semantic roles and entities within a text. An example task could involve analyzing and concatenating specific parts of words or phrases, as seen in datasets like Last Letter Concatenation, which includes challenges like “Take the last letters of the words in ‘Lady Gaga’ and concatenate them.”\n    \n*   **Logic Reasoning:** In logic reasoning, an NLP system is tasked with drawing logical inferences based on established rules and principles. This includes identifying fallacies, assessing the validity of arguments, and making deductions through deductive reasoning. For example, understanding and interpreting dates and their significance in context, as seen in datasets with questions like “Today is Christmas Eve 1937, what is the date tomorrow in MM/DD/YYYY?”\n    \n\n**Arithmetic Reasoning:** This involves an NLP system’s capability to process and compute mathematical data. It encompasses a range of operations, from simple arithmetic like addition and subtraction to more intricate mathematical tasks like solving algebraic equations or calculus problems. For example, it could involve determining the sum of numbers in a text or solving more complex mathematical expressions presented in natural language.\n\n**Commonsense Reasoning:** This type of reasoning is about the NLP system’s ability to interpret and make sense of information that is generally known or assumed by humans. It includes understanding social norms, cultural implications, and everyday experiences. For instance, an NLP system employing commonsense reasoning can discern the implausibility of historical figures using modern technology. A relevant dataset in this context is [StrategyQA](https://allenai.org/data/strategyqa), which includes True/False questions like “Did Aristotle use a laptop?”\n\n**Symbolic Reasoning:** This involves the manipulation and interpretation of symbolic information by an NLP system. Key tasks include parsing sentences, executing string operations, and identifying semantic roles and entities within a text. An example task could involve analyzing and concatenating specific parts of words or phrases, as seen in datasets like Last Letter Concatenation, which includes challenges like “Take the last letters of the words in ‘Lady Gaga’ and concatenate them.”\n\n**Logic Reasoning:** In logic reasoning, an NLP system is tasked with drawing logical inferences based on established rules and principles. This includes identifying fallacies, assessing the validity of arguments, and making deductions through deductive reasoning. For example, understanding and interpreting dates and their significance in context, as seen in datasets with questions like “Today is Christmas Eve 1937, what is the date tomorrow in MM/DD/YYYY?”",
      "order": 172,
      "orderInChapter": 1,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 546,
        "contentLength": 4182
      },
      "nextCards": [
        "ai-interview-how-much-vram-is-required-to-load-a-7b-llm-173",
        "ai-interview-what-are-word-embeddings-in-nlp-174"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-mixture-of-lora-experts-82",
        "ai-word-vectors-bag-of-words-bow-23",
        "ai-nlp-tasks-definition-and-purpose-21",
        "ai-nlp-tasks-future-directions-26",
        "ai-nlp-tasks-definition-and-purpose-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-different-types-of-reasoning-tasks-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-much-vram-is-required-to-load-a-7b-llm-173",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "How Much VRAM is Required to Load a 7B LLM?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>The VRAM requirement for loading a 7 billion parameter Large Language Model (LLM) varies based on the precision of the parameters. In full precision (float32), each parameter uses 4 bytes, totaling 28 GB for the entire model. If half precision (16 bits or 2 bytes per parameter) is used, this requirement is halved to 14 GB. More efficient algorithms can reduce this further: using 4-bit precision lowers the requirement to just 3.5 GB. However, for training, the memory demands increase significantly depending on the optimizer. For instance, using the AdamW optimizer requires 56 GB (8 bytes per parameter), while AdaFactor needs 28 GB (4 bytes per parameter). More recent optimizers like 8-bit AdamW could reduce this to 14 GB. This information is detailed in discussions and documents on platforms like Hugging Face.</li>\n</ul>",
      "contentMarkdown": "*   The VRAM requirement for loading a 7 billion parameter Large Language Model (LLM) varies based on the precision of the parameters. In full precision (float32), each parameter uses 4 bytes, totaling 28 GB for the entire model. If half precision (16 bits or 2 bytes per parameter) is used, this requirement is halved to 14 GB. More efficient algorithms can reduce this further: using 4-bit precision lowers the requirement to just 3.5 GB. However, for training, the memory demands increase significantly depending on the optimizer. For instance, using the AdamW optimizer requires 56 GB (8 bytes per parameter), while AdaFactor needs 28 GB (4 bytes per parameter). More recent optimizers like 8-bit AdamW could reduce this to 14 GB. This information is detailed in discussions and documents on platforms like Hugging Face.",
      "order": 173,
      "orderInChapter": 2,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "llm"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 133,
        "contentLength": 842
      },
      "nextCards": [
        "ai-interview-what-are-word-embeddings-in-nlp-174",
        "ai-interview-what-is-sentence-encoding-175"
      ],
      "relatedCards": [
        "ai-prompt-engineering-how-does-react-work-5",
        "ai-prompt-engineering-react-usage-with-langchain-9",
        "ai-token-sampling-logits-and-softmax-3",
        "ai-reinforcement-learning-the-bellman-equation-2",
        "ai-mixture-of-experts-openmoe-71"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-much-vram-is-required-to-load-a-7b-llm?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-word-embeddings-in-nlp-174",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What are Word Embeddings in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Word embeddings are dense vector representations of words in natural language processing (NLP). These vectors are learned from data using models like word2vec or GloVe and capture the semantic meaning of words. Words with similar meanings have similar vector representations. These embeddings are crucial in various NLP tasks, including language translation, text classification, and text generation, where they serve as input and facilitate the understanding of language nuances.</li>\n</ul>",
      "contentMarkdown": "*   Word embeddings are dense vector representations of words in natural language processing (NLP). These vectors are learned from data using models like word2vec or GloVe and capture the semantic meaning of words. Words with similar meanings have similar vector representations. These embeddings are crucial in various NLP tasks, including language translation, text classification, and text generation, where they serve as input and facilitate the understanding of language nuances.",
      "order": 174,
      "orderInChapter": 3,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "embedding",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 69,
        "contentLength": 502
      },
      "nextCards": [
        "ai-interview-what-is-sentence-encoding-175",
        "ai-interview-explain-the-concept-of-attention-mechanism-in-nlp-176"
      ],
      "relatedCards": [
        "ai-word-vectors-glove-global-vectors-for-word-representation-27",
        "ai-word-vectors-extensions-and-successors-37",
        "ai-mixture-of-experts-structural-and-concept-aware-routing-53",
        "ai-data-filtering-embedding-extraction-22",
        "ai-data-filtering-deduplication-methods-36"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-word-embeddings-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-sentence-encoding-175",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is Sentence Encoding?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Sentence encoding in NLP is the transformation of sentences into fixed-length vector representations, known as sentence embeddings. These embeddings are generated through various methods, including bag-of-words, TF-IDF, or advanced models like BERT. The process typically involves tokenizing the sentence into words or tokens, computing their individual embeddings, and then aggregating these to form a cohesive sentence representation. These embeddings are used in diverse NLP tasks like text classification, text generation, and assessing text similarity.</li>\n</ul>",
      "contentMarkdown": "*   Sentence encoding in NLP is the transformation of sentences into fixed-length vector representations, known as sentence embeddings. These embeddings are generated through various methods, including bag-of-words, TF-IDF, or advanced models like BERT. The process typically involves tokenizing the sentence into words or tokens, computing their individual embeddings, and then aggregating these to form a cohesive sentence representation. These embeddings are used in diverse NLP tasks like text classification, text generation, and assessing text similarity.",
      "order": 175,
      "orderInChapter": 4,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "embedding",
        "bert",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 75,
        "contentLength": 579
      },
      "nextCards": [
        "ai-interview-explain-the-concept-of-attention-mechanism-in-nlp-176",
        "ai-interview-what-are-transformer-models-in-nlp-177"
      ],
      "relatedCards": [
        "ai-data-filtering-embedding-extraction-22",
        "ai-data-filtering-deduplication-methods-36",
        "ai-word-vectors-bag-of-words-bow-8",
        "ai-word-vectors-comparative-summary-30",
        "ai-word-vectors-key-takeaways-31"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-sentence-encoding?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-concept-of-attention-mechanism-in-nlp-176",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Explain the Concept of Attention Mechanism in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>The attention mechanism in NLP is a technique that allows neural networks to focus on different parts of the input data, assigning varying levels of importance to each part. It’s particularly useful in tasks like machine translation, where the model needs to selectively concentrate on specific segments of the input sentence during different phases of processing. The mechanism can be implemented in several ways, such as additive attention (summing query and key vectors) and dot-product attention (multiplying query and key vectors).</li>\n</ul>",
      "contentMarkdown": "*   The attention mechanism in NLP is a technique that allows neural networks to focus on different parts of the input data, assigning varying levels of importance to each part. It’s particularly useful in tasks like machine translation, where the model needs to selectively concentrate on specific segments of the input sentence during different phases of processing. The mechanism can be implemented in several ways, such as additive attention (summing query and key vectors) and dot-product attention (multiplying query and key vectors).",
      "order": 176,
      "orderInChapter": 5,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "attention",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 82,
        "contentLength": 558
      },
      "nextCards": [
        "ai-interview-what-are-transformer-models-in-nlp-177",
        "ai-interview-can-you-explain-the-concept-of-named-entity-recogn-178"
      ],
      "relatedCards": [
        "ai-transformers-gnns-build-representations-of-graphs-23",
        "ai-architectures-applications-32",
        "ai-attention-origins-and-definitions-7",
        "ai-vit-why-does-vit-use-linear-projections-of-flattened-p-3",
        "ai-word-vectors-contextual-and-sequential-data-embeddings-18"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-concept-of-attention-mechanism-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-transformer-models-in-nlp-177",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What are Transformer Models in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Transformer models are a groundbreaking neural network architecture in NLP, renowned for their success in tasks like language translation and comprehension. Introduced in the seminal transformer paper, these models utilize the self-attention mechanism, enabling them to process long input sequences effectively and manage word dependencies. The architecture’s ability to weigh different parts of the input distinctly is key to its performance. For a detailed exploration, refer to documents like <a href=\"transformer.md\">transformer.md</a>.</li>\n</ul>",
      "contentMarkdown": "*   Transformer models are a groundbreaking neural network architecture in NLP, renowned for their success in tasks like language translation and comprehension. Introduced in the seminal transformer paper, these models utilize the self-attention mechanism, enabling them to process long input sequences effectively and manage word dependencies. The architecture’s ability to weigh different parts of the input distinctly is key to its performance. For a detailed exploration, refer to documents like [transformer.md](transformer.md).",
      "order": 177,
      "orderInChapter": 6,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "transformer",
        "attention",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 71,
        "contentLength": 562
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-named-entity-recogn-178",
        "ai-interview-explain-part-of-speech-pos-tagging-in-nlp-179"
      ],
      "relatedCards": [
        "ai-transformers-gnns-build-representations-of-graphs-23",
        "ai-attention-linear-attention-13",
        "ai-transformers-scaling-issues-12",
        "ai-transformers-sentences-are-fully-connected-word-graphs-24",
        "ai-transformers-long-term-dependencies-32"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-transformer-models-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-named-entity-recogn-178",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Can You Explain the Concept of Named Entity Recognition (NER) in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Named Entity Recognition (NER) is a crucial task in information extraction where the aim is to identify and categorize named entities in text into specific groups like person names, organizations, locations, and others. NER systems can be built using rule-based methods or machine learning techniques. They play a vital role in various applications, including information retrieval, question answering, and summarization, by providing a structured understanding of the text.</li>\n</ul>",
      "contentMarkdown": "*   Named Entity Recognition (NER) is a crucial task in information extraction where the aim is to identify and categorize named entities in text into specific groups like person names, organizations, locations, and others. NER systems can be built using rule-based methods or machine learning techniques. They play a vital role in various applications, including information retrieval, question answering, and summarization, by providing a structured understanding of the text.",
      "order": 178,
      "orderInChapter": 7,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 69,
        "contentLength": 496
      },
      "nextCards": [
        "ai-interview-explain-part-of-speech-pos-tagging-in-nlp-179",
        "ai-interview-can-you-explain-the-concept-of-language-modeling-i-180"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-named-entity-recognition-(ner)-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-part-of-speech-pos-tagging-in-nlp-179",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Explain Part-of-Speech (POS) Tagging in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Part-of-Speech (POS) tagging is the process of labeling each word in a text with its appropriate grammatical category, such as noun, verb, adjective, etc. This is a foundational step in numerous NLP tasks, facilitating deeper linguistic analysis of texts. POS tagging methods range from rule-based systems to machine learning approaches, with algorithms like Hidden Markov Models and Conditional Random Fields often employed for this purpose.</li>\n</ul>",
      "contentMarkdown": "*   Part-of-Speech (POS) tagging is the process of labeling each word in a text with its appropriate grammatical category, such as noun, verb, adjective, etc. This is a foundational step in numerous NLP tasks, facilitating deeper linguistic analysis of texts. POS tagging methods range from rule-based systems to machine learning approaches, with algorithms like Hidden Markov Models and Conditional Random Fields often employed for this purpose.",
      "order": 179,
      "orderInChapter": 8,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "machine learning",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 66,
        "contentLength": 464
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-language-modeling-i-180",
        "ai-interview-can-you-explain-the-concept-of-text-summarization-181"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-mixture-of-experts-mixture-of-lora-experts-82"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-part-of-speech-(pos)-tagging-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-language-modeling-i-180",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Can You Explain the Concept of Language Modeling in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Language modeling is an essential task in NLP, focusing on predicting the next word in a sentence based on the preceding words. This involves training a model on a vast corpus of text to understand the probabilistic distribution of words within a language. Language models are fundamental to a variety of applications, including machine translation, text generation, and speech recognition, enabling systems to generate coherent and contextually relevant language outputs.</li>\n</ul>",
      "contentMarkdown": "*   Language modeling is an essential task in NLP, focusing on predicting the next word in a sentence based on the preceding words. This involves training a model on a vast corpus of text to understand the probabilistic distribution of words within a language. Language models are fundamental to a variety of applications, including machine translation, text generation, and speech recognition, enabling systems to generate coherent and contextually relevant language outputs.",
      "order": 180,
      "orderInChapter": 9,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 71,
        "contentLength": 494
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-text-summarization-181",
        "ai-interview-what-is-sentiment-analysis-182"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-mixture-of-lora-experts-82",
        "ai-word-vectors-bag-of-words-bow-23",
        "ai-nlp-tasks-definition-and-purpose-21",
        "ai-nlp-tasks-future-directions-26",
        "ai-nlp-tasks-definition-and-purpose-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-language-modeling-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-text-summarization-181",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Can You Explain the Concept of Text Summarization?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Text summarization is the process of condensing a text into a shorter version while retaining its key information. There are two primary approaches: extractive summarization, which involves selecting significant sentences or phrases directly from the text, and abstractive summarization, which generates new text that encapsulates the original content’s essence. This task is crucial in distilling large volumes of information into digestible, informative summaries.</li>\n</ul>",
      "contentMarkdown": "*   Text summarization is the process of condensing a text into a shorter version while retaining its key information. There are two primary approaches: extractive summarization, which involves selecting significant sentences or phrases directly from the text, and abstractive summarization, which generates new text that encapsulates the original content’s essence. This task is crucial in distilling large volumes of information into digestible, informative summaries.",
      "order": 181,
      "orderInChapter": 10,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 64,
        "contentLength": 488
      },
      "nextCards": [
        "ai-interview-what-is-sentiment-analysis-182",
        "ai-interview-can-you-explain-the-concept-of-dependency-parsing-183"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-text-summarization?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-sentiment-analysis-182",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is Sentiment Analysis?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Sentiment analysis is the process of determining the emotional tone behind a piece of text, categorizing it as positive, negative, or neutral. This task is accomplished through various methodologies, including rule-based systems, machine learning, and deep learning techniques. Sentiment analysis finds extensive application in fields like customer feedback analysis and social media monitoring, providing valuable insights into public opinion and attitudes.</li>\n</ul>",
      "contentMarkdown": "*   Sentiment analysis is the process of determining the emotional tone behind a piece of text, categorizing it as positive, negative, or neutral. This task is accomplished through various methodologies, including rule-based systems, machine learning, and deep learning techniques. Sentiment analysis finds extensive application in fields like customer feedback analysis and social media monitoring, providing valuable insights into public opinion and attitudes.",
      "order": 182,
      "orderInChapter": 11,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "deep learning",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 62,
        "contentLength": 480
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-dependency-parsing-183",
        "ai-interview-explain-the-coreference-resolution-task-in-nlp-184"
      ],
      "relatedCards": [
        "ai-online-testing-why-is-online-testing-necessary-despite-offline-ev-80",
        "ai-drift-tests-and-techniques-5",
        "ai-mlops-tooling-simplification-tools-18",
        "ai-ml-comp-machine-learning-or-deep-learning-10",
        "ai-encoder-vs-decoder-models-how-does-an-autoregressive-model-work-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-sentiment-analysis?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-dependency-parsing-183",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Can You Explain the Concept of Dependency Parsing?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Dependency parsing is a method used in NLP to analyze the grammatical structure of a sentence by identifying the relationships between its words. This involves constructing a dependency parse tree that graphically represents these relationships, highlighting how words in a sentence depend on each other. Dependency parsing is a fundamental step in many NLP applications, including machine translation, text summarization, and information extraction, aiding in the comprehension of sentence structure and syntax.</li>\n</ul>",
      "contentMarkdown": "*   Dependency parsing is a method used in NLP to analyze the grammatical structure of a sentence by identifying the relationships between its words. This involves constructing a dependency parse tree that graphically represents these relationships, highlighting how words in a sentence depend on each other. Dependency parsing is a fundamental step in many NLP applications, including machine translation, text summarization, and information extraction, aiding in the comprehension of sentence structure and syntax.",
      "order": 183,
      "orderInChapter": 12,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 73,
        "contentLength": 534
      },
      "nextCards": [
        "ai-interview-explain-the-coreference-resolution-task-in-nlp-184",
        "ai-interview-explain-stemming-and-lemmatization-in-nlp-185"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-mixture-of-lora-experts-82",
        "ai-word-vectors-bag-of-words-bow-23",
        "ai-nlp-tasks-definition-and-purpose-21",
        "ai-nlp-tasks-future-directions-26",
        "ai-nlp-tasks-definition-and-purpose-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-dependency-parsing?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-coreference-resolution-task-in-nlp-184",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Explain the Coreference Resolution Task in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Coreference resolution in NLP involves identifying instances where different expressions in a text refer to the same entity. This process entails analyzing the text to determine when two or more expressions share the same referent, a critical aspect of understanding textual context and relationships. For example, in the sentence “Mohit lives in Pune and he works as a Data Scientist,” coreference resolution would recognize “Mohit” and “he” as referring to the same individual. This task is integral to various NLP applications, such as machine translation, summarization, and information extraction.</li>\n</ul>",
      "contentMarkdown": "*   Coreference resolution in NLP involves identifying instances where different expressions in a text refer to the same entity. This process entails analyzing the text to determine when two or more expressions share the same referent, a critical aspect of understanding textual context and relationships. For example, in the sentence “Mohit lives in Pune and he works as a Data Scientist,” coreference resolution would recognize “Mohit” and “he” as referring to the same individual. This task is integral to various NLP applications, such as machine translation, summarization, and information extraction.",
      "order": 184,
      "orderInChapter": 13,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 90,
        "contentLength": 624
      },
      "nextCards": [
        "ai-interview-explain-stemming-and-lemmatization-in-nlp-185",
        "ai-interview-what-is-text-classification-186"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-mixture-of-lora-experts-82",
        "ai-word-vectors-bag-of-words-bow-23",
        "ai-nlp-tasks-definition-and-purpose-21",
        "ai-nlp-tasks-future-directions-26",
        "ai-nlp-tasks-definition-and-purpose-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-coreference-resolution-task-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-stemming-and-lemmatization-in-nlp-185",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Explain Stemming and Lemmatization in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>\n    <p><strong>Stemming:</strong> This is a linguistic process that reduces words to their root form or stem, often by trimming affixes (suffixes or prefixes). Stemming algorithms, such as Porter’s stemmer, simplify words but may not always result in a valid word. For example, “running” might be stemmed to “runn.” The primary objective is to decrease text dimensionality and consolidate different forms of a word for analysis.</p>\n  </li>\n  <li>\n    <p><strong>Lemmatization:</strong> Unlike stemming, lemmatization reduces words to their base or dictionary form, known as the lemma. It involves a more sophisticated linguistic understanding, considering the word’s part of speech and context. Thus, “running” would be correctly lemmatized to “run.” Lemmatization is beneficial in NLP tasks for its accuracy in grouping various word forms while maintaining semantic integrity.</p>\n  </li>\n</ul>\n<p><strong>Stemming:</strong> This is a linguistic process that reduces words to their root form or stem, often by trimming affixes (suffixes or prefixes). Stemming algorithms, such as Porter’s stemmer, simplify words but may not always result in a valid word. For example, “running” might be stemmed to “runn.” The primary objective is to decrease text dimensionality and consolidate different forms of a word for analysis.</p>\n<p><strong>Lemmatization:</strong> Unlike stemming, lemmatization reduces words to their base or dictionary form, known as the lemma. It involves a more sophisticated linguistic understanding, considering the word’s part of speech and context. Thus, “running” would be correctly lemmatized to “run.” Lemmatization is beneficial in NLP tasks for its accuracy in grouping various word forms while maintaining semantic integrity.</p>",
      "contentMarkdown": "*   **Stemming:** This is a linguistic process that reduces words to their root form or stem, often by trimming affixes (suffixes or prefixes). Stemming algorithms, such as Porter’s stemmer, simplify words but may not always result in a valid word. For example, “running” might be stemmed to “runn.” The primary objective is to decrease text dimensionality and consolidate different forms of a word for analysis.\n    \n*   **Lemmatization:** Unlike stemming, lemmatization reduces words to their base or dictionary form, known as the lemma. It involves a more sophisticated linguistic understanding, considering the word’s part of speech and context. Thus, “running” would be correctly lemmatized to “run.” Lemmatization is beneficial in NLP tasks for its accuracy in grouping various word forms while maintaining semantic integrity.\n    \n\n**Stemming:** This is a linguistic process that reduces words to their root form or stem, often by trimming affixes (suffixes or prefixes). Stemming algorithms, such as Porter’s stemmer, simplify words but may not always result in a valid word. For example, “running” might be stemmed to “runn.” The primary objective is to decrease text dimensionality and consolidate different forms of a word for analysis.\n\n**Lemmatization:** Unlike stemming, lemmatization reduces words to their base or dictionary form, known as the lemma. It involves a more sophisticated linguistic understanding, considering the word’s part of speech and context. Thus, “running” would be correctly lemmatized to “run.” Lemmatization is beneficial in NLP tasks for its accuracy in grouping various word forms while maintaining semantic integrity.",
      "order": 185,
      "orderInChapter": 14,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 244,
        "contentLength": 1768
      },
      "nextCards": [
        "ai-interview-what-is-text-classification-186",
        "ai-interview-what-are-dialogue-systems-in-nlp-187"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-mixture-of-lora-experts-82",
        "ai-word-vectors-bag-of-words-bow-23",
        "ai-nlp-tasks-definition-and-purpose-21",
        "ai-nlp-tasks-future-directions-26",
        "ai-nlp-tasks-definition-and-purpose-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-stemming-and-lemmatization-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-text-classification-186",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is Text Classification?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>\n    <p>Text classification refers to the task of categorizing text into predefined labels or categories. It involves training models on labeled datasets to predict the category of new text. This task finds extensive application in diverse domains, such as in sentiment analysis, spam detection, and topic categorization. Text classification can be of various types:</p>\n\n    <ul>\n      <li><strong>Binary Classification:</strong> Involves two distinct categories, like categorizing sentiments as positive or negative.</li>\n      <li><strong>Multi-Class Classification:</strong> Deals with more than two categories, such as classifying text into multiple sentiment categories like positive, negative, and neutral.</li>\n      <li><strong>Multi-Label Classification:</strong> Each text can be assigned multiple labels, accommodating texts that embody elements of multiple categories simultaneously.</li>\n    </ul>\n  </li>\n</ul>\n<p>Text classification refers to the task of categorizing text into predefined labels or categories. It involves training models on labeled datasets to predict the category of new text. This task finds extensive application in diverse domains, such as in sentiment analysis, spam detection, and topic categorization. Text classification can be of various types:</p>\n<ul>\n      <li><strong>Binary Classification:</strong> Involves two distinct categories, like categorizing sentiments as positive or negative.</li>\n      <li><strong>Multi-Class Classification:</strong> Deals with more than two categories, such as classifying text into multiple sentiment categories like positive, negative, and neutral.</li>\n      <li><strong>Multi-Label Classification:</strong> Each text can be assigned multiple labels, accommodating texts that embody elements of multiple categories simultaneously.</li>\n    </ul>",
      "contentMarkdown": "*   Text classification refers to the task of categorizing text into predefined labels or categories. It involves training models on labeled datasets to predict the category of new text. This task finds extensive application in diverse domains, such as in sentiment analysis, spam detection, and topic categorization. Text classification can be of various types:\n    \n    *   **Binary Classification:** Involves two distinct categories, like categorizing sentiments as positive or negative.\n    *   **Multi-Class Classification:** Deals with more than two categories, such as classifying text into multiple sentiment categories like positive, negative, and neutral.\n    *   **Multi-Label Classification:** Each text can be assigned multiple labels, accommodating texts that embody elements of multiple categories simultaneously.\n\nText classification refers to the task of categorizing text into predefined labels or categories. It involves training models on labeled datasets to predict the category of new text. This task finds extensive application in diverse domains, such as in sentiment analysis, spam detection, and topic categorization. Text classification can be of various types:\n\n*   **Binary Classification:** Involves two distinct categories, like categorizing sentiments as positive or negative.\n*   **Multi-Class Classification:** Deals with more than two categories, such as classifying text into multiple sentiment categories like positive, negative, and neutral.\n*   **Multi-Label Classification:** Each text can be assigned multiple labels, accommodating texts that embody elements of multiple categories simultaneously.",
      "order": 186,
      "orderInChapter": 15,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 217,
        "contentLength": 1838
      },
      "nextCards": [
        "ai-interview-what-are-dialogue-systems-in-nlp-187",
        "ai-interview-please-explain-the-concept-of-text-generation-188"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-text-classification?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-dialogue-systems-in-nlp-187",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What are Dialogue Systems in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Dialogue systems, also known as conversational agents or chatbots, are computer programs designed to interact with humans using natural language. These systems can understand and respond to user inputs, perform tasks like answering queries, and facilitate actions like bookings or reservations. They can be created using rule-based methods or through machine learning and deep learning techniques, and are commonly integrated into various platforms like smartphones, websites, and messaging applications.</li>\n</ul>",
      "contentMarkdown": "*   Dialogue systems, also known as conversational agents or chatbots, are computer programs designed to interact with humans using natural language. These systems can understand and respond to user inputs, perform tasks like answering queries, and facilitate actions like bookings or reservations. They can be created using rule-based methods or through machine learning and deep learning techniques, and are commonly integrated into various platforms like smartphones, websites, and messaging applications.",
      "order": 187,
      "orderInChapter": 16,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "deep learning",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 70,
        "contentLength": 526
      },
      "nextCards": [
        "ai-interview-please-explain-the-concept-of-text-generation-188",
        "ai-interview-can-you-explain-the-concept-of-text-similarity-in--189"
      ],
      "relatedCards": [
        "ai-online-testing-why-is-online-testing-necessary-despite-offline-ev-80",
        "ai-drift-tests-and-techniques-5",
        "ai-mlops-tooling-simplification-tools-18",
        "ai-ml-comp-machine-learning-or-deep-learning-10",
        "ai-encoder-vs-decoder-models-how-does-an-autoregressive-model-work-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-dialogue-systems-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-please-explain-the-concept-of-text-generation-188",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Please Explain the Concept of Text Generation?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Text generation in NLP involves creating new text that is stylistically or thematically similar to a given dataset. This is achieved through models trained on large text corpora, learning the probability distribution of words and phrases. Text generation has a range of applications, from powering chatbots to aiding in text completion and summarization.</li>\n</ul>",
      "contentMarkdown": "*   Text generation in NLP involves creating new text that is stylistically or thematically similar to a given dataset. This is achieved through models trained on large text corpora, learning the probability distribution of words and phrases. Text generation has a range of applications, from powering chatbots to aiding in text completion and summarization.",
      "order": 188,
      "orderInChapter": 17,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "nlp"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 54,
        "contentLength": 376
      },
      "nextCards": [
        "ai-interview-can-you-explain-the-concept-of-text-similarity-in--189",
        "ai-interview-please-explain-text-clustering-190"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-mixture-of-lora-experts-82",
        "ai-word-vectors-bag-of-words-bow-23",
        "ai-nlp-tasks-definition-and-purpose-21",
        "ai-nlp-tasks-future-directions-26",
        "ai-nlp-tasks-definition-and-purpose-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#please-explain-the-concept-of-text-generation?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-can-you-explain-the-concept-of-text-similarity-in--189",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Can You Explain the Concept of Text Similarity in NLP?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Text similarity is the task of assessing the degree of similarity between two text segments. This is typically achieved using various measures like cosine similarity, Jaccard similarity, or the Levenshtein distance. Applications of text similarity are broad, encompassing areas like plagiarism detection and text retrieval. For further details, resources like <a href=\"text_similarity.md\">text_similarity.md</a> offer comprehensive explanations.</li>\n</ul>",
      "contentMarkdown": "*   Text similarity is the task of assessing the degree of similarity between two text segments. This is typically achieved using various measures like cosine similarity, Jaccard similarity, or the Levenshtein distance. Applications of text similarity are broad, encompassing areas like plagiarism detection and text retrieval. For further details, resources like [text\\_similarity.md](text_similarity.md) offer comprehensive explanations.",
      "order": 189,
      "orderInChapter": 18,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 55,
        "contentLength": 467
      },
      "nextCards": [
        "ai-interview-please-explain-text-clustering-190",
        "ai-interview-what-is-named-entity-disambiguation-ned-191"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#can-you-explain-the-concept-of-text-similarity-in-nlp?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-please-explain-text-clustering-190",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Please Explain Text Clustering?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Text clustering involves grouping texts based on their similarity. This process typically comprises two stages: first, transforming text into a suitable representation (often through text embedding algorithms) and then applying clustering algorithms like K-means, Hierarchical Clustering, or DBSCAN. Text clustering is instrumental in various applications such as topic modeling, sentiment analysis, and text summarization, helping to organize and categorize large volumes of textual data.</li>\n</ul>",
      "contentMarkdown": "*   Text clustering involves grouping texts based on their similarity. This process typically comprises two stages: first, transforming text into a suitable representation (often through text embedding algorithms) and then applying clustering algorithms like K-means, Hierarchical Clustering, or DBSCAN. Text clustering is instrumental in various applications such as topic modeling, sentiment analysis, and text summarization, helping to organize and categorize large volumes of textual data.",
      "order": 190,
      "orderInChapter": 19,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "embedding"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 65,
        "contentLength": 511
      },
      "nextCards": [
        "ai-interview-what-is-named-entity-disambiguation-ned-191",
        "ai-interview-what-is-the-difference-between-a-feedforward-neura-192"
      ],
      "relatedCards": [
        "ai-diffusion-models-key-papers-introducing-external-classifiers-for-te-27",
        "ai-diffusion-models-prompting-text-to-video-models-31",
        "ai-diffusion-models-imagen-video-high-definition-video-generation-with-61",
        "ai-gnn-edge-features-in-message-passing-14",
        "ai-gnn-edge-features-in-gnn-based-link-prediction-17"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#please-explain-text-clustering?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-named-entity-disambiguation-ned-191",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is Named Entity Disambiguation (NED)?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Named Entity Disambiguation (NED) is the task of resolving which specific entity a mention in text refers to, from a set of possible entities. This involves techniques like string matching, co-reference resolution, or graph-based methods. NED is critical in tasks like information extraction and knowledge base population, where it helps in accurately linking textual mentions to the correct entities in a database. For example, it can differentiate and correctly associate various name forms like “Mohit M.” or “M. Mayank” with a single entity, such as “Mohit Mayank,” in a structured database.</li>\n</ul>",
      "contentMarkdown": "*   Named Entity Disambiguation (NED) is the task of resolving which specific entity a mention in text refers to, from a set of possible entities. This involves techniques like string matching, co-reference resolution, or graph-based methods. NED is critical in tasks like information extraction and knowledge base population, where it helps in accurately linking textual mentions to the correct entities in a database. For example, it can differentiate and correctly associate various name forms like “Mohit M.” or “M. Mayank” with a single entity, such as “Mohit Mayank,” in a structured database.",
      "order": 191,
      "orderInChapter": 20,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 92,
        "contentLength": 617
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-a-feedforward-neura-192",
        "ai-interview-is-bert-a-text-generation-model-193"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-named-entity-disambiguation-(ned)?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-a-feedforward-neura-192",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is the Difference Between a Feedforward Neural Network and a Recurrent Neural Network?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>A feedforward neural network is a straightforward neural architecture where data flows in one direction from input to output, without any cycles or feedback loops. It’s primarily used for static pattern recognition. In contrast, a recurrent neural network (RNN) features loops in its architecture, allowing information to persist and be passed along through the network. This cyclical data flow makes RNNs especially suited for processing sequences of data, like in language modeling and speech recognition, where the context and dependencies between data points are crucial.</li>\n</ul>",
      "contentMarkdown": "*   A feedforward neural network is a straightforward neural architecture where data flows in one direction from input to output, without any cycles or feedback loops. It’s primarily used for static pattern recognition. In contrast, a recurrent neural network (RNN) features loops in its architecture, allowing information to persist and be passed along through the network. This cyclical data flow makes RNNs especially suited for processing sequences of data, like in language modeling and speech recognition, where the context and dependencies between data points are crucial.",
      "order": 192,
      "orderInChapter": 21,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "neural network",
        "rnn"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 86,
        "contentLength": 597
      },
      "nextCards": [
        "ai-interview-is-bert-a-text-generation-model-193",
        "ai-interview-what-is-weight-tying-in-language-model-194"
      ],
      "relatedCards": [
        "ai-architectures-vanishing-gradients-27",
        "ai-architectures-encoder-29",
        "ai-reinforcement-learning-deep-model-based-methods-19",
        "ai-diffusion-models-at-a-high-level-how-do-diffusion-models-work-what--42",
        "ai-transformers-inductive-biases-of-transformers-25"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-a-feedforward-neural-network-and-a-recurrent-neural-network?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-bert-a-text-generation-model-193",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "Is BERT a Text Generation Model?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>No, BERT (Bidirectional Encoder Representations from Transformers) is not primarily a text generation model. Unlike typical language models that predict the next token in a sequence based on previous context, BERT’s bidirectional approach makes it unsuitable for sequential prediction tasks. It’s designed for tasks like text classification, where understanding the context around each word is more critical than generating new text sequences.</li>\n</ul>",
      "contentMarkdown": "*   No, BERT (Bidirectional Encoder Representations from Transformers) is not primarily a text generation model. Unlike typical language models that predict the next token in a sequence based on previous context, BERT’s bidirectional approach makes it unsuitable for sequential prediction tasks. It’s designed for tasks like text classification, where understanding the context around each word is more critical than generating new text sequences.",
      "order": 193,
      "orderInChapter": 22,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "transformer",
        "bert"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 63,
        "contentLength": 465
      },
      "nextCards": [
        "ai-interview-what-is-weight-tying-in-language-model-194",
        "ai-interview-what-is-so-special-about-the-special-tokens-used-i-195"
      ],
      "relatedCards": [
        "ai-fine-tune-and-eval-BERT-load-tokenizer-5",
        "ai-fine-tune-and-eval-BERT-load-pre-trained-model-11",
        "ai-reasoning-in-LLMs-arc-agi-1-original-arc-challenge-43",
        "ai-model-compression-design-methodologies-51",
        "ai-encoder-vs-decoder-models-what-problems-does-permutation-language-modeling-b-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-bert-a-text-generation-model?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-weight-tying-in-language-model-194",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is Weight Tying in Language Model?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Weight tying in language models refers to the practice of using the same weight matrix for both the input-to-embedding layer and the hidden-to-softmax layer. The rationale behind this is that these layers essentially perform inverse operations of each other, transforming words to embeddings and embeddings back to words. This technique can improve model performance and efficiency, as seen in many language modeling applications. For a detailed explanation, references like Tom Roth’s articles on weight tying can be consulted.</li>\n</ul>",
      "contentMarkdown": "*   Weight tying in language models refers to the practice of using the same weight matrix for both the input-to-embedding layer and the hidden-to-softmax layer. The rationale behind this is that these layers essentially perform inverse operations of each other, transforming words to embeddings and embeddings back to words. This technique can improve model performance and efficiency, as seen in many language modeling applications. For a detailed explanation, references like Tom Roth’s articles on weight tying can be consulted.",
      "order": 194,
      "orderInChapter": 23,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "embedding"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 79,
        "contentLength": 550
      },
      "nextCards": [
        "ai-interview-what-is-so-special-about-the-special-tokens-used-i-195",
        "ai-interview-what-are-attention-masks-196"
      ],
      "relatedCards": [
        "ai-diffusion-models-key-papers-introducing-external-classifiers-for-te-27",
        "ai-diffusion-models-prompting-text-to-video-models-31",
        "ai-diffusion-models-imagen-video-high-definition-video-generation-with-61",
        "ai-gnn-edge-features-in-message-passing-14",
        "ai-gnn-edge-features-in-gnn-based-link-prediction-17"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-weight-tying-in-language-model?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-so-special-about-the-special-tokens-used-i-195",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What is so Special about the Special Tokens Used in Different LM Tokenizers?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Special tokens in language model (LM) tokenizers serve specific functions and are independent of the input text. For instance, BERT uses <code class=\"language-plaintext highlighter-rouge\">[CLS]</code> at the beginning of each input for classification tasks and <code class=\"language-plaintext highlighter-rouge\">[SEP]</code> to separate different segments. GPT-2 employs a special token to denote the end of a sentence. These tokens can be tailored for specific use cases and are often included during fine-tuning. For a deeper understanding, resources like Stack Overflow answers and specialized blog posts provide detailed insights.</li>\n</ul>",
      "contentMarkdown": "*   Special tokens in language model (LM) tokenizers serve specific functions and are independent of the input text. For instance, BERT uses `[CLS]` at the beginning of each input for classification tasks and `[SEP]` to separate different segments. GPT-2 employs a special token to denote the end of a sentence. These tokens can be tailored for specific use cases and are often included during fine-tuning. For a deeper understanding, resources like Stack Overflow answers and specialized blog posts provide detailed insights.",
      "order": 195,
      "orderInChapter": 24,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "bert",
        "gpt",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 81,
        "contentLength": 656
      },
      "nextCards": [
        "ai-interview-what-are-attention-masks-196",
        "ai-interview-what-is-dummy-variable-trap-in-ml-197"
      ],
      "relatedCards": [
        "ai-factuality-in-LLMs-case-study-b-safe-search-augmented-factuality-eval-30",
        "ai-reasoning-in-LLMs-baselines-and-key-results-56",
        "ai-top-30-papers-lost-in-the-middle-how-language-models-use-long-co-31",
        "ai-transformers-adding-a-new-token-to-the-tokenizers-vocabulary-an-13",
        "ai-transformers-huggingface-encoder-decoder-models-45"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-so-special-about-the-special-tokens-used-in-different-lm-tokenizers?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-attention-masks-196",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "NLP",
      "title": "What are Attention Masks?",
      "subtitle": "NLP",
      "contentHtml": "<ul>\n  <li>Attention masks in NLP are boolean markers used at the token level to distinguish between significant and insignificant tokens in input. They are particularly useful in batch training with texts of varying lengths, where padding is added to shorter texts. The padding tokens are marked with a 0 in the attention mask, while original input tokens are marked as 1. This differentiation is crucial in ensuring that models focus on relevant information.</li>\n  <li>Note: We can use a special token for padding. For example in BERT it can be <code class=\"language-plaintext highlighter-rouge\">[PAD]</code> token and in GPT-2 we can use <code class=\"language-plaintext highlighter-rouge\">&lt;|endoftext|&gt;</code> token.</li>\n  <li><a href=\"https://lukesalamone.github.io/posts/what-are-attention-masks/\">Refer blog @ lukesalamone.com</a>.</li>\n</ul>",
      "contentMarkdown": "*   Attention masks in NLP are boolean markers used at the token level to distinguish between significant and insignificant tokens in input. They are particularly useful in batch training with texts of varying lengths, where padding is added to shorter texts. The padding tokens are marked with a 0 in the attention mask, while original input tokens are marked as 1. This differentiation is crucial in ensuring that models focus on relevant information.\n*   Note: We can use a special token for padding. For example in BERT it can be `[PAD]` token and in GPT-2 we can use `<|endoftext|>` token.\n*   [Refer blog @ lukesalamone.com](https://lukesalamone.github.io/posts/what-are-attention-masks/).",
      "order": 196,
      "orderInChapter": 25,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "attention",
        "bert",
        "gpt",
        "nlp"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 105,
        "contentLength": 856
      },
      "nextCards": [
        "ai-interview-what-is-dummy-variable-trap-in-ml-197",
        "ai-interview-what-is-entropy-information-theory-198"
      ],
      "relatedCards": [
        "ai-transformers-how-does-attention-mask-differ-for-encode-vs-decod-64",
        "ai-flashattention-summary-19",
        "ai-transformers-what-is-the-fraction-of-attention-weights-relative-60",
        "ai-word-vectors-contextualized-embeddings-and-the-post-word2vec-er-38",
        "ai-transformers-are-transformers-learning-neural-syntax-33"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-attention-masks?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-dummy-variable-trap-in-ml-197",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Machine Learning",
      "title": "What is Dummy Variable Trap in ML?",
      "subtitle": "Machine Learning",
      "contentHtml": "<ul>\n  <li>When using linear models, like logistic regression, on a one-hot encoded <em>(dummy var)</em> dataset with a finite set of levels <em>(unique values in a categorical column)</em>, it is suggested to drop one level from the final data such that the total number of new one-hot encoded columns added is one less than the unique levels in the column. For example, consider a <code class=\"language-plaintext highlighter-rouge\">season</code> column that contains 4 unique values <code class=\"language-plaintext highlighter-rouge\">spring</code>, <code class=\"language-plaintext highlighter-rouge\">summer</code>, <code class=\"language-plaintext highlighter-rouge\">fall</code>, and <code class=\"language-plaintext highlighter-rouge\">winter</code>. When doing one-hot encoding it is suggested to finally keep any 3 and not all 4 columns.</li>\n  <li><strong>The reason:</strong> <em>“If dummy variables for all categories were included, their sum would equal 1 for all observations, which is identical to and hence perfectly correlated with the vector-of-ones variable whose coefficient is the constant term; if the vector-of-ones variable were also present, this would result in perfect multicollinearity, so that the matrix inversion in the estimation algorithm would be impossible.”</em> Refer <a href=\"https://en.wikipedia.org/wiki/Dummy_variable_(statistics)\">Wikipedia</a></li>\n  <li>Note that if you’re using regularization, then don’t drop a level as it biases your model in favor of the variable you dropped. Refer <a href=\"https://kiwidamien.github.io/are-you-getting-burned-by-one-hot-encoding.html\">Damien Martin’s Blog</a>.</li>\n</ul>",
      "contentMarkdown": "*   When using linear models, like logistic regression, on a one-hot encoded _(dummy var)_ dataset with a finite set of levels _(unique values in a categorical column)_, it is suggested to drop one level from the final data such that the total number of new one-hot encoded columns added is one less than the unique levels in the column. For example, consider a `season` column that contains 4 unique values `spring`, `summer`, `fall`, and `winter`. When doing one-hot encoding it is suggested to finally keep any 3 and not all 4 columns.\n*   **The reason:** _“If dummy variables for all categories were included, their sum would equal 1 for all observations, which is identical to and hence perfectly correlated with the vector-of-ones variable whose coefficient is the constant term; if the vector-of-ones variable were also present, this would result in perfect multicollinearity, so that the matrix inversion in the estimation algorithm would be impossible.”_ Refer [Wikipedia](https://en.wikipedia.org/wiki/Dummy_variable_\\(statistics\\))\n*   Note that if you’re using regularization, then don’t drop a level as it biases your model in favor of the variable you dropped. Refer [Damien Martin’s Blog](https://kiwidamien.github.io/are-you-getting-burned-by-one-hot-encoding.html).",
      "order": 197,
      "orderInChapter": 1,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "regularization"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 184,
        "contentLength": 1648
      },
      "nextCards": [
        "ai-interview-what-is-entropy-information-theory-198",
        "ai-interview-even-though-sigmoid-function-is-non-linear-why-is--199"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-is-an-occasional-side-effect-of-boosting-an-increa-28",
        "ai-diffusion-models-what-does-the-stable-in-stable-diffusion-refer-to-48",
        "ai-diffusion-models-integration-with-mse-46",
        "ai-diffusion-models-high-resolution-image-synthesis-with-latent-diffus-54",
        "ai-mixture-of-experts-overview-19"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-dummy-variable-trap-in-ml?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-entropy-information-theory-198",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Machine Learning",
      "title": "What is Entropy (information Theory)?",
      "subtitle": "Machine Learning",
      "contentHtml": "<ul>\n  <li>Entropy is a measurement of uncertainty of a system. Intuitively, it is the amount of information needed to remove uncertainty from the system. The entropy of a probability distribution <code class=\"language-plaintext highlighter-rouge\">p</code> for various states of a system can be computed as: <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-161-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;></mrow></munderover><mo stretchy=&quot;false&quot;>(</mo><msub><mi>p</mi><mi>i</mi></msub><mi>log</mi><mo>&amp;#x2061;</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1309\" style=\"width: 7.086em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 5.888em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1005.84em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1310\"><span class=\"mo\" id=\"MathJax-Span-1311\" style=\"font-family: STIXGeneral-Regular;\">−</span><span class=\"munderover\" id=\"MathJax-Span-1312\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1313\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1314\"><span class=\"mrow\" id=\"MathJax-Span-1315\"><span class=\"mi\" id=\"MathJax-Span-1316\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1317\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1318\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1319\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-1320\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mi\" id=\"MathJax-Span-1321\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1322\"></span><span class=\"msubsup\" id=\"MathJax-Span-1323\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1324\" style=\"font-family: STIXGeneral-Italic;\">p</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-1325\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1326\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mo>−</mo><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow><mrow class=\"MJX-TeXAtom-ORD\"></mrow></munderover><mo stretchy=\"false\">(</mo><msub><mi>p</mi><mi>i</mi></msub><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-161\">-\\sum_{i}^{} (p_i \\log p_i)</script>.</li>\n</ul>",
      "contentMarkdown": "*   Entropy is a measurement of uncertainty of a system. Intuitively, it is the amount of information needed to remove uncertainty from the system. The entropy of a probability distribution `p` for various states of a system can be computed as: −∑i(pilogpi)−∑i(pilog⁡pi)\\-\\\\sum\\_{i}^{} (p\\_i \\\\log p\\_i).",
      "order": 198,
      "orderInChapter": 2,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 45,
        "contentLength": 4690
      },
      "nextCards": [
        "ai-interview-even-though-sigmoid-function-is-non-linear-why-is--199",
        "ai-interview-what-is-the-difference-between-standardization-and-200"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-entropy-(information-theory)?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-even-though-sigmoid-function-is-non-linear-why-is--199",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Machine Learning",
      "title": "Even Though Sigmoid Function is Non-linear, Why is Logistic Regression Considered a Linear Classifier?",
      "subtitle": "Machine Learning",
      "contentHtml": "<ul>\n  <li>Logistic regression is often referred to as a linear classifier despite using the sigmoid (logistic) activation function because it models the relationship between the input features and the log-odds (logit) of the binary target variable in a linear manner. The linearity in logistic regression refers to the fact that it creates a linear decision boundary in the feature space, which is a hyperplane. <a href=\"https://stats.stackexchange.com/questions/93569/why-is-logistic-regression-a-linear-classifier\">Refer</a></li>\n</ul>",
      "contentMarkdown": "*   Logistic regression is often referred to as a linear classifier despite using the sigmoid (logistic) activation function because it models the relationship between the input features and the log-odds (logit) of the binary target variable in a linear manner. The linearity in logistic regression refers to the fact that it creates a linear decision boundary in the feature space, which is a hyperplane. [Refer](https://stats.stackexchange.com/questions/93569/why-is-logistic-regression-a-linear-classifier)",
      "order": 199,
      "orderInChapter": 3,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 65,
        "contentLength": 538
      },
      "nextCards": [
        "ai-interview-what-is-the-difference-between-standardization-and-200",
        "ai-interview-when-do-you-standardize-or-normalize-features-201"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-moe-llava-29",
        "ai-mixture-of-experts-components-38",
        "ai-xavier-init-case-1-a-too-large-initialization-leads-to-explodi-1",
        "ai-activation-functions-sigmoid-1",
        "ai-activation-functions-citation-8"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#even-though-sigmoid-function-is-non-linear,-why-is-logistic-regression-considered-a-linear-classifier?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-difference-between-standardization-and-200",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is the Difference Between Standardization and Normalization?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Normalization means rescaling the values into a range of (typically) [0,1].</li>\n  <li>Standardization refers to centering the values around the mean with a unit standard deviation.</li>\n</ul>",
      "contentMarkdown": "*   Normalization means rescaling the values into a range of (typically) \\[0,1\\].\n*   Standardization refers to centering the values around the mean with a unit standard deviation.",
      "order": 200,
      "orderInChapter": 1,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 27,
        "contentLength": 203
      },
      "nextCards": [
        "ai-interview-when-do-you-standardize-or-normalize-features-201",
        "ai-interview-explain-the-advantages-of-the-parquet-data-format--202"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-difference-between-standardization-and-normalization?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-when-do-you-standardize-or-normalize-features-201",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "When Do You Standardize or Normalize Features?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Rule of thumb:\n    <ul>\n      <li>Standardization, when the data follows a Gaussian distribution and your algorithm assumes your data follows a Gaussian Distribution like Linear Regression.</li>\n      <li>Normalization, when your data has varying scales and your algorithm doesn’t make assumptions about the distribution of your data like KNN.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Standardization, when the data follows a Gaussian distribution and your algorithm assumes your data follows a Gaussian Distribution like Linear Regression.</li>\n      <li>Normalization, when your data has varying scales and your algorithm doesn’t make assumptions about the distribution of your data like KNN.</li>\n    </ul>\n<h4 id=\"why-is-relying-on-the-mean-to-make-a-business-decision-based-on-data-statistics-a-problem\">Why is Relying on the Mean to Make a Business Decision Based on Data Statistics a Problem?</h4>\n<ul>\n  <li>There is a famous joke in Statistics which says that, “if someone’s head is in the freezer and leg is in the oven, the average body temperature would be fine, but the person may not be alive”.</li>\n  <li>Making decisions solely based on mean value is not advisable. The issue with mean is that it is affected significantly by the presence of outliers, and may not be the correct central representation of the dataset.</li>\n  <li>It is thus advised that the mean should be used along with other measures and measures of variability for better understanding and explainability of the data.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/mean.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Rule of thumb:\n    *   Standardization, when the data follows a Gaussian distribution and your algorithm assumes your data follows a Gaussian Distribution like Linear Regression.\n    *   Normalization, when your data has varying scales and your algorithm doesn’t make assumptions about the distribution of your data like KNN.\n\n*   Standardization, when the data follows a Gaussian distribution and your algorithm assumes your data follows a Gaussian Distribution like Linear Regression.\n*   Normalization, when your data has varying scales and your algorithm doesn’t make assumptions about the distribution of your data like KNN.\n\n#### Why is Relying on the Mean to Make a Business Decision Based on Data Statistics a Problem?\n\n*   There is a famous joke in Statistics which says that, “if someone’s head is in the freezer and leg is in the oven, the average body temperature would be fine, but the person may not be alive”.\n*   Making decisions solely based on mean value is not advisable. The issue with mean is that it is affected significantly by the presence of outliers, and may not be the correct central representation of the dataset.\n*   It is thus advised that the mean should be used along with other measures and measures of variability for better understanding and explainability of the data.\n\n![](/primers/ai/assets/interview/mean.jpeg)",
      "order": 201,
      "orderInChapter": 2,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 213,
        "contentLength": 1593
      },
      "nextCards": [
        "ai-interview-explain-the-advantages-of-the-parquet-data-format--202",
        "ai-interview-what-is-redis-203"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#when-do-you-standardize-or-normalize-features?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-the-advantages-of-the-parquet-data-format--202",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Explain the Advantages of the Parquet Data Format and How You Can Achieve the Best Data Compression with It?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>The parquet format is something that every data person has to be aware about. Its a popular choice for data storage for faster query and better compression but do you know how the sorting order can be very important when we optimize for compression?</p>\n  </li>\n  <li>\n    <p>Parquet uses columnar storage, which means that data is stored by column rather than by row. This can lead to significant improvements in compression, because values in a column tend to be more homogeneous than values in a row. However, to achieve the best compression, it’s important to sort the data within each column in a specific way.</p>\n  </li>\n  <li>\n    <p>Parquet uses a technique called “run-length encoding” (RLE) to compress repetitive sequences of values within a column. RLE works by storing a value once, followed by a count of how many times that value is repeated. For example, if a column contains the values [1,1, 1, 1, 2, 2, 3, 3, 3, 3, 3], RLE would store it as [1, 4, 2, 2, 3, 5].</p>\n  </li>\n  <li>\n    <p>To take advantage of RLE, it’s important to sort the data within each column in a way that maximizes the number of repetitive sequences. For example, if a column contains the values [1, 2, 3, 4, 5, 1, 2, 3, 4, 5], sorting it as [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] would result in better compression.</p>\n  </li>\n  <li>\n    <p>In addition to RLE, Parquet also uses other compression techniques such as dictionary encoding and bit-packing to achieve high compression ratios. These techniques also benefit from sorted data, as they can take advantage of the repetition and predictability of sorted values to achieve better compression.</p>\n  </li>\n  <li>\n    <p>What about the order of sorting when we sort on multiple columns, does that have an impact ? The asnwer is yes. Sorting the data by the most significant column(s) first can lead to better compression because it can group similar values together, allowing for better compression within each data page.</p>\n  </li>\n  <li>\n    <p>For example, consider a dataset with three columns: column1, column2 and column3. If most of the values in column1 are the same or similar (lower cardinality), then sorting the data by column1 first can help group together similar values and achieve better compression within each data page.</p>\n  </li>\n  <li>\n    <p>In summary, the sorting order of data can have a significant impact on data compression in Parquet and should be considered for data pipelines.</p>\n  </li>\n</ul>\n<p>The parquet format is something that every data person has to be aware about. Its a popular choice for data storage for faster query and better compression but do you know how the sorting order can be very important when we optimize for compression?</p>\n<p>Parquet uses columnar storage, which means that data is stored by column rather than by row. This can lead to significant improvements in compression, because values in a column tend to be more homogeneous than values in a row. However, to achieve the best compression, it’s important to sort the data within each column in a specific way.</p>\n<p>Parquet uses a technique called “run-length encoding” (RLE) to compress repetitive sequences of values within a column. RLE works by storing a value once, followed by a count of how many times that value is repeated. For example, if a column contains the values [1,1, 1, 1, 2, 2, 3, 3, 3, 3, 3], RLE would store it as [1, 4, 2, 2, 3, 5].</p>\n<p>To take advantage of RLE, it’s important to sort the data within each column in a way that maximizes the number of repetitive sequences. For example, if a column contains the values [1, 2, 3, 4, 5, 1, 2, 3, 4, 5], sorting it as [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] would result in better compression.</p>\n<p>In addition to RLE, Parquet also uses other compression techniques such as dictionary encoding and bit-packing to achieve high compression ratios. These techniques also benefit from sorted data, as they can take advantage of the repetition and predictability of sorted values to achieve better compression.</p>\n<p>What about the order of sorting when we sort on multiple columns, does that have an impact ? The asnwer is yes. Sorting the data by the most significant column(s) first can lead to better compression because it can group similar values together, allowing for better compression within each data page.</p>\n<p>For example, consider a dataset with three columns: column1, column2 and column3. If most of the values in column1 are the same or similar (lower cardinality), then sorting the data by column1 first can help group together similar values and achieve better compression within each data page.</p>\n<p>In summary, the sorting order of data can have a significant impact on data compression in Parquet and should be considered for data pipelines.</p>",
      "contentMarkdown": "*   The parquet format is something that every data person has to be aware about. Its a popular choice for data storage for faster query and better compression but do you know how the sorting order can be very important when we optimize for compression?\n    \n*   Parquet uses columnar storage, which means that data is stored by column rather than by row. This can lead to significant improvements in compression, because values in a column tend to be more homogeneous than values in a row. However, to achieve the best compression, it’s important to sort the data within each column in a specific way.\n    \n*   Parquet uses a technique called “run-length encoding” (RLE) to compress repetitive sequences of values within a column. RLE works by storing a value once, followed by a count of how many times that value is repeated. For example, if a column contains the values \\[1,1, 1, 1, 2, 2, 3, 3, 3, 3, 3\\], RLE would store it as \\[1, 4, 2, 2, 3, 5\\].\n    \n*   To take advantage of RLE, it’s important to sort the data within each column in a way that maximizes the number of repetitive sequences. For example, if a column contains the values \\[1, 2, 3, 4, 5, 1, 2, 3, 4, 5\\], sorting it as \\[1, 1, 2, 2, 3, 3, 4, 4, 5, 5\\] would result in better compression.\n    \n*   In addition to RLE, Parquet also uses other compression techniques such as dictionary encoding and bit-packing to achieve high compression ratios. These techniques also benefit from sorted data, as they can take advantage of the repetition and predictability of sorted values to achieve better compression.\n    \n*   What about the order of sorting when we sort on multiple columns, does that have an impact ? The asnwer is yes. Sorting the data by the most significant column(s) first can lead to better compression because it can group similar values together, allowing for better compression within each data page.\n    \n*   For example, consider a dataset with three columns: column1, column2 and column3. If most of the values in column1 are the same or similar (lower cardinality), then sorting the data by column1 first can help group together similar values and achieve better compression within each data page.\n    \n*   In summary, the sorting order of data can have a significant impact on data compression in Parquet and should be considered for data pipelines.\n    \n\nThe parquet format is something that every data person has to be aware about. Its a popular choice for data storage for faster query and better compression but do you know how the sorting order can be very important when we optimize for compression?\n\nParquet uses columnar storage, which means that data is stored by column rather than by row. This can lead to significant improvements in compression, because values in a column tend to be more homogeneous than values in a row. However, to achieve the best compression, it’s important to sort the data within each column in a specific way.\n\nParquet uses a technique called “run-length encoding” (RLE) to compress repetitive sequences of values within a column. RLE works by storing a value once, followed by a count of how many times that value is repeated. For example, if a column contains the values \\[1,1, 1, 1, 2, 2, 3, 3, 3, 3, 3\\], RLE would store it as \\[1, 4, 2, 2, 3, 5\\].\n\nTo take advantage of RLE, it’s important to sort the data within each column in a way that maximizes the number of repetitive sequences. For example, if a column contains the values \\[1, 2, 3, 4, 5, 1, 2, 3, 4, 5\\], sorting it as \\[1, 1, 2, 2, 3, 3, 4, 4, 5, 5\\] would result in better compression.\n\nIn addition to RLE, Parquet also uses other compression techniques such as dictionary encoding and bit-packing to achieve high compression ratios. These techniques also benefit from sorted data, as they can take advantage of the repetition and predictability of sorted values to achieve better compression.\n\nWhat about the order of sorting when we sort on multiple columns, does that have an impact ? The asnwer is yes. Sorting the data by the most significant column(s) first can lead to better compression because it can group similar values together, allowing for better compression within each data page.\n\nFor example, consider a dataset with three columns: column1, column2 and column3. If most of the values in column1 are the same or similar (lower cardinality), then sorting the data by column1 first can help group together similar values and achieve better compression within each data page.\n\nIn summary, the sorting order of data can have a significant impact on data compression in Parquet and should be considered for data pipelines.",
      "order": 202,
      "orderInChapter": 3,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 796,
        "contentLength": 4808
      },
      "nextCards": [
        "ai-interview-what-is-redis-203",
        "ai-interview-pitfalls-in-spark-data-engineering-that-can-hurt-y-204"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-the-advantages-of-the-parquet-data-format-and-how-you-can-achieve-the-best-data-compression-with-it?",
      "scrapedAt": "2025-12-28T11:58:12.844Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-redis-203",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is Redis?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Redis is not just a key-value cache - it can be used as a database, as a pub-sub, and much more.</li>\n  <li>\n    <p>“Redis” actually stands for “Remote DIctionary Server”. Redis was originally designed as a key-value store database for remote access, with a focus on speed, simplicity, and versatility.</p>\n  </li>\n  <li>\n    <p>Since Redis’ code is open source, you can deploy Redis yourself. There are many ways of Redis deployment: standalone mode, cluster mode, sentinel mode, and replication mode.</p>\n  </li>\n  <li>\n    <p>In Redis, the most popular mode of deployment is cluster mode. Redis Cluster is a distributed implementation of Redis, in which data is partitioned and distributed across multiple nodes in a cluster.</p>\n  </li>\n  <li>\n    <p>In Redis Cluster, each node is responsible for a subset of the keyspace, and multiple nodes work together to form a distributed system that can handle large amounts of data and high traffic loads. The partitioning of data is based on hashing of the key, and each node is responsible for a range of hash slots.</p>\n  </li>\n  <li>\n    <p>The hash slot range is distributed evenly among the nodes in the cluster, and each node is responsible for storing and serving data for the hash slots assigned to it. When a client sends a request to a node, the node checks the hash slot of the requested key, and if the slot is owned by the node, the request is processed locally. Otherwise, the request is forwarded to the node that owns the slot.</p>\n  </li>\n  <li>\n    <p>Redis Cluster also provides features for node failover, in which if a node fails, its hash slot range is automatically taken over by another node in the cluster. This ensures high availability and fault tolerance in the system.</p>\n  </li>\n  <li>Overall, in clustered Redis, data is arranged based on a consistent hashing algorithm, where each node is responsible for a subset of the keyspace and works together to form a distributed system that can handle large amounts of data and traffic loads.</li>\n</ul>\n<p>“Redis” actually stands for “Remote DIctionary Server”. Redis was originally designed as a key-value store database for remote access, with a focus on speed, simplicity, and versatility.</p>\n<p>Since Redis’ code is open source, you can deploy Redis yourself. There are many ways of Redis deployment: standalone mode, cluster mode, sentinel mode, and replication mode.</p>\n<p>In Redis, the most popular mode of deployment is cluster mode. Redis Cluster is a distributed implementation of Redis, in which data is partitioned and distributed across multiple nodes in a cluster.</p>\n<p>In Redis Cluster, each node is responsible for a subset of the keyspace, and multiple nodes work together to form a distributed system that can handle large amounts of data and high traffic loads. The partitioning of data is based on hashing of the key, and each node is responsible for a range of hash slots.</p>\n<p>The hash slot range is distributed evenly among the nodes in the cluster, and each node is responsible for storing and serving data for the hash slots assigned to it. When a client sends a request to a node, the node checks the hash slot of the requested key, and if the slot is owned by the node, the request is processed locally. Otherwise, the request is forwarded to the node that owns the slot.</p>\n<p>Redis Cluster also provides features for node failover, in which if a node fails, its hash slot range is automatically taken over by another node in the cluster. This ensures high availability and fault tolerance in the system.</p>",
      "contentMarkdown": "*   Redis is not just a key-value cache - it can be used as a database, as a pub-sub, and much more.\n*   “Redis” actually stands for “Remote DIctionary Server”. Redis was originally designed as a key-value store database for remote access, with a focus on speed, simplicity, and versatility.\n    \n*   Since Redis’ code is open source, you can deploy Redis yourself. There are many ways of Redis deployment: standalone mode, cluster mode, sentinel mode, and replication mode.\n    \n*   In Redis, the most popular mode of deployment is cluster mode. Redis Cluster is a distributed implementation of Redis, in which data is partitioned and distributed across multiple nodes in a cluster.\n    \n*   In Redis Cluster, each node is responsible for a subset of the keyspace, and multiple nodes work together to form a distributed system that can handle large amounts of data and high traffic loads. The partitioning of data is based on hashing of the key, and each node is responsible for a range of hash slots.\n    \n*   The hash slot range is distributed evenly among the nodes in the cluster, and each node is responsible for storing and serving data for the hash slots assigned to it. When a client sends a request to a node, the node checks the hash slot of the requested key, and if the slot is owned by the node, the request is processed locally. Otherwise, the request is forwarded to the node that owns the slot.\n    \n*   Redis Cluster also provides features for node failover, in which if a node fails, its hash slot range is automatically taken over by another node in the cluster. This ensures high availability and fault tolerance in the system.\n    \n*   Overall, in clustered Redis, data is arranged based on a consistent hashing algorithm, where each node is responsible for a subset of the keyspace and works together to form a distributed system that can handle large amounts of data and traffic loads.\n\n“Redis” actually stands for “Remote DIctionary Server”. Redis was originally designed as a key-value store database for remote access, with a focus on speed, simplicity, and versatility.\n\nSince Redis’ code is open source, you can deploy Redis yourself. There are many ways of Redis deployment: standalone mode, cluster mode, sentinel mode, and replication mode.\n\nIn Redis, the most popular mode of deployment is cluster mode. Redis Cluster is a distributed implementation of Redis, in which data is partitioned and distributed across multiple nodes in a cluster.\n\nIn Redis Cluster, each node is responsible for a subset of the keyspace, and multiple nodes work together to form a distributed system that can handle large amounts of data and high traffic loads. The partitioning of data is based on hashing of the key, and each node is responsible for a range of hash slots.\n\nThe hash slot range is distributed evenly among the nodes in the cluster, and each node is responsible for storing and serving data for the hash slots assigned to it. When a client sends a request to a node, the node checks the hash slot of the requested key, and if the slot is owned by the node, the request is processed locally. Otherwise, the request is forwarded to the node that owns the slot.\n\nRedis Cluster also provides features for node failover, in which if a node fails, its hash slot range is automatically taken over by another node in the cluster. This ensures high availability and fault tolerance in the system.",
      "order": 203,
      "orderInChapter": 4,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 581,
        "contentLength": 3577
      },
      "nextCards": [
        "ai-interview-pitfalls-in-spark-data-engineering-that-can-hurt-y-204",
        "ai-interview-what-are-generative-and-discriminative-models-205"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-redis?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-pitfalls-in-spark-data-engineering-that-can-hurt-y-204",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Pitfalls in Spark Data Engineering That Can Hurt Your Data Lake Performance",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>Not sorting your parquet files from lowest to highest cardinality: Run length encoding compression is your best friend when storing data. Leverage it as much as you can!</p>\n  </li>\n  <li>\n    <p>Using VARCHAR ids when BIGINT would work: JOINs on BIGINT are much more performant than JOINs of VARCHAR</p>\n  </li>\n  <li>\n    <p>Over/under partitioning your Spark jobs: Set <code class=\"language-plaintext highlighter-rouge\">spark.sql.shuffle.partitions</code> so that each partition has about 200mbs. Too big partitions hurt memory and reliability. Too small causes unnecessary network overhead.</p>\n  </li>\n  <li>\n    <p>Over/under provisioning your Spark job memory: Set <code class=\"language-plaintext highlighter-rouge\">spark.executor.memory</code> so that your job has enough memory to run plus a little bit of overhead. Under provisioning causes unnecessary out of memory exceptions. Over provisioning increases EC2 costs.</p>\n  </li>\n</ul>\n<p>Not sorting your parquet files from lowest to highest cardinality: Run length encoding compression is your best friend when storing data. Leverage it as much as you can!</p>\n<p>Using VARCHAR ids when BIGINT would work: JOINs on BIGINT are much more performant than JOINs of VARCHAR</p>\n<p>Over/under partitioning your Spark jobs: Set <code class=\"language-plaintext highlighter-rouge\">spark.sql.shuffle.partitions</code> so that each partition has about 200mbs. Too big partitions hurt memory and reliability. Too small causes unnecessary network overhead.</p>\n<p>Over/under provisioning your Spark job memory: Set <code class=\"language-plaintext highlighter-rouge\">spark.executor.memory</code> so that your job has enough memory to run plus a little bit of overhead. Under provisioning causes unnecessary out of memory exceptions. Over provisioning increases EC2 costs.</p>",
      "contentMarkdown": "*   Not sorting your parquet files from lowest to highest cardinality: Run length encoding compression is your best friend when storing data. Leverage it as much as you can!\n    \n*   Using VARCHAR ids when BIGINT would work: JOINs on BIGINT are much more performant than JOINs of VARCHAR\n    \n*   Over/under partitioning your Spark jobs: Set `spark.sql.shuffle.partitions` so that each partition has about 200mbs. Too big partitions hurt memory and reliability. Too small causes unnecessary network overhead.\n    \n*   Over/under provisioning your Spark job memory: Set `spark.executor.memory` so that your job has enough memory to run plus a little bit of overhead. Under provisioning causes unnecessary out of memory exceptions. Over provisioning increases EC2 costs.\n    \n\nNot sorting your parquet files from lowest to highest cardinality: Run length encoding compression is your best friend when storing data. Leverage it as much as you can!\n\nUsing VARCHAR ids when BIGINT would work: JOINs on BIGINT are much more performant than JOINs of VARCHAR\n\nOver/under partitioning your Spark jobs: Set `spark.sql.shuffle.partitions` so that each partition has about 200mbs. Too big partitions hurt memory and reliability. Too small causes unnecessary network overhead.\n\nOver/under provisioning your Spark job memory: Set `spark.executor.memory` so that your job has enough memory to run plus a little bit of overhead. Under provisioning causes unnecessary out of memory exceptions. Over provisioning increases EC2 costs.",
      "order": 204,
      "orderInChapter": 5,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 222,
        "contentLength": 1842
      },
      "nextCards": [
        "ai-interview-what-are-generative-and-discriminative-models-205",
        "ai-interview-what-are-distance-weighted-knns-what-are-the-limit-206"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#pitfalls-in-spark-data-engineering-that-can-hurt-your-data-lake-performance",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-generative-and-discriminative-models-205",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Generative and Discriminative Models?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Many ML models can be classified into two categories:\n    <ul>\n      <li>Generative</li>\n      <li>Discriminative</li>\n    </ul>\n  </li>\n  <li>This is depicted in the image below <a href=\"http://dailydoseofds.com/\">(source)</a>.</li>\n  <li>Discriminative models:\n    <ul>\n      <li>learn decision boundaries that separate different classes.</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td>maximize the conditional probability: P(Y</td>\n              <td>X) — Given X, maximize the probability of label Y.</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li>are specifically meant for classification tasks.</li>\n    </ul>\n  </li>\n  <li>Generative models:\n    <ul>\n      <li>maximize the joint probability: P(X, Y)</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td>learn the class-conditional distribution P(X</td>\n              <td>Y)</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li>are typically not preferred to solve downstream classification tasks.</li>\n    </ul>\n  </li>\n  <li>As generative models learn the underlying distribution, they can generate new samples. But this is not possible with discriminative models.</li>\n  <li>Furthermore, generative models possess discriminative properties, i.e., they can be used for classification tasks (if needed). But discriminative models do not possess generative properties.</li>\n</ul>\n<ul>\n      <li>Generative</li>\n      <li>Discriminative</li>\n    </ul>\n<ul>\n      <li>learn decision boundaries that separate different classes.</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td>maximize the conditional probability: P(Y</td>\n              <td>X) — Given X, maximize the probability of label Y.</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li>are specifically meant for classification tasks.</li>\n    </ul>\n<table>\n          <tbody>\n            <tr>\n              <td>maximize the conditional probability: P(Y</td>\n              <td>X) — Given X, maximize the probability of label Y.</td>\n            </tr>\n          </tbody>\n        </table>\n<ul>\n      <li>maximize the joint probability: P(X, Y)</li>\n      <li>\n        <table>\n          <tbody>\n            <tr>\n              <td>learn the class-conditional distribution P(X</td>\n              <td>Y)</td>\n            </tr>\n          </tbody>\n        </table>\n      </li>\n      <li>are typically not preferred to solve downstream classification tasks.</li>\n    </ul>\n<table>\n          <tbody>\n            <tr>\n              <td>learn the class-conditional distribution P(X</td>\n              <td>Y)</td>\n            </tr>\n          </tbody>\n        </table>\n<p><img src=\"/primers/ai/assets/interview/GenerativeDiscriminative.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   Many ML models can be classified into two categories:\n    *   Generative\n    *   Discriminative\n*   This is depicted in the image below [(source)](http://dailydoseofds.com/).\n*   Discriminative models:\n    *   learn decision boundaries that separate different classes.\n    *   maximize the conditional probability: P(Y\n        \n        X) — Given X, maximize the probability of label Y.\n        \n    *   are specifically meant for classification tasks.\n*   Generative models:\n    *   maximize the joint probability: P(X, Y)\n    *   learn the class-conditional distribution P(X\n        \n        Y)\n        \n    *   are typically not preferred to solve downstream classification tasks.\n*   As generative models learn the underlying distribution, they can generate new samples. But this is not possible with discriminative models.\n*   Furthermore, generative models possess discriminative properties, i.e., they can be used for classification tasks (if needed). But discriminative models do not possess generative properties.\n\n*   Generative\n*   Discriminative\n\n*   learn decision boundaries that separate different classes.\n*   maximize the conditional probability: P(Y\n    \n    X) — Given X, maximize the probability of label Y.\n    \n*   are specifically meant for classification tasks.\n\nmaximize the conditional probability: P(Y\n\nX) — Given X, maximize the probability of label Y.\n\n*   maximize the joint probability: P(X, Y)\n*   learn the class-conditional distribution P(X\n    \n    Y)\n    \n*   are typically not preferred to solve downstream classification tasks.\n\nlearn the class-conditional distribution P(X\n\nY)\n\n![](/primers/ai/assets/interview/GenerativeDiscriminative.jpeg)",
      "order": 205,
      "orderInChapter": 6,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 211,
        "contentLength": 2858
      },
      "nextCards": [
        "ai-interview-what-are-distance-weighted-knns-what-are-the-limit-206",
        "ai-interview-how-does-kafka-work-as-a-pub-sub-207"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-generative-and-discriminative-models?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-distance-weighted-knns-what-are-the-limit-206",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Distance-weighted KNNs? What are the Limitation of Traditional KNNs?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>kNNs, by default, classify a new data point as follows:\n    <ul>\n      <li>Count its class-wise “k” nearest neighbors</li>\n      <li>Assign the data point to the class with the highest count</li>\n    </ul>\n  </li>\n  <li>As a result, during classification, the vicinity of a class is entirely ignored.</li>\n  <li>Yet, this may be extremely important, especially when you have a class with few samples.</li>\n  <li>Distance-weighted kNNs are a more robust alternative to traditional kNNs.</li>\n  <li>As the name suggests, they consider the distance to the nearest neighbor during prediction.</li>\n  <li>Thus, the closer a specific neighbor, the more will be its impact on the final prediction.</li>\n  <li>Its effectiveness is evident from the image below <a href=\"http://dailydoseofds.com/\">(source)</a>.</li>\n</ul>\n<ul>\n      <li>Count its class-wise “k” nearest neighbors</li>\n      <li>Assign the data point to the class with the highest count</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/DWkNNs.jpeg\" alt=\"\"></p>\n<ul>\n  <li>Traditional kNN (with k=7) will never predict the blue class, while distance-weighted kNN is more robust in its prediction.</li>\n  <li>Typically, a distance-weighted kNN works much better than a traditional kNN. And this makes intuitive sense as well.</li>\n  <li>Yet, their utility may go unnoticed. This is because many frameworks like sklearn consider “uniform” weighting by default.</li>\n</ul>",
      "contentMarkdown": "*   kNNs, by default, classify a new data point as follows:\n    *   Count its class-wise “k” nearest neighbors\n    *   Assign the data point to the class with the highest count\n*   As a result, during classification, the vicinity of a class is entirely ignored.\n*   Yet, this may be extremely important, especially when you have a class with few samples.\n*   Distance-weighted kNNs are a more robust alternative to traditional kNNs.\n*   As the name suggests, they consider the distance to the nearest neighbor during prediction.\n*   Thus, the closer a specific neighbor, the more will be its impact on the final prediction.\n*   Its effectiveness is evident from the image below [(source)](http://dailydoseofds.com/).\n\n*   Count its class-wise “k” nearest neighbors\n*   Assign the data point to the class with the highest count\n\n![](/primers/ai/assets/interview/DWkNNs.jpeg)\n\n*   Traditional kNN (with k=7) will never predict the blue class, while distance-weighted kNN is more robust in its prediction.\n*   Typically, a distance-weighted kNN works much better than a traditional kNN. And this makes intuitive sense as well.\n*   Yet, their utility may go unnoticed. This is because many frameworks like sklearn consider “uniform” weighting by default.",
      "order": 206,
      "orderInChapter": 7,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 191,
        "contentLength": 1444
      },
      "nextCards": [
        "ai-interview-how-does-kafka-work-as-a-pub-sub-207",
        "ai-interview-how-do-you-swap-two-numbers-without-a-temporary-va-208"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-distance-weighted-knns?-what-are-the-limitation-of-traditional-knns?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-kafka-work-as-a-pub-sub-207",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Does Kafka Work As a Pub-Sub?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li><strong>Topics:</strong> Kafka divides its messages into categories called Topics. A topic is like a table in a database, and the messages are the rows in that table.</li>\n  <li><strong>Producers:</strong> Producers are applications that publish (or write) records to Kafka.</li>\n  <li><strong>Consumers:</strong> Consumers are the applications that subscribe to (read and process) data from Kafka topics.</li>\n  <li><strong>Brokers:</strong> A Kafka server is also called a broker; it is responsible for reliably storing data provided by the producers and making it available to the consumers.</li>\n  <li><strong>Records:</strong> A record is a message or an event that gets stored in Kafka.</li>\n  <li>Message Flow:\n    <ul>\n      <li>Each message that Kafka receives from a producer is associated with a topic.</li>\n      <li>Consumers can subscribe to a topic to get notified when new messages are added to that topic.</li>\n      <li>A topic can have multiple subscribers that read messages from it.</li>\n      <li>In a Kafka cluster, a topic is identified by its name and must be unique.</li>\n    </ul>\n  </li>\n  <li>Messages in a topic can be read as often as needed -— unlike traditional messaging systems, messages are not deleted after consumption. Instead, Kafka retains messages for a configurable amount of time or until a storage size is exceeded. Kafka’s performance is effectively constant with respect to data size, so storing data for a long time is perfectly fine.</li>\n</ul>\n<ul>\n      <li>Each message that Kafka receives from a producer is associated with a topic.</li>\n      <li>Consumers can subscribe to a topic to get notified when new messages are added to that topic.</li>\n      <li>A topic can have multiple subscribers that read messages from it.</li>\n      <li>In a Kafka cluster, a topic is identified by its name and must be unique.</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/KafkaPS.jpeg\" alt=\"\"></p>",
      "contentMarkdown": "*   **Topics:** Kafka divides its messages into categories called Topics. A topic is like a table in a database, and the messages are the rows in that table.\n*   **Producers:** Producers are applications that publish (or write) records to Kafka.\n*   **Consumers:** Consumers are the applications that subscribe to (read and process) data from Kafka topics.\n*   **Brokers:** A Kafka server is also called a broker; it is responsible for reliably storing data provided by the producers and making it available to the consumers.\n*   **Records:** A record is a message or an event that gets stored in Kafka.\n*   Message Flow:\n    *   Each message that Kafka receives from a producer is associated with a topic.\n    *   Consumers can subscribe to a topic to get notified when new messages are added to that topic.\n    *   A topic can have multiple subscribers that read messages from it.\n    *   In a Kafka cluster, a topic is identified by its name and must be unique.\n*   Messages in a topic can be read as often as needed -— unlike traditional messaging systems, messages are not deleted after consumption. Instead, Kafka retains messages for a configurable amount of time or until a storage size is exceeded. Kafka’s performance is effectively constant with respect to data size, so storing data for a long time is perfectly fine.\n\n*   Each message that Kafka receives from a producer is associated with a topic.\n*   Consumers can subscribe to a topic to get notified when new messages are added to that topic.\n*   A topic can have multiple subscribers that read messages from it.\n*   In a Kafka cluster, a topic is identified by its name and must be unique.\n\n![](/primers/ai/assets/interview/KafkaPS.jpeg)",
      "order": 207,
      "orderInChapter": 8,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 283,
        "contentLength": 1958
      },
      "nextCards": [
        "ai-interview-how-do-you-swap-two-numbers-without-a-temporary-va-208",
        "ai-interview-how-would-a-compiler-tackle-swap-operations-in-a-p-209"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-kafka-work-as-a-pub-sub?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-do-you-swap-two-numbers-without-a-temporary-va-208",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Do You Swap Two Numbers Without a Temporary Variable?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Credits for this answer go to <a href=\"https://www.linkedin.com/in/prateek-chandra-j-9906632a/\">Prateek Chandra Jha</a>.</li>\n  <li>One of the most ingenious uses of the bitwise XOR operation is in swapping two numbers without using a temporary variable. This trick is often cited in computer science curriculum and coding interviews because of its clever exploitation of the properties of XOR.</li>\n  <li>Properties of XOR used in this context:\n    <ol>\n      <li>A XOR A = 0</li>\n      <li>A XOR 0 = A</li>\n      <li>A XOR B = B XOR A (Commutative)</li>\n      <li>(A XOR B) XOR C = A XOR (B XOR C) (Associative)</li>\n      <li>A XOR B XOR A = B</li>\n    </ol>\n  </li>\n  <li>Using the above properties, we can swap two numbers <code class=\"language-plaintext highlighter-rouge\">a</code> and <code class=\"language-plaintext highlighter-rouge\">b</code> as follows:\n    <ol>\n      <li>a = a XOR b</li>\n      <li>b = a XOR b which is equivalent to b = (a XOR b) XOR b = a XOR (b XOR b) = a XOR 0 = a</li>\n      <li>a = a XOR b which is equivalent to a = (a XOR b) XOR a = b XOR (a XOR a) = b XOR 0 = b</li>\n    </ol>\n  </li>\n  <li>Real-world Example:\n    <ul>\n      <li>Let’s say you’re working on a multiplayer card game. Each player has two cards in their hands, and there’s an option for players to exchange (swap) their cards instantly.</li>\n      <li>In the game’s programming, each card has a unique number ID. To make the card exchange operation efficient, you don’t want to use extra memory (even if it’s small) to store temporary values. This is especially crucial if thousands of exchanges are happening in real-time.</li>\n      <li>Here, the XOR swap becomes handy:\n        <ul>\n          <li>Player A has card with ID <code class=\"language-plaintext highlighter-rouge\">a</code>.</li>\n          <li>Player B has card with ID <code class=\"language-plaintext highlighter-rouge\">b</code>.</li>\n        </ul>\n      </li>\n      <li>To swap them without using a temporary variable:\n        <ol>\n          <li><code class=\"language-plaintext highlighter-rouge\">a = a XOR b</code></li>\n          <li><code class=\"language-plaintext highlighter-rouge\">b = a XOR b</code></li>\n          <li><code class=\"language-plaintext highlighter-rouge\">a = a XOR b</code></li>\n        </ol>\n      </li>\n      <li>After these operations, Player A will have the card with ID <code class=\"language-plaintext highlighter-rouge\">b</code>, and Player B will have the card with ID <code class=\"language-plaintext highlighter-rouge\">a</code>.</li>\n      <li>It’s worth noting that in modern-day programming, compilers are highly optimized, and this trick might not offer a noticeable performance improvement. Moreover, readability and clarity of code are often more valued, so using a temporary variable for swapping is more common. However, the XOR swap remains a classic demonstration of a clever bit-level technique.</li>\n    </ul>\n  </li>\n</ul>\n<ol>\n      <li>A XOR A = 0</li>\n      <li>A XOR 0 = A</li>\n      <li>A XOR B = B XOR A (Commutative)</li>\n      <li>(A XOR B) XOR C = A XOR (B XOR C) (Associative)</li>\n      <li>A XOR B XOR A = B</li>\n    </ol>\n<ol>\n      <li>a = a XOR b</li>\n      <li>b = a XOR b which is equivalent to b = (a XOR b) XOR b = a XOR (b XOR b) = a XOR 0 = a</li>\n      <li>a = a XOR b which is equivalent to a = (a XOR b) XOR a = b XOR (a XOR a) = b XOR 0 = b</li>\n    </ol>\n<ul>\n      <li>Let’s say you’re working on a multiplayer card game. Each player has two cards in their hands, and there’s an option for players to exchange (swap) their cards instantly.</li>\n      <li>In the game’s programming, each card has a unique number ID. To make the card exchange operation efficient, you don’t want to use extra memory (even if it’s small) to store temporary values. This is especially crucial if thousands of exchanges are happening in real-time.</li>\n      <li>Here, the XOR swap becomes handy:\n        <ul>\n          <li>Player A has card with ID <code class=\"language-plaintext highlighter-rouge\">a</code>.</li>\n          <li>Player B has card with ID <code class=\"language-plaintext highlighter-rouge\">b</code>.</li>\n        </ul>\n      </li>\n      <li>To swap them without using a temporary variable:\n        <ol>\n          <li><code class=\"language-plaintext highlighter-rouge\">a = a XOR b</code></li>\n          <li><code class=\"language-plaintext highlighter-rouge\">b = a XOR b</code></li>\n          <li><code class=\"language-plaintext highlighter-rouge\">a = a XOR b</code></li>\n        </ol>\n      </li>\n      <li>After these operations, Player A will have the card with ID <code class=\"language-plaintext highlighter-rouge\">b</code>, and Player B will have the card with ID <code class=\"language-plaintext highlighter-rouge\">a</code>.</li>\n      <li>It’s worth noting that in modern-day programming, compilers are highly optimized, and this trick might not offer a noticeable performance improvement. Moreover, readability and clarity of code are often more valued, so using a temporary variable for swapping is more common. However, the XOR swap remains a classic demonstration of a clever bit-level technique.</li>\n    </ul>\n<ul>\n          <li>Player A has card with ID <code class=\"language-plaintext highlighter-rouge\">a</code>.</li>\n          <li>Player B has card with ID <code class=\"language-plaintext highlighter-rouge\">b</code>.</li>\n        </ul>\n<ol>\n          <li><code class=\"language-plaintext highlighter-rouge\">a = a XOR b</code></li>\n          <li><code class=\"language-plaintext highlighter-rouge\">b = a XOR b</code></li>\n          <li><code class=\"language-plaintext highlighter-rouge\">a = a XOR b</code></li>\n        </ol>",
      "contentMarkdown": "*   Credits for this answer go to [Prateek Chandra Jha](https://www.linkedin.com/in/prateek-chandra-j-9906632a/).\n*   One of the most ingenious uses of the bitwise XOR operation is in swapping two numbers without using a temporary variable. This trick is often cited in computer science curriculum and coding interviews because of its clever exploitation of the properties of XOR.\n*   Properties of XOR used in this context:\n    1.  A XOR A = 0\n    2.  A XOR 0 = A\n    3.  A XOR B = B XOR A (Commutative)\n    4.  (A XOR B) XOR C = A XOR (B XOR C) (Associative)\n    5.  A XOR B XOR A = B\n*   Using the above properties, we can swap two numbers `a` and `b` as follows:\n    1.  a = a XOR b\n    2.  b = a XOR b which is equivalent to b = (a XOR b) XOR b = a XOR (b XOR b) = a XOR 0 = a\n    3.  a = a XOR b which is equivalent to a = (a XOR b) XOR a = b XOR (a XOR a) = b XOR 0 = b\n*   Real-world Example:\n    *   Let’s say you’re working on a multiplayer card game. Each player has two cards in their hands, and there’s an option for players to exchange (swap) their cards instantly.\n    *   In the game’s programming, each card has a unique number ID. To make the card exchange operation efficient, you don’t want to use extra memory (even if it’s small) to store temporary values. This is especially crucial if thousands of exchanges are happening in real-time.\n    *   Here, the XOR swap becomes handy:\n        *   Player A has card with ID `a`.\n        *   Player B has card with ID `b`.\n    *   To swap them without using a temporary variable:\n        1.  `a = a XOR b`\n        2.  `b = a XOR b`\n        3.  `a = a XOR b`\n    *   After these operations, Player A will have the card with ID `b`, and Player B will have the card with ID `a`.\n    *   It’s worth noting that in modern-day programming, compilers are highly optimized, and this trick might not offer a noticeable performance improvement. Moreover, readability and clarity of code are often more valued, so using a temporary variable for swapping is more common. However, the XOR swap remains a classic demonstration of a clever bit-level technique.\n\n1.  A XOR A = 0\n2.  A XOR 0 = A\n3.  A XOR B = B XOR A (Commutative)\n4.  (A XOR B) XOR C = A XOR (B XOR C) (Associative)\n5.  A XOR B XOR A = B\n\n1.  a = a XOR b\n2.  b = a XOR b which is equivalent to b = (a XOR b) XOR b = a XOR (b XOR b) = a XOR 0 = a\n3.  a = a XOR b which is equivalent to a = (a XOR b) XOR a = b XOR (a XOR a) = b XOR 0 = b\n\n*   Let’s say you’re working on a multiplayer card game. Each player has two cards in their hands, and there’s an option for players to exchange (swap) their cards instantly.\n*   In the game’s programming, each card has a unique number ID. To make the card exchange operation efficient, you don’t want to use extra memory (even if it’s small) to store temporary values. This is especially crucial if thousands of exchanges are happening in real-time.\n*   Here, the XOR swap becomes handy:\n    *   Player A has card with ID `a`.\n    *   Player B has card with ID `b`.\n*   To swap them without using a temporary variable:\n    1.  `a = a XOR b`\n    2.  `b = a XOR b`\n    3.  `a = a XOR b`\n*   After these operations, Player A will have the card with ID `b`, and Player B will have the card with ID `a`.\n*   It’s worth noting that in modern-day programming, compilers are highly optimized, and this trick might not offer a noticeable performance improvement. Moreover, readability and clarity of code are often more valued, so using a temporary variable for swapping is more common. However, the XOR swap remains a classic demonstration of a clever bit-level technique.\n\n*   Player A has card with ID `a`.\n*   Player B has card with ID `b`.\n\n1.  `a = a XOR b`\n2.  `b = a XOR b`\n3.  `a = a XOR b`",
      "order": 208,
      "orderInChapter": 9,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 734,
        "contentLength": 5675
      },
      "nextCards": [
        "ai-interview-how-would-a-compiler-tackle-swap-operations-in-a-p-209",
        "ai-interview-how-are-xor-filters-used-what-if-you-require-bette-210"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-do-you-swap-two-numbers-without-a-temporary-variable?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-would-a-compiler-tackle-swap-operations-in-a-p-209",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Would a Compiler Tackle Swap Operations in a Program?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Credits for this answer go to <a href=\"https://www.linkedin.com/in/prateek-chandra-j-9906632a/\">Prateek Chandra Jha</a>.</li>\n  <li>Modern compilers utilize a range of optimizations to produce efficient machine code. When it comes to swapping variables, compilers often employ strategies based on the specific context of the code and the target architecture.\n    <ol>\n      <li><strong>Using Registers:</strong> Modern processors have several registers, which are small storage areas directly on the CPU. When swapping two variables, a compiler might load one of the variables into a register, move the other variable to the original’s place, and then take the value from the register to place it in the second variable’s original position. This is essentially the classic temporary variable swap, but it’s done using fast CPU registers.</li>\n      <li><strong>Optimized XOR Swap:</strong> A modern compiler might recognize this pattern and potentially optimize it further. However, this doesn’t necessarily mean that the XOR trick will be used in the generated machine code. The compiler could decide that a register-based swap (as mentioned above) is faster and transform the XOR-based swap into a register-based one.</li>\n      <li><strong>Elimination of Swap:</strong> In certain contexts, the compiler might determine that the swap operation is redundant and can be safely eliminated without affecting the program’s behavior. For instance, if the variables are swapped back to their original values later in the code and there’s no use of the swapped values in between, then the compiler might just eliminate the swaps entirely.</li>\n      <li><strong>Using SIMD (Single Instruction, Multiple Data) Instructions:</strong> On architectures that support SIMD, multiple data elements can be processed in parallel. In certain contexts, swapping operations can be optimized using SIMD instructions.</li>\n      <li><strong>Inlining and Other Optimizations:</strong> If the swapping operation is part of a small function that gets called multiple times, the compiler might inline the function (replace the function call with the function’s content) to eliminate the overhead of the function call. Once inlined, the swapping operation can be further optimized in the context of the calling function.</li>\n    </ol>\n  </li>\n  <li>Real-world Example:\n    <ul>\n      <li>Imagine a graphics program that’s performing operations on pairs of pixel values. Let’s say there’s a piece of code that frequently swaps these pixel values:\n        <pre><code class=\"language-C\">  void swap(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n  }\n</code></pre>\n      </li>\n      <li>In a loop that calls this function thousands of times, a modern compiler might inline the swap function right into the loop to avoid the overhead of the function calls. Furthermore, if the loop swaps the values back to their original state later on without any significant computation in between, the compiler might even eliminate these swap operations altogether, judging them as redundant.</li>\n    </ul>\n  </li>\n</ul>\n<ol>\n      <li><strong>Using Registers:</strong> Modern processors have several registers, which are small storage areas directly on the CPU. When swapping two variables, a compiler might load one of the variables into a register, move the other variable to the original’s place, and then take the value from the register to place it in the second variable’s original position. This is essentially the classic temporary variable swap, but it’s done using fast CPU registers.</li>\n      <li><strong>Optimized XOR Swap:</strong> A modern compiler might recognize this pattern and potentially optimize it further. However, this doesn’t necessarily mean that the XOR trick will be used in the generated machine code. The compiler could decide that a register-based swap (as mentioned above) is faster and transform the XOR-based swap into a register-based one.</li>\n      <li><strong>Elimination of Swap:</strong> In certain contexts, the compiler might determine that the swap operation is redundant and can be safely eliminated without affecting the program’s behavior. For instance, if the variables are swapped back to their original values later in the code and there’s no use of the swapped values in between, then the compiler might just eliminate the swaps entirely.</li>\n      <li><strong>Using SIMD (Single Instruction, Multiple Data) Instructions:</strong> On architectures that support SIMD, multiple data elements can be processed in parallel. In certain contexts, swapping operations can be optimized using SIMD instructions.</li>\n      <li><strong>Inlining and Other Optimizations:</strong> If the swapping operation is part of a small function that gets called multiple times, the compiler might inline the function (replace the function call with the function’s content) to eliminate the overhead of the function call. Once inlined, the swapping operation can be further optimized in the context of the calling function.</li>\n    </ol>\n<ul>\n      <li>Imagine a graphics program that’s performing operations on pairs of pixel values. Let’s say there’s a piece of code that frequently swaps these pixel values:\n        <pre><code class=\"language-C\">  void swap(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n  }\n</code></pre>\n      </li>\n      <li>In a loop that calls this function thousands of times, a modern compiler might inline the swap function right into the loop to avoid the overhead of the function calls. Furthermore, if the loop swaps the values back to their original state later on without any significant computation in between, the compiler might even eliminate these swap operations altogether, judging them as redundant.</li>\n    </ul>\n<pre><code class=\"language-C\">  void swap(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n  }\n</code></pre>",
      "contentMarkdown": "*   Credits for this answer go to [Prateek Chandra Jha](https://www.linkedin.com/in/prateek-chandra-j-9906632a/).\n*   Modern compilers utilize a range of optimizations to produce efficient machine code. When it comes to swapping variables, compilers often employ strategies based on the specific context of the code and the target architecture.\n    1.  **Using Registers:** Modern processors have several registers, which are small storage areas directly on the CPU. When swapping two variables, a compiler might load one of the variables into a register, move the other variable to the original’s place, and then take the value from the register to place it in the second variable’s original position. This is essentially the classic temporary variable swap, but it’s done using fast CPU registers.\n    2.  **Optimized XOR Swap:** A modern compiler might recognize this pattern and potentially optimize it further. However, this doesn’t necessarily mean that the XOR trick will be used in the generated machine code. The compiler could decide that a register-based swap (as mentioned above) is faster and transform the XOR-based swap into a register-based one.\n    3.  **Elimination of Swap:** In certain contexts, the compiler might determine that the swap operation is redundant and can be safely eliminated without affecting the program’s behavior. For instance, if the variables are swapped back to their original values later in the code and there’s no use of the swapped values in between, then the compiler might just eliminate the swaps entirely.\n    4.  **Using SIMD (Single Instruction, Multiple Data) Instructions:** On architectures that support SIMD, multiple data elements can be processed in parallel. In certain contexts, swapping operations can be optimized using SIMD instructions.\n    5.  **Inlining and Other Optimizations:** If the swapping operation is part of a small function that gets called multiple times, the compiler might inline the function (replace the function call with the function’s content) to eliminate the overhead of the function call. Once inlined, the swapping operation can be further optimized in the context of the calling function.\n*   Real-world Example:\n    *   Imagine a graphics program that’s performing operations on pairs of pixel values. Let’s say there’s a piece of code that frequently swaps these pixel values:\n        \n        ```C\n          void swap(int *a, int *b) {\n          int temp = *a;\n          *a = *b;\n          *b = temp;\n          }\n        ```\n        \n    *   In a loop that calls this function thousands of times, a modern compiler might inline the swap function right into the loop to avoid the overhead of the function calls. Furthermore, if the loop swaps the values back to their original state later on without any significant computation in between, the compiler might even eliminate these swap operations altogether, judging them as redundant.\n\n1.  **Using Registers:** Modern processors have several registers, which are small storage areas directly on the CPU. When swapping two variables, a compiler might load one of the variables into a register, move the other variable to the original’s place, and then take the value from the register to place it in the second variable’s original position. This is essentially the classic temporary variable swap, but it’s done using fast CPU registers.\n2.  **Optimized XOR Swap:** A modern compiler might recognize this pattern and potentially optimize it further. However, this doesn’t necessarily mean that the XOR trick will be used in the generated machine code. The compiler could decide that a register-based swap (as mentioned above) is faster and transform the XOR-based swap into a register-based one.\n3.  **Elimination of Swap:** In certain contexts, the compiler might determine that the swap operation is redundant and can be safely eliminated without affecting the program’s behavior. For instance, if the variables are swapped back to their original values later in the code and there’s no use of the swapped values in between, then the compiler might just eliminate the swaps entirely.\n4.  **Using SIMD (Single Instruction, Multiple Data) Instructions:** On architectures that support SIMD, multiple data elements can be processed in parallel. In certain contexts, swapping operations can be optimized using SIMD instructions.\n5.  **Inlining and Other Optimizations:** If the swapping operation is part of a small function that gets called multiple times, the compiler might inline the function (replace the function call with the function’s content) to eliminate the overhead of the function call. Once inlined, the swapping operation can be further optimized in the context of the calling function.\n\n*   Imagine a graphics program that’s performing operations on pairs of pixel values. Let’s say there’s a piece of code that frequently swaps these pixel values:\n    \n    ```C\n      void swap(int *a, int *b) {\n      int temp = *a;\n      *a = *b;\n      *b = temp;\n      }\n    ```\n    \n*   In a loop that calls this function thousands of times, a modern compiler might inline the swap function right into the loop to avoid the overhead of the function calls. Furthermore, if the loop swaps the values back to their original state later on without any significant computation in between, the compiler might even eliminate these swap operations altogether, judging them as redundant.\n\n```C\n  void swap(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n  }\n```",
      "order": 209,
      "orderInChapter": 10,
      "difficulty": 5,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "optimization"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 843,
        "contentLength": 5900
      },
      "nextCards": [
        "ai-interview-how-are-xor-filters-used-what-if-you-require-bette-210",
        "ai-interview-what-are-indexing-techniques-for-nosql-databases-211"
      ],
      "relatedCards": [
        "ai-support-vector-machines-model-16",
        "ai-diffusion-models-in-diffusion-models-there-is-a-forward-diffusion-p-44",
        "ai-diffusion-models-diffusion-model-alignment-using-direct-preference--55",
        "ai-diffusion-models-diffusion-model-alignment-using-direct-preference--66",
        "ai-reinforcement-learning-computational-resources-and-scalability-40"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-would-a-compiler-tackle-swap-operations-in-a-program?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-are-xor-filters-used-what-if-you-require-bette-210",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How are XOR Filters Used? What If You Require Better Performance Than Bloom Filters?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Credits for this answer go to <a href=\"https://www.linkedin.com/in/devagarwal1803/\">Dev Agarwal</a>.</li>\n  <li>Bloom Filters trade-off latency for performance (in terms of false positives). But can we do better to minimize these false positives? Indeed, we can! Introducing a new player in the data structure arena: the XOR Filter.</li>\n  <li>As the name suggests, XOR Filters leverage XOR (exclusive OR) operations to encode the presence of elements. This advanced technique comes with a more intricate setup involving auxiliary arrays and values, but it offers an intriguing advantage – better accuracy as shown in the figure below.</li>\n</ul>\n<p><img src=\"/primers/ai/assets/interview/XORF.jpeg\" alt=\"\"></p>\n<ul>\n  <li>Let’s break the process into steps to understand a bit more:\n    <ol>\n      <li>Hash each word to produce an array of hashes.</li>\n      <li>XOR the hashes together to form a single value.</li>\n      <li>Store this XOR value. For our example, let’s say we hash “apple” to hash(apple) = 3, “banana” to hash(banana) = 7, and “cherry” to hash(cherry) = 4. The XOR of these hash values would be 3 XOR 7 XOR 4 = 4.</li>\n    </ol>\n  </li>\n  <li>Now, when checking for the presence of “cherry,” we hash it to hash(cherry) = 4 and XOR it with the stored XOR value of 4. If the result is 0, “cherry” is likely in the set.</li>\n  <li>While this example simplifies the process, XOR filters offer more accurate set membership testing and can handle more elements before becoming prone to false positives compared to Bloom filters. However, implementing XOR filters can be more complex and might require more memory than Bloom filters.</li>\n  <li>As a detailed example:\n    <ul>\n      <li>Let’s say we’re building an XOR filter to check if a given number is present in a set of integers. We’ll use a simplified version of the algorithm, and for clarity, here’s an end-to-end example:</li>\n      <li><strong>Step 1:</strong> Hashing\n        <ol>\n          <li>We have a set of integers: 7, 15, and 23.</li>\n          <li>We apply a hash function to each integer to generate hash values:\n    - Hash(7) = 2\n    - Hash(15) = 1\n    - Hash(23) = 3</li>\n        </ol>\n      </li>\n      <li><strong>Step 2:</strong> Creating XOR Values\n        <ol>\n          <li>We create XOR values by combining the hash values using bitwise XOR.</li>\n          <li>XOR Value = Hash(7) XOR Hash(15) XOR Hash(23) = 2 XOR 1 XOR 3 = 0.</li>\n        </ol>\n      </li>\n      <li><strong>Step 3:</strong> Storing the XOR Value\n        <ol>\n          <li>We store the XOR value (0) for the set of integers (7, 15, 23).</li>\n        </ol>\n      </li>\n      <li><strong>Step 4:</strong> Checking Membership\n        <ol>\n          <li>Now, let’s check if a new number, 10, is in the set.</li>\n          <li>We hash 10: Hash(10) = 2.</li>\n          <li>We XOR Hash(10) with the stored XOR value: 2 XOR 0 = 2.</li>\n        </ol>\n      </li>\n      <li><strong>Step 5:</strong> Determining Membership\n        <ol>\n          <li>If the result of the XOR operation is 0, then it’s likely that the number is in the set. In this case, 10 is not in the set since 2 XOR 0 is not 0.</li>\n        </ol>\n      </li>\n    </ul>\n  </li>\n  <li>Real-World Analogy:\n    <ul>\n      <li>Think of the XOR value as a “fingerprint” of the set. It’s derived from the hash values of the elements and captures their combined presence. When you want to check if a new number is in the set, you hash the new number, XOR it with the stored XOR value, and see if the result matches 0. If it does, there’s a high chance the number is in the set; if not, it’s likely not in the set.</li>\n    </ul>\n  </li>\n  <li>This XOR filtering approach boasts a higher accuracy rate than Bloom filters when it comes to reducing false positives. Nevertheless, it’s important to note that constructing and maintaining XOR filters can demand more memory and computational resources compared to their Bloom counterparts.</li>\n  <li>Compared to Bloom or Cuckoo filters, XOR filters are immutable. They are meant to be built once and used many times, unlike Bloom or Cuckoo filters where elements can be added dynamically. It makes XOR filters unfit for many “online” use-cases.</li>\n</ul>\n<ol>\n      <li>Hash each word to produce an array of hashes.</li>\n      <li>XOR the hashes together to form a single value.</li>\n      <li>Store this XOR value. For our example, let’s say we hash “apple” to hash(apple) = 3, “banana” to hash(banana) = 7, and “cherry” to hash(cherry) = 4. The XOR of these hash values would be 3 XOR 7 XOR 4 = 4.</li>\n    </ol>\n<ul>\n      <li>Let’s say we’re building an XOR filter to check if a given number is present in a set of integers. We’ll use a simplified version of the algorithm, and for clarity, here’s an end-to-end example:</li>\n      <li><strong>Step 1:</strong> Hashing\n        <ol>\n          <li>We have a set of integers: 7, 15, and 23.</li>\n          <li>We apply a hash function to each integer to generate hash values:\n    - Hash(7) = 2\n    - Hash(15) = 1\n    - Hash(23) = 3</li>\n        </ol>\n      </li>\n      <li><strong>Step 2:</strong> Creating XOR Values\n        <ol>\n          <li>We create XOR values by combining the hash values using bitwise XOR.</li>\n          <li>XOR Value = Hash(7) XOR Hash(15) XOR Hash(23) = 2 XOR 1 XOR 3 = 0.</li>\n        </ol>\n      </li>\n      <li><strong>Step 3:</strong> Storing the XOR Value\n        <ol>\n          <li>We store the XOR value (0) for the set of integers (7, 15, 23).</li>\n        </ol>\n      </li>\n      <li><strong>Step 4:</strong> Checking Membership\n        <ol>\n          <li>Now, let’s check if a new number, 10, is in the set.</li>\n          <li>We hash 10: Hash(10) = 2.</li>\n          <li>We XOR Hash(10) with the stored XOR value: 2 XOR 0 = 2.</li>\n        </ol>\n      </li>\n      <li><strong>Step 5:</strong> Determining Membership\n        <ol>\n          <li>If the result of the XOR operation is 0, then it’s likely that the number is in the set. In this case, 10 is not in the set since 2 XOR 0 is not 0.</li>\n        </ol>\n      </li>\n    </ul>\n<ol>\n          <li>We have a set of integers: 7, 15, and 23.</li>\n          <li>We apply a hash function to each integer to generate hash values:\n    - Hash(7) = 2\n    - Hash(15) = 1\n    - Hash(23) = 3</li>\n        </ol>\n<ol>\n          <li>We create XOR values by combining the hash values using bitwise XOR.</li>\n          <li>XOR Value = Hash(7) XOR Hash(15) XOR Hash(23) = 2 XOR 1 XOR 3 = 0.</li>\n        </ol>\n<ol>\n          <li>We store the XOR value (0) for the set of integers (7, 15, 23).</li>\n        </ol>\n<ol>\n          <li>Now, let’s check if a new number, 10, is in the set.</li>\n          <li>We hash 10: Hash(10) = 2.</li>\n          <li>We XOR Hash(10) with the stored XOR value: 2 XOR 0 = 2.</li>\n        </ol>\n<ol>\n          <li>If the result of the XOR operation is 0, then it’s likely that the number is in the set. In this case, 10 is not in the set since 2 XOR 0 is not 0.</li>\n        </ol>\n<ul>\n      <li>Think of the XOR value as a “fingerprint” of the set. It’s derived from the hash values of the elements and captures their combined presence. When you want to check if a new number is in the set, you hash the new number, XOR it with the stored XOR value, and see if the result matches 0. If it does, there’s a high chance the number is in the set; if not, it’s likely not in the set.</li>\n    </ul>",
      "contentMarkdown": "*   Credits for this answer go to [Dev Agarwal](https://www.linkedin.com/in/devagarwal1803/).\n*   Bloom Filters trade-off latency for performance (in terms of false positives). But can we do better to minimize these false positives? Indeed, we can! Introducing a new player in the data structure arena: the XOR Filter.\n*   As the name suggests, XOR Filters leverage XOR (exclusive OR) operations to encode the presence of elements. This advanced technique comes with a more intricate setup involving auxiliary arrays and values, but it offers an intriguing advantage – better accuracy as shown in the figure below.\n\n![](/primers/ai/assets/interview/XORF.jpeg)\n\n*   Let’s break the process into steps to understand a bit more:\n    1.  Hash each word to produce an array of hashes.\n    2.  XOR the hashes together to form a single value.\n    3.  Store this XOR value. For our example, let’s say we hash “apple” to hash(apple) = 3, “banana” to hash(banana) = 7, and “cherry” to hash(cherry) = 4. The XOR of these hash values would be 3 XOR 7 XOR 4 = 4.\n*   Now, when checking for the presence of “cherry,” we hash it to hash(cherry) = 4 and XOR it with the stored XOR value of 4. If the result is 0, “cherry” is likely in the set.\n*   While this example simplifies the process, XOR filters offer more accurate set membership testing and can handle more elements before becoming prone to false positives compared to Bloom filters. However, implementing XOR filters can be more complex and might require more memory than Bloom filters.\n*   As a detailed example:\n    *   Let’s say we’re building an XOR filter to check if a given number is present in a set of integers. We’ll use a simplified version of the algorithm, and for clarity, here’s an end-to-end example:\n    *   **Step 1:** Hashing\n        1.  We have a set of integers: 7, 15, and 23.\n        2.  We apply a hash function to each integer to generate hash values: - Hash(7) = 2 - Hash(15) = 1 - Hash(23) = 3\n    *   **Step 2:** Creating XOR Values\n        1.  We create XOR values by combining the hash values using bitwise XOR.\n        2.  XOR Value = Hash(7) XOR Hash(15) XOR Hash(23) = 2 XOR 1 XOR 3 = 0.\n    *   **Step 3:** Storing the XOR Value\n        1.  We store the XOR value (0) for the set of integers (7, 15, 23).\n    *   **Step 4:** Checking Membership\n        1.  Now, let’s check if a new number, 10, is in the set.\n        2.  We hash 10: Hash(10) = 2.\n        3.  We XOR Hash(10) with the stored XOR value: 2 XOR 0 = 2.\n    *   **Step 5:** Determining Membership\n        1.  If the result of the XOR operation is 0, then it’s likely that the number is in the set. In this case, 10 is not in the set since 2 XOR 0 is not 0.\n*   Real-World Analogy:\n    *   Think of the XOR value as a “fingerprint” of the set. It’s derived from the hash values of the elements and captures their combined presence. When you want to check if a new number is in the set, you hash the new number, XOR it with the stored XOR value, and see if the result matches 0. If it does, there’s a high chance the number is in the set; if not, it’s likely not in the set.\n*   This XOR filtering approach boasts a higher accuracy rate than Bloom filters when it comes to reducing false positives. Nevertheless, it’s important to note that constructing and maintaining XOR filters can demand more memory and computational resources compared to their Bloom counterparts.\n*   Compared to Bloom or Cuckoo filters, XOR filters are immutable. They are meant to be built once and used many times, unlike Bloom or Cuckoo filters where elements can be added dynamically. It makes XOR filters unfit for many “online” use-cases.\n\n1.  Hash each word to produce an array of hashes.\n2.  XOR the hashes together to form a single value.\n3.  Store this XOR value. For our example, let’s say we hash “apple” to hash(apple) = 3, “banana” to hash(banana) = 7, and “cherry” to hash(cherry) = 4. The XOR of these hash values would be 3 XOR 7 XOR 4 = 4.\n\n*   Let’s say we’re building an XOR filter to check if a given number is present in a set of integers. We’ll use a simplified version of the algorithm, and for clarity, here’s an end-to-end example:\n*   **Step 1:** Hashing\n    1.  We have a set of integers: 7, 15, and 23.\n    2.  We apply a hash function to each integer to generate hash values: - Hash(7) = 2 - Hash(15) = 1 - Hash(23) = 3\n*   **Step 2:** Creating XOR Values\n    1.  We create XOR values by combining the hash values using bitwise XOR.\n    2.  XOR Value = Hash(7) XOR Hash(15) XOR Hash(23) = 2 XOR 1 XOR 3 = 0.\n*   **Step 3:** Storing the XOR Value\n    1.  We store the XOR value (0) for the set of integers (7, 15, 23).\n*   **Step 4:** Checking Membership\n    1.  Now, let’s check if a new number, 10, is in the set.\n    2.  We hash 10: Hash(10) = 2.\n    3.  We XOR Hash(10) with the stored XOR value: 2 XOR 0 = 2.\n*   **Step 5:** Determining Membership\n    1.  If the result of the XOR operation is 0, then it’s likely that the number is in the set. In this case, 10 is not in the set since 2 XOR 0 is not 0.\n\n1.  We have a set of integers: 7, 15, and 23.\n2.  We apply a hash function to each integer to generate hash values: - Hash(7) = 2 - Hash(15) = 1 - Hash(23) = 3\n\n1.  We create XOR values by combining the hash values using bitwise XOR.\n2.  XOR Value = Hash(7) XOR Hash(15) XOR Hash(23) = 2 XOR 1 XOR 3 = 0.\n\n1.  We store the XOR value (0) for the set of integers (7, 15, 23).\n\n1.  Now, let’s check if a new number, 10, is in the set.\n2.  We hash 10: Hash(10) = 2.\n3.  We XOR Hash(10) with the stored XOR value: 2 XOR 0 = 2.\n\n1.  If the result of the XOR operation is 0, then it’s likely that the number is in the set. In this case, 10 is not in the set since 2 XOR 0 is not 0.\n\n*   Think of the XOR value as a “fingerprint” of the set. It’s derived from the hash values of the elements and captures their combined presence. When you want to check if a new number is in the set, you hash the new number, XOR it with the stored XOR value, and see if the result matches 0. If it does, there’s a high chance the number is in the set; if not, it’s likely not in the set.",
      "order": 210,
      "orderInChapter": 11,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 1145,
        "contentLength": 7418
      },
      "nextCards": [
        "ai-interview-what-are-indexing-techniques-for-nosql-databases-211",
        "ai-interview-does-dpo-for-llm-alignment-use-the-bradley-terry-m-212"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-are-xor-filters-used?-what-if-you-require-better-performance-than-bloom-filters?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-indexing-techniques-for-nosql-databases-211",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Indexing Techniques for NoSQL Databases?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Credits for this answer go to <a href=\"https://www.linkedin.com/in/prateek-chandra-j-9906632a/\">Prateek Chandra Jha</a>.</li>\n  <li>NoSQL databases (usually) run faster than SQL databases, thanks to their ease of scalability and the intelligent indexing techniques they use under-the-hood.</li>\n  <li>In NoSQL databases, indexing techniques vary based on the type of NoSQL database (document-based, key-value, columnar, or graph). Regardless of the type, the goal of indexing is to improve data retrieval performance. Let’s dive into some common indexing techniques across different NoSQL database types:\n    <ol>\n      <li>B-Tree Indexing:\n        <ul>\n          <li>Used by many NoSQL databases, including some configurations of MongoDB.</li>\n          <li>Like in relational databases, B-trees can quickly locate data based on the indexed key. They are particularly useful for range queries.</li>\n        </ul>\n      </li>\n      <li>Hash Indexing:\n        <ul>\n          <li>Common in key-value stores like Redis.</li>\n          <li>Given a key, the database applies a hash function to find the location of the corresponding value.</li>\n          <li>It’s very efficient for point queries (where you’re looking up a single key-value pair) but not for range queries.</li>\n        </ul>\n      </li>\n      <li>Compound Indexing:\n        <ul>\n          <li>Used in document stores like MongoDB.</li>\n          <li>Allows for creating indexes on multiple fields. This is particularly useful when queries need to filter or sort by multiple fields.</li>\n        </ul>\n      </li>\n      <li>Geospatial Indexing:\n        <ul>\n          <li>Many NoSQL databases like MongoDB and Elasticsearch support this.</li>\n          <li>Used to index data based on geographic location. For instance, you could use a geospatial index to quickly retrieve all restaurants within a 5-mile radius of a specific point.</li>\n        </ul>\n      </li>\n      <li>Bitmap Indexing:\n        <ul>\n          <li>Often used in column-family stores like HBase or Cassandra.</li>\n          <li>Efficient for scenarios where the indexed column has a low cardinality (i.e., a limited number of unique values).</li>\n          <li>Uses a bitmap for each unique value and sets bits for rows that have that value.</li>\n        </ul>\n      </li>\n      <li>Inverted Indexing:\n        <ul>\n          <li>Common in full-text search databases like Elasticsearch.</li>\n          <li>Instead of mapping documents to keywords (like a traditional index), it maps keywords to the list of documents that contain them. This is essential for efficient full-text search operations.</li>\n        </ul>\n      </li>\n      <li>Secondary Indexing:\n        <ul>\n          <li>Provides a way to query data on non-primary key columns.</li>\n          <li>Used in databases like Cassandra where the primary mode of access is through the primary key. A secondary index allows for efficient querying on other columns.</li>\n        </ul>\n      </li>\n      <li>Edge Indexing:\n        <ul>\n          <li>Used in graph databases like Neo4j.</li>\n          <li>Helps in efficiently traversing relationships (edges) in the graph.</li>\n        </ul>\n      </li>\n      <li>Prefix Indexing:\n        <ul>\n          <li>Used in databases like Redis.</li>\n          <li>Helps in efficiently querying keys with a common prefix.</li>\n        </ul>\n      </li>\n      <li>Sparse Indexing:\n        <ul>\n          <li>Particularly useful in databases like MongoDB for collections where only a subset of documents contains the indexed field.</li>\n          <li>Instead of having an entry for each document in the collection, the sparse index only includes entries for documents that have the indexed field.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li>While these are some of the common indexing techniques, NoSQL databases often combine and customize these techniques based on their architecture and use-case specifics.</li>\n</ul>\n<ol>\n      <li>B-Tree Indexing:\n        <ul>\n          <li>Used by many NoSQL databases, including some configurations of MongoDB.</li>\n          <li>Like in relational databases, B-trees can quickly locate data based on the indexed key. They are particularly useful for range queries.</li>\n        </ul>\n      </li>\n      <li>Hash Indexing:\n        <ul>\n          <li>Common in key-value stores like Redis.</li>\n          <li>Given a key, the database applies a hash function to find the location of the corresponding value.</li>\n          <li>It’s very efficient for point queries (where you’re looking up a single key-value pair) but not for range queries.</li>\n        </ul>\n      </li>\n      <li>Compound Indexing:\n        <ul>\n          <li>Used in document stores like MongoDB.</li>\n          <li>Allows for creating indexes on multiple fields. This is particularly useful when queries need to filter or sort by multiple fields.</li>\n        </ul>\n      </li>\n      <li>Geospatial Indexing:\n        <ul>\n          <li>Many NoSQL databases like MongoDB and Elasticsearch support this.</li>\n          <li>Used to index data based on geographic location. For instance, you could use a geospatial index to quickly retrieve all restaurants within a 5-mile radius of a specific point.</li>\n        </ul>\n      </li>\n      <li>Bitmap Indexing:\n        <ul>\n          <li>Often used in column-family stores like HBase or Cassandra.</li>\n          <li>Efficient for scenarios where the indexed column has a low cardinality (i.e., a limited number of unique values).</li>\n          <li>Uses a bitmap for each unique value and sets bits for rows that have that value.</li>\n        </ul>\n      </li>\n      <li>Inverted Indexing:\n        <ul>\n          <li>Common in full-text search databases like Elasticsearch.</li>\n          <li>Instead of mapping documents to keywords (like a traditional index), it maps keywords to the list of documents that contain them. This is essential for efficient full-text search operations.</li>\n        </ul>\n      </li>\n      <li>Secondary Indexing:\n        <ul>\n          <li>Provides a way to query data on non-primary key columns.</li>\n          <li>Used in databases like Cassandra where the primary mode of access is through the primary key. A secondary index allows for efficient querying on other columns.</li>\n        </ul>\n      </li>\n      <li>Edge Indexing:\n        <ul>\n          <li>Used in graph databases like Neo4j.</li>\n          <li>Helps in efficiently traversing relationships (edges) in the graph.</li>\n        </ul>\n      </li>\n      <li>Prefix Indexing:\n        <ul>\n          <li>Used in databases like Redis.</li>\n          <li>Helps in efficiently querying keys with a common prefix.</li>\n        </ul>\n      </li>\n      <li>Sparse Indexing:\n        <ul>\n          <li>Particularly useful in databases like MongoDB for collections where only a subset of documents contains the indexed field.</li>\n          <li>Instead of having an entry for each document in the collection, the sparse index only includes entries for documents that have the indexed field.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Used by many NoSQL databases, including some configurations of MongoDB.</li>\n          <li>Like in relational databases, B-trees can quickly locate data based on the indexed key. They are particularly useful for range queries.</li>\n        </ul>\n<ul>\n          <li>Common in key-value stores like Redis.</li>\n          <li>Given a key, the database applies a hash function to find the location of the corresponding value.</li>\n          <li>It’s very efficient for point queries (where you’re looking up a single key-value pair) but not for range queries.</li>\n        </ul>\n<ul>\n          <li>Used in document stores like MongoDB.</li>\n          <li>Allows for creating indexes on multiple fields. This is particularly useful when queries need to filter or sort by multiple fields.</li>\n        </ul>\n<ul>\n          <li>Many NoSQL databases like MongoDB and Elasticsearch support this.</li>\n          <li>Used to index data based on geographic location. For instance, you could use a geospatial index to quickly retrieve all restaurants within a 5-mile radius of a specific point.</li>\n        </ul>\n<ul>\n          <li>Often used in column-family stores like HBase or Cassandra.</li>\n          <li>Efficient for scenarios where the indexed column has a low cardinality (i.e., a limited number of unique values).</li>\n          <li>Uses a bitmap for each unique value and sets bits for rows that have that value.</li>\n        </ul>\n<ul>\n          <li>Common in full-text search databases like Elasticsearch.</li>\n          <li>Instead of mapping documents to keywords (like a traditional index), it maps keywords to the list of documents that contain them. This is essential for efficient full-text search operations.</li>\n        </ul>\n<ul>\n          <li>Provides a way to query data on non-primary key columns.</li>\n          <li>Used in databases like Cassandra where the primary mode of access is through the primary key. A secondary index allows for efficient querying on other columns.</li>\n        </ul>\n<ul>\n          <li>Used in graph databases like Neo4j.</li>\n          <li>Helps in efficiently traversing relationships (edges) in the graph.</li>\n        </ul>\n<ul>\n          <li>Used in databases like Redis.</li>\n          <li>Helps in efficiently querying keys with a common prefix.</li>\n        </ul>\n<ul>\n          <li>Particularly useful in databases like MongoDB for collections where only a subset of documents contains the indexed field.</li>\n          <li>Instead of having an entry for each document in the collection, the sparse index only includes entries for documents that have the indexed field.</li>\n        </ul>",
      "contentMarkdown": "*   Credits for this answer go to [Prateek Chandra Jha](https://www.linkedin.com/in/prateek-chandra-j-9906632a/).\n*   NoSQL databases (usually) run faster than SQL databases, thanks to their ease of scalability and the intelligent indexing techniques they use under-the-hood.\n*   In NoSQL databases, indexing techniques vary based on the type of NoSQL database (document-based, key-value, columnar, or graph). Regardless of the type, the goal of indexing is to improve data retrieval performance. Let’s dive into some common indexing techniques across different NoSQL database types:\n    1.  B-Tree Indexing:\n        *   Used by many NoSQL databases, including some configurations of MongoDB.\n        *   Like in relational databases, B-trees can quickly locate data based on the indexed key. They are particularly useful for range queries.\n    2.  Hash Indexing:\n        *   Common in key-value stores like Redis.\n        *   Given a key, the database applies a hash function to find the location of the corresponding value.\n        *   It’s very efficient for point queries (where you’re looking up a single key-value pair) but not for range queries.\n    3.  Compound Indexing:\n        *   Used in document stores like MongoDB.\n        *   Allows for creating indexes on multiple fields. This is particularly useful when queries need to filter or sort by multiple fields.\n    4.  Geospatial Indexing:\n        *   Many NoSQL databases like MongoDB and Elasticsearch support this.\n        *   Used to index data based on geographic location. For instance, you could use a geospatial index to quickly retrieve all restaurants within a 5-mile radius of a specific point.\n    5.  Bitmap Indexing:\n        *   Often used in column-family stores like HBase or Cassandra.\n        *   Efficient for scenarios where the indexed column has a low cardinality (i.e., a limited number of unique values).\n        *   Uses a bitmap for each unique value and sets bits for rows that have that value.\n    6.  Inverted Indexing:\n        *   Common in full-text search databases like Elasticsearch.\n        *   Instead of mapping documents to keywords (like a traditional index), it maps keywords to the list of documents that contain them. This is essential for efficient full-text search operations.\n    7.  Secondary Indexing:\n        *   Provides a way to query data on non-primary key columns.\n        *   Used in databases like Cassandra where the primary mode of access is through the primary key. A secondary index allows for efficient querying on other columns.\n    8.  Edge Indexing:\n        *   Used in graph databases like Neo4j.\n        *   Helps in efficiently traversing relationships (edges) in the graph.\n    9.  Prefix Indexing:\n        *   Used in databases like Redis.\n        *   Helps in efficiently querying keys with a common prefix.\n    10.  Sparse Indexing:\n         *   Particularly useful in databases like MongoDB for collections where only a subset of documents contains the indexed field.\n         *   Instead of having an entry for each document in the collection, the sparse index only includes entries for documents that have the indexed field.\n*   While these are some of the common indexing techniques, NoSQL databases often combine and customize these techniques based on their architecture and use-case specifics.\n\n1.  B-Tree Indexing:\n    *   Used by many NoSQL databases, including some configurations of MongoDB.\n    *   Like in relational databases, B-trees can quickly locate data based on the indexed key. They are particularly useful for range queries.\n2.  Hash Indexing:\n    *   Common in key-value stores like Redis.\n    *   Given a key, the database applies a hash function to find the location of the corresponding value.\n    *   It’s very efficient for point queries (where you’re looking up a single key-value pair) but not for range queries.\n3.  Compound Indexing:\n    *   Used in document stores like MongoDB.\n    *   Allows for creating indexes on multiple fields. This is particularly useful when queries need to filter or sort by multiple fields.\n4.  Geospatial Indexing:\n    *   Many NoSQL databases like MongoDB and Elasticsearch support this.\n    *   Used to index data based on geographic location. For instance, you could use a geospatial index to quickly retrieve all restaurants within a 5-mile radius of a specific point.\n5.  Bitmap Indexing:\n    *   Often used in column-family stores like HBase or Cassandra.\n    *   Efficient for scenarios where the indexed column has a low cardinality (i.e., a limited number of unique values).\n    *   Uses a bitmap for each unique value and sets bits for rows that have that value.\n6.  Inverted Indexing:\n    *   Common in full-text search databases like Elasticsearch.\n    *   Instead of mapping documents to keywords (like a traditional index), it maps keywords to the list of documents that contain them. This is essential for efficient full-text search operations.\n7.  Secondary Indexing:\n    *   Provides a way to query data on non-primary key columns.\n    *   Used in databases like Cassandra where the primary mode of access is through the primary key. A secondary index allows for efficient querying on other columns.\n8.  Edge Indexing:\n    *   Used in graph databases like Neo4j.\n    *   Helps in efficiently traversing relationships (edges) in the graph.\n9.  Prefix Indexing:\n    *   Used in databases like Redis.\n    *   Helps in efficiently querying keys with a common prefix.\n10.  Sparse Indexing:\n     *   Particularly useful in databases like MongoDB for collections where only a subset of documents contains the indexed field.\n     *   Instead of having an entry for each document in the collection, the sparse index only includes entries for documents that have the indexed field.\n\n*   Used by many NoSQL databases, including some configurations of MongoDB.\n*   Like in relational databases, B-trees can quickly locate data based on the indexed key. They are particularly useful for range queries.\n\n*   Common in key-value stores like Redis.\n*   Given a key, the database applies a hash function to find the location of the corresponding value.\n*   It’s very efficient for point queries (where you’re looking up a single key-value pair) but not for range queries.\n\n*   Used in document stores like MongoDB.\n*   Allows for creating indexes on multiple fields. This is particularly useful when queries need to filter or sort by multiple fields.\n\n*   Many NoSQL databases like MongoDB and Elasticsearch support this.\n*   Used to index data based on geographic location. For instance, you could use a geospatial index to quickly retrieve all restaurants within a 5-mile radius of a specific point.\n\n*   Often used in column-family stores like HBase or Cassandra.\n*   Efficient for scenarios where the indexed column has a low cardinality (i.e., a limited number of unique values).\n*   Uses a bitmap for each unique value and sets bits for rows that have that value.\n\n*   Common in full-text search databases like Elasticsearch.\n*   Instead of mapping documents to keywords (like a traditional index), it maps keywords to the list of documents that contain them. This is essential for efficient full-text search operations.\n\n*   Provides a way to query data on non-primary key columns.\n*   Used in databases like Cassandra where the primary mode of access is through the primary key. A secondary index allows for efficient querying on other columns.\n\n*   Used in graph databases like Neo4j.\n*   Helps in efficiently traversing relationships (edges) in the graph.\n\n*   Used in databases like Redis.\n*   Helps in efficiently querying keys with a common prefix.\n\n*   Particularly useful in databases like MongoDB for collections where only a subset of documents contains the indexed field.\n*   Instead of having an entry for each document in the collection, the sparse index only includes entries for documents that have the indexed field.",
      "order": 211,
      "orderInChapter": 12,
      "difficulty": 4,
      "estimatedMinutes": 7,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1201,
        "contentLength": 9780
      },
      "nextCards": [
        "ai-interview-does-dpo-for-llm-alignment-use-the-bradley-terry-m-212",
        "ai-interview-are-k-nearest-neighbors-and-k-means-clustering-par-213"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-indexing-techniques-for-nosql-databases?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-does-dpo-for-llm-alignment-use-the-bradley-terry-m-212",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Does DPO for LLM Alignment Use the Bradley-Terry Model? If So, How?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>The Direct Preference Optimization (DPO) method for aligning Large Language Models (LLMs) does use the Bradley-Terry model. Here’s a detailed explanation of how the Bradley-Terry model is used in DPO for LLM alignment:</p>\n  </li>\n  <li><strong>Overview of the Bradley-Terry Model</strong>:\n    <ul>\n      <li>The Bradley-Terry model is a probability model used for pairwise comparisons. It assigns a score to each item (in this context, model outputs), and the probability that one item is preferred over another is a function of their respective scores. Formally, if item <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-162-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1327\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1328\"><span class=\"mi\" id=\"MathJax-Span-1329\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-162\">i</script> has a score <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-163-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1330\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1331\"><span class=\"msubsup\" id=\"MathJax-Span-1332\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1333\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1334\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-163\">s_i</script> and item <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-164-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1335\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1336\"><span class=\"mi\" id=\"MathJax-Span-1337\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-164\">j</script> has a score <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-165-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1338\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1339\"><span class=\"msubsup\" id=\"MathJax-Span-1340\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1341\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1342\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-165\">s_j</script>, the probability <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-166-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mtext>&amp;#xA0;is preferred over&amp;#xA0;</mtext><mi>j</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1343\" style=\"width: 10.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 8.909em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1008.86em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1344\"><span class=\"mi\" id=\"MathJax-Span-1345\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1346\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1347\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mtext\" id=\"MathJax-Span-1348\" style=\"font-family: STIXGeneral-Regular;\">&nbsp;is preferred over&nbsp;</span><span class=\"mi\" id=\"MathJax-Span-1349\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1350\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mtext>&nbsp;is preferred over&nbsp;</mtext><mi>j</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-166\">P(i \\text{ is preferred over } j)</script> is given by:</li>\n    </ul>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-167-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mtext>&amp;#xA0;is preferred over&amp;#xA0;</mtext><mi>j</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>&amp;#x2061;</mo><mo stretchy=&quot;false&quot;>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></mrow><mrow><mi>exp</mi><mo>&amp;#x2061;</mo><mo stretchy=&quot;false&quot;>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mi>exp</mi><mo>&amp;#x2061;</mo><mo stretchy=&quot;false&quot;>(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy=&quot;false&quot;>)</mo></mrow></mfrac></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1351\" style=\"width: 20.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 17.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.68em, 1017.19em, 3.336em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1352\"><span class=\"mi\" id=\"MathJax-Span-1353\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1354\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1355\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mtext\" id=\"MathJax-Span-1356\" style=\"font-family: STIXGeneral-Regular;\">&nbsp;is preferred over&nbsp;</span><span class=\"mi\" id=\"MathJax-Span-1357\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1358\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1359\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1360\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 6.878em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.18em, 1002.71em, 4.378em, -999.997em); top: -4.685em; left: 50%; margin-left: -1.404em;\"><span class=\"mrow\" id=\"MathJax-Span-1361\"><span class=\"mi\" id=\"MathJax-Span-1362\" style=\"font-family: STIXGeneral-Regular;\">exp</span><span class=\"mo\" id=\"MathJax-Span-1363\"></span><span class=\"mo\" id=\"MathJax-Span-1364\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1365\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1366\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1367\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1368\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.18em, 1006.72em, 4.482em, -999.997em); top: -3.331em; left: 50%; margin-left: -3.383em;\"><span class=\"mrow\" id=\"MathJax-Span-1369\"><span class=\"mi\" id=\"MathJax-Span-1370\" style=\"font-family: STIXGeneral-Regular;\">exp</span><span class=\"mo\" id=\"MathJax-Span-1371\"></span><span class=\"mo\" id=\"MathJax-Span-1372\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1373\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1374\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1375\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1376\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1377\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-1378\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">exp</span><span class=\"mo\" id=\"MathJax-Span-1379\"></span><span class=\"mo\" id=\"MathJax-Span-1380\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1381\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1382\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1383\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1384\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1006.88em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 6.878em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -1.247em; border-left: 0px solid; width: 0px; height: 2.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mtext>&nbsp;is preferred over&nbsp;</mtext><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo>+</mo><mi>exp</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy=\"false\">)</mo></mrow></mfrac></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-167\">P(i \\text{ is preferred over } j) = \\frac{\\exp(s_i)}{\\exp(s_i) + \\exp(s_j)}</script>\n  </li>\n  <li><strong>Application in DPO for LLM Alignment</strong>:\n    <ol>\n      <li><strong>Data Collection</strong>:\n        <ul>\n          <li>Human evaluators provide pairwise comparisons of model outputs. For example, given two responses from the LLM, the evaluator indicates which one is better according to specific criteria (e.g., relevance, coherence, correctness).</li>\n        </ul>\n      </li>\n      <li><strong>Modeling Preferences</strong>:\n        <ul>\n          <li>The outputs of the LLM are treated as items in the Bradley-Terry model. Each output has an associated score reflecting its quality or alignment with human preferences.</li>\n        </ul>\n      </li>\n      <li><strong>Score Estimation</strong>:\n        <ul>\n          <li>The scores <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-168-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1385\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1386\"><span class=\"msubsup\" id=\"MathJax-Span-1387\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1388\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1389\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-168\">s_i</script> for each output are estimated using the observed preferences. If output <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-169-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1390\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1391\"><span class=\"mi\" id=\"MathJax-Span-1392\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-169\">i</script> is preferred over output <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-170-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1393\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1394\"><span class=\"mi\" id=\"MathJax-Span-1395\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-170\">j</script> in several comparisons, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-171-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1396\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1397\"><span class=\"msubsup\" id=\"MathJax-Span-1398\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1399\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1400\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-171\">s_i</script> will be higher than <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-172-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1401\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1402\"><span class=\"msubsup\" id=\"MathJax-Span-1403\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1404\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1405\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-172\">s_j</script>. The scores are typically estimated using maximum likelihood estimation (MLE) or other optimization techniques suited for the Bradley-Terry model.</li>\n        </ul>\n      </li>\n      <li><strong>Optimization</strong>:\n        <ul>\n          <li>Once the scores are estimated, the LLM is fine-tuned to maximize the likelihood of generating outputs with higher scores. The objective is to adjust the model parameters so that the outputs align better with human preferences as captured by the Bradley-Terry model scores.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li><strong>Detailed Steps in DPO</strong>:\n    <ol>\n      <li><strong>Generate Outputs</strong>:\n        <ul>\n          <li>Generate multiple outputs for a given prompt using the LLM.</li>\n        </ul>\n      </li>\n      <li><strong>Pairwise Comparisons</strong>:\n        <ul>\n          <li>Collect human feedback by asking evaluators to compare pairs of outputs and indicate which one is better.</li>\n        </ul>\n      </li>\n      <li><strong>Fit Bradley-Terry Model</strong>:\n        <ul>\n          <li>Use the collected pairwise comparisons to fit the Bradley-Terry model and estimate the scores for each output.</li>\n        </ul>\n      </li>\n      <li><strong>Update LLM</strong>:\n        <ul>\n          <li>Fine-tune the LLM using the estimated scores. The objective is to adjust the model parameters such that the likelihood of producing higher-scored (preferred) outputs is maximized. This step often involves gradient-based optimization techniques where the loss function incorporates the Bradley-Terry model probabilities.\n         - By iteratively performing these steps, the LLM can be aligned more closely with human preferences, producing outputs that are more likely to be preferred by human evaluators.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li><strong>Summary</strong>:\n    <ul>\n      <li>The Bradley-Terry model plays a crucial role in the Direct Preference Optimization method by providing a statistical framework for modeling and estimating the preferences of different model outputs. This, in turn, guides the fine-tuning of the LLM to align its outputs with human preferences effectively.</li>\n    </ul>\n  </li>\n</ul>\n<p>The Direct Preference Optimization (DPO) method for aligning Large Language Models (LLMs) does use the Bradley-Terry model. Here’s a detailed explanation of how the Bradley-Terry model is used in DPO for LLM alignment:</p>\n<ul>\n      <li>The Bradley-Terry model is a probability model used for pairwise comparisons. It assigns a score to each item (in this context, model outputs), and the probability that one item is preferred over another is a function of their respective scores. Formally, if item <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-162-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1327\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1328\"><span class=\"mi\" id=\"MathJax-Span-1329\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-162\">i</script> has a score <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-163-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1330\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1331\"><span class=\"msubsup\" id=\"MathJax-Span-1332\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1333\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1334\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-163\">s_i</script> and item <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-164-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1335\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1336\"><span class=\"mi\" id=\"MathJax-Span-1337\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-164\">j</script> has a score <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-165-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1338\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1339\"><span class=\"msubsup\" id=\"MathJax-Span-1340\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1341\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1342\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-165\">s_j</script>, the probability <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-166-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>i</mi><mtext>&amp;#xA0;is preferred over&amp;#xA0;</mtext><mi>j</mi><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1343\" style=\"width: 10.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 8.909em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1008.86em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1344\"><span class=\"mi\" id=\"MathJax-Span-1345\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1346\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1347\" style=\"font-family: STIXGeneral-Italic;\">i</span><span class=\"mtext\" id=\"MathJax-Span-1348\" style=\"font-family: STIXGeneral-Regular;\">&nbsp;is preferred over&nbsp;</span><span class=\"mi\" id=\"MathJax-Span-1349\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1350\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mtext>&nbsp;is preferred over&nbsp;</mtext><mi>j</mi><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-166\">P(i \\text{ is preferred over } j)</script> is given by:</li>\n    </ul>\n<ol>\n      <li><strong>Data Collection</strong>:\n        <ul>\n          <li>Human evaluators provide pairwise comparisons of model outputs. For example, given two responses from the LLM, the evaluator indicates which one is better according to specific criteria (e.g., relevance, coherence, correctness).</li>\n        </ul>\n      </li>\n      <li><strong>Modeling Preferences</strong>:\n        <ul>\n          <li>The outputs of the LLM are treated as items in the Bradley-Terry model. Each output has an associated score reflecting its quality or alignment with human preferences.</li>\n        </ul>\n      </li>\n      <li><strong>Score Estimation</strong>:\n        <ul>\n          <li>The scores <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-168-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1385\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1386\"><span class=\"msubsup\" id=\"MathJax-Span-1387\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1388\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1389\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-168\">s_i</script> for each output are estimated using the observed preferences. If output <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-169-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1390\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1391\"><span class=\"mi\" id=\"MathJax-Span-1392\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-169\">i</script> is preferred over output <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-170-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1393\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1394\"><span class=\"mi\" id=\"MathJax-Span-1395\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-170\">j</script> in several comparisons, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-171-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1396\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1397\"><span class=\"msubsup\" id=\"MathJax-Span-1398\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1399\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1400\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-171\">s_i</script> will be higher than <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-172-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1401\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1402\"><span class=\"msubsup\" id=\"MathJax-Span-1403\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1404\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1405\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-172\">s_j</script>. The scores are typically estimated using maximum likelihood estimation (MLE) or other optimization techniques suited for the Bradley-Terry model.</li>\n        </ul>\n      </li>\n      <li><strong>Optimization</strong>:\n        <ul>\n          <li>Once the scores are estimated, the LLM is fine-tuned to maximize the likelihood of generating outputs with higher scores. The objective is to adjust the model parameters so that the outputs align better with human preferences as captured by the Bradley-Terry model scores.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Human evaluators provide pairwise comparisons of model outputs. For example, given two responses from the LLM, the evaluator indicates which one is better according to specific criteria (e.g., relevance, coherence, correctness).</li>\n        </ul>\n<ul>\n          <li>The outputs of the LLM are treated as items in the Bradley-Terry model. Each output has an associated score reflecting its quality or alignment with human preferences.</li>\n        </ul>\n<ul>\n          <li>The scores <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-168-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1385\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1386\"><span class=\"msubsup\" id=\"MathJax-Span-1387\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1388\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1389\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-168\">s_i</script> for each output are estimated using the observed preferences. If output <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-169-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1390\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1391\"><span class=\"mi\" id=\"MathJax-Span-1392\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-169\">i</script> is preferred over output <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-170-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1393\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1394\"><span class=\"mi\" id=\"MathJax-Span-1395\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-170\">j</script> in several comparisons, <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-171-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1396\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1397\"><span class=\"msubsup\" id=\"MathJax-Span-1398\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1399\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1400\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-171\">s_i</script> will be higher than <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-172-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1401\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1000.68em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1402\"><span class=\"msubsup\" id=\"MathJax-Span-1403\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.37em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1404\" style=\"font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.367em;\"><span class=\"mi\" id=\"MathJax-Span-1405\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>s</mi><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-172\">s_j</script>. The scores are typically estimated using maximum likelihood estimation (MLE) or other optimization techniques suited for the Bradley-Terry model.</li>\n        </ul>\n<ul>\n          <li>Once the scores are estimated, the LLM is fine-tuned to maximize the likelihood of generating outputs with higher scores. The objective is to adjust the model parameters so that the outputs align better with human preferences as captured by the Bradley-Terry model scores.</li>\n        </ul>\n<ol>\n      <li><strong>Generate Outputs</strong>:\n        <ul>\n          <li>Generate multiple outputs for a given prompt using the LLM.</li>\n        </ul>\n      </li>\n      <li><strong>Pairwise Comparisons</strong>:\n        <ul>\n          <li>Collect human feedback by asking evaluators to compare pairs of outputs and indicate which one is better.</li>\n        </ul>\n      </li>\n      <li><strong>Fit Bradley-Terry Model</strong>:\n        <ul>\n          <li>Use the collected pairwise comparisons to fit the Bradley-Terry model and estimate the scores for each output.</li>\n        </ul>\n      </li>\n      <li><strong>Update LLM</strong>:\n        <ul>\n          <li>Fine-tune the LLM using the estimated scores. The objective is to adjust the model parameters such that the likelihood of producing higher-scored (preferred) outputs is maximized. This step often involves gradient-based optimization techniques where the loss function incorporates the Bradley-Terry model probabilities.\n         - By iteratively performing these steps, the LLM can be aligned more closely with human preferences, producing outputs that are more likely to be preferred by human evaluators.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>Generate multiple outputs for a given prompt using the LLM.</li>\n        </ul>\n<ul>\n          <li>Collect human feedback by asking evaluators to compare pairs of outputs and indicate which one is better.</li>\n        </ul>\n<ul>\n          <li>Use the collected pairwise comparisons to fit the Bradley-Terry model and estimate the scores for each output.</li>\n        </ul>\n<ul>\n          <li>Fine-tune the LLM using the estimated scores. The objective is to adjust the model parameters such that the likelihood of producing higher-scored (preferred) outputs is maximized. This step often involves gradient-based optimization techniques where the loss function incorporates the Bradley-Terry model probabilities.\n         - By iteratively performing these steps, the LLM can be aligned more closely with human preferences, producing outputs that are more likely to be preferred by human evaluators.</li>\n        </ul>\n<ul>\n      <li>The Bradley-Terry model plays a crucial role in the Direct Preference Optimization method by providing a statistical framework for modeling and estimating the preferences of different model outputs. This, in turn, guides the fine-tuning of the LLM to align its outputs with human preferences effectively.</li>\n    </ul>",
      "contentMarkdown": "*   The Direct Preference Optimization (DPO) method for aligning Large Language Models (LLMs) does use the Bradley-Terry model. Here’s a detailed explanation of how the Bradley-Terry model is used in DPO for LLM alignment:\n    \n*   **Overview of the Bradley-Terry Model**:\n    \n    *   The Bradley-Terry model is a probability model used for pairwise comparisons. It assigns a score to each item (in this context, model outputs), and the probability that one item is preferred over another is a function of their respective scores. Formally, if item iii has a score sisis\\_i and item jjj has a score sjsjs\\_j, the probability P(i is preferred over j)P(i is preferred over j)P(i \\\\text{ is preferred over } j) is given by:\n    \n    P(i is preferred over j)\\=exp(si)exp(si)+exp(sj)P(i is preferred over j)\\=exp⁡(si)exp⁡(si)+exp⁡(sj)\n    \n    P(i \\\\text{ is preferred over } j) = \\\\frac{\\\\exp(s\\_i)}{\\\\exp(s\\_i) + \\\\exp(s\\_j)}\n*   **Application in DPO for LLM Alignment**:\n    1.  **Data Collection**:\n        *   Human evaluators provide pairwise comparisons of model outputs. For example, given two responses from the LLM, the evaluator indicates which one is better according to specific criteria (e.g., relevance, coherence, correctness).\n    2.  **Modeling Preferences**:\n        *   The outputs of the LLM are treated as items in the Bradley-Terry model. Each output has an associated score reflecting its quality or alignment with human preferences.\n    3.  **Score Estimation**:\n        *   The scores sisis\\_i for each output are estimated using the observed preferences. If output iii is preferred over output jjj in several comparisons, sisis\\_i will be higher than sjsjs\\_j. The scores are typically estimated using maximum likelihood estimation (MLE) or other optimization techniques suited for the Bradley-Terry model.\n    4.  **Optimization**:\n        *   Once the scores are estimated, the LLM is fine-tuned to maximize the likelihood of generating outputs with higher scores. The objective is to adjust the model parameters so that the outputs align better with human preferences as captured by the Bradley-Terry model scores.\n*   **Detailed Steps in DPO**:\n    1.  **Generate Outputs**:\n        *   Generate multiple outputs for a given prompt using the LLM.\n    2.  **Pairwise Comparisons**:\n        *   Collect human feedback by asking evaluators to compare pairs of outputs and indicate which one is better.\n    3.  **Fit Bradley-Terry Model**:\n        *   Use the collected pairwise comparisons to fit the Bradley-Terry model and estimate the scores for each output.\n    4.  **Update LLM**:\n        *   Fine-tune the LLM using the estimated scores. The objective is to adjust the model parameters such that the likelihood of producing higher-scored (preferred) outputs is maximized. This step often involves gradient-based optimization techniques where the loss function incorporates the Bradley-Terry model probabilities. - By iteratively performing these steps, the LLM can be aligned more closely with human preferences, producing outputs that are more likely to be preferred by human evaluators.\n*   **Summary**:\n    *   The Bradley-Terry model plays a crucial role in the Direct Preference Optimization method by providing a statistical framework for modeling and estimating the preferences of different model outputs. This, in turn, guides the fine-tuning of the LLM to align its outputs with human preferences effectively.\n\nThe Direct Preference Optimization (DPO) method for aligning Large Language Models (LLMs) does use the Bradley-Terry model. Here’s a detailed explanation of how the Bradley-Terry model is used in DPO for LLM alignment:\n\n*   The Bradley-Terry model is a probability model used for pairwise comparisons. It assigns a score to each item (in this context, model outputs), and the probability that one item is preferred over another is a function of their respective scores. Formally, if item iii has a score sisis\\_i and item jjj has a score sjsjs\\_j, the probability P(i is preferred over j)P(i is preferred over j)P(i \\\\text{ is preferred over } j) is given by:\n\n1.  **Data Collection**:\n    *   Human evaluators provide pairwise comparisons of model outputs. For example, given two responses from the LLM, the evaluator indicates which one is better according to specific criteria (e.g., relevance, coherence, correctness).\n2.  **Modeling Preferences**:\n    *   The outputs of the LLM are treated as items in the Bradley-Terry model. Each output has an associated score reflecting its quality or alignment with human preferences.\n3.  **Score Estimation**:\n    *   The scores sisis\\_i for each output are estimated using the observed preferences. If output iii is preferred over output jjj in several comparisons, sisis\\_i will be higher than sjsjs\\_j. The scores are typically estimated using maximum likelihood estimation (MLE) or other optimization techniques suited for the Bradley-Terry model.\n4.  **Optimization**:\n    *   Once the scores are estimated, the LLM is fine-tuned to maximize the likelihood of generating outputs with higher scores. The objective is to adjust the model parameters so that the outputs align better with human preferences as captured by the Bradley-Terry model scores.\n\n*   Human evaluators provide pairwise comparisons of model outputs. For example, given two responses from the LLM, the evaluator indicates which one is better according to specific criteria (e.g., relevance, coherence, correctness).\n\n*   The outputs of the LLM are treated as items in the Bradley-Terry model. Each output has an associated score reflecting its quality or alignment with human preferences.\n\n*   The scores sisis\\_i for each output are estimated using the observed preferences. If output iii is preferred over output jjj in several comparisons, sisis\\_i will be higher than sjsjs\\_j. The scores are typically estimated using maximum likelihood estimation (MLE) or other optimization techniques suited for the Bradley-Terry model.\n\n*   Once the scores are estimated, the LLM is fine-tuned to maximize the likelihood of generating outputs with higher scores. The objective is to adjust the model parameters so that the outputs align better with human preferences as captured by the Bradley-Terry model scores.\n\n1.  **Generate Outputs**:\n    *   Generate multiple outputs for a given prompt using the LLM.\n2.  **Pairwise Comparisons**:\n    *   Collect human feedback by asking evaluators to compare pairs of outputs and indicate which one is better.\n3.  **Fit Bradley-Terry Model**:\n    *   Use the collected pairwise comparisons to fit the Bradley-Terry model and estimate the scores for each output.\n4.  **Update LLM**:\n    *   Fine-tune the LLM using the estimated scores. The objective is to adjust the model parameters such that the likelihood of producing higher-scored (preferred) outputs is maximized. This step often involves gradient-based optimization techniques where the loss function incorporates the Bradley-Terry model probabilities. - By iteratively performing these steps, the LLM can be aligned more closely with human preferences, producing outputs that are more likely to be preferred by human evaluators.\n\n*   Generate multiple outputs for a given prompt using the LLM.\n\n*   Collect human feedback by asking evaluators to compare pairs of outputs and indicate which one is better.\n\n*   Use the collected pairwise comparisons to fit the Bradley-Terry model and estimate the scores for each output.\n\n*   Fine-tune the LLM using the estimated scores. The objective is to adjust the model parameters such that the likelihood of producing higher-scored (preferred) outputs is maximized. This step often involves gradient-based optimization techniques where the loss function incorporates the Bradley-Terry model probabilities. - By iteratively performing these steps, the LLM can be aligned more closely with human preferences, producing outputs that are more likely to be preferred by human evaluators.\n\n*   The Bradley-Terry model plays a crucial role in the Direct Preference Optimization method by providing a statistical framework for modeling and estimating the preferences of different model outputs. This, in turn, guides the fine-tuning of the LLM to align its outputs with human preferences effectively.",
      "order": 212,
      "orderInChapter": 13,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "llm",
        "optimization",
        "loss function",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 1212,
        "contentLength": 57443
      },
      "nextCards": [
        "ai-interview-are-k-nearest-neighbors-and-k-means-clustering-par-213",
        "ai-interview-how-are-code-llms-trained-with-the-fill-in-the-mid-214"
      ],
      "relatedCards": [
        "ai-preference-optimization-pseudocode-rlhf-training-procedure-5",
        "ai-RAG-richrag-crafting-rich-responses-for-multi-faceted--53",
        "ai-deepseek-R1-grpo-successors-9",
        "ai-LLM-merging-llms-66",
        "ai-preference-optimization-grpo-successors-11"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#does-dpo-for-llm-alignment-use-the-bradley-terry-model?-if-so,-how?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-are-k-nearest-neighbors-and-k-means-clustering-par-213",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Are K-Nearest Neighbors and K-means Clustering Parametric?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>The terms “parametric” and “non-parametric” refer to whether a method makes strong assumptions about the form of the underlying distribution of the data. Both k-NN and k-means clustering are non-parametric methods because they do not assume a specific form for the underlying data distribution and rely heavily on the data itself rather than predefined parameters.Let’s examine k-Nearest Neighbors (k-NN) and k-means clustering in this context.</li>\n</ul>\n<h4 id=\"k-nearest-neighbors-k-nn\">K-Nearest Neighbors (k-NN)</h4>\n<ul>\n  <li>k-NN is considered a non-parametric method. This is because k-NN does not make any assumptions about the underlying distribution of the data. Instead, it relies on the distance between data points to make predictions or classifications. The model is defined by the training data itself rather than parameters that summarize the data.</li>\n</ul>\n<h4 id=\"k-means-clustering-1\">K-means Clustering</h4>\n<ul>\n  <li>k-means clustering is also considered a non-parametric method. While k-means does make an assumption about the number of clusters (k), it does not make strong assumptions about the form of the data distribution within those clusters. Instead, it iteratively partitions the data into k clusters based on distance measures. The means of the clusters are updated iteratively based on the current assignment of points to clusters, but this process does not depend on a fixed set of parameters that describe the overall data distribution.</li>\n</ul>",
      "contentMarkdown": "*   The terms “parametric” and “non-parametric” refer to whether a method makes strong assumptions about the form of the underlying distribution of the data. Both k-NN and k-means clustering are non-parametric methods because they do not assume a specific form for the underlying data distribution and rely heavily on the data itself rather than predefined parameters.Let’s examine k-Nearest Neighbors (k-NN) and k-means clustering in this context.\n\n#### K-Nearest Neighbors (k-NN)\n\n*   k-NN is considered a non-parametric method. This is because k-NN does not make any assumptions about the underlying distribution of the data. Instead, it relies on the distance between data points to make predictions or classifications. The model is defined by the training data itself rather than parameters that summarize the data.\n\n#### K-means Clustering\n\n*   k-means clustering is also considered a non-parametric method. While k-means does make an assumption about the number of clusters (k), it does not make strong assumptions about the form of the data distribution within those clusters. Instead, it iteratively partitions the data into k clusters based on distance measures. The means of the clusters are updated iteratively based on the current assignment of points to clusters, but this process does not depend on a fixed set of parameters that describe the overall data distribution.",
      "order": 213,
      "orderInChapter": 14,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 211,
        "contentLength": 1498
      },
      "nextCards": [
        "ai-interview-how-are-code-llms-trained-with-the-fill-in-the-mid-214",
        "ai-interview-for-a-rag-pipeline-aimed-at-a-code-generation-use--215"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#are-k-nearest-neighbors-and-k-means-clustering-parametric?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-are-code-llms-trained-with-the-fill-in-the-mid-214",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How are Code LLMs Trained with the “fill-in-the-middle” Pre-training Task?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>The implementation of “Fill-in-the-middle” (FIM) as a pre-training task in the loss function involves designing the training process to predict the missing middle section of a code sequence given the surrounding context (prefix and suffix). Here’s a detailed breakdown of how this can be integrated into the loss function:</li>\n</ul>\n<h4 id=\"implementation-of-fim-in-the-loss-function\">Implementation of FIM in the Loss Function</h4>\n<ol>\n  <li><strong>Data Preparation:</strong>\n    <ul>\n      <li><strong>Segmenting Code:</strong> For each code snippet in the training data, divide the sequence into three parts: the prefix (beginning of the code), the suffix (end of the code), and the middle section, which is to be predicted.</li>\n      <li><strong>Masking the Middle:</strong> The middle section is replaced with a special mask token that indicates to the model that this part needs to be generated.</li>\n    </ul>\n  </li>\n  <li><strong>Model Architecture:</strong>\n    <ul>\n      <li><strong>Input Representation:</strong> Concatenate the prefix and suffix, inserting the special mask token where the middle section should be.</li>\n      <li><strong>Contextual Encoding:</strong> The model processes the concatenated input to generate contextual embeddings for the prefix, mask token, and suffix.</li>\n    </ul>\n  </li>\n  <li><strong>Prediction Mechanism:</strong>\n    <ul>\n      <li><strong>Decoder Input:</strong> The model’s decoder (or the autoregressive part of the transformer) is provided with the context from the encoder and the mask token to generate the middle section.</li>\n      <li><strong>Sequence Generation:</strong> The model generates tokens sequentially for the middle section, leveraging the contextual information from both the prefix and suffix.</li>\n    </ul>\n  </li>\n  <li><strong>Loss Function Design:</strong>\n    <ul>\n      <li><strong>Cross-Entropy Loss:</strong> The primary loss function used is typically the cross-entropy loss, which measures the difference between the predicted tokens and the actual tokens in the middle section.</li>\n      <li><strong>Masked Tokens Loss Calculation:</strong> Only the positions corresponding to the middle section are considered for the loss calculation. The loss is computed by comparing the predicted tokens with the actual tokens in the masked middle section.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li><strong>Segmenting Code:</strong> For each code snippet in the training data, divide the sequence into three parts: the prefix (beginning of the code), the suffix (end of the code), and the middle section, which is to be predicted.</li>\n      <li><strong>Masking the Middle:</strong> The middle section is replaced with a special mask token that indicates to the model that this part needs to be generated.</li>\n    </ul>\n<ul>\n      <li><strong>Input Representation:</strong> Concatenate the prefix and suffix, inserting the special mask token where the middle section should be.</li>\n      <li><strong>Contextual Encoding:</strong> The model processes the concatenated input to generate contextual embeddings for the prefix, mask token, and suffix.</li>\n    </ul>\n<ul>\n      <li><strong>Decoder Input:</strong> The model’s decoder (or the autoregressive part of the transformer) is provided with the context from the encoder and the mask token to generate the middle section.</li>\n      <li><strong>Sequence Generation:</strong> The model generates tokens sequentially for the middle section, leveraging the contextual information from both the prefix and suffix.</li>\n    </ul>\n<ul>\n      <li><strong>Cross-Entropy Loss:</strong> The primary loss function used is typically the cross-entropy loss, which measures the difference between the predicted tokens and the actual tokens in the middle section.</li>\n      <li><strong>Masked Tokens Loss Calculation:</strong> Only the positions corresponding to the middle section are considered for the loss calculation. The loss is computed by comparing the predicted tokens with the actual tokens in the masked middle section.</li>\n    </ul>\n<h4 id=\"detailed-steps-for-loss-calculation\">Detailed Steps for Loss Calculation</h4>\n<ol>\n  <li><strong>Token-Level Prediction:</strong>\n    <ul>\n      <li>For each token position in the middle section, the model outputs a probability distribution over the vocabulary.</li>\n      <li>Let <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-173-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1406\" style=\"width: 2.034em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.669em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.67em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1407\"><span class=\"msubsup\" id=\"MathJax-Span-1408\"><span style=\"display: inline-block; position: relative; width: 1.669em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1409\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1410\"><span class=\"mrow\" id=\"MathJax-Span-1411\"><span class=\"mi\" id=\"MathJax-Span-1412\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1413\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1414\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1415\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-173\">y_{true}</script> be the actual token and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-174-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1416\" style=\"width: 2.294em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.878em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.88em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1417\"><span class=\"msubsup\" id=\"MathJax-Span-1418\"><span style=\"display: inline-block; position: relative; width: 1.878em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1419\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1420\"><span class=\"mrow\" id=\"MathJax-Span-1421\"><span class=\"mi\" id=\"MathJax-Span-1422\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-1423\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1424\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-1425\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-174\">y_{pred}</script> be the predicted probability distribution for a given position in the middle section.</li>\n    </ul>\n  </li>\n  <li><strong>Cross-Entropy Loss for Each Token:</strong>\n    <ul>\n      <li>The cross-entropy loss for a single token position <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-175-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1426\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1427\"><span class=\"mi\" id=\"MathJax-Span-1428\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-175\">i</script> is calculated as:\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-176-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mtext>Loss</mtext><mi>i</mi></msub><mo>=</mo><mo>&amp;#x2212;</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mtext>context</mtext><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1429\" style=\"width: 14.638em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 12.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.669em, 1012.14em, 2.919em, -999.997em); top: -2.497em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1430\"><span class=\"msubsup\" id=\"MathJax-Span-1431\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1001.83em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1432\" style=\"font-family: STIXGeneral-Regular;\">Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 1.878em;\"><span class=\"mi\" id=\"MathJax-Span-1433\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1434\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-1435\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"mi\" id=\"MathJax-Span-1436\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1437\"></span><span class=\"mi\" id=\"MathJax-Span-1438\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"mo\" id=\"MathJax-Span-1439\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1440\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1441\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1442\"><span class=\"mrow\" id=\"MathJax-Span-1443\"><span class=\"mi\" id=\"MathJax-Span-1444\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1445\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1446\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1447\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mo\" id=\"MathJax-Span-1448\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1449\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-1450\"><span class=\"mrow\" id=\"MathJax-Span-1451\"><span class=\"mo\" id=\"MathJax-Span-1452\" style=\"font-family: STIXVariants;\">|</span></span></span><span class=\"mtext\" id=\"MathJax-Span-1453\" style=\"font-family: STIXGeneral-Regular;\">context</span><span class=\"mo\" id=\"MathJax-Span-1454\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.503em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mtext>Loss</mtext><mi>i</mi></msub><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=\"MJX-TeXAtom-ORD\"><mo stretchy=\"false\">|</mo></mrow><mtext>context</mtext><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-176\">\\text{Loss}_i = -\\log P(y_{true,i} | \\text{context})</script>\nwhere <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-177-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mtext>context</mtext><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1455\" style=\"width: 7.919em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 6.565em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.669em, 1006.51em, 2.919em, -999.997em); top: -2.497em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1456\"><span class=\"mi\" id=\"MathJax-Span-1457\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1458\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1459\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1460\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1461\"><span class=\"mrow\" id=\"MathJax-Span-1462\"><span class=\"mi\" id=\"MathJax-Span-1463\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1464\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1465\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1466\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mo\" id=\"MathJax-Span-1467\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1468\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-1469\"><span class=\"mrow\" id=\"MathJax-Span-1470\"><span class=\"mo\" id=\"MathJax-Span-1471\" style=\"font-family: STIXVariants;\">|</span></span></span><span class=\"mtext\" id=\"MathJax-Span-1472\" style=\"font-family: STIXGeneral-Regular;\">context</span><span class=\"mo\" id=\"MathJax-Span-1473\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.503em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=\"MJX-TeXAtom-ORD\"><mo stretchy=\"false\">|</mo></mrow><mtext>context</mtext><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-177\">P(y_{true,i} | \\text{context})</script> is the predicted probability of the true token <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-178-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1474\" style=\"width: 2.503em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1002.09em, 2.555em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1475\"><span class=\"msubsup\" id=\"MathJax-Span-1476\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1477\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1478\"><span class=\"mrow\" id=\"MathJax-Span-1479\"><span class=\"mi\" id=\"MathJax-Span-1480\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1481\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1482\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1483\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mo\" id=\"MathJax-Span-1484\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1485\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-178\">y_{true,i}</script> given the context (prefix and suffix).</li>\n    </ul>\n  </li>\n  <li><strong>Aggregate Loss:</strong>\n    <ul>\n      <li>The total loss for a single training example is the sum of the cross-entropy losses for all token positions in the middle section:\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-179-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Total Loss</mtext><mo>=</mo><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>&amp;#x2208;</mo><mtext>middle</mtext></mrow></munder><msub><mtext>Loss</mtext><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1486\" style=\"width: 13.648em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.357em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1011.36em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1487\"><span class=\"mtext\" id=\"MathJax-Span-1488\" style=\"font-family: STIXGeneral-Regular;\">Total Loss</span><span class=\"mo\" id=\"MathJax-Span-1489\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"munderover\" id=\"MathJax-Span-1490\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 3.648em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1491\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1492\"><span class=\"mrow\" id=\"MathJax-Span-1493\"><span class=\"mi\" id=\"MathJax-Span-1494\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-1495\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∈</span><span class=\"mtext\" id=\"MathJax-Span-1496\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">middle</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1497\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1001.83em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1498\" style=\"font-family: STIXGeneral-Regular;\">Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 1.878em;\"><span class=\"mi\" id=\"MathJax-Span-1499\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.441em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Total Loss</mtext><mo>=</mo><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi><mo>∈</mo><mtext>middle</mtext></mrow></munder><msub><mtext>Loss</mtext><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-179\">\\text{Total Loss} = \\sum_{i \\in \\text{middle}} \\text{Loss}_i</script></li>\n    </ul>\n  </li>\n  <li><strong>Batch Loss:</strong>\n    <ul>\n      <li>The loss is averaged over all training examples in the batch to obtain the final loss used for backpropagation:\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-180-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Batch Loss</mtext><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1500\" style=\"width: 16.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 13.492em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.096em, 1013.49em, 2.815em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1501\"><span class=\"mtext\" id=\"MathJax-Span-1502\" style=\"font-family: STIXGeneral-Regular;\">Batch Loss</span><span class=\"mo\" id=\"MathJax-Span-1503\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1504\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1000.26em, 4.169em, -999.997em); top: -4.424em; left: 50%; margin-left: -0.154em;\"><span class=\"mn\" id=\"MathJax-Span-1505\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.52em, 4.169em, -999.997em); top: -3.643em; left: 50%; margin-left: -0.258em;\"><span class=\"mi\" id=\"MathJax-Span-1506\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1000.63em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.628em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span><span class=\"munderover\" id=\"MathJax-Span-1507\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.034em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1508\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.58em, 4.169em, -999.997em); top: -4.477em; left: 0.94em;\"><span class=\"mi\" id=\"MathJax-Span-1509\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1001.1em, 4.326em, -999.997em); top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1510\"><span class=\"mrow\" id=\"MathJax-Span-1511\"><span class=\"mi\" id=\"MathJax-Span-1512\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1513\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">=</span><span class=\"mn\" id=\"MathJax-Span-1514\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1515\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 4.534em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1004.22em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1516\" style=\"font-family: STIXGeneral-Regular;\">Total Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 4.273em;\"><span class=\"mi\" id=\"MathJax-Span-1517\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.622em; border-left: 0px solid; width: 0px; height: 1.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Batch Loss</mtext><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-180\">\\text{Batch Loss} = \\frac{1}{N} \\sum_{j=1}^N \\text{Total Loss}_j</script>\nwhere <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-181-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1518\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1519\"><span class=\"mi\" id=\"MathJax-Span-1520\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-181\">N</script> is the number of training examples in the batch and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-182-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1521\" style=\"width: 5.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.534em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1004.53em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1522\"><span class=\"msubsup\" id=\"MathJax-Span-1523\"><span style=\"display: inline-block; position: relative; width: 4.534em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1004.22em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1524\" style=\"font-family: STIXGeneral-Regular;\">Total Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 4.273em;\"><span class=\"mi\" id=\"MathJax-Span-1525\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-182\">\\text{Total Loss}_j</script> is the total loss for the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-183-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1526\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1527\"><span class=\"mi\" id=\"MathJax-Span-1528\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-183\">j</script>-th example.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>For each token position in the middle section, the model outputs a probability distribution over the vocabulary.</li>\n      <li>Let <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-173-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1406\" style=\"width: 2.034em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.669em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.67em, 2.503em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1407\"><span class=\"msubsup\" id=\"MathJax-Span-1408\"><span style=\"display: inline-block; position: relative; width: 1.669em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1409\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1410\"><span class=\"mrow\" id=\"MathJax-Span-1411\"><span class=\"mi\" id=\"MathJax-Span-1412\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1413\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1414\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1415\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 0.878em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-173\">y_{true}</script> be the actual token and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-174-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1416\" style=\"width: 2.294em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.878em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1001.88em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1417\"><span class=\"msubsup\" id=\"MathJax-Span-1418\"><span style=\"display: inline-block; position: relative; width: 1.878em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1419\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1420\"><span class=\"mrow\" id=\"MathJax-Span-1421\"><span class=\"mi\" id=\"MathJax-Span-1422\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">p</span><span class=\"mi\" id=\"MathJax-Span-1423\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1424\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mi\" id=\"MathJax-Span-1425\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">d<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-174\">y_{pred}</script> be the predicted probability distribution for a given position in the middle section.</li>\n    </ul>\n<ul>\n      <li>The cross-entropy loss for a single token position <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-175-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>i</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1426\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1427\"><span class=\"mi\" id=\"MathJax-Span-1428\" style=\"font-family: STIXGeneral-Italic;\">i</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>i</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-175\">i</script> is calculated as:\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-176-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mtext>Loss</mtext><mi>i</mi></msub><mo>=</mo><mo>&amp;#x2212;</mo><mi>log</mi><mo>&amp;#x2061;</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mtext>context</mtext><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1429\" style=\"width: 14.638em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 12.19em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.669em, 1012.14em, 2.919em, -999.997em); top: -2.497em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1430\"><span class=\"msubsup\" id=\"MathJax-Span-1431\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1001.83em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1432\" style=\"font-family: STIXGeneral-Regular;\">Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 1.878em;\"><span class=\"mi\" id=\"MathJax-Span-1433\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1434\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-1435\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">−</span><span class=\"mi\" id=\"MathJax-Span-1436\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">log</span><span class=\"mo\" id=\"MathJax-Span-1437\"></span><span class=\"mi\" id=\"MathJax-Span-1438\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.211em;\">P</span><span class=\"mo\" id=\"MathJax-Span-1439\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1440\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1441\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1442\"><span class=\"mrow\" id=\"MathJax-Span-1443\"><span class=\"mi\" id=\"MathJax-Span-1444\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1445\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1446\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1447\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mo\" id=\"MathJax-Span-1448\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1449\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-1450\"><span class=\"mrow\" id=\"MathJax-Span-1451\"><span class=\"mo\" id=\"MathJax-Span-1452\" style=\"font-family: STIXVariants;\">|</span></span></span><span class=\"mtext\" id=\"MathJax-Span-1453\" style=\"font-family: STIXGeneral-Regular;\">context</span><span class=\"mo\" id=\"MathJax-Span-1454\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.503em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mtext>Loss</mtext><mi>i</mi></msub><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=\"MJX-TeXAtom-ORD\"><mo stretchy=\"false\">|</mo></mrow><mtext>context</mtext><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-176\">\\text{Loss}_i = -\\log P(y_{true,i} | \\text{context})</script>\nwhere <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-177-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mtext>context</mtext><mo stretchy=&quot;false&quot;>)</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1455\" style=\"width: 7.919em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 6.565em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.669em, 1006.51em, 2.919em, -999.997em); top: -2.497em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1456\"><span class=\"mi\" id=\"MathJax-Span-1457\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1458\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"msubsup\" id=\"MathJax-Span-1459\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1460\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1461\"><span class=\"mrow\" id=\"MathJax-Span-1462\"><span class=\"mi\" id=\"MathJax-Span-1463\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1464\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1465\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1466\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mo\" id=\"MathJax-Span-1467\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1468\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"texatom\" id=\"MathJax-Span-1469\"><span class=\"mrow\" id=\"MathJax-Span-1470\"><span class=\"mo\" id=\"MathJax-Span-1471\" style=\"font-family: STIXVariants;\">|</span></span></span><span class=\"mtext\" id=\"MathJax-Span-1472\" style=\"font-family: STIXGeneral-Regular;\">context</span><span class=\"mo\" id=\"MathJax-Span-1473\" style=\"font-family: STIXGeneral-Regular;\">)</span></span><span style=\"display: inline-block; width: 0px; height: 2.503em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 1.253em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub><mrow class=\"MJX-TeXAtom-ORD\"><mo stretchy=\"false\">|</mo></mrow><mtext>context</mtext><mo stretchy=\"false\">)</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-177\">P(y_{true,i} | \\text{context})</script> is the predicted probability of the true token <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-178-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>y</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1474\" style=\"width: 2.503em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1002.09em, 2.555em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1475\"><span class=\"msubsup\" id=\"MathJax-Span-1476\"><span style=\"display: inline-block; position: relative; width: 2.086em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1477\" style=\"font-family: STIXGeneral-Italic;\">y</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1478\"><span class=\"mrow\" id=\"MathJax-Span-1479\"><span class=\"mi\" id=\"MathJax-Span-1480\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1481\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mi\" id=\"MathJax-Span-1482\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">u</span><span class=\"mi\" id=\"MathJax-Span-1483\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">e</span><span class=\"mo\" id=\"MathJax-Span-1484\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">,</span><span class=\"mi\" id=\"MathJax-Span-1485\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.372em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>y</mi><mrow class=\"MJX-TeXAtom-ORD\"><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>,</mo><mi>i</mi></mrow></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-178\">y_{true,i}</script> given the context (prefix and suffix).</li>\n    </ul>\n<ul>\n      <li>The total loss for a single training example is the sum of the cross-entropy losses for all token positions in the middle section:\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-179-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Total Loss</mtext><mo>=</mo><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>&amp;#x2208;</mo><mtext>middle</mtext></mrow></munder><msub><mtext>Loss</mtext><mi>i</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1486\" style=\"width: 13.648em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.357em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1011.36em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1487\"><span class=\"mtext\" id=\"MathJax-Span-1488\" style=\"font-family: STIXGeneral-Regular;\">Total Loss</span><span class=\"mo\" id=\"MathJax-Span-1489\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"munderover\" id=\"MathJax-Span-1490\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 3.648em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1491\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1492\"><span class=\"mrow\" id=\"MathJax-Span-1493\"><span class=\"mi\" id=\"MathJax-Span-1494\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span class=\"mo\" id=\"MathJax-Span-1495\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">∈</span><span class=\"mtext\" id=\"MathJax-Span-1496\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">middle</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1497\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.138em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1001.83em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1498\" style=\"font-family: STIXGeneral-Regular;\">Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 1.878em;\"><span class=\"mi\" id=\"MathJax-Span-1499\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.441em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Total Loss</mtext><mo>=</mo><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi><mo>∈</mo><mtext>middle</mtext></mrow></munder><msub><mtext>Loss</mtext><mi>i</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-179\">\\text{Total Loss} = \\sum_{i \\in \\text{middle}} \\text{Loss}_i</script></li>\n    </ul>\n<ul>\n      <li>The loss is averaged over all training examples in the batch to obtain the final loss used for backpropagation:\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-180-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Batch Loss</mtext><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1500\" style=\"width: 16.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 13.492em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.096em, 1013.49em, 2.815em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1501\"><span class=\"mtext\" id=\"MathJax-Span-1502\" style=\"font-family: STIXGeneral-Regular;\">Batch Loss</span><span class=\"mo\" id=\"MathJax-Span-1503\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1504\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.628em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1000.26em, 4.169em, -999.997em); top: -4.424em; left: 50%; margin-left: -0.154em;\"><span class=\"mn\" id=\"MathJax-Span-1505\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.52em, 4.169em, -999.997em); top: -3.643em; left: 50%; margin-left: -0.258em;\"><span class=\"mi\" id=\"MathJax-Span-1506\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1000.63em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.628em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span><span class=\"munderover\" id=\"MathJax-Span-1507\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 2.034em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1508\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.58em, 4.169em, -999.997em); top: -4.477em; left: 0.94em;\"><span class=\"mi\" id=\"MathJax-Span-1509\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1001.1em, 4.326em, -999.997em); top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1510\"><span class=\"mrow\" id=\"MathJax-Span-1511\"><span class=\"mi\" id=\"MathJax-Span-1512\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1513\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">=</span><span class=\"mn\" id=\"MathJax-Span-1514\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1515\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 4.534em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1004.22em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1516\" style=\"font-family: STIXGeneral-Regular;\">Total Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 4.273em;\"><span class=\"mi\" id=\"MathJax-Span-1517\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.622em; border-left: 0px solid; width: 0px; height: 1.816em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Batch Loss</mtext><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-180\">\\text{Batch Loss} = \\frac{1}{N} \\sum_{j=1}^N \\text{Total Loss}_j</script>\nwhere <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-181-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1518\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1519\"><span class=\"mi\" id=\"MathJax-Span-1520\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-181\">N</script> is the number of training examples in the batch and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-182-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1521\" style=\"width: 5.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.534em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1004.53em, 2.607em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1522\"><span class=\"msubsup\" id=\"MathJax-Span-1523\"><span style=\"display: inline-block; position: relative; width: 4.534em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1004.22em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mtext\" id=\"MathJax-Span-1524\" style=\"font-family: STIXGeneral-Regular;\">Total Loss</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 4.273em;\"><span class=\"mi\" id=\"MathJax-Span-1525\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.316em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mtext>Total Loss</mtext><mi>j</mi></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-182\">\\text{Total Loss}_j</script> is the total loss for the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-183-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>j</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1526\" style=\"width: 0.315em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.263em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.26em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1527\"><span class=\"mi\" id=\"MathJax-Span-1528\" style=\"font-family: STIXGeneral-Italic;\">j<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>j</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-183\">j</script>-th example.</li>\n    </ul>\n<h4 id=\"practical-example\">Practical Example</h4>\n<ul>\n  <li>Assume a code snippet is split as follows:\n    <ul>\n      <li>Prefix: <code class=\"language-plaintext highlighter-rouge\">def add_numbers(a, b):</code></li>\n      <li>Suffix: <code class=\"language-plaintext highlighter-rouge\">return a + b</code></li>\n      <li>Middle: <code class=\"language-plaintext highlighter-rouge\">[body placeholder]</code></li>\n    </ul>\n  </li>\n  <li>The input to the model during training would look like:</li>\n</ul>\n<ul>\n      <li>Prefix: <code class=\"language-plaintext highlighter-rouge\">def add_numbers(a, b):</code></li>\n      <li>Suffix: <code class=\"language-plaintext highlighter-rouge\">return a + b</code></li>\n      <li>Middle: <code class=\"language-plaintext highlighter-rouge\">[body placeholder]</code></li>\n    </ul>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code15\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code15\">def add_numbers(a, b): [MASK] return result\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code15\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code15\">def add_numbers(a, b): [MASK] return result\n</code></pre>\n<ul>\n  <li>The model needs to predict the masked middle part, which might be an indentation followed by the main logic, such as:\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code16\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code16\">  result = a + b\n</code></pre></div>    </div>\n  </li>\n  <li>During training, the model is penalized for the difference between its predicted tokens for the middle section and the actual tokens.</li>\n  <li>By incorporating this FIM objective into the loss function, the model learns to generate code that coherently fits within the given context, improving its ability to handle tasks where code needs to be inserted or completed in the middle of existing code blocks.</li>\n</ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code16\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code16\">  result = a + b\n</code></pre>",
      "contentMarkdown": "*   The implementation of “Fill-in-the-middle” (FIM) as a pre-training task in the loss function involves designing the training process to predict the missing middle section of a code sequence given the surrounding context (prefix and suffix). Here’s a detailed breakdown of how this can be integrated into the loss function:\n\n#### Implementation of FIM in the Loss Function\n\n1.  **Data Preparation:**\n    *   **Segmenting Code:** For each code snippet in the training data, divide the sequence into three parts: the prefix (beginning of the code), the suffix (end of the code), and the middle section, which is to be predicted.\n    *   **Masking the Middle:** The middle section is replaced with a special mask token that indicates to the model that this part needs to be generated.\n2.  **Model Architecture:**\n    *   **Input Representation:** Concatenate the prefix and suffix, inserting the special mask token where the middle section should be.\n    *   **Contextual Encoding:** The model processes the concatenated input to generate contextual embeddings for the prefix, mask token, and suffix.\n3.  **Prediction Mechanism:**\n    *   **Decoder Input:** The model’s decoder (or the autoregressive part of the transformer) is provided with the context from the encoder and the mask token to generate the middle section.\n    *   **Sequence Generation:** The model generates tokens sequentially for the middle section, leveraging the contextual information from both the prefix and suffix.\n4.  **Loss Function Design:**\n    *   **Cross-Entropy Loss:** The primary loss function used is typically the cross-entropy loss, which measures the difference between the predicted tokens and the actual tokens in the middle section.\n    *   **Masked Tokens Loss Calculation:** Only the positions corresponding to the middle section are considered for the loss calculation. The loss is computed by comparing the predicted tokens with the actual tokens in the masked middle section.\n\n*   **Segmenting Code:** For each code snippet in the training data, divide the sequence into three parts: the prefix (beginning of the code), the suffix (end of the code), and the middle section, which is to be predicted.\n*   **Masking the Middle:** The middle section is replaced with a special mask token that indicates to the model that this part needs to be generated.\n\n*   **Input Representation:** Concatenate the prefix and suffix, inserting the special mask token where the middle section should be.\n*   **Contextual Encoding:** The model processes the concatenated input to generate contextual embeddings for the prefix, mask token, and suffix.\n\n*   **Decoder Input:** The model’s decoder (or the autoregressive part of the transformer) is provided with the context from the encoder and the mask token to generate the middle section.\n*   **Sequence Generation:** The model generates tokens sequentially for the middle section, leveraging the contextual information from both the prefix and suffix.\n\n*   **Cross-Entropy Loss:** The primary loss function used is typically the cross-entropy loss, which measures the difference between the predicted tokens and the actual tokens in the middle section.\n*   **Masked Tokens Loss Calculation:** Only the positions corresponding to the middle section are considered for the loss calculation. The loss is computed by comparing the predicted tokens with the actual tokens in the masked middle section.\n\n#### Detailed Steps for Loss Calculation\n\n1.  **Token-Level Prediction:**\n    *   For each token position in the middle section, the model outputs a probability distribution over the vocabulary.\n    *   Let ytrueytruey\\_{true} be the actual token and ypredypredy\\_{pred} be the predicted probability distribution for a given position in the middle section.\n2.  **Cross-Entropy Loss for Each Token:**\n    *   The cross-entropy loss for a single token position iii is calculated as: Lossi\\=−logP(ytrue,i|context)Lossi\\=−log⁡P(ytrue,i|context)\\\\text{Loss}\\_i = -\\\\log P(y\\_{true,i} | \\\\text{context}) where P(ytrue,i|context)P(ytrue,i|context)P(y\\_{true,i} | \\\\text{context}) is the predicted probability of the true token ytrue,iytrue,iy\\_{true,i} given the context (prefix and suffix).\n3.  **Aggregate Loss:**\n    *   The total loss for a single training example is the sum of the cross-entropy losses for all token positions in the middle section: Total Loss\\=∑i∈middleLossiTotal Loss\\=∑i∈middleLossi\\\\text{Total Loss} = \\\\sum\\_{i \\\\in \\\\text{middle}} \\\\text{Loss}\\_i\n4.  **Batch Loss:**\n    *   The loss is averaged over all training examples in the batch to obtain the final loss used for backpropagation: Batch Loss\\=1N∑Nj\\=1Total LossjBatch Loss\\=1N∑j\\=1NTotal Lossj\\\\text{Batch Loss} = \\\\frac{1}{N} \\\\sum\\_{j=1}^N \\\\text{Total Loss}\\_j where NNN is the number of training examples in the batch and Total LossjTotal Lossj\\\\text{Total Loss}\\_j is the total loss for the jjj\\-th example.\n\n*   For each token position in the middle section, the model outputs a probability distribution over the vocabulary.\n*   Let ytrueytruey\\_{true} be the actual token and ypredypredy\\_{pred} be the predicted probability distribution for a given position in the middle section.\n\n*   The cross-entropy loss for a single token position iii is calculated as: Lossi\\=−logP(ytrue,i|context)Lossi\\=−log⁡P(ytrue,i|context)\\\\text{Loss}\\_i = -\\\\log P(y\\_{true,i} | \\\\text{context}) where P(ytrue,i|context)P(ytrue,i|context)P(y\\_{true,i} | \\\\text{context}) is the predicted probability of the true token ytrue,iytrue,iy\\_{true,i} given the context (prefix and suffix).\n\n*   The total loss for a single training example is the sum of the cross-entropy losses for all token positions in the middle section: Total Loss\\=∑i∈middleLossiTotal Loss\\=∑i∈middleLossi\\\\text{Total Loss} = \\\\sum\\_{i \\\\in \\\\text{middle}} \\\\text{Loss}\\_i\n\n*   The loss is averaged over all training examples in the batch to obtain the final loss used for backpropagation: Batch Loss\\=1N∑Nj\\=1Total LossjBatch Loss\\=1N∑j\\=1NTotal Lossj\\\\text{Batch Loss} = \\\\frac{1}{N} \\\\sum\\_{j=1}^N \\\\text{Total Loss}\\_j where NNN is the number of training examples in the batch and Total LossjTotal Lossj\\\\text{Total Loss}\\_j is the total loss for the jjj\\-th example.\n\n#### Practical Example\n\n*   Assume a code snippet is split as follows:\n    *   Prefix: `def add_numbers(a, b):`\n    *   Suffix: `return a + b`\n    *   Middle: `[body placeholder]`\n*   The input to the model during training would look like:\n\n*   Prefix: `def add_numbers(a, b):`\n*   Suffix: `return a + b`\n*   Middle: `[body placeholder]`\n\n![](https://aman.ai/images/copy.png)\n\n`def add_numbers(a, b): [MASK] return result`\n\n![](https://aman.ai/images/copy.png)\n\n`def add_numbers(a, b): [MASK] return result`\n\n*   The model needs to predict the masked middle part, which might be an indentation followed by the main logic, such as:\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `result = a + b`\n    \n*   During training, the model is penalized for the difference between its predicted tokens for the middle section and the actual tokens.\n*   By incorporating this FIM objective into the loss function, the model learns to generate code that coherently fits within the given context, improving its ability to handle tasks where code needs to be inserted or completed in the middle of existing code blocks.\n\n![](https://aman.ai/images/copy.png)\n\n  `result = a + b`",
      "order": 214,
      "orderInChapter": 15,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "transformer",
        "embedding",
        "backpropagation",
        "loss function"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": true,
        "hasImages": true,
        "wordCount": 1033,
        "contentLength": 72034
      },
      "nextCards": [
        "ai-interview-for-a-rag-pipeline-aimed-at-a-code-generation-use--215",
        "ai-interview-for-a-rag-pipeline-aimed-at-a-sql-generation-use-c-216"
      ],
      "relatedCards": [
        "ai-loss-multiple-negative-ranking-loss-16",
        "ai-GeminiEmbedding-training-objective-contrastive-nce-with-in-batch-n-4",
        "ai-vision-language-models-clip-9",
        "ai-diffusion-models-implementing-the-original-paper-34",
        "ai-gpt4o-native-image-generation-diffusion-specific-training-behavior-21"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-are-code-llms-trained-with-the-“fill-in-the-middle”-pre-training-task?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-for-a-rag-pipeline-aimed-at-a-code-generation-use--215",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "For a RAG Pipeline Aimed at a Code Generation Use-case, What is Typically Chunked and Retrieved for the RAG Aspect?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>In a RAG (Retrieval-Augmented Generation) pipeline for code generation, the chunks that are typically retrieved and used can vary depending on the specific use-case and the granularity required. However, the most common chunks include:</li>\n</ul>\n<h4 id=\"code-snippets\">Code Snippets</h4>\n<ul>\n  <li><strong>Code Segments:</strong>\n    <ul>\n      <li>Short, reusable pieces of code that solve specific problems or perform certain functions. These can be function definitions, loops, conditionals, or smaller logic blocks.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code17\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code17\">  <span class=\"k\">def</span> <span class=\"nf\">add_numbers</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n      <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Short, reusable pieces of code that solve specific problems or perform certain functions. These can be function definitions, loops, conditionals, or smaller logic blocks.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code17\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code17\">  <span class=\"k\">def</span> <span class=\"nf\">add_numbers</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n      <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n</code></pre>\n<h4 id=\"code-templates\">Code Templates</h4>\n<ul>\n  <li><strong>Code Patterns:</strong>\n    <ul>\n      <li>More extensive templates that provide a skeleton or structure for common coding tasks. These templates can include boilerplate code for setting up frameworks, classes, or entire scripts.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code18\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code18\">  <span class=\"k\">class</span> <span class=\"nc\">MyClass</span><span class=\"p\">:</span>\n      <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">param</span><span class=\"p\">):</span>\n          <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">param</span> <span class=\"o\">=</span> <span class=\"n\">param</span>\n\t    \n      <span class=\"k\">def</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n          <span class=\"k\">pass</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>More extensive templates that provide a skeleton or structure for common coding tasks. These templates can include boilerplate code for setting up frameworks, classes, or entire scripts.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code18\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code18\">  <span class=\"k\">class</span> <span class=\"nc\">MyClass</span><span class=\"p\">:</span>\n      <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">param</span><span class=\"p\">):</span>\n          <span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">param</span> <span class=\"o\">=</span> <span class=\"n\">param</span>\n\t    \n      <span class=\"k\">def</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n          <span class=\"k\">pass</span>\n</code></pre>\n<h4 id=\"documentation-and-comments\">Documentation and Comments</h4>\n<ul>\n  <li><strong>API Documentation:</strong>\n    <ul>\n      <li>Relevant parts of documentation that describe how to use specific functions, classes, or libraries. This can include usage examples, parameter descriptions, and return values.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n  ```plaintext\n  Function: add_numbers(a, b)\n    <ul>\n      <li>Adds two numbers and returns the result.</li>\n      <li>Parameters:\n        <ul>\n          <li>a: int or float, the first number</li>\n          <li>b: int or float, the second number</li>\n        </ul>\n      </li>\n      <li>Returns:\n        <ul>\n          <li>int or float, the sum of a and b\n```</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Relevant parts of documentation that describe how to use specific functions, classes, or libraries. This can include usage examples, parameter descriptions, and return values.</li>\n    </ul>\n<ul>\n      <li>Adds two numbers and returns the result.</li>\n      <li>Parameters:\n        <ul>\n          <li>a: int or float, the first number</li>\n          <li>b: int or float, the second number</li>\n        </ul>\n      </li>\n      <li>Returns:\n        <ul>\n          <li>int or float, the sum of a and b\n```</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>a: int or float, the first number</li>\n          <li>b: int or float, the second number</li>\n        </ul>\n<ul>\n          <li>int or float, the sum of a and b\n```</li>\n        </ul>\n<h4 id=\"stack-overflow-and-forum-posts\">Stack Overflow and Forum Posts</h4>\n<p><strong>Q&amp;A Snippets:</strong></p>\n<ul>\n  <li>Excerpts from question-and-answer sites like Stack Overflow, where similar problems have been discussed and solved. These snippets often include practical solutions and discussions about best practices.</li>\n</ul>\n<p><strong>Example:</strong></p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code19\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code19\">Q: How can I sum two numbers in Python?\nA: You can use the simple addition operator:\n```python\nresult = a + b\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code19\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code19\">Q: How can I sum two numbers in Python?\nA: You can use the simple addition operator:\n```python\nresult = a + b\n</code></pre>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code20\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code20\">\n### 5. Code Comments and Explanations\n**Inline Comments:**\n- Comments within code that explain the purpose and logic of specific lines or blocks. These are crucial for understanding and modifying the code.\n\n**Example:**\n```python\ndef add_numbers(a, b):\n    # This function takes two numbers and returns their sum\n    return a + b\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code20\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code20\">\n### 5. Code Comments and Explanations\n**Inline Comments:**\n- Comments within code that explain the purpose and logic of specific lines or blocks. These are crucial for understanding and modifying the code.\n\n**Example:**\n```python\ndef add_numbers(a, b):\n    # This function takes two numbers and returns their sum\n    return a + b\n</code></pre>\n<h4 id=\"configuration-and-setup-files\">Configuration and Setup Files</h4>\n<ul>\n  <li><strong>Config Files:</strong>\n    <ul>\n      <li>Examples of configuration files (e.g., JSON, YAML) and setup scripts that are commonly used in specific environments or projects.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-json highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code21\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code21\"><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"nl\">\"setting1\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"value1\"</span><span class=\"p\">,</span><span class=\"w\">\n    </span><span class=\"nl\">\"setting2\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"value2\"</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Examples of configuration files (e.g., JSON, YAML) and setup scripts that are commonly used in specific environments or projects.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code21\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code21\"><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"nl\">\"setting1\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"value1\"</span><span class=\"p\">,</span><span class=\"w\">\n    </span><span class=\"nl\">\"setting2\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"value2\"</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre>\n<h4 id=\"chunking-strategy\">Chunking Strategy</h4>\n<ul>\n  <li>\n    <p>The chunking strategy typically involves:</p>\n\n    <ul>\n      <li><strong>Granularity:</strong>\n        <ul>\n          <li>Splitting the code and associated text into logical and functional units that can be independently retrieved and recombined.</li>\n        </ul>\n      </li>\n      <li><strong>Context Preservation:</strong>\n        <ul>\n          <li>Ensuring that each chunk retains enough context to be meaningful when retrieved. This might involve including preceding and following lines of code or associated documentation.</li>\n        </ul>\n      </li>\n      <li><strong>Indexing:</strong>\n        <ul>\n          <li>Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<p>The chunking strategy typically involves:</p>\n<ul>\n      <li><strong>Granularity:</strong>\n        <ul>\n          <li>Splitting the code and associated text into logical and functional units that can be independently retrieved and recombined.</li>\n        </ul>\n      </li>\n      <li><strong>Context Preservation:</strong>\n        <ul>\n          <li>Ensuring that each chunk retains enough context to be meaningful when retrieved. This might involve including preceding and following lines of code or associated documentation.</li>\n        </ul>\n      </li>\n      <li><strong>Indexing:</strong>\n        <ul>\n          <li>Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.</li>\n        </ul>\n      </li>\n    </ul>\n<ul>\n          <li>Splitting the code and associated text into logical and functional units that can be independently retrieved and recombined.</li>\n        </ul>\n<ul>\n          <li>Ensuring that each chunk retains enough context to be meaningful when retrieved. This might involve including preceding and following lines of code or associated documentation.</li>\n        </ul>\n<ul>\n          <li>Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.</li>\n        </ul>\n<h4 id=\"example-rag-workflow\">Example RAG Workflow</h4>\n<ol>\n  <li><strong>Query Input:</strong>\n    <ul>\n      <li>A user inputs a query or a partial code snippet.</li>\n    </ul>\n  </li>\n  <li><strong>Retrieval:</strong>\n    <ul>\n      <li>The system uses the retrieval model to fetch relevant code snippets, templates, documentation, and comments from the indexed chunks.</li>\n    </ul>\n  </li>\n  <li><strong>Generation:</strong>\n    <ul>\n      <li>The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate code snippet.</li>\n    </ul>\n  </li>\n  <li><strong>Output:</strong>\n    <ul>\n      <li>The final code generation is presented to the user, combining the retrieved information and newly generated content.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>A user inputs a query or a partial code snippet.</li>\n    </ul>\n<ul>\n      <li>The system uses the retrieval model to fetch relevant code snippets, templates, documentation, and comments from the indexed chunks.</li>\n    </ul>\n<ul>\n      <li>The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate code snippet.</li>\n    </ul>\n<ul>\n      <li>The final code generation is presented to the user, combining the retrieved information and newly generated content.</li>\n    </ul>\n<ul>\n  <li>By chunking and retrieving these various types of information, the RAG pipeline can provide highly relevant and context-aware code generation assistance.</li>\n</ul>",
      "contentMarkdown": "*   In a RAG (Retrieval-Augmented Generation) pipeline for code generation, the chunks that are typically retrieved and used can vary depending on the specific use-case and the granularity required. However, the most common chunks include:\n\n#### Code Snippets\n\n*   **Code Segments:**\n    *   Short, reusable pieces of code that solve specific problems or perform certain functions. These can be function definitions, loops, conditionals, or smaller logic blocks.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `def add_numbers(a, b):       return a + b`\n    \n\n*   Short, reusable pieces of code that solve specific problems or perform certain functions. These can be function definitions, loops, conditionals, or smaller logic blocks.\n\n![](https://aman.ai/images/copy.png)\n\n  `def add_numbers(a, b):       return a + b`\n\n#### Code Templates\n\n*   **Code Patterns:**\n    *   More extensive templates that provide a skeleton or structure for common coding tasks. These templates can include boilerplate code for setting up frameworks, classes, or entire scripts.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `class MyClass:       def __init__(self, param):           self.param = param \t           def method(self):           pass`\n    \n\n*   More extensive templates that provide a skeleton or structure for common coding tasks. These templates can include boilerplate code for setting up frameworks, classes, or entire scripts.\n\n![](https://aman.ai/images/copy.png)\n\n  `class MyClass:       def __init__(self, param):           self.param = param \t           def method(self):           pass`\n\n#### Documentation and Comments\n\n*   **API Documentation:**\n    *   Relevant parts of documentation that describe how to use specific functions, classes, or libraries. This can include usage examples, parameter descriptions, and return values.\n*   **Example:** \\`\\`\\`plaintext Function: add\\_numbers(a, b)\n    *   Adds two numbers and returns the result.\n    *   Parameters:\n        *   a: int or float, the first number\n        *   b: int or float, the second number\n    *   Returns:\n        *   int or float, the sum of a and b \\`\\`\\`\n\n*   Relevant parts of documentation that describe how to use specific functions, classes, or libraries. This can include usage examples, parameter descriptions, and return values.\n\n*   Adds two numbers and returns the result.\n*   Parameters:\n    *   a: int or float, the first number\n    *   b: int or float, the second number\n*   Returns:\n    *   int or float, the sum of a and b \\`\\`\\`\n\n*   a: int or float, the first number\n*   b: int or float, the second number\n\n*   int or float, the sum of a and b \\`\\`\\`\n\n#### Stack Overflow and Forum Posts\n\n**Q&A Snippets:**\n\n*   Excerpts from question-and-answer sites like Stack Overflow, where similar problems have been discussed and solved. These snippets often include practical solutions and discussions about best practices.\n\n**Example:**\n\n![](https://aman.ai/images/copy.png)\n\n`Q: How can I sum two numbers in Python? A: You can use the simple addition operator: ```python result = a + b`\n\n![](https://aman.ai/images/copy.png)\n\n`Q: How can I sum two numbers in Python? A: You can use the simple addition operator: ```python result = a + b`\n\n![](https://aman.ai/images/copy.png)\n\n`### 5. Code Comments and Explanations **Inline Comments:** - Comments within code that explain the purpose and logic of specific lines or blocks. These are crucial for understanding and modifying the code.  **Example:** ```python def add_numbers(a, b):     # This function takes two numbers and returns their sum     return a + b`\n\n![](https://aman.ai/images/copy.png)\n\n`### 5. Code Comments and Explanations **Inline Comments:** - Comments within code that explain the purpose and logic of specific lines or blocks. These are crucial for understanding and modifying the code.  **Example:** ```python def add_numbers(a, b):     # This function takes two numbers and returns their sum     return a + b`\n\n#### Configuration and Setup Files\n\n*   **Config Files:**\n    *   Examples of configuration files (e.g., JSON, YAML) and setup scripts that are commonly used in specific environments or projects.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `{     \"setting1\": \"value1\",     \"setting2\": \"value2\"   }`\n    \n\n*   Examples of configuration files (e.g., JSON, YAML) and setup scripts that are commonly used in specific environments or projects.\n\n![](https://aman.ai/images/copy.png)\n\n  `{     \"setting1\": \"value1\",     \"setting2\": \"value2\"   }`\n\n#### Chunking Strategy\n\n*   The chunking strategy typically involves:\n    \n    *   **Granularity:**\n        *   Splitting the code and associated text into logical and functional units that can be independently retrieved and recombined.\n    *   **Context Preservation:**\n        *   Ensuring that each chunk retains enough context to be meaningful when retrieved. This might involve including preceding and following lines of code or associated documentation.\n    *   **Indexing:**\n        *   Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.\n\nThe chunking strategy typically involves:\n\n*   **Granularity:**\n    *   Splitting the code and associated text into logical and functional units that can be independently retrieved and recombined.\n*   **Context Preservation:**\n    *   Ensuring that each chunk retains enough context to be meaningful when retrieved. This might involve including preceding and following lines of code or associated documentation.\n*   **Indexing:**\n    *   Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.\n\n*   Splitting the code and associated text into logical and functional units that can be independently retrieved and recombined.\n\n*   Ensuring that each chunk retains enough context to be meaningful when retrieved. This might involve including preceding and following lines of code or associated documentation.\n\n*   Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.\n\n#### Example RAG Workflow\n\n1.  **Query Input:**\n    *   A user inputs a query or a partial code snippet.\n2.  **Retrieval:**\n    *   The system uses the retrieval model to fetch relevant code snippets, templates, documentation, and comments from the indexed chunks.\n3.  **Generation:**\n    *   The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate code snippet.\n4.  **Output:**\n    *   The final code generation is presented to the user, combining the retrieved information and newly generated content.\n\n*   A user inputs a query or a partial code snippet.\n\n*   The system uses the retrieval model to fetch relevant code snippets, templates, documentation, and comments from the indexed chunks.\n\n*   The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate code snippet.\n\n*   The final code generation is presented to the user, combining the retrieved information and newly generated content.\n\n*   By chunking and retrieving these various types of information, the RAG pipeline can provide highly relevant and context-aware code generation assistance.",
      "order": 215,
      "orderInChapter": 16,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 1030,
        "contentLength": 14564
      },
      "nextCards": [
        "ai-interview-for-a-rag-pipeline-aimed-at-a-sql-generation-use-c-216",
        "ai-interview-how-is-logistic-regression-a-linear-model-if-the-s-217"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#for-a-rag-pipeline-aimed-at-a-code-generation-use-case,-what-is-typically-chunked-and-retrieved-for-the-rag-aspect?",
      "scrapedAt": "2025-12-28T11:58:12.845Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-for-a-rag-pipeline-aimed-at-a-sql-generation-use-c-216",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "For a RAG Pipeline Aimed at a SQL Generation Use-case, What is Typically Chunked and Retrieved for the RAG Aspect?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>For a RAG (Retrieval-Augmented Generation) pipeline aimed at SQL generation, the chunks that are typically retrieved can include a variety of SQL-related components. These chunks help in understanding the context, structure, and specifics of SQL queries. Here are the primary types of chunks:</li>\n</ul>\n<h4 id=\"sql-queries\">SQL Queries</h4>\n<ul>\n  <li><strong>Common Queries:</strong>\n    <ul>\n      <li>Frequently used SQL queries that cover standard operations such as SELECT, INSERT, UPDATE, DELETE, JOIN, and aggregate functions.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code22\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code22\">  <span class=\"k\">SELECT</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">age</span> <span class=\"k\">FROM</span> <span class=\"n\">users</span> <span class=\"k\">WHERE</span> <span class=\"n\">age</span> <span class=\"o\">&gt;</span> <span class=\"mi\">30</span><span class=\"p\">;</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Frequently used SQL queries that cover standard operations such as SELECT, INSERT, UPDATE, DELETE, JOIN, and aggregate functions.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code22\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code22\">  <span class=\"k\">SELECT</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">age</span> <span class=\"k\">FROM</span> <span class=\"n\">users</span> <span class=\"k\">WHERE</span> <span class=\"n\">age</span> <span class=\"o\">&gt;</span> <span class=\"mi\">30</span><span class=\"p\">;</span>\n</code></pre>\n<h4 id=\"query-templates\">Query Templates</h4>\n<ul>\n  <li><strong>Parameterized Templates:</strong>\n    <ul>\n      <li>Reusable query structures that can be easily adapted to different tables and columns. These templates often include placeholders for dynamic content.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code23\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code23\">  <span class=\"k\">SELECT</span> <span class=\"p\">{</span><span class=\"n\">columns</span><span class=\"p\">}</span> <span class=\"k\">FROM</span> <span class=\"p\">{</span><span class=\"k\">table</span><span class=\"p\">}</span> <span class=\"k\">WHERE</span> <span class=\"p\">{</span><span class=\"n\">condition</span><span class=\"p\">};</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Reusable query structures that can be easily adapted to different tables and columns. These templates often include placeholders for dynamic content.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code23\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code23\">  <span class=\"k\">SELECT</span> <span class=\"p\">{</span><span class=\"n\">columns</span><span class=\"p\">}</span> <span class=\"k\">FROM</span> <span class=\"p\">{</span><span class=\"k\">table</span><span class=\"p\">}</span> <span class=\"k\">WHERE</span> <span class=\"p\">{</span><span class=\"n\">condition</span><span class=\"p\">};</span>\n</code></pre>\n<h4 id=\"database-schema-information\">Database Schema Information</h4>\n<ul>\n  <li><strong>Table Definitions:</strong>\n    <ul>\n      <li>Definitions of database schemas, including table structures, column names, data types, constraints, and relationships between tables.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code24\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code24\">  Table: users\n  Columns: id (INT, PRIMARY KEY), name (VARCHAR), age (INT), email (VARCHAR)\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Definitions of database schemas, including table structures, column names, data types, constraints, and relationships between tables.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code24\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code24\">  Table: users\n  Columns: id (INT, PRIMARY KEY), name (VARCHAR), age (INT), email (VARCHAR)\n</code></pre>\n<h4 id=\"sql-functions-and-procedures\">SQL Functions and Procedures</h4>\n<ul>\n  <li><strong>Stored Procedures:</strong>\n    <ul>\n      <li>Examples of stored procedures and functions that perform specific tasks within the database. These can be particularly useful for complex operations.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code25\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code25\">  <span class=\"k\">CREATE</span> <span class=\"k\">PROCEDURE</span> <span class=\"n\">GetUserAge</span> <span class=\"p\">(</span><span class=\"k\">IN</span> <span class=\"n\">userId</span> <span class=\"nb\">INT</span><span class=\"p\">)</span>\n  <span class=\"k\">BEGIN</span>\n      <span class=\"k\">SELECT</span> <span class=\"n\">age</span> <span class=\"k\">FROM</span> <span class=\"n\">users</span> <span class=\"k\">WHERE</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">userId</span><span class=\"p\">;</span>\n  <span class=\"k\">END</span><span class=\"p\">;</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Examples of stored procedures and functions that perform specific tasks within the database. These can be particularly useful for complex operations.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code25\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code25\">  <span class=\"k\">CREATE</span> <span class=\"k\">PROCEDURE</span> <span class=\"n\">GetUserAge</span> <span class=\"p\">(</span><span class=\"k\">IN</span> <span class=\"n\">userId</span> <span class=\"nb\">INT</span><span class=\"p\">)</span>\n  <span class=\"k\">BEGIN</span>\n      <span class=\"k\">SELECT</span> <span class=\"n\">age</span> <span class=\"k\">FROM</span> <span class=\"n\">users</span> <span class=\"k\">WHERE</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">userId</span><span class=\"p\">;</span>\n  <span class=\"k\">END</span><span class=\"p\">;</span>\n</code></pre>\n<h4 id=\"sql-documentation-and-best-practices\">SQL Documentation and Best Practices</h4>\n<ul>\n  <li><strong>Guidelines:</strong>\n    <ul>\n      <li>Documentation snippets and best practices for writing efficient and secure SQL queries. This includes indexing strategies, query optimization tips, and security considerations.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code26\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code26\">  To optimize SELECT queries, ensure that frequently queried columns are indexed.\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Documentation snippets and best practices for writing efficient and secure SQL queries. This includes indexing strategies, query optimization tips, and security considerations.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code26\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code26\">  To optimize SELECT queries, ensure that frequently queried columns are indexed.\n</code></pre>\n<h4 id=\"query-optimization-techniques\">Query Optimization Techniques</h4>\n<ul>\n  <li><strong>Performance Tips:</strong>\n    <ul>\n      <li>Explanations and examples of how to optimize SQL queries for better performance, including the use of indexes, query restructuring, and avoiding common pitfalls.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code27\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code27\">  Use INNER JOIN instead of subqueries for better performance.\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Explanations and examples of how to optimize SQL queries for better performance, including the use of indexes, query restructuring, and avoiding common pitfalls.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code27\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code27\">  Use INNER JOIN instead of subqueries for better performance.\n</code></pre>\n<h4 id=\"example-use-cases-and-query-patterns\">Example Use-Cases and Query Patterns</h4>\n<ul>\n  <li><strong>Use-Case Specific Queries:</strong>\n    <ul>\n      <li>Example queries tailored to specific use-cases such as reporting, data analysis, user management, etc. These provide practical examples that can be adapted to similar scenarios.</li>\n    </ul>\n  </li>\n  <li><strong>Example:</strong>\n    <div class=\"language-sql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code28\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code28\">  <span class=\"k\">SELECT</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">FROM</span> <span class=\"n\">orders</span> <span class=\"k\">WHERE</span> <span class=\"n\">order_date</span> <span class=\"k\">BETWEEN</span> <span class=\"s1\">'2023-01-01'</span> <span class=\"k\">AND</span> <span class=\"s1\">'2023-12-31'</span><span class=\"p\">;</span>\n</code></pre></div>    </div>\n  </li>\n</ul>\n<ul>\n      <li>Example queries tailored to specific use-cases such as reporting, data analysis, user management, etc. These provide practical examples that can be adapted to similar scenarios.</li>\n    </ul>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code28\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code28\">  <span class=\"k\">SELECT</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">FROM</span> <span class=\"n\">orders</span> <span class=\"k\">WHERE</span> <span class=\"n\">order_date</span> <span class=\"k\">BETWEEN</span> <span class=\"s1\">'2023-01-01'</span> <span class=\"k\">AND</span> <span class=\"s1\">'2023-12-31'</span><span class=\"p\">;</span>\n</code></pre>\n<h4 id=\"chunking-strategy-1\">Chunking Strategy</h4>\n<ul>\n  <li>\n    <p>The chunking strategy for SQL generation typically involves:</p>\n\n    <ul>\n      <li>\n        <p><strong>Granularity:</strong> Breaking down the SQL queries and related information into logical units that can be retrieved and recombined. This might include individual clauses (e.g., SELECT, FROM, WHERE), complete queries, and schema definitions.</p>\n      </li>\n      <li>\n        <p><strong>Context Preservation:</strong> Ensuring that each chunk retains enough context to be meaningful. For instance, a WHERE clause chunk should include references to the table and columns it applies to.</p>\n      </li>\n      <li>\n        <p><strong>Indexing:</strong> Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.</p>\n      </li>\n    </ul>\n  </li>\n</ul>\n<p>The chunking strategy for SQL generation typically involves:</p>\n<ul>\n      <li>\n        <p><strong>Granularity:</strong> Breaking down the SQL queries and related information into logical units that can be retrieved and recombined. This might include individual clauses (e.g., SELECT, FROM, WHERE), complete queries, and schema definitions.</p>\n      </li>\n      <li>\n        <p><strong>Context Preservation:</strong> Ensuring that each chunk retains enough context to be meaningful. For instance, a WHERE clause chunk should include references to the table and columns it applies to.</p>\n      </li>\n      <li>\n        <p><strong>Indexing:</strong> Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.</p>\n      </li>\n    </ul>\n<p><strong>Granularity:</strong> Breaking down the SQL queries and related information into logical units that can be retrieved and recombined. This might include individual clauses (e.g., SELECT, FROM, WHERE), complete queries, and schema definitions.</p>\n<p><strong>Context Preservation:</strong> Ensuring that each chunk retains enough context to be meaningful. For instance, a WHERE clause chunk should include references to the table and columns it applies to.</p>\n<p><strong>Indexing:</strong> Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.</p>\n<h4 id=\"example-rag-workflow-for-sql-generation\">Example RAG Workflow for SQL Generation</h4>\n<ol>\n  <li><strong>Query Input:</strong>\n    <ul>\n      <li>A user inputs a natural language query or a partial SQL statement.</li>\n    </ul>\n  </li>\n  <li><strong>Retrieval:</strong>\n    <ul>\n      <li>The system uses the retrieval model to fetch relevant SQL queries, templates, schema information, and documentation from the indexed chunks.</li>\n    </ul>\n  </li>\n  <li><strong>Generation:</strong>\n    <ul>\n      <li>The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate SQL query.</li>\n    </ul>\n  </li>\n  <li><strong>Output:</strong>\n    <ul>\n      <li>The final SQL query is presented to the user, combining the retrieved information and newly generated content.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>A user inputs a natural language query or a partial SQL statement.</li>\n    </ul>\n<ul>\n      <li>The system uses the retrieval model to fetch relevant SQL queries, templates, schema information, and documentation from the indexed chunks.</li>\n    </ul>\n<ul>\n      <li>The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate SQL query.</li>\n    </ul>\n<ul>\n      <li>The final SQL query is presented to the user, combining the retrieved information and newly generated content.</li>\n    </ul>\n<ul>\n  <li>By chunking and retrieving these various types of SQL-related information, the RAG pipeline can provide highly relevant and context-aware SQL query generation assistance, helping users to write efficient and accurate queries tailored to their specific needs.</li>\n</ul>",
      "contentMarkdown": "*   For a RAG (Retrieval-Augmented Generation) pipeline aimed at SQL generation, the chunks that are typically retrieved can include a variety of SQL-related components. These chunks help in understanding the context, structure, and specifics of SQL queries. Here are the primary types of chunks:\n\n#### SQL Queries\n\n*   **Common Queries:**\n    *   Frequently used SQL queries that cover standard operations such as SELECT, INSERT, UPDATE, DELETE, JOIN, and aggregate functions.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `SELECT name, age FROM users WHERE age > 30;`\n    \n\n*   Frequently used SQL queries that cover standard operations such as SELECT, INSERT, UPDATE, DELETE, JOIN, and aggregate functions.\n\n![](https://aman.ai/images/copy.png)\n\n  `SELECT name, age FROM users WHERE age > 30;`\n\n#### Query Templates\n\n*   **Parameterized Templates:**\n    *   Reusable query structures that can be easily adapted to different tables and columns. These templates often include placeholders for dynamic content.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `SELECT {columns} FROM {table} WHERE {condition};`\n    \n\n*   Reusable query structures that can be easily adapted to different tables and columns. These templates often include placeholders for dynamic content.\n\n![](https://aman.ai/images/copy.png)\n\n  `SELECT {columns} FROM {table} WHERE {condition};`\n\n#### Database Schema Information\n\n*   **Table Definitions:**\n    *   Definitions of database schemas, including table structures, column names, data types, constraints, and relationships between tables.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `Table: users   Columns: id (INT, PRIMARY KEY), name (VARCHAR), age (INT), email (VARCHAR)`\n    \n\n*   Definitions of database schemas, including table structures, column names, data types, constraints, and relationships between tables.\n\n![](https://aman.ai/images/copy.png)\n\n  `Table: users   Columns: id (INT, PRIMARY KEY), name (VARCHAR), age (INT), email (VARCHAR)`\n\n#### SQL Functions and Procedures\n\n*   **Stored Procedures:**\n    *   Examples of stored procedures and functions that perform specific tasks within the database. These can be particularly useful for complex operations.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `CREATE PROCEDURE GetUserAge (IN userId INT)   BEGIN       SELECT age FROM users WHERE id = userId;   END;`\n    \n\n*   Examples of stored procedures and functions that perform specific tasks within the database. These can be particularly useful for complex operations.\n\n![](https://aman.ai/images/copy.png)\n\n  `CREATE PROCEDURE GetUserAge (IN userId INT)   BEGIN       SELECT age FROM users WHERE id = userId;   END;`\n\n#### SQL Documentation and Best Practices\n\n*   **Guidelines:**\n    *   Documentation snippets and best practices for writing efficient and secure SQL queries. This includes indexing strategies, query optimization tips, and security considerations.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `To optimize SELECT queries, ensure that frequently queried columns are indexed.`\n    \n\n*   Documentation snippets and best practices for writing efficient and secure SQL queries. This includes indexing strategies, query optimization tips, and security considerations.\n\n![](https://aman.ai/images/copy.png)\n\n  `To optimize SELECT queries, ensure that frequently queried columns are indexed.`\n\n#### Query Optimization Techniques\n\n*   **Performance Tips:**\n    *   Explanations and examples of how to optimize SQL queries for better performance, including the use of indexes, query restructuring, and avoiding common pitfalls.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `Use INNER JOIN instead of subqueries for better performance.`\n    \n\n*   Explanations and examples of how to optimize SQL queries for better performance, including the use of indexes, query restructuring, and avoiding common pitfalls.\n\n![](https://aman.ai/images/copy.png)\n\n  `Use INNER JOIN instead of subqueries for better performance.`\n\n#### Example Use-Cases and Query Patterns\n\n*   **Use-Case Specific Queries:**\n    *   Example queries tailored to specific use-cases such as reporting, data analysis, user management, etc. These provide practical examples that can be adapted to similar scenarios.\n*   **Example:**\n    \n    ![](https://aman.ai/images/copy.png)\n    \n      `SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31';`\n    \n\n*   Example queries tailored to specific use-cases such as reporting, data analysis, user management, etc. These provide practical examples that can be adapted to similar scenarios.\n\n![](https://aman.ai/images/copy.png)\n\n  `SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31';`\n\n#### Chunking Strategy\n\n*   The chunking strategy for SQL generation typically involves:\n    \n    *   **Granularity:** Breaking down the SQL queries and related information into logical units that can be retrieved and recombined. This might include individual clauses (e.g., SELECT, FROM, WHERE), complete queries, and schema definitions.\n        \n    *   **Context Preservation:** Ensuring that each chunk retains enough context to be meaningful. For instance, a WHERE clause chunk should include references to the table and columns it applies to.\n        \n    *   **Indexing:** Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.\n        \n\nThe chunking strategy for SQL generation typically involves:\n\n*   **Granularity:** Breaking down the SQL queries and related information into logical units that can be retrieved and recombined. This might include individual clauses (e.g., SELECT, FROM, WHERE), complete queries, and schema definitions.\n    \n*   **Context Preservation:** Ensuring that each chunk retains enough context to be meaningful. For instance, a WHERE clause chunk should include references to the table and columns it applies to.\n    \n*   **Indexing:** Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.\n    \n\n**Granularity:** Breaking down the SQL queries and related information into logical units that can be retrieved and recombined. This might include individual clauses (e.g., SELECT, FROM, WHERE), complete queries, and schema definitions.\n\n**Context Preservation:** Ensuring that each chunk retains enough context to be meaningful. For instance, a WHERE clause chunk should include references to the table and columns it applies to.\n\n**Indexing:** Indexing these chunks using a search engine (e.g., Elasticsearch) or an approximate nearest neighbor search tool (e.g., FAISS) to facilitate fast and accurate retrieval.\n\n#### Example RAG Workflow for SQL Generation\n\n1.  **Query Input:**\n    *   A user inputs a natural language query or a partial SQL statement.\n2.  **Retrieval:**\n    *   The system uses the retrieval model to fetch relevant SQL queries, templates, schema information, and documentation from the indexed chunks.\n3.  **Generation:**\n    *   The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate SQL query.\n4.  **Output:**\n    *   The final SQL query is presented to the user, combining the retrieved information and newly generated content.\n\n*   A user inputs a natural language query or a partial SQL statement.\n\n*   The system uses the retrieval model to fetch relevant SQL queries, templates, schema information, and documentation from the indexed chunks.\n\n*   The generative model takes the retrieved chunks and the user’s input to generate a complete and contextually appropriate SQL query.\n\n*   The final SQL query is presented to the user, combining the retrieved information and newly generated content.\n\n*   By chunking and retrieving these various types of SQL-related information, the RAG pipeline can provide highly relevant and context-aware SQL query generation assistance, helping users to write efficient and accurate queries tailored to their specific needs.",
      "order": 216,
      "orderInChapter": 17,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice",
        "optimization"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 1061,
        "contentLength": 16648
      },
      "nextCards": [
        "ai-interview-how-is-logistic-regression-a-linear-model-if-the-s-217",
        "ai-interview-how-much-memory-is-needed-to-serve-a-large-languag-218"
      ],
      "relatedCards": [
        "ai-support-vector-machines-model-16",
        "ai-diffusion-models-in-diffusion-models-there-is-a-forward-diffusion-p-44",
        "ai-diffusion-models-diffusion-model-alignment-using-direct-preference--55",
        "ai-diffusion-models-diffusion-model-alignment-using-direct-preference--66",
        "ai-reinforcement-learning-computational-resources-and-scalability-40"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#for-a-rag-pipeline-aimed-at-a-sql-generation-use-case,-what-is-typically-chunked-and-retrieved-for-the-rag-aspect?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-is-logistic-regression-a-linear-model-if-the-s-217",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How is Logistic Regression a Linear Model If the Sigmoid Function is Non-linear?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Logistic regression is considered a linear model, though it incorporates a non-linear function. The linearity in logistic regression refers to the linear relationship between the input features and the log-odds of the outcome, not necessarily the direct relationship between the features and the predicted probability.</li>\n  <li>In logistic regression, the model predicts the probability of an outcome by first calculating a linear combination of the input features, expressed as:</li>\n</ul>\n<div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-184-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>z</mi><mo>=</mo><msub><mi>&amp;#x03B2;</mi><mn>0</mn></msub><mo>+</mo><msub><mi>&amp;#x03B2;</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>&amp;#x03B2;</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mo>&amp;#x22EF;</mo><mo>+</mo><msub><mi>&amp;#x03B2;</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1529\" style=\"width: 16.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 13.44em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.565em, 1013.44em, 2.763em, -999.997em); top: -2.393em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1530\"><span class=\"mi\" id=\"MathJax-Span-1531\" style=\"font-family: STIXGeneral-Italic;\">z</span><span class=\"mo\" id=\"MathJax-Span-1532\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"msubsup\" id=\"MathJax-Span-1533\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.52em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1534\" style=\"font-family: STIXGeneral-Italic;\">β<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mn\" id=\"MathJax-Span-1535\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">0</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1536\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"msubsup\" id=\"MathJax-Span-1537\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.52em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1538\" style=\"font-family: STIXGeneral-Italic;\">β<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mn\" id=\"MathJax-Span-1539\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1540\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1541\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1542\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1543\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"msubsup\" id=\"MathJax-Span-1544\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.52em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1545\" style=\"font-family: STIXGeneral-Italic;\">β<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mn\" id=\"MathJax-Span-1546\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1547\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1548\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mn\" id=\"MathJax-Span-1549\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1550\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mo\" id=\"MathJax-Span-1551\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">⋯</span><span class=\"mo\" id=\"MathJax-Span-1552\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"msubsup\" id=\"MathJax-Span-1553\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.52em, 4.378em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1554\" style=\"font-family: STIXGeneral-Italic;\">β<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.523em;\"><span class=\"mi\" id=\"MathJax-Span-1555\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1556\"><span style=\"display: inline-block; position: relative; width: 0.888em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1557\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1558\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">n</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.398em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>z</mi><mo>=</mo><msub><mi>β</mi><mn>0</mn></msub><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>β</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>β</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></math></span></span></div>\n<ul>\n  <li>This linear combination <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-185-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>z</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1559\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.451em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1560\"><span class=\"mi\" id=\"MathJax-Span-1561\" style=\"font-family: STIXGeneral-Italic;\">z</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.184em; border-left: 0px solid; width: 0px; height: 0.753em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>z</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-185\">z</script> is then passed through a sigmoid function (also known as a logistic function):</li>\n</ul>\n<div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-186-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>sigmoid</mtext><mo stretchy=&quot;false&quot;>(</mo><mi>z</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>z</mi></mrow></msup></mrow></mfrac></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1562\" style=\"width: 10.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 8.857em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.68em, 1008.86em, 3.076em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1563\"><span class=\"mtext\" id=\"MathJax-Span-1564\" style=\"font-family: STIXGeneral-Regular;\">sigmoid</span><span class=\"mo\" id=\"MathJax-Span-1565\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1566\" style=\"font-family: STIXGeneral-Italic;\">z</span><span class=\"mo\" id=\"MathJax-Span-1567\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1568\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1569\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 3.128em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.42em, 4.169em, -999.997em); top: -4.685em; left: 50%; margin-left: -0.258em;\"><span class=\"mn\" id=\"MathJax-Span-1570\" style=\"font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.18em, 1002.97em, 4.221em, -999.997em); top: -3.331em; left: 50%; margin-left: -1.508em;\"><span class=\"mrow\" id=\"MathJax-Span-1571\"><span class=\"mn\" id=\"MathJax-Span-1572\" style=\"font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-1573\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"msubsup\" id=\"MathJax-Span-1574\" style=\"padding-left: 0.263em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1575\" style=\"font-family: STIXGeneral-Italic;\">e</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.32em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-1576\"><span class=\"mrow\" id=\"MathJax-Span-1577\"><span class=\"mo\" id=\"MathJax-Span-1578\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">−</span><span class=\"mi\" id=\"MathJax-Span-1579\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">z</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1003.13em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 3.128em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.934em; border-left: 0px solid; width: 0px; height: 2.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mtext>sigmoid</mtext><mo stretchy=\"false\">(</mo><mi>z</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow class=\"MJX-TeXAtom-ORD\"><mo>−</mo><mi>z</mi></mrow></msup></mrow></mfrac></math></span></span></div>\n<ul>\n  <li>The sigmoid function maps <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-187-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>z</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1580\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.47em, 2.451em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1581\"><span class=\"mi\" id=\"MathJax-Span-1582\" style=\"font-family: STIXGeneral-Italic;\">z</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.184em; border-left: 0px solid; width: 0px; height: 0.753em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>z</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-187\">z</script> to a value between 0 and 1, representing the probability of the outcome. While the sigmoid function is non-linear, logistic regression is still considered a linear model because the key relationship in the model—the relationship between the input features and the log-odds (the logarithm of the odds) of the outcome—is linear.</li>\n  <li>In summary, logistic regression is a linear model with respect to the log-odds, but it uses the non-linear sigmoid function to produce probabilities.</li>\n</ul>",
      "contentMarkdown": "*   Logistic regression is considered a linear model, though it incorporates a non-linear function. The linearity in logistic regression refers to the linear relationship between the input features and the log-odds of the outcome, not necessarily the direct relationship between the features and the predicted probability.\n*   In logistic regression, the model predicts the probability of an outcome by first calculating a linear combination of the input features, expressed as:\n\nz\\=β0+β1x1+β2x2+⋯+βnxnz\\=β0+β1x1+β2x2+⋯+βnxn\n\n*   This linear combination zzz is then passed through a sigmoid function (also known as a logistic function):\n\nsigmoid(z)\\=11+e−zsigmoid(z)\\=11+e−z\n\n*   The sigmoid function maps zzz to a value between 0 and 1, representing the probability of the outcome. While the sigmoid function is non-linear, logistic regression is still considered a linear model because the key relationship in the model—the relationship between the input features and the log-odds (the logarithm of the odds) of the outcome—is linear.\n*   In summary, logistic regression is a linear model with respect to the log-odds, but it uses the non-linear sigmoid function to produce probabilities.",
      "order": 217,
      "orderInChapter": 18,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 171,
        "contentLength": 15874
      },
      "nextCards": [
        "ai-interview-how-much-memory-is-needed-to-serve-a-large-languag-218",
        "ai-interview-what-is-consistent-hashing-in-distributed-systems-219"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-is-logistic-regression-a-linear-model-if-the-sigmoid-function-is-non-linear?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-much-memory-is-needed-to-serve-a-large-languag-218",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Much Memory is Needed to Serve a Large Language Model (LLM)?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Here’s the math behind deploying a model with size <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-188-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1583\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1584\"><span class=\"mi\" id=\"MathJax-Span-1585\" style=\"font-family: STIXGeneral-Italic;\">P</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-188\">P</script>. Here’s a formula that can help you estimate the GPU memory required for serving an LLM:</li>\n</ul>\n<div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-189-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>M</mi><mo>=</mo><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>P</mi><mo>&amp;#x2217;</mo><mn>4</mn><mi>B</mi><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>32</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>Q</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mn>1.2</mn></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1586\" style=\"width: 13.857em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 11.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.409em, 1011.51em, 2.555em, -999.997em); top: -2.237em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1587\"><span class=\"mi\" id=\"MathJax-Span-1588\" style=\"font-family: STIXGeneral-Italic;\">M<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1589\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mo\" id=\"MathJax-Span-1590\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">(</span><span class=\"mo\" id=\"MathJax-Span-1591\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1592\" style=\"font-family: STIXGeneral-Italic;\">P</span><span class=\"mo\" id=\"MathJax-Span-1593\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mn\" id=\"MathJax-Span-1594\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">4</span><span class=\"mi\" id=\"MathJax-Span-1595\" style=\"font-family: STIXGeneral-Italic;\">B</span><span class=\"mo\" id=\"MathJax-Span-1596\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"texatom\" id=\"MathJax-Span-1597\"><span class=\"mrow\" id=\"MathJax-Span-1598\"><span class=\"mo\" id=\"MathJax-Span-1599\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mo\" id=\"MathJax-Span-1600\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mn\" id=\"MathJax-Span-1601\" style=\"font-family: STIXGeneral-Regular;\">32</span><span class=\"texatom\" id=\"MathJax-Span-1602\"><span class=\"mrow\" id=\"MathJax-Span-1603\"><span class=\"mo\" id=\"MathJax-Span-1604\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mi\" id=\"MathJax-Span-1605\" style=\"font-family: STIXGeneral-Italic;\">Q</span><span class=\"mo\" id=\"MathJax-Span-1606\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1607\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1608\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">∗</span><span class=\"mn\" id=\"MathJax-Span-1609\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">1.2</span></span><span style=\"display: inline-block; width: 0px; height: 2.242em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>M</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>P</mi><mo>∗</mo><mn>4</mn><mi>B</mi><mo stretchy=\"false\">)</mo><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mo stretchy=\"false\">(</mo><mn>32</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mi>Q</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>∗</mo><mn>1.2</mn></math></span></span></div>\n<ul>\n  <li>where:\n    <ul>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-190-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1610\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.94em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1611\"><span class=\"mi\" id=\"MathJax-Span-1612\" style=\"font-family: STIXGeneral-Italic;\">M<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>M</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-190\">M</script> is the GPU memory in Gigabytes.</li>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-191-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1613\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1614\"><span class=\"mi\" id=\"MathJax-Span-1615\" style=\"font-family: STIXGeneral-Italic;\">P</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-191\">P</script> is the number of parameters in the model.</li>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-192-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>4</mn><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1616\" style=\"width: 1.409em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1001.15em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1617\"><span class=\"mn\" id=\"MathJax-Span-1618\" style=\"font-family: STIXGeneral-Regular;\">4</span><span class=\"mi\" id=\"MathJax-Span-1619\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-192\">4B</script> represents the 4 bytes used per parameter.</li>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-193-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>Q</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1620\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.73em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1621\"><span class=\"mi\" id=\"MathJax-Span-1622\" style=\"font-family: STIXGeneral-Italic;\">Q</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>Q</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-193\">Q</script> is the number of bits for loading the model.</li>\n      <li>1.2 accounts for a 20% overhead.</li>\n    </ul>\n  </li>\n  <li>This overhead isn’t just a buffer - it’s crucial for additional memory used during inference, such as storing activations (intermediate results) of the model. Along with the model, the input data (i.e., the batch) is also stored in GPU VRAM during inference. Thus, the model’s weights, input batch, and its intermediate activations are all need to fit into GPU VRAM for inference.</li>\n</ul>\n<ul>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-190-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1610\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.94em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1611\"><span class=\"mi\" id=\"MathJax-Span-1612\" style=\"font-family: STIXGeneral-Italic;\">M<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>M</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-190\">M</script> is the GPU memory in Gigabytes.</li>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-191-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1613\" style=\"width: 0.732em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.576em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.58em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1614\"><span class=\"mi\" id=\"MathJax-Span-1615\" style=\"font-family: STIXGeneral-Italic;\">P</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>P</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-191\">P</script> is the number of parameters in the model.</li>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-192-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>4</mn><mi>B</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1616\" style=\"width: 1.409em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.148em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1001.15em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1617\"><span class=\"mn\" id=\"MathJax-Span-1618\" style=\"font-family: STIXGeneral-Regular;\">4</span><span class=\"mi\" id=\"MathJax-Span-1619\" style=\"font-family: STIXGeneral-Italic;\">B</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mn>4</mn><mi>B</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-192\">4B</script> represents the 4 bytes used per parameter.</li>\n      <li><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-193-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>Q</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1620\" style=\"width: 0.888em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.732em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.73em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1621\"><span class=\"mi\" id=\"MathJax-Span-1622\" style=\"font-family: STIXGeneral-Italic;\">Q</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>Q</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-193\">Q</script> is the number of bits for loading the model.</li>\n      <li>1.2 accounts for a 20% overhead.</li>\n    </ul>",
      "contentMarkdown": "*   Here’s the math behind deploying a model with size PPP. Here’s a formula that can help you estimate the GPU memory required for serving an LLM:\n\nM\\=((P∗4B)/(32/Q))∗1.2M\\=((P∗4B)/(32/Q))∗1.2\n\n*   where:\n    *   MMM is the GPU memory in Gigabytes.\n    *   PPP is the number of parameters in the model.\n    *   4B4B4B represents the 4 bytes used per parameter.\n    *   QQQ is the number of bits for loading the model.\n    *   1.2 accounts for a 20% overhead.\n*   This overhead isn’t just a buffer - it’s crucial for additional memory used during inference, such as storing activations (intermediate results) of the model. Along with the model, the input data (i.e., the batch) is also stored in GPU VRAM during inference. Thus, the model’s weights, input batch, and its intermediate activations are all need to fit into GPU VRAM for inference.\n\n*   MMM is the GPU memory in Gigabytes.\n*   PPP is the number of parameters in the model.\n*   4B4B4B represents the 4 bytes used per parameter.\n*   QQQ is the number of bits for loading the model.\n*   1.2 accounts for a 20% overhead.",
      "order": 218,
      "orderInChapter": 19,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "llm",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 183,
        "contentLength": 16192
      },
      "nextCards": [
        "ai-interview-what-is-consistent-hashing-in-distributed-systems-219",
        "ai-interview-what-are-some-load-balancing-algorithms-in-distrib-220"
      ],
      "relatedCards": [
        "ai-distributed-training-parallelism-the-ultra-scale-playbook-training-llms-on-gpu-clus-41",
        "ai-ml-runtimes-implementation-details-5",
        "ai-mixture-of-experts-qmoe-practical-sub-1-bit-compression-of-trillion-p-79",
        "ai-mixture-of-experts-qmoe-practical-sub-1-bit-compression-of-trillion-p-84",
        "ai-mixture-of-experts-jetmoe-reaching-llama2-performance-with-01m-dollar-83"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-much-memory-is-needed-to-serve-a-large-language-model-(llm)?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-consistent-hashing-in-distributed-systems-219",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is Consistent Hashing in Distributed Systems?",
      "subtitle": "Misc",
      "contentHtml": "<h4 id=\"overview\">Overview</h4>\n<ul>\n  <li>Consistent hashing is a key algorithm used in distributed systems to distribute data across multiple nodes in a way that minimizes data reorganization when nodes are added or removed. It is particularly important in systems where nodes can dynamically join or leave, such as in distributed databases, caching systems, and peer-to-peer networks.</li>\n</ul>\n<h4 id=\"problem-with-traditional-hashing\">Problem with Traditional Hashing</h4>\n<ul>\n  <li>In traditional hashing, keys are mapped to a fixed set of buckets (nodes). For instance, if a hash function maps keys to buckets using modulo operation (e.g., <code class=\"language-plaintext highlighter-rouge\">hash(key) % N</code>, where <code class=\"language-plaintext highlighter-rouge\">N</code> is the number of nodes), adding or removing a node requires redistributing all keys across the new set of nodes. This leads to a large amount of data movement, which is inefficient.</li>\n</ul>\n<h4 id=\"how-consistent-hashing-works\">How Consistent Hashing Works</h4>\n<ul>\n  <li>Consistent hashing addresses this problem by mapping both the data keys and the nodes to a virtual circular hash space, often visualized as a ring.</li>\n</ul>\n<ol>\n  <li><strong>Hash Space and Ring:</strong>\n    <ul>\n      <li>The hash space is usually represented as a circle (a “ring”) where the hash function outputs values that can be thought of as points on this ring.</li>\n      <li>Nodes and keys are assigned positions on this ring using the same hash function.</li>\n    </ul>\n  </li>\n  <li><strong>Assigning Keys to Nodes:</strong>\n    <ul>\n      <li>Each key is mapped to the closest node in the clockwise direction on the ring. This means that each node is responsible for the range of keys between it and the next node in the clockwise direction.</li>\n    </ul>\n  </li>\n  <li><strong>Adding or Removing Nodes:</strong>\n    <ul>\n      <li><strong>Adding a Node:</strong> The new node will only take responsibility for a portion of the keys from the existing node that was previously responsible for that range, minimizing the data movement.</li>\n      <li><strong>Removing a Node:</strong> Only the nodes immediately adjacent to the removed node will take over its keys, again minimizing disruption.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>The hash space is usually represented as a circle (a “ring”) where the hash function outputs values that can be thought of as points on this ring.</li>\n      <li>Nodes and keys are assigned positions on this ring using the same hash function.</li>\n    </ul>\n<ul>\n      <li>Each key is mapped to the closest node in the clockwise direction on the ring. This means that each node is responsible for the range of keys between it and the next node in the clockwise direction.</li>\n    </ul>\n<ul>\n      <li><strong>Adding a Node:</strong> The new node will only take responsibility for a portion of the keys from the existing node that was previously responsible for that range, minimizing the data movement.</li>\n      <li><strong>Removing a Node:</strong> Only the nodes immediately adjacent to the removed node will take over its keys, again minimizing disruption.</li>\n    </ul>\n<h4 id=\"virtual-nodes-vnodes\">Virtual Nodes (vNodes)</h4>\n<ul>\n  <li>To prevent uneven distribution of keys, consistent hashing often uses a technique called virtual nodes (vNodes). Each physical node is assigned multiple virtual nodes, which are spread across the hash space. This increases the likelihood of an even distribution of keys, even if the physical nodes themselves are unevenly distributed or vary in number.</li>\n</ul>\n<h4 id=\"advantages\">Advantages</h4>\n<ul>\n  <li><strong>Scalability:</strong> The system can easily scale by adding or removing nodes with minimal data movement.</li>\n  <li><strong>Load Balancing:</strong> Virtual nodes help in evenly distributing the load across all physical nodes.</li>\n  <li><strong>Fault Tolerance:</strong> If a node fails, only the nodes adjacent to it in the hash ring are affected, making the system more resilient.</li>\n</ul>\n<h4 id=\"use-cases\">Use Cases</h4>\n<ul>\n  <li><strong>Distributed Caching Systems:</strong> Systems like Amazon DynamoDB and Apache Cassandra use consistent hashing to distribute data across multiple nodes in a cluster.</li>\n  <li><strong>Load Balancers:</strong> Load balancers use consistent hashing to ensure that requests from the same client are directed to the same server, improving cache hit rates.</li>\n  <li><strong>Content Delivery Networks (CDNs):</strong> CDNs use consistent hashing to distribute content across multiple edge servers.</li>\n</ul>\n<h4 id=\"conclusion\">Conclusion</h4>\n<ul>\n  <li>Consistent hashing is a powerful tool in distributed systems that provides a scalable and efficient way to manage data across dynamic and distributed environments. By minimizing the amount of data that needs to be moved when changes occur, it ensures that the system remains performant and resilient even as it scales.</li>\n</ul>",
      "contentMarkdown": "#### Overview\n\n*   Consistent hashing is a key algorithm used in distributed systems to distribute data across multiple nodes in a way that minimizes data reorganization when nodes are added or removed. It is particularly important in systems where nodes can dynamically join or leave, such as in distributed databases, caching systems, and peer-to-peer networks.\n\n#### Problem with Traditional Hashing\n\n*   In traditional hashing, keys are mapped to a fixed set of buckets (nodes). For instance, if a hash function maps keys to buckets using modulo operation (e.g., `hash(key) % N`, where `N` is the number of nodes), adding or removing a node requires redistributing all keys across the new set of nodes. This leads to a large amount of data movement, which is inefficient.\n\n#### How Consistent Hashing Works\n\n*   Consistent hashing addresses this problem by mapping both the data keys and the nodes to a virtual circular hash space, often visualized as a ring.\n\n1.  **Hash Space and Ring:**\n    *   The hash space is usually represented as a circle (a “ring”) where the hash function outputs values that can be thought of as points on this ring.\n    *   Nodes and keys are assigned positions on this ring using the same hash function.\n2.  **Assigning Keys to Nodes:**\n    *   Each key is mapped to the closest node in the clockwise direction on the ring. This means that each node is responsible for the range of keys between it and the next node in the clockwise direction.\n3.  **Adding or Removing Nodes:**\n    *   **Adding a Node:** The new node will only take responsibility for a portion of the keys from the existing node that was previously responsible for that range, minimizing the data movement.\n    *   **Removing a Node:** Only the nodes immediately adjacent to the removed node will take over its keys, again minimizing disruption.\n\n*   The hash space is usually represented as a circle (a “ring”) where the hash function outputs values that can be thought of as points on this ring.\n*   Nodes and keys are assigned positions on this ring using the same hash function.\n\n*   Each key is mapped to the closest node in the clockwise direction on the ring. This means that each node is responsible for the range of keys between it and the next node in the clockwise direction.\n\n*   **Adding a Node:** The new node will only take responsibility for a portion of the keys from the existing node that was previously responsible for that range, minimizing the data movement.\n*   **Removing a Node:** Only the nodes immediately adjacent to the removed node will take over its keys, again minimizing disruption.\n\n#### Virtual Nodes (vNodes)\n\n*   To prevent uneven distribution of keys, consistent hashing often uses a technique called virtual nodes (vNodes). Each physical node is assigned multiple virtual nodes, which are spread across the hash space. This increases the likelihood of an even distribution of keys, even if the physical nodes themselves are unevenly distributed or vary in number.\n\n#### Advantages\n\n*   **Scalability:** The system can easily scale by adding or removing nodes with minimal data movement.\n*   **Load Balancing:** Virtual nodes help in evenly distributing the load across all physical nodes.\n*   **Fault Tolerance:** If a node fails, only the nodes adjacent to it in the hash ring are affected, making the system more resilient.\n\n#### Use Cases\n\n*   **Distributed Caching Systems:** Systems like Amazon DynamoDB and Apache Cassandra use consistent hashing to distribute data across multiple nodes in a cluster.\n*   **Load Balancers:** Load balancers use consistent hashing to ensure that requests from the same client are directed to the same server, improving cache hit rates.\n*   **Content Delivery Networks (CDNs):** CDNs use consistent hashing to distribute content across multiple edge servers.\n\n#### Conclusion\n\n*   Consistent hashing is a powerful tool in distributed systems that provides a scalable and efficient way to manage data across dynamic and distributed environments. By minimizing the amount of data that needs to be moved when changes occur, it ensures that the system remains performant and resilient even as it scales.",
      "order": 219,
      "orderInChapter": 20,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 677,
        "contentLength": 5016
      },
      "nextCards": [
        "ai-interview-what-are-some-load-balancing-algorithms-in-distrib-220",
        "ai-interview-why-is-flash-attention-needed-and-how-does-it-work-221"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-consistent-hashing-in-distributed-systems?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-some-load-balancing-algorithms-in-distrib-220",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Some Load Balancing Algorithms in Distributed Systems?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Load balancing in distributed systems is a critical technique used to distribute workload across multiple computing resources (such as servers, CPUs, or network links) to ensure no single resource is overwhelmed. The goal is to optimize resource use, maximize throughput, minimize response time, and avoid overload. Below are some common load balancing algorithms used in distributed systems:</li>\n</ul>\n<h4 id=\"round-robin\">Round Robin</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Requests are distributed sequentially among all available resources in a circular order.</li>\n  <li><strong>Use Case</strong>: Simple and effective when all servers have similar capacity.</li>\n  <li><strong>Pros</strong>: Easy to implement and understand.</li>\n  <li><strong>Cons</strong>: Doesn’t consider the current load on each resource, which can lead to inefficient utilization if servers have different capacities or are unevenly loaded.</li>\n</ul>\n<h4 id=\"weighted-round-robin\">Weighted Round Robin</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Similar to Round Robin but assigns a weight to each server based on its capacity or other criteria. Servers with higher weights receive more requests.</li>\n  <li><strong>Use Case</strong>: Useful when the resources have varying capacities.</li>\n  <li><strong>Pros</strong>: Takes into account the differences in server capacity.</li>\n  <li><strong>Cons</strong>: Still doesn’t consider real-time load on servers.</li>\n</ul>\n<h4 id=\"least-connections\">Least Connections</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Directs traffic to the server with the fewest active connections.</li>\n  <li><strong>Use Case</strong>: Suitable for environments where connection durations vary significantly.</li>\n  <li><strong>Pros</strong>: Balances load more effectively in environments with variable connection lengths.</li>\n  <li><strong>Cons</strong>: May not be efficient if the time required to process requests varies significantly.</li>\n</ul>\n<h4 id=\"weighted-least-connections\">Weighted Least Connections</h4>\n<ul>\n  <li><strong>Mechanism</strong>: An extension of Least Connections where servers are also assigned weights. Servers with more capacity (higher weight) will receive more connections but still prefer those with fewer active connections.</li>\n  <li><strong>Use Case</strong>: Useful when servers have different capacities and connection durations vary.</li>\n  <li><strong>Pros</strong>: More nuanced distribution than simple Least Connections.</li>\n  <li><strong>Cons</strong>: More complex to implement and requires proper configuration of weights.</li>\n</ul>\n<h4 id=\"least-response-time\">Least Response Time</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Directs traffic to the server with the lowest average response time.</li>\n  <li><strong>Use Case</strong>: Effective in environments where response time is a critical metric.</li>\n  <li><strong>Pros</strong>: Ensures requests are directed to the most responsive servers.</li>\n  <li><strong>Cons</strong>: Requires real-time monitoring and may not adapt quickly to sudden changes in server load.</li>\n</ul>\n<h4 id=\"ip-hashing\">IP Hashing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Uses the client’s IP address to compute a hash, which then determines which server will handle the request.</li>\n  <li><strong>Use Case</strong>: Ensures the same client is consistently directed to the same server (session persistence).</li>\n  <li><strong>Pros</strong>: Simple and effective for session persistence.</li>\n  <li><strong>Cons</strong>: Can lead to uneven distribution if there is a skew in client IP distribution.</li>\n</ul>\n<h4 id=\"consistent-hashing\">Consistent Hashing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Distributes requests based on a hash of the request, such as the client’s IP address or a specific resource identifier. Servers are also hashed, and requests are routed to the closest server in the hash ring.</li>\n  <li><strong>Use Case</strong>: Highly effective in distributed systems where nodes can join or leave dynamically (e.g., caching systems like Memcached).</li>\n  <li><strong>Pros</strong>: Minimizes the number of keys that need to be remapped when nodes are added or removed.</li>\n  <li><strong>Cons</strong>: More complex to implement than simple hashing.</li>\n</ul>\n<h4 id=\"randomized-load-balancing\">Randomized Load Balancing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Requests are assigned randomly to any available resource.</li>\n  <li><strong>Use Case</strong>: Suitable for large-scale systems with many resources where uniform distribution is likely over time.</li>\n  <li><strong>Pros</strong>: Extremely simple to implement.</li>\n  <li><strong>Cons</strong>: May result in uneven distribution in the short term.</li>\n</ul>\n<h4 id=\"centralized-load-balancing\">Centralized Load Balancing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: A central node monitors and manages the load on all resources and assigns incoming requests based on this global knowledge.</li>\n  <li><strong>Use Case</strong>: Systems where a central authority can optimize global performance.</li>\n  <li><strong>Pros</strong>: Can achieve optimal load distribution if the central node has accurate and up-to-date information.</li>\n  <li><strong>Cons</strong>: Single point of failure and potential bottleneck.</li>\n</ul>\n<h4 id=\"distributed-load-balancing\">Distributed Load Balancing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Each node independently decides where to forward requests based on local load information.</li>\n  <li><strong>Use Case</strong>: Highly distributed systems where central coordination is impractical.</li>\n  <li><strong>Pros</strong>: Scalable and fault-tolerant.</li>\n  <li><strong>Cons</strong>: Can be less efficient due to lack of global information.</li>\n</ul>\n<h4 id=\"dynamic-load-balancing\">Dynamic Load Balancing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Load balancing decisions are made dynamically based on real-time metrics such as server load, response time, or other performance indicators.</li>\n  <li><strong>Use Case</strong>: Environments with rapidly changing workloads.</li>\n  <li><strong>Pros</strong>: Adaptable to changing conditions, ensuring efficient load distribution.</li>\n  <li><strong>Cons</strong>: Complexity in implementation and the need for continuous monitoring.</li>\n</ul>\n<h4 id=\"agent-based-load-balancing\">Agent-Based Load Balancing</h4>\n<ul>\n  <li><strong>Mechanism</strong>: Agents on each node autonomously manage and distribute load by communicating with other agents, making local decisions based on global information.</li>\n  <li><strong>Use Case</strong>: Complex, large-scale distributed systems where decentralized decision-making is preferred.</li>\n  <li><strong>Pros</strong>: High fault tolerance and adaptability.</li>\n  <li>\n    <p><strong>Cons</strong>: Complexity and overhead in maintaining communication between agents.</p>\n  </li>\n  <li>Each algorithm has its strengths and weaknesses, and the choice of algorithm depends on the specific requirements of the distributed system, such as the nature of the workload, the capacity of the resources, and the performance goals. In many systems, a combination of these algorithms may be used to achieve the best performance.</li>\n</ul>\n<p><strong>Cons</strong>: Complexity and overhead in maintaining communication between agents.</p>",
      "contentMarkdown": "*   Load balancing in distributed systems is a critical technique used to distribute workload across multiple computing resources (such as servers, CPUs, or network links) to ensure no single resource is overwhelmed. The goal is to optimize resource use, maximize throughput, minimize response time, and avoid overload. Below are some common load balancing algorithms used in distributed systems:\n\n#### Round Robin\n\n*   **Mechanism**: Requests are distributed sequentially among all available resources in a circular order.\n*   **Use Case**: Simple and effective when all servers have similar capacity.\n*   **Pros**: Easy to implement and understand.\n*   **Cons**: Doesn’t consider the current load on each resource, which can lead to inefficient utilization if servers have different capacities or are unevenly loaded.\n\n#### Weighted Round Robin\n\n*   **Mechanism**: Similar to Round Robin but assigns a weight to each server based on its capacity or other criteria. Servers with higher weights receive more requests.\n*   **Use Case**: Useful when the resources have varying capacities.\n*   **Pros**: Takes into account the differences in server capacity.\n*   **Cons**: Still doesn’t consider real-time load on servers.\n\n#### Least Connections\n\n*   **Mechanism**: Directs traffic to the server with the fewest active connections.\n*   **Use Case**: Suitable for environments where connection durations vary significantly.\n*   **Pros**: Balances load more effectively in environments with variable connection lengths.\n*   **Cons**: May not be efficient if the time required to process requests varies significantly.\n\n#### Weighted Least Connections\n\n*   **Mechanism**: An extension of Least Connections where servers are also assigned weights. Servers with more capacity (higher weight) will receive more connections but still prefer those with fewer active connections.\n*   **Use Case**: Useful when servers have different capacities and connection durations vary.\n*   **Pros**: More nuanced distribution than simple Least Connections.\n*   **Cons**: More complex to implement and requires proper configuration of weights.\n\n#### Least Response Time\n\n*   **Mechanism**: Directs traffic to the server with the lowest average response time.\n*   **Use Case**: Effective in environments where response time is a critical metric.\n*   **Pros**: Ensures requests are directed to the most responsive servers.\n*   **Cons**: Requires real-time monitoring and may not adapt quickly to sudden changes in server load.\n\n#### IP Hashing\n\n*   **Mechanism**: Uses the client’s IP address to compute a hash, which then determines which server will handle the request.\n*   **Use Case**: Ensures the same client is consistently directed to the same server (session persistence).\n*   **Pros**: Simple and effective for session persistence.\n*   **Cons**: Can lead to uneven distribution if there is a skew in client IP distribution.\n\n#### Consistent Hashing\n\n*   **Mechanism**: Distributes requests based on a hash of the request, such as the client’s IP address or a specific resource identifier. Servers are also hashed, and requests are routed to the closest server in the hash ring.\n*   **Use Case**: Highly effective in distributed systems where nodes can join or leave dynamically (e.g., caching systems like Memcached).\n*   **Pros**: Minimizes the number of keys that need to be remapped when nodes are added or removed.\n*   **Cons**: More complex to implement than simple hashing.\n\n#### Randomized Load Balancing\n\n*   **Mechanism**: Requests are assigned randomly to any available resource.\n*   **Use Case**: Suitable for large-scale systems with many resources where uniform distribution is likely over time.\n*   **Pros**: Extremely simple to implement.\n*   **Cons**: May result in uneven distribution in the short term.\n\n#### Centralized Load Balancing\n\n*   **Mechanism**: A central node monitors and manages the load on all resources and assigns incoming requests based on this global knowledge.\n*   **Use Case**: Systems where a central authority can optimize global performance.\n*   **Pros**: Can achieve optimal load distribution if the central node has accurate and up-to-date information.\n*   **Cons**: Single point of failure and potential bottleneck.\n\n#### Distributed Load Balancing\n\n*   **Mechanism**: Each node independently decides where to forward requests based on local load information.\n*   **Use Case**: Highly distributed systems where central coordination is impractical.\n*   **Pros**: Scalable and fault-tolerant.\n*   **Cons**: Can be less efficient due to lack of global information.\n\n#### Dynamic Load Balancing\n\n*   **Mechanism**: Load balancing decisions are made dynamically based on real-time metrics such as server load, response time, or other performance indicators.\n*   **Use Case**: Environments with rapidly changing workloads.\n*   **Pros**: Adaptable to changing conditions, ensuring efficient load distribution.\n*   **Cons**: Complexity in implementation and the need for continuous monitoring.\n\n#### Agent-Based Load Balancing\n\n*   **Mechanism**: Agents on each node autonomously manage and distribute load by communicating with other agents, making local decisions based on global information.\n*   **Use Case**: Complex, large-scale distributed systems where decentralized decision-making is preferred.\n*   **Pros**: High fault tolerance and adaptability.\n*   **Cons**: Complexity and overhead in maintaining communication between agents.\n    \n*   Each algorithm has its strengths and weaknesses, and the choice of algorithm depends on the specific requirements of the distributed system, such as the nature of the workload, the capacity of the resources, and the performance goals. In many systems, a combination of these algorithms may be used to achieve the best performance.\n\n**Cons**: Complexity and overhead in maintaining communication between agents.",
      "order": 220,
      "orderInChapter": 21,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 841,
        "contentLength": 7367
      },
      "nextCards": [
        "ai-interview-why-is-flash-attention-needed-and-how-does-it-work-221",
        "ai-interview-what-is-continuous-and-dynamic-batching-222"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-some-load-balancing-algorithms-in-distributed-systems?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-is-flash-attention-needed-and-how-does-it-work-221",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Why is Flash Attention Needed, and How Does It Work?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Flash Attention is a technique designed to improve the efficiency and performance of the attention mechanism in transformers, which are a type of neural network architecture widely used in natural language processing (NLP) and other areas. Flash Attention is motivated by the need to address the inefficiencies and scalability issues inherent in the traditional implementation of attention mechanisms, especially as the size of models and datasets continues to grow.</li>\n  <li>Flash Attention addresses key limitations of traditional attention mechanisms by optimizing memory usage and computational efficiency. By implementing more memory-efficient algorithms, tiling strategies, kernel fusion, and other optimizations, Flash Attention enables transformers to handle longer sequences and larger models, making it a critical advancement for scaling up NLP models and improving their deployment in real-world applications.</li>\n</ul>\n<h4 id=\"why-is-flash-attention-needed\">Why is Flash Attention Needed?</h4>\n<ol>\n  <li>\n    <p><strong>Computational Complexity</strong>: Traditional attention mechanisms have a computational complexity of (O(N^2)) where (N) is the sequence length. This quadratic scaling can become a significant bottleneck as the sequence length increases, making it computationally expensive and memory-intensive. For large models or long sequences, this can be a major limitation.</p>\n  </li>\n  <li>\n    <p><strong>Memory Usage</strong>: The standard attention mechanism requires storing large attention matrices, which scale with the square of the sequence length. This leads to high memory consumption, which can quickly exhaust the available memory on GPUs, limiting the size of sequences that can be processed.</p>\n  </li>\n  <li>\n    <p><strong>Performance Bottlenecks</strong>: As the sequence length increases, the time taken to compute the attention grows, leading to latency issues. This can make real-time or low-latency applications challenging when using large transformers.</p>\n  </li>\n  <li>\n    <p><strong>Scalability</strong>: To deploy transformers in production or to train very large models efficiently, scalability is essential. The traditional attention mechanism’s limitations in both computation and memory make scaling up models and handling long sequences more difficult.</p>\n  </li>\n</ol>\n<p><strong>Computational Complexity</strong>: Traditional attention mechanisms have a computational complexity of (O(N^2)) where (N) is the sequence length. This quadratic scaling can become a significant bottleneck as the sequence length increases, making it computationally expensive and memory-intensive. For large models or long sequences, this can be a major limitation.</p>\n<p><strong>Memory Usage</strong>: The standard attention mechanism requires storing large attention matrices, which scale with the square of the sequence length. This leads to high memory consumption, which can quickly exhaust the available memory on GPUs, limiting the size of sequences that can be processed.</p>\n<p><strong>Performance Bottlenecks</strong>: As the sequence length increases, the time taken to compute the attention grows, leading to latency issues. This can make real-time or low-latency applications challenging when using large transformers.</p>\n<p><strong>Scalability</strong>: To deploy transformers in production or to train very large models efficiently, scalability is essential. The traditional attention mechanism’s limitations in both computation and memory make scaling up models and handling long sequences more difficult.</p>\n<h4 id=\"how-does-flash-attention-work\">How Does Flash Attention Work?</h4>\n<ul>\n  <li>\n    <p>Flash Attention is a more efficient implementation of the attention mechanism, focusing on reducing memory usage and computational overhead. It achieves this through a few key innovations:</p>\n\n    <ol>\n      <li>\n        <p><strong>Memory-Efficient Algorithm</strong>: Flash Attention avoids the need to materialize the full attention matrix, which is typically done in traditional implementations. Instead, it computes attention scores and performs the softmax operation in a more memory-efficient manner. This approach reduces memory bandwidth usage and helps in fitting longer sequences into the available GPU memory.</p>\n      </li>\n      <li>\n        <p><strong>Tiling and Partitioning</strong>: Flash Attention divides the sequence into smaller tiles or blocks and processes them sequentially. This tiling strategy allows the attention computation to be performed on smaller chunks of data, reducing the peak memory usage. By only keeping the necessary parts of the sequence in memory at any given time, Flash Attention can handle longer sequences more efficiently.</p>\n      </li>\n      <li>\n        <p><strong>Kernel Fusion and Optimization</strong>: The implementation of Flash Attention often uses optimized custom CUDA kernels to perform multiple operations in a single pass. This reduces the number of memory read and write operations, increasing throughput and reducing latency. Kernel fusion combines operations like matrix multiplication, softmax, and scaling into a single kernel, which minimizes overhead.</p>\n      </li>\n      <li>\n        <p><strong>Low-Rank Approximations</strong>: In some variants of Flash Attention, low-rank approximations of the attention matrix are used. This approximation reduces the dimensionality of the problem, making it computationally cheaper while still capturing the most important information in the attention scores.</p>\n      </li>\n      <li>\n        <p><strong>On-the-Fly Computation</strong>: Instead of storing large intermediate matrices, Flash Attention computes values on the fly as needed. This reduces memory pressure and allows for more efficient use of cache memory.</p>\n      </li>\n    </ol>\n  </li>\n</ul>\n<p>Flash Attention is a more efficient implementation of the attention mechanism, focusing on reducing memory usage and computational overhead. It achieves this through a few key innovations:</p>\n<ol>\n      <li>\n        <p><strong>Memory-Efficient Algorithm</strong>: Flash Attention avoids the need to materialize the full attention matrix, which is typically done in traditional implementations. Instead, it computes attention scores and performs the softmax operation in a more memory-efficient manner. This approach reduces memory bandwidth usage and helps in fitting longer sequences into the available GPU memory.</p>\n      </li>\n      <li>\n        <p><strong>Tiling and Partitioning</strong>: Flash Attention divides the sequence into smaller tiles or blocks and processes them sequentially. This tiling strategy allows the attention computation to be performed on smaller chunks of data, reducing the peak memory usage. By only keeping the necessary parts of the sequence in memory at any given time, Flash Attention can handle longer sequences more efficiently.</p>\n      </li>\n      <li>\n        <p><strong>Kernel Fusion and Optimization</strong>: The implementation of Flash Attention often uses optimized custom CUDA kernels to perform multiple operations in a single pass. This reduces the number of memory read and write operations, increasing throughput and reducing latency. Kernel fusion combines operations like matrix multiplication, softmax, and scaling into a single kernel, which minimizes overhead.</p>\n      </li>\n      <li>\n        <p><strong>Low-Rank Approximations</strong>: In some variants of Flash Attention, low-rank approximations of the attention matrix are used. This approximation reduces the dimensionality of the problem, making it computationally cheaper while still capturing the most important information in the attention scores.</p>\n      </li>\n      <li>\n        <p><strong>On-the-Fly Computation</strong>: Instead of storing large intermediate matrices, Flash Attention computes values on the fly as needed. This reduces memory pressure and allows for more efficient use of cache memory.</p>\n      </li>\n    </ol>\n<p><strong>Memory-Efficient Algorithm</strong>: Flash Attention avoids the need to materialize the full attention matrix, which is typically done in traditional implementations. Instead, it computes attention scores and performs the softmax operation in a more memory-efficient manner. This approach reduces memory bandwidth usage and helps in fitting longer sequences into the available GPU memory.</p>\n<p><strong>Tiling and Partitioning</strong>: Flash Attention divides the sequence into smaller tiles or blocks and processes them sequentially. This tiling strategy allows the attention computation to be performed on smaller chunks of data, reducing the peak memory usage. By only keeping the necessary parts of the sequence in memory at any given time, Flash Attention can handle longer sequences more efficiently.</p>\n<p><strong>Kernel Fusion and Optimization</strong>: The implementation of Flash Attention often uses optimized custom CUDA kernels to perform multiple operations in a single pass. This reduces the number of memory read and write operations, increasing throughput and reducing latency. Kernel fusion combines operations like matrix multiplication, softmax, and scaling into a single kernel, which minimizes overhead.</p>\n<p><strong>Low-Rank Approximations</strong>: In some variants of Flash Attention, low-rank approximations of the attention matrix are used. This approximation reduces the dimensionality of the problem, making it computationally cheaper while still capturing the most important information in the attention scores.</p>\n<p><strong>On-the-Fly Computation</strong>: Instead of storing large intermediate matrices, Flash Attention computes values on the fly as needed. This reduces memory pressure and allows for more efficient use of cache memory.</p>\n<h4 id=\"benefits-of-flash-attention\">Benefits of Flash Attention</h4>\n<ol>\n  <li>\n    <p><strong>Reduced Memory Footprint</strong>: By avoiding the need to store full attention matrices and using a tiled computation approach, Flash Attention significantly reduces the memory required for attention computation.</p>\n  </li>\n  <li>\n    <p><strong>Improved Speed and Efficiency</strong>: Flash Attention’s optimized computation and reduced memory usage lead to faster execution, making it suitable for real-time applications and enabling larger models to be trained and deployed.</p>\n  </li>\n  <li>\n    <p><strong>Scalability</strong>: The reduced computational and memory demands make Flash Attention more scalable, allowing it to handle longer sequences and larger models without running into the same bottlenecks as traditional attention mechanisms.</p>\n  </li>\n  <li>\n    <p><strong>Better Utilization of Hardware Resources</strong>: By leveraging GPU memory more efficiently and reducing memory bandwidth requirements, Flash Attention makes better use of available hardware, potentially lowering infrastructure costs and energy consumption.</p>\n  </li>\n</ol>\n<p><strong>Reduced Memory Footprint</strong>: By avoiding the need to store full attention matrices and using a tiled computation approach, Flash Attention significantly reduces the memory required for attention computation.</p>\n<p><strong>Improved Speed and Efficiency</strong>: Flash Attention’s optimized computation and reduced memory usage lead to faster execution, making it suitable for real-time applications and enabling larger models to be trained and deployed.</p>\n<p><strong>Scalability</strong>: The reduced computational and memory demands make Flash Attention more scalable, allowing it to handle longer sequences and larger models without running into the same bottlenecks as traditional attention mechanisms.</p>\n<p><strong>Better Utilization of Hardware Resources</strong>: By leveraging GPU memory more efficiently and reducing memory bandwidth requirements, Flash Attention makes better use of available hardware, potentially lowering infrastructure costs and energy consumption.</p>",
      "contentMarkdown": "*   Flash Attention is a technique designed to improve the efficiency and performance of the attention mechanism in transformers, which are a type of neural network architecture widely used in natural language processing (NLP) and other areas. Flash Attention is motivated by the need to address the inefficiencies and scalability issues inherent in the traditional implementation of attention mechanisms, especially as the size of models and datasets continues to grow.\n*   Flash Attention addresses key limitations of traditional attention mechanisms by optimizing memory usage and computational efficiency. By implementing more memory-efficient algorithms, tiling strategies, kernel fusion, and other optimizations, Flash Attention enables transformers to handle longer sequences and larger models, making it a critical advancement for scaling up NLP models and improving their deployment in real-world applications.\n\n#### Why is Flash Attention Needed?\n\n1.  **Computational Complexity**: Traditional attention mechanisms have a computational complexity of (O(N^2)) where (N) is the sequence length. This quadratic scaling can become a significant bottleneck as the sequence length increases, making it computationally expensive and memory-intensive. For large models or long sequences, this can be a major limitation.\n    \n2.  **Memory Usage**: The standard attention mechanism requires storing large attention matrices, which scale with the square of the sequence length. This leads to high memory consumption, which can quickly exhaust the available memory on GPUs, limiting the size of sequences that can be processed.\n    \n3.  **Performance Bottlenecks**: As the sequence length increases, the time taken to compute the attention grows, leading to latency issues. This can make real-time or low-latency applications challenging when using large transformers.\n    \n4.  **Scalability**: To deploy transformers in production or to train very large models efficiently, scalability is essential. The traditional attention mechanism’s limitations in both computation and memory make scaling up models and handling long sequences more difficult.\n    \n\n**Computational Complexity**: Traditional attention mechanisms have a computational complexity of (O(N^2)) where (N) is the sequence length. This quadratic scaling can become a significant bottleneck as the sequence length increases, making it computationally expensive and memory-intensive. For large models or long sequences, this can be a major limitation.\n\n**Memory Usage**: The standard attention mechanism requires storing large attention matrices, which scale with the square of the sequence length. This leads to high memory consumption, which can quickly exhaust the available memory on GPUs, limiting the size of sequences that can be processed.\n\n**Performance Bottlenecks**: As the sequence length increases, the time taken to compute the attention grows, leading to latency issues. This can make real-time or low-latency applications challenging when using large transformers.\n\n**Scalability**: To deploy transformers in production or to train very large models efficiently, scalability is essential. The traditional attention mechanism’s limitations in both computation and memory make scaling up models and handling long sequences more difficult.\n\n#### How Does Flash Attention Work?\n\n*   Flash Attention is a more efficient implementation of the attention mechanism, focusing on reducing memory usage and computational overhead. It achieves this through a few key innovations:\n    \n    1.  **Memory-Efficient Algorithm**: Flash Attention avoids the need to materialize the full attention matrix, which is typically done in traditional implementations. Instead, it computes attention scores and performs the softmax operation in a more memory-efficient manner. This approach reduces memory bandwidth usage and helps in fitting longer sequences into the available GPU memory.\n        \n    2.  **Tiling and Partitioning**: Flash Attention divides the sequence into smaller tiles or blocks and processes them sequentially. This tiling strategy allows the attention computation to be performed on smaller chunks of data, reducing the peak memory usage. By only keeping the necessary parts of the sequence in memory at any given time, Flash Attention can handle longer sequences more efficiently.\n        \n    3.  **Kernel Fusion and Optimization**: The implementation of Flash Attention often uses optimized custom CUDA kernels to perform multiple operations in a single pass. This reduces the number of memory read and write operations, increasing throughput and reducing latency. Kernel fusion combines operations like matrix multiplication, softmax, and scaling into a single kernel, which minimizes overhead.\n        \n    4.  **Low-Rank Approximations**: In some variants of Flash Attention, low-rank approximations of the attention matrix are used. This approximation reduces the dimensionality of the problem, making it computationally cheaper while still capturing the most important information in the attention scores.\n        \n    5.  **On-the-Fly Computation**: Instead of storing large intermediate matrices, Flash Attention computes values on the fly as needed. This reduces memory pressure and allows for more efficient use of cache memory.\n        \n\nFlash Attention is a more efficient implementation of the attention mechanism, focusing on reducing memory usage and computational overhead. It achieves this through a few key innovations:\n\n1.  **Memory-Efficient Algorithm**: Flash Attention avoids the need to materialize the full attention matrix, which is typically done in traditional implementations. Instead, it computes attention scores and performs the softmax operation in a more memory-efficient manner. This approach reduces memory bandwidth usage and helps in fitting longer sequences into the available GPU memory.\n    \n2.  **Tiling and Partitioning**: Flash Attention divides the sequence into smaller tiles or blocks and processes them sequentially. This tiling strategy allows the attention computation to be performed on smaller chunks of data, reducing the peak memory usage. By only keeping the necessary parts of the sequence in memory at any given time, Flash Attention can handle longer sequences more efficiently.\n    \n3.  **Kernel Fusion and Optimization**: The implementation of Flash Attention often uses optimized custom CUDA kernels to perform multiple operations in a single pass. This reduces the number of memory read and write operations, increasing throughput and reducing latency. Kernel fusion combines operations like matrix multiplication, softmax, and scaling into a single kernel, which minimizes overhead.\n    \n4.  **Low-Rank Approximations**: In some variants of Flash Attention, low-rank approximations of the attention matrix are used. This approximation reduces the dimensionality of the problem, making it computationally cheaper while still capturing the most important information in the attention scores.\n    \n5.  **On-the-Fly Computation**: Instead of storing large intermediate matrices, Flash Attention computes values on the fly as needed. This reduces memory pressure and allows for more efficient use of cache memory.\n    \n\n**Memory-Efficient Algorithm**: Flash Attention avoids the need to materialize the full attention matrix, which is typically done in traditional implementations. Instead, it computes attention scores and performs the softmax operation in a more memory-efficient manner. This approach reduces memory bandwidth usage and helps in fitting longer sequences into the available GPU memory.\n\n**Tiling and Partitioning**: Flash Attention divides the sequence into smaller tiles or blocks and processes them sequentially. This tiling strategy allows the attention computation to be performed on smaller chunks of data, reducing the peak memory usage. By only keeping the necessary parts of the sequence in memory at any given time, Flash Attention can handle longer sequences more efficiently.\n\n**Kernel Fusion and Optimization**: The implementation of Flash Attention often uses optimized custom CUDA kernels to perform multiple operations in a single pass. This reduces the number of memory read and write operations, increasing throughput and reducing latency. Kernel fusion combines operations like matrix multiplication, softmax, and scaling into a single kernel, which minimizes overhead.\n\n**Low-Rank Approximations**: In some variants of Flash Attention, low-rank approximations of the attention matrix are used. This approximation reduces the dimensionality of the problem, making it computationally cheaper while still capturing the most important information in the attention scores.\n\n**On-the-Fly Computation**: Instead of storing large intermediate matrices, Flash Attention computes values on the fly as needed. This reduces memory pressure and allows for more efficient use of cache memory.\n\n#### Benefits of Flash Attention\n\n1.  **Reduced Memory Footprint**: By avoiding the need to store full attention matrices and using a tiled computation approach, Flash Attention significantly reduces the memory required for attention computation.\n    \n2.  **Improved Speed and Efficiency**: Flash Attention’s optimized computation and reduced memory usage lead to faster execution, making it suitable for real-time applications and enabling larger models to be trained and deployed.\n    \n3.  **Scalability**: The reduced computational and memory demands make Flash Attention more scalable, allowing it to handle longer sequences and larger models without running into the same bottlenecks as traditional attention mechanisms.\n    \n4.  **Better Utilization of Hardware Resources**: By leveraging GPU memory more efficiently and reducing memory bandwidth requirements, Flash Attention makes better use of available hardware, potentially lowering infrastructure costs and energy consumption.\n    \n\n**Reduced Memory Footprint**: By avoiding the need to store full attention matrices and using a tiled computation approach, Flash Attention significantly reduces the memory required for attention computation.\n\n**Improved Speed and Efficiency**: Flash Attention’s optimized computation and reduced memory usage lead to faster execution, making it suitable for real-time applications and enabling larger models to be trained and deployed.\n\n**Scalability**: The reduced computational and memory demands make Flash Attention more scalable, allowing it to handle longer sequences and larger models without running into the same bottlenecks as traditional attention mechanisms.\n\n**Better Utilization of Hardware Resources**: By leveraging GPU memory more efficiently and reducing memory bandwidth requirements, Flash Attention makes better use of available hardware, potentially lowering infrastructure costs and energy consumption.",
      "order": 221,
      "orderInChapter": 22,
      "difficulty": 5,
      "estimatedMinutes": 8,
      "tags": [
        "practice",
        "neural network",
        "transformer",
        "attention",
        "nlp",
        "optimization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1485,
        "contentLength": 11965
      },
      "nextCards": [
        "ai-interview-what-is-continuous-and-dynamic-batching-222",
        "ai-interview-how-does-colbert-carry-out-late-interaction-223"
      ],
      "relatedCards": [
        "ai-transformers-gnns-build-representations-of-graphs-23",
        "ai-transformers-the-road-ahead-for-transformers-39",
        "ai-model-acceleration-hardware-aware-scheduling-18",
        "ai-word-vectors-contextual-and-sequential-data-embeddings-18",
        "ai-diffusion-models-pixart-alpha-fast-training-of-diffusion-transforme-58"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-is-flash-attention-needed,-and-how-does-it-work?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-continuous-and-dynamic-batching-222",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is Continuous and Dynamic Batching?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Continuous and dynamic batching are concepts related to optimizing the processing of tasks or data in systems, particularly in the context of machine learning, data processing, and distributed computing. These approaches help to improve the efficiency and throughput of systems by adjusting how data is grouped and processed based on current conditions and demands. Let’s explore each concept in detail:</li>\n</ul>\n<h4 id=\"continuous-batching\">Continuous Batching</h4>\n<ul>\n  <li>Continuous batching refers to a method where incoming data or tasks are continuously accumulated into batches over time until certain conditions are met. This approach is commonly used in scenarios where tasks or data arrive at unpredictable rates, and it is beneficial to process them in groups rather than individually to improve efficiency.</li>\n  <li>Both continuous and dynamic batching are techniques that help manage how tasks and data are processed in systems. Continuous batching accumulates tasks into batches over time, while dynamic batching adjusts batch sizes and timing based on real-time system conditions. These methods are essential for optimizing performance, reducing latency, and ensuring efficient use of computational resources in various applications, including machine learning, data processing, and real-time analytics.</li>\n</ul>\n<h5 id=\"key-characteristics-of-continuous-batching\">Key Characteristics of Continuous Batching</h5>\n<ol>\n  <li><strong>Batch Formation:</strong> Data or tasks are accumulated over a time window or until a batch size threshold is reached.</li>\n  <li><strong>Efficiency:</strong> By processing data in batches, continuous batching can reduce the overhead associated with task switching, communication, and processing, leading to more efficient use of resources.</li>\n  <li><strong>Latency Considerations:</strong> While continuous batching can improve throughput, it may introduce some latency since data waits to be accumulated into a batch before being processed.</li>\n  <li><strong>Adaptability:</strong> Systems can adjust the batch size or time window dynamically based on current load or system conditions, allowing for flexibility in managing varying input rates.</li>\n</ol>\n<h5 id=\"examples-of-continuous-batching\">Examples of Continuous Batching</h5>\n<ul>\n  <li><strong>Stream Processing:</strong> In real-time data analytics, continuous batching can be used to group incoming data streams into micro-batches for processing, allowing for near-real-time analysis while maintaining efficiency.</li>\n  <li><strong>Machine Learning Training:</strong> In machine learning, especially with neural networks, training data is often processed in batches. Continuous batching can help accumulate training examples until a certain batch size is reached, then process them together for gradient updates.</li>\n</ul>\n<h4 id=\"dynamic-batching\">Dynamic Batching</h4>\n<p><strong>Dynamic batching</strong> is a more adaptive and intelligent approach where the system dynamically decides how to batch incoming tasks or data based on the current state of the system, such as load, available resources, and input rate. This method aims to optimize both latency and throughput by adjusting batch sizes and processing schedules in real-time.</p>\n<h5 id=\"key-characteristics-of-dynamic-batching\">Key Characteristics of Dynamic Batching</h5>\n<ol>\n  <li><strong>Real-Time Adjustment:</strong> Unlike fixed or static batching, dynamic batching changes the size of the batches and how frequently they are processed based on real-time feedback.</li>\n  <li><strong>Resource Optimization:</strong> By adapting to the current state of system resources and load, dynamic batching can optimize resource utilization, balancing between maximizing throughput and minimizing latency.</li>\n  <li><strong>Predictive and Reactive:</strong> Dynamic batching can be both predictive (anticipating future load based on trends) and reactive (responding to current load and resource availability).</li>\n  <li><strong>Complexity:</strong> Implementing dynamic batching is more complex as it requires monitoring and decision-making algorithms to determine the optimal batch size and timing.</li>\n</ol>\n<h5 id=\"examples-of-dynamic-batching\">Examples of Dynamic Batching</h5>\n<ul>\n  <li><strong>Online Inference in Machine Learning:</strong> When serving machine learning models for real-time predictions, requests may come in bursts. Dynamic batching can group requests into batches based on current load, optimizing GPU/TPU utilization and reducing waiting time for predictions.</li>\n  <li><strong>Distributed Computing Systems:</strong> In distributed data processing frameworks (e.g., Apache Spark), dynamic batching can adjust the task sizes sent to different nodes based on current processing speed and network conditions to optimize job completion time.</li>\n</ul>\n<h4 id=\"comparison-and-use-cases\">Comparison and Use Cases</h4>\n<ul>\n  <li><strong>Continuous Batching</strong> is more about consistently accumulating data into batches for processing, which is effective for steady workloads or when batch processing is inherently more efficient. It’s typically used in applications where some latency is acceptable, and throughput is a higher priority.</li>\n  <li><strong>Dynamic Batching</strong> goes a step further by incorporating real-time adjustments to batch sizes and processing schedules, which is crucial in environments with fluctuating workloads and varying system states. It is particularly useful in scenarios where both latency and throughput need to be optimized, such as online inference, real-time analytics, or cloud-based services.</li>\n</ul>",
      "contentMarkdown": "*   Continuous and dynamic batching are concepts related to optimizing the processing of tasks or data in systems, particularly in the context of machine learning, data processing, and distributed computing. These approaches help to improve the efficiency and throughput of systems by adjusting how data is grouped and processed based on current conditions and demands. Let’s explore each concept in detail:\n\n#### Continuous Batching\n\n*   Continuous batching refers to a method where incoming data or tasks are continuously accumulated into batches over time until certain conditions are met. This approach is commonly used in scenarios where tasks or data arrive at unpredictable rates, and it is beneficial to process them in groups rather than individually to improve efficiency.\n*   Both continuous and dynamic batching are techniques that help manage how tasks and data are processed in systems. Continuous batching accumulates tasks into batches over time, while dynamic batching adjusts batch sizes and timing based on real-time system conditions. These methods are essential for optimizing performance, reducing latency, and ensuring efficient use of computational resources in various applications, including machine learning, data processing, and real-time analytics.\n\n##### Key Characteristics of Continuous Batching\n\n1.  **Batch Formation:** Data or tasks are accumulated over a time window or until a batch size threshold is reached.\n2.  **Efficiency:** By processing data in batches, continuous batching can reduce the overhead associated with task switching, communication, and processing, leading to more efficient use of resources.\n3.  **Latency Considerations:** While continuous batching can improve throughput, it may introduce some latency since data waits to be accumulated into a batch before being processed.\n4.  **Adaptability:** Systems can adjust the batch size or time window dynamically based on current load or system conditions, allowing for flexibility in managing varying input rates.\n\n##### Examples of Continuous Batching\n\n*   **Stream Processing:** In real-time data analytics, continuous batching can be used to group incoming data streams into micro-batches for processing, allowing for near-real-time analysis while maintaining efficiency.\n*   **Machine Learning Training:** In machine learning, especially with neural networks, training data is often processed in batches. Continuous batching can help accumulate training examples until a certain batch size is reached, then process them together for gradient updates.\n\n#### Dynamic Batching\n\n**Dynamic batching** is a more adaptive and intelligent approach where the system dynamically decides how to batch incoming tasks or data based on the current state of the system, such as load, available resources, and input rate. This method aims to optimize both latency and throughput by adjusting batch sizes and processing schedules in real-time.\n\n##### Key Characteristics of Dynamic Batching\n\n1.  **Real-Time Adjustment:** Unlike fixed or static batching, dynamic batching changes the size of the batches and how frequently they are processed based on real-time feedback.\n2.  **Resource Optimization:** By adapting to the current state of system resources and load, dynamic batching can optimize resource utilization, balancing between maximizing throughput and minimizing latency.\n3.  **Predictive and Reactive:** Dynamic batching can be both predictive (anticipating future load based on trends) and reactive (responding to current load and resource availability).\n4.  **Complexity:** Implementing dynamic batching is more complex as it requires monitoring and decision-making algorithms to determine the optimal batch size and timing.\n\n##### Examples of Dynamic Batching\n\n*   **Online Inference in Machine Learning:** When serving machine learning models for real-time predictions, requests may come in bursts. Dynamic batching can group requests into batches based on current load, optimizing GPU/TPU utilization and reducing waiting time for predictions.\n*   **Distributed Computing Systems:** In distributed data processing frameworks (e.g., Apache Spark), dynamic batching can adjust the task sizes sent to different nodes based on current processing speed and network conditions to optimize job completion time.\n\n#### Comparison and Use Cases\n\n*   **Continuous Batching** is more about consistently accumulating data into batches for processing, which is effective for steady workloads or when batch processing is inherently more efficient. It’s typically used in applications where some latency is acceptable, and throughput is a higher priority.\n*   **Dynamic Batching** goes a step further by incorporating real-time adjustments to batch sizes and processing schedules, which is crucial in environments with fluctuating workloads and varying system states. It is particularly useful in scenarios where both latency and throughput need to be optimized, such as online inference, real-time analytics, or cloud-based services.",
      "order": 222,
      "orderInChapter": 23,
      "difficulty": 4,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "neural network",
        "machine learning",
        "optimization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 709,
        "contentLength": 5673
      },
      "nextCards": [
        "ai-interview-how-does-colbert-carry-out-late-interaction-223",
        "ai-interview-what-are-bi--and-cross-encoder-architectures-for-r-224"
      ],
      "relatedCards": [
        "ai-loss-mean-squared-error-mse-l2-loss-10",
        "ai-decision-trees-and-ensemble-methods-can-decision-trees-be-fine-tuned-ie-do-they-have-i-18",
        "ai-reinforcement-learning-key-components-of-reinforcement-learning-1",
        "ai-top-30-papers-a-simple-neural-network-module-for-relational-reas-16",
        "ai-federated-learning-privacy-21"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-continuous-and-dynamic-batching?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-colbert-carry-out-late-interaction-223",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Does ColBERT Carry Out Late Interaction?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>ColBERT (Contextualized Late Interaction over BERT) is a neural retrieval model that optimizes the trade-off between efficiency and effectiveness in information retrieval tasks. The term <strong>“Late Interaction”</strong> refers to the way ColBERT delays the interaction between the query and document representations until the final stages of the retrieval process, rather than performing it during the encoding phase.</li>\n  <li>Here’s a breakdown of how ColBERT carries out Late Interaction.</li>\n</ul>\n<h4 id=\"independent-encoding-of-queries-and-documents\">Independent Encoding of Queries and Documents</h4>\n<ul>\n  <li><strong>BERT-based Encoding</strong>: ColBERT uses BERT (Bidirectional Encoder Representations from Transformers) to independently encode queries and documents into vectors.\n    <ul>\n      <li>Each query is tokenized and fed through BERT to generate a set of token embeddings.</li>\n      <li>Similarly, each document is tokenized and fed through BERT to generate a set of token embeddings.</li>\n    </ul>\n  </li>\n  <li>The key difference here from other retrieval models (like dense retrieval) is that ColBERT avoids encoding the interaction between the query and document at this stage. The two are processed separately to avoid early interaction (i.e., before retrieval), which is computationally expensive.</li>\n</ul>\n<ul>\n      <li>Each query is tokenized and fed through BERT to generate a set of token embeddings.</li>\n      <li>Similarly, each document is tokenized and fed through BERT to generate a set of token embeddings.</li>\n    </ul>\n<h4 id=\"maxsim-scoring-late-interaction-stage\">Maxsim Scoring (Late Interaction Stage)</h4>\n<ul>\n  <li>Once both the query and document are encoded into vectors, the Late Interaction occurs during the scoring phase.</li>\n  <li>Specifically, ColBERT calculates the cosine similarity (or dot product) between each token embedding from the query and each token embedding from the document.</li>\n  <li>The next step is the Maxsim operation, where for each query token, ColBERT identifies the maximum similarity score across all document tokens. This operation allows the model to focus on the most relevant parts of the document for each query term.\n    <ul>\n      <li>For example, if a query has three tokens and a document has five tokens, ColBERT will compute the similarity between each query token and all document tokens, then pick the highest similarity score for each query token.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>For example, if a query has three tokens and a document has five tokens, ColBERT will compute the similarity between each query token and all document tokens, then pick the highest similarity score for each query token.</li>\n    </ul>\n<h4 id=\"aggregation-of-scores\">Aggregation of Scores</h4>\n<ul>\n  <li>After performing the Maxsim operation for each query token, the individual similarity scores are aggregated (usually by summing or averaging) to produce a final relevance score for the document in relation to the query.</li>\n  <li>This final score is used to rank documents during retrieval.</li>\n</ul>\n<h4 id=\"key-benefits-of-late-interaction-in-colbert\">Key Benefits of Late Interaction in ColBERT</h4>\n<ul>\n  <li><strong>Efficiency</strong>: Since the interaction between the query and document embeddings is delayed until the final scoring stage, the embeddings for both queries and documents can be precomputed and stored independently. This allows efficient indexing and retrieval.</li>\n  <li><strong>Effectiveness</strong>: Late interaction preserves token-level granularity, allowing more fine-grained matching between query and document tokens compared to early interaction models, which may lose important token-level nuances.</li>\n</ul>\n<h4 id=\"example-query-document-matching-with-late-interaction\">Example: Query-Document Matching with Late Interaction</h4>\n<ul>\n  <li>Suppose we have a query <code class=\"language-plaintext highlighter-rouge\">\"climate change impact\"</code> and a document with text about the environmental effects of global warming.\n    <ul>\n      <li>ColBERT encodes <code class=\"language-plaintext highlighter-rouge\">\"climate\"</code>, <code class=\"language-plaintext highlighter-rouge\">\"change\"</code>, and <code class=\"language-plaintext highlighter-rouge\">\"impact\"</code> as vectors independently from the document.</li>\n      <li>For each token in the query, it compares with all document token embeddings, finds the max similarity for each, and aggregates these maximum values to generate a score that represents how well the document matches the query.</li>\n    </ul>\n  </li>\n  <li>In summary, ColBERT’s late interaction happens by deferring the interaction between query and document token representations to the last stage, allowing efficient computation of relevance scores while still maintaining the fine-grained matching ability. This design balances the computational complexity with the retrieval effectiveness, making it a powerful model for information retrieval tasks.</li>\n</ul>\n<ul>\n      <li>ColBERT encodes <code class=\"language-plaintext highlighter-rouge\">\"climate\"</code>, <code class=\"language-plaintext highlighter-rouge\">\"change\"</code>, and <code class=\"language-plaintext highlighter-rouge\">\"impact\"</code> as vectors independently from the document.</li>\n      <li>For each token in the query, it compares with all document token embeddings, finds the max similarity for each, and aggregates these maximum values to generate a score that represents how well the document matches the query.</li>\n    </ul>",
      "contentMarkdown": "*   ColBERT (Contextualized Late Interaction over BERT) is a neural retrieval model that optimizes the trade-off between efficiency and effectiveness in information retrieval tasks. The term **“Late Interaction”** refers to the way ColBERT delays the interaction between the query and document representations until the final stages of the retrieval process, rather than performing it during the encoding phase.\n*   Here’s a breakdown of how ColBERT carries out Late Interaction.\n\n#### Independent Encoding of Queries and Documents\n\n*   **BERT-based Encoding**: ColBERT uses BERT (Bidirectional Encoder Representations from Transformers) to independently encode queries and documents into vectors.\n    *   Each query is tokenized and fed through BERT to generate a set of token embeddings.\n    *   Similarly, each document is tokenized and fed through BERT to generate a set of token embeddings.\n*   The key difference here from other retrieval models (like dense retrieval) is that ColBERT avoids encoding the interaction between the query and document at this stage. The two are processed separately to avoid early interaction (i.e., before retrieval), which is computationally expensive.\n\n*   Each query is tokenized and fed through BERT to generate a set of token embeddings.\n*   Similarly, each document is tokenized and fed through BERT to generate a set of token embeddings.\n\n#### Maxsim Scoring (Late Interaction Stage)\n\n*   Once both the query and document are encoded into vectors, the Late Interaction occurs during the scoring phase.\n*   Specifically, ColBERT calculates the cosine similarity (or dot product) between each token embedding from the query and each token embedding from the document.\n*   The next step is the Maxsim operation, where for each query token, ColBERT identifies the maximum similarity score across all document tokens. This operation allows the model to focus on the most relevant parts of the document for each query term.\n    *   For example, if a query has three tokens and a document has five tokens, ColBERT will compute the similarity between each query token and all document tokens, then pick the highest similarity score for each query token.\n\n*   For example, if a query has three tokens and a document has five tokens, ColBERT will compute the similarity between each query token and all document tokens, then pick the highest similarity score for each query token.\n\n#### Aggregation of Scores\n\n*   After performing the Maxsim operation for each query token, the individual similarity scores are aggregated (usually by summing or averaging) to produce a final relevance score for the document in relation to the query.\n*   This final score is used to rank documents during retrieval.\n\n#### Key Benefits of Late Interaction in ColBERT\n\n*   **Efficiency**: Since the interaction between the query and document embeddings is delayed until the final scoring stage, the embeddings for both queries and documents can be precomputed and stored independently. This allows efficient indexing and retrieval.\n*   **Effectiveness**: Late interaction preserves token-level granularity, allowing more fine-grained matching between query and document tokens compared to early interaction models, which may lose important token-level nuances.\n\n#### Example: Query-Document Matching with Late Interaction\n\n*   Suppose we have a query `\"climate change impact\"` and a document with text about the environmental effects of global warming.\n    *   ColBERT encodes `\"climate\"`, `\"change\"`, and `\"impact\"` as vectors independently from the document.\n    *   For each token in the query, it compares with all document token embeddings, finds the max similarity for each, and aggregates these maximum values to generate a score that represents how well the document matches the query.\n*   In summary, ColBERT’s late interaction happens by deferring the interaction between query and document token representations to the last stage, allowing efficient computation of relevance scores while still maintaining the fine-grained matching ability. This design balances the computational complexity with the retrieval effectiveness, making it a powerful model for information retrieval tasks.\n\n*   ColBERT encodes `\"climate\"`, `\"change\"`, and `\"impact\"` as vectors independently from the document.\n*   For each token in the query, it compares with all document token embeddings, finds the max similarity for each, and aggregates these maximum values to generate a score that represents how well the document matches the query.",
      "order": 223,
      "orderInChapter": 24,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "transformer",
        "embedding",
        "bert"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 676,
        "contentLength": 5582
      },
      "nextCards": [
        "ai-interview-what-are-bi--and-cross-encoder-architectures-for-r-224",
        "ai-interview-what-are-the-pros-and-cons-of-gradient-boosting-de-225"
      ],
      "relatedCards": [
        "ai-transformers-in-bert-how-do-we-go-from-qqq-kkk-and-vvv-at-the-f-61",
        "ai-transformers-what-gets-passed-on-from-the-output-of-the-previou-62",
        "ai-loss-multiple-negative-ranking-loss-16",
        "ai-bert-in-bert-how-do-we-go-from-qqq-kkk-and-vvv-at-the-f-15",
        "ai-bert-what-gets-passed-on-from-the-output-of-the-previou-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-colbert-carry-out-late-interaction?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-bi--and-cross-encoder-architectures-for-r-224",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Bi- and Cross-encoder Architectures for Retrieval?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>The distinction between bi-encoder and cross-encoder architectures is fundamental to understanding the efficacy of re-ranking models in information retrieval.</p>\n  </li>\n  <li>Bi-encoders operate similarly to vector search methodologies, wherein the query and documents are processed independently. The architecture involves two primary steps:\n    <ol>\n      <li>Pre-computation of document embeddings.</li>\n      <li>During inference, the computation of the query embedding.</li>\n    </ol>\n  </li>\n  <li>This approach renders bi-encoders particularly suitable for first-stage retrieval due to their:\n    <ul>\n      <li>Speed and efficiency</li>\n      <li>Scalability</li>\n    </ul>\n  </li>\n  <li>\n    <p>However, a notable limitation is their potential to overlook contextual nuances present in the data.</p>\n  </li>\n  <li>Cross-encoders, conversely, are frequently employed in re-ranking scenarios. They engage in simultaneous processing of the query and the associated documents. The methodology consists of:\n    <ol>\n      <li>Concatenating the query with each document in the format: <code class=\"language-plaintext highlighter-rouge\">[CLS] Query [SEP] Document [SEP]</code>.</li>\n      <li>Processing these combined inputs to leverage full cross-attention mechanisms.</li>\n    </ol>\n  </li>\n  <li>This architectural design makes cross-encoders especially effective for second-stage retrieval, providing:\n    <ul>\n      <li>Contextually rich outputs that yield more precise results</li>\n      <li>An inherent drawback of being slower and more computationally intensive, particularly at scale.</li>\n    </ul>\n  </li>\n  <li>To achieve optimal search results, a synergistic combination of both bi-encoders and cross-encoders is recommended.</li>\n  <li>The figure below (<a href=\"https://www.linkedin.com/in/804250ab/\">source</a>) shows both architectures.</li>\n</ul>\n<p>The distinction between bi-encoder and cross-encoder architectures is fundamental to understanding the efficacy of re-ranking models in information retrieval.</p>\n<ol>\n      <li>Pre-computation of document embeddings.</li>\n      <li>During inference, the computation of the query embedding.</li>\n    </ol>\n<ul>\n      <li>Speed and efficiency</li>\n      <li>Scalability</li>\n    </ul>\n<p>However, a notable limitation is their potential to overlook contextual nuances present in the data.</p>\n<ol>\n      <li>Concatenating the query with each document in the format: <code class=\"language-plaintext highlighter-rouge\">[CLS] Query [SEP] Document [SEP]</code>.</li>\n      <li>Processing these combined inputs to leverage full cross-attention mechanisms.</li>\n    </ol>\n<ul>\n      <li>Contextually rich outputs that yield more precise results</li>\n      <li>An inherent drawback of being slower and more computationally intensive, particularly at scale.</li>\n    </ul>\n<p><img src=\"/primers/ai/assets/interview/bi_cross.jpg\" alt=\"\"></p>",
      "contentMarkdown": "*   The distinction between bi-encoder and cross-encoder architectures is fundamental to understanding the efficacy of re-ranking models in information retrieval.\n    \n*   Bi-encoders operate similarly to vector search methodologies, wherein the query and documents are processed independently. The architecture involves two primary steps:\n    1.  Pre-computation of document embeddings.\n    2.  During inference, the computation of the query embedding.\n*   This approach renders bi-encoders particularly suitable for first-stage retrieval due to their:\n    *   Speed and efficiency\n    *   Scalability\n*   However, a notable limitation is their potential to overlook contextual nuances present in the data.\n    \n*   Cross-encoders, conversely, are frequently employed in re-ranking scenarios. They engage in simultaneous processing of the query and the associated documents. The methodology consists of:\n    1.  Concatenating the query with each document in the format: `[CLS] Query [SEP] Document [SEP]`.\n    2.  Processing these combined inputs to leverage full cross-attention mechanisms.\n*   This architectural design makes cross-encoders especially effective for second-stage retrieval, providing:\n    *   Contextually rich outputs that yield more precise results\n    *   An inherent drawback of being slower and more computationally intensive, particularly at scale.\n*   To achieve optimal search results, a synergistic combination of both bi-encoders and cross-encoders is recommended.\n*   The figure below ([source](https://www.linkedin.com/in/804250ab/)) shows both architectures.\n\nThe distinction between bi-encoder and cross-encoder architectures is fundamental to understanding the efficacy of re-ranking models in information retrieval.\n\n1.  Pre-computation of document embeddings.\n2.  During inference, the computation of the query embedding.\n\n*   Speed and efficiency\n*   Scalability\n\nHowever, a notable limitation is their potential to overlook contextual nuances present in the data.\n\n1.  Concatenating the query with each document in the format: `[CLS] Query [SEP] Document [SEP]`.\n2.  Processing these combined inputs to leverage full cross-attention mechanisms.\n\n*   Contextually rich outputs that yield more precise results\n*   An inherent drawback of being slower and more computationally intensive, particularly at scale.\n\n![](/primers/ai/assets/interview/bi_cross.jpg)",
      "order": 224,
      "orderInChapter": 25,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "attention",
        "embedding"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 303,
        "contentLength": 2923
      },
      "nextCards": [
        "ai-interview-what-are-the-pros-and-cons-of-gradient-boosting-de-225",
        "ai-interview-why-are-gbdts-highly-effective-with-sparse-data-226"
      ],
      "relatedCards": [
        "ai-attention-key-equations-and-design-20",
        "ai-transformers-step-2-token-embeddings-and-positional-encoding-16",
        "ai-diffusion-models-text-conditioning-in-diffusion-models-24",
        "ai-diffusion-models-in-the-context-of-diffusion-models-what-role-does--50",
        "ai-transformers-did-the-original-transformer-use-absolute-or-relat-56"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-bi--and-cross-encoder-architectures-for-retrieval?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-pros-and-cons-of-gradient-boosting-de-225",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are the Pros and Cons of Gradient Boosting Decision Trees?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Gradient Boosting Decision Trees (GBDT) is a powerful and widely used machine learning technique, particularly for tasks like classification and regression. It builds an ensemble of decision trees in a sequential manner to optimize predictive performance.</li>\n  <li>GBDT is a highly effective machine learning algorithm with several advantages in terms of predictive accuracy, flexibility, and minimal preprocessing requirements. However, it comes with trade-offs, including high computational cost, sensitivity to hyperparameters, and difficulty in interpreting models. It is widely used in industry but may not be suitable for all tasks, especially those requiring low-latency predictions, real-time learning, or deep interpretability. For tasks where speed, scalability, or explainability are key concerns, alternatives like Random Forest, linear models, or neural networks may be more appropriate.</li>\n  <li>Below are the detailed pros and cons of GBDT:</li>\n</ul>\n<h4 id=\"pros-of-gbdt\">Pros of GBDT</h4>\n<ol>\n  <li><strong>High Predictive Accuracy:</strong>\n    <ul>\n      <li><strong>Boosting Effectiveness:</strong> GBDT iteratively improves the model by combining weak learners (decision trees) to form a strong learner. This boosting mechanism focuses on the errors made by previous models, leading to significant improvements in performance.</li>\n      <li><strong>Handling Non-Linear Relationships:</strong> Since decision trees can model complex, non-linear relationships, GBDT inherits this ability, making it highly effective at capturing intricate patterns in the data.</li>\n    </ul>\n  </li>\n  <li><strong>Versatile:</strong>\n    <ul>\n      <li><strong>Can Handle Various Types of Data:</strong> GBDT works well with both numeric and categorical data. It doesn’t require much data preprocessing, like scaling or normalization, which is often needed for algorithms like SVM or neural networks.</li>\n      <li><strong>Applicable to Different Problems:</strong> GBDT can be used for classification, regression, and even ranking tasks. Its flexibility makes it a go-to choice for many machine learning problems.</li>\n    </ul>\n  </li>\n  <li><strong>Built-in Feature Selection:</strong>\n    <ul>\n      <li><strong>Feature Importance:</strong> GBDT naturally selects important features during training by focusing on those that reduce the most error. This implicit feature selection is useful when dealing with high-dimensional data.</li>\n      <li><strong>Automatic Handling of Irrelevant Features:</strong> By focusing on areas where the model performs poorly, GBDT downweights irrelevant or noisy features without explicit feature elimination methods.</li>\n    </ul>\n  </li>\n  <li><strong>Handling Missing Data:</strong>\n    <ul>\n      <li><strong>Missing Values Tolerance:</strong> GBDT can handle missing values quite effectively by splitting on missing data as part of the decision-making process, reducing the need for imputation.</li>\n    </ul>\n  </li>\n  <li><strong>No Need for Extensive Data Preprocessing:</strong>\n    <ul>\n      <li><strong>Minimal Data Transformation:</strong> GBDT does not require heavy transformations like normalization, standardization, or one-hot encoding for categorical variables, making it easier to implement on raw data compared to other algorithms.</li>\n    </ul>\n  </li>\n  <li><strong>Effective with Limited Hyperparameter Tuning:</strong>\n    <ul>\n      <li><strong>Out-of-the-box Performance:</strong> GBDT algorithms, particularly modern implementations like XGBoost, LightGBM, and CatBoost, often perform reasonably well with default settings. With fine-tuning, they can be pushed to achieve very high performance.</li>\n    </ul>\n  </li>\n  <li><strong>Ensemble Learning:</strong>\n    <ul>\n      <li><strong>Combining Weak Learners:</strong> GBDT combines multiple decision trees (weak learners), leading to improved generalization by reducing variance and bias compared to a single decision tree.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li><strong>Boosting Effectiveness:</strong> GBDT iteratively improves the model by combining weak learners (decision trees) to form a strong learner. This boosting mechanism focuses on the errors made by previous models, leading to significant improvements in performance.</li>\n      <li><strong>Handling Non-Linear Relationships:</strong> Since decision trees can model complex, non-linear relationships, GBDT inherits this ability, making it highly effective at capturing intricate patterns in the data.</li>\n    </ul>\n<ul>\n      <li><strong>Can Handle Various Types of Data:</strong> GBDT works well with both numeric and categorical data. It doesn’t require much data preprocessing, like scaling or normalization, which is often needed for algorithms like SVM or neural networks.</li>\n      <li><strong>Applicable to Different Problems:</strong> GBDT can be used for classification, regression, and even ranking tasks. Its flexibility makes it a go-to choice for many machine learning problems.</li>\n    </ul>\n<ul>\n      <li><strong>Feature Importance:</strong> GBDT naturally selects important features during training by focusing on those that reduce the most error. This implicit feature selection is useful when dealing with high-dimensional data.</li>\n      <li><strong>Automatic Handling of Irrelevant Features:</strong> By focusing on areas where the model performs poorly, GBDT downweights irrelevant or noisy features without explicit feature elimination methods.</li>\n    </ul>\n<ul>\n      <li><strong>Missing Values Tolerance:</strong> GBDT can handle missing values quite effectively by splitting on missing data as part of the decision-making process, reducing the need for imputation.</li>\n    </ul>\n<ul>\n      <li><strong>Minimal Data Transformation:</strong> GBDT does not require heavy transformations like normalization, standardization, or one-hot encoding for categorical variables, making it easier to implement on raw data compared to other algorithms.</li>\n    </ul>\n<ul>\n      <li><strong>Out-of-the-box Performance:</strong> GBDT algorithms, particularly modern implementations like XGBoost, LightGBM, and CatBoost, often perform reasonably well with default settings. With fine-tuning, they can be pushed to achieve very high performance.</li>\n    </ul>\n<ul>\n      <li><strong>Combining Weak Learners:</strong> GBDT combines multiple decision trees (weak learners), leading to improved generalization by reducing variance and bias compared to a single decision tree.</li>\n    </ul>\n<h4 id=\"cons-of-gbdt\">Cons of GBDT</h4>\n<ol>\n  <li><strong>Computationally Expensive:</strong>\n    <ul>\n      <li><strong>High Training Time:</strong> GBDT builds trees sequentially, meaning each tree depends on the results of the previous one. This sequential nature increases training time, especially on large datasets.</li>\n      <li><strong>Memory Consumption:</strong> Due to the large number of trees generated in the boosting process, GBDT can require significant memory resources, particularly if the depth of trees is large.</li>\n    </ul>\n  </li>\n  <li><strong>Sensitive to Hyperparameters:</strong>\n    <ul>\n      <li><strong>Tuning Complexity:</strong> While GBDT can perform well out of the box, fine-tuning is often required to get the best performance. Key hyperparameters like learning rate, number of trees, tree depth, and minimum samples per split need careful optimization.</li>\n      <li><strong>Risk of Overfitting:</strong> If the number of trees is too high or the learning rate is too low, the model can overfit to the training data. Thus, finding a good balance between model complexity and regularization is crucial.</li>\n    </ul>\n  </li>\n  <li><strong>Difficult to Interpret:</strong>\n    <ul>\n      <li><strong>Black Box Nature:</strong> Although decision trees are relatively interpretable, an ensemble of hundreds or thousands of trees is much harder to interpret. This makes GBDT less explainable than simpler models like linear regression or a single decision tree.</li>\n      <li><strong>Harder for Stakeholders to Understand:</strong> In real-world applications, where explainability is important (e.g., in healthcare or finance), GBDT models may be difficult to justify to non-technical stakeholders.</li>\n    </ul>\n  </li>\n  <li><strong>Lack of Online Learning Capability:</strong>\n    <ul>\n      <li><strong>Cannot Learn Incrementally:</strong> GBDT models are trained in batches, and once trained, they cannot easily accommodate new data without retraining from scratch. This makes them unsuitable for real-time learning or applications requiring frequent model updates.</li>\n    </ul>\n  </li>\n  <li><strong>Sensitivity to Noisy Data:</strong>\n    <ul>\n      <li><strong>Noise Amplification:</strong> GBDT can sometimes amplify the effects of noise in the data. Since each tree attempts to fix errors made by the previous tree, any overfitting to noisy patterns can propagate through the model.</li>\n    </ul>\n  </li>\n  <li><strong>Requires Careful Handling of Imbalanced Data:</strong>\n    <ul>\n      <li><strong>Less Effective on Imbalanced Datasets:</strong> GBDT does not inherently handle class imbalances well. Special techniques like adjusting the loss function, using weighted data, or applying sampling strategies are often needed to mitigate this issue.</li>\n    </ul>\n  </li>\n  <li><strong>Long Inference Times:</strong>\n    <ul>\n      <li><strong>Prediction Speed:</strong> GBDT’s prediction speed can be slow, especially with a large number of trees or deep trees. This can make it less suitable for low-latency applications, where real-time or near-real-time predictions are required.</li>\n    </ul>\n  </li>\n  <li><strong>Limited Extrapolation Beyond Training Data:</strong>\n    <ul>\n      <li><strong>Poor Extrapolation:</strong> Like decision trees, GBDT models struggle with data points that fall outside the range of the training data (extrapolation). For example, they are not well-suited for problems where future trends need to be predicted based on past data (e.g., time series forecasting with far horizons).</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li><strong>High Training Time:</strong> GBDT builds trees sequentially, meaning each tree depends on the results of the previous one. This sequential nature increases training time, especially on large datasets.</li>\n      <li><strong>Memory Consumption:</strong> Due to the large number of trees generated in the boosting process, GBDT can require significant memory resources, particularly if the depth of trees is large.</li>\n    </ul>\n<ul>\n      <li><strong>Tuning Complexity:</strong> While GBDT can perform well out of the box, fine-tuning is often required to get the best performance. Key hyperparameters like learning rate, number of trees, tree depth, and minimum samples per split need careful optimization.</li>\n      <li><strong>Risk of Overfitting:</strong> If the number of trees is too high or the learning rate is too low, the model can overfit to the training data. Thus, finding a good balance between model complexity and regularization is crucial.</li>\n    </ul>\n<ul>\n      <li><strong>Black Box Nature:</strong> Although decision trees are relatively interpretable, an ensemble of hundreds or thousands of trees is much harder to interpret. This makes GBDT less explainable than simpler models like linear regression or a single decision tree.</li>\n      <li><strong>Harder for Stakeholders to Understand:</strong> In real-world applications, where explainability is important (e.g., in healthcare or finance), GBDT models may be difficult to justify to non-technical stakeholders.</li>\n    </ul>\n<ul>\n      <li><strong>Cannot Learn Incrementally:</strong> GBDT models are trained in batches, and once trained, they cannot easily accommodate new data without retraining from scratch. This makes them unsuitable for real-time learning or applications requiring frequent model updates.</li>\n    </ul>\n<ul>\n      <li><strong>Noise Amplification:</strong> GBDT can sometimes amplify the effects of noise in the data. Since each tree attempts to fix errors made by the previous tree, any overfitting to noisy patterns can propagate through the model.</li>\n    </ul>\n<ul>\n      <li><strong>Less Effective on Imbalanced Datasets:</strong> GBDT does not inherently handle class imbalances well. Special techniques like adjusting the loss function, using weighted data, or applying sampling strategies are often needed to mitigate this issue.</li>\n    </ul>\n<ul>\n      <li><strong>Prediction Speed:</strong> GBDT’s prediction speed can be slow, especially with a large number of trees or deep trees. This can make it less suitable for low-latency applications, where real-time or near-real-time predictions are required.</li>\n    </ul>\n<ul>\n      <li><strong>Poor Extrapolation:</strong> Like decision trees, GBDT models struggle with data points that fall outside the range of the training data (extrapolation). For example, they are not well-suited for problems where future trends need to be predicted based on past data (e.g., time series forecasting with far horizons).</li>\n    </ul>",
      "contentMarkdown": "*   Gradient Boosting Decision Trees (GBDT) is a powerful and widely used machine learning technique, particularly for tasks like classification and regression. It builds an ensemble of decision trees in a sequential manner to optimize predictive performance.\n*   GBDT is a highly effective machine learning algorithm with several advantages in terms of predictive accuracy, flexibility, and minimal preprocessing requirements. However, it comes with trade-offs, including high computational cost, sensitivity to hyperparameters, and difficulty in interpreting models. It is widely used in industry but may not be suitable for all tasks, especially those requiring low-latency predictions, real-time learning, or deep interpretability. For tasks where speed, scalability, or explainability are key concerns, alternatives like Random Forest, linear models, or neural networks may be more appropriate.\n*   Below are the detailed pros and cons of GBDT:\n\n#### Pros of GBDT\n\n1.  **High Predictive Accuracy:**\n    *   **Boosting Effectiveness:** GBDT iteratively improves the model by combining weak learners (decision trees) to form a strong learner. This boosting mechanism focuses on the errors made by previous models, leading to significant improvements in performance.\n    *   **Handling Non-Linear Relationships:** Since decision trees can model complex, non-linear relationships, GBDT inherits this ability, making it highly effective at capturing intricate patterns in the data.\n2.  **Versatile:**\n    *   **Can Handle Various Types of Data:** GBDT works well with both numeric and categorical data. It doesn’t require much data preprocessing, like scaling or normalization, which is often needed for algorithms like SVM or neural networks.\n    *   **Applicable to Different Problems:** GBDT can be used for classification, regression, and even ranking tasks. Its flexibility makes it a go-to choice for many machine learning problems.\n3.  **Built-in Feature Selection:**\n    *   **Feature Importance:** GBDT naturally selects important features during training by focusing on those that reduce the most error. This implicit feature selection is useful when dealing with high-dimensional data.\n    *   **Automatic Handling of Irrelevant Features:** By focusing on areas where the model performs poorly, GBDT downweights irrelevant or noisy features without explicit feature elimination methods.\n4.  **Handling Missing Data:**\n    *   **Missing Values Tolerance:** GBDT can handle missing values quite effectively by splitting on missing data as part of the decision-making process, reducing the need for imputation.\n5.  **No Need for Extensive Data Preprocessing:**\n    *   **Minimal Data Transformation:** GBDT does not require heavy transformations like normalization, standardization, or one-hot encoding for categorical variables, making it easier to implement on raw data compared to other algorithms.\n6.  **Effective with Limited Hyperparameter Tuning:**\n    *   **Out-of-the-box Performance:** GBDT algorithms, particularly modern implementations like XGBoost, LightGBM, and CatBoost, often perform reasonably well with default settings. With fine-tuning, they can be pushed to achieve very high performance.\n7.  **Ensemble Learning:**\n    *   **Combining Weak Learners:** GBDT combines multiple decision trees (weak learners), leading to improved generalization by reducing variance and bias compared to a single decision tree.\n\n*   **Boosting Effectiveness:** GBDT iteratively improves the model by combining weak learners (decision trees) to form a strong learner. This boosting mechanism focuses on the errors made by previous models, leading to significant improvements in performance.\n*   **Handling Non-Linear Relationships:** Since decision trees can model complex, non-linear relationships, GBDT inherits this ability, making it highly effective at capturing intricate patterns in the data.\n\n*   **Can Handle Various Types of Data:** GBDT works well with both numeric and categorical data. It doesn’t require much data preprocessing, like scaling or normalization, which is often needed for algorithms like SVM or neural networks.\n*   **Applicable to Different Problems:** GBDT can be used for classification, regression, and even ranking tasks. Its flexibility makes it a go-to choice for many machine learning problems.\n\n*   **Feature Importance:** GBDT naturally selects important features during training by focusing on those that reduce the most error. This implicit feature selection is useful when dealing with high-dimensional data.\n*   **Automatic Handling of Irrelevant Features:** By focusing on areas where the model performs poorly, GBDT downweights irrelevant or noisy features without explicit feature elimination methods.\n\n*   **Missing Values Tolerance:** GBDT can handle missing values quite effectively by splitting on missing data as part of the decision-making process, reducing the need for imputation.\n\n*   **Minimal Data Transformation:** GBDT does not require heavy transformations like normalization, standardization, or one-hot encoding for categorical variables, making it easier to implement on raw data compared to other algorithms.\n\n*   **Out-of-the-box Performance:** GBDT algorithms, particularly modern implementations like XGBoost, LightGBM, and CatBoost, often perform reasonably well with default settings. With fine-tuning, they can be pushed to achieve very high performance.\n\n*   **Combining Weak Learners:** GBDT combines multiple decision trees (weak learners), leading to improved generalization by reducing variance and bias compared to a single decision tree.\n\n#### Cons of GBDT\n\n1.  **Computationally Expensive:**\n    *   **High Training Time:** GBDT builds trees sequentially, meaning each tree depends on the results of the previous one. This sequential nature increases training time, especially on large datasets.\n    *   **Memory Consumption:** Due to the large number of trees generated in the boosting process, GBDT can require significant memory resources, particularly if the depth of trees is large.\n2.  **Sensitive to Hyperparameters:**\n    *   **Tuning Complexity:** While GBDT can perform well out of the box, fine-tuning is often required to get the best performance. Key hyperparameters like learning rate, number of trees, tree depth, and minimum samples per split need careful optimization.\n    *   **Risk of Overfitting:** If the number of trees is too high or the learning rate is too low, the model can overfit to the training data. Thus, finding a good balance between model complexity and regularization is crucial.\n3.  **Difficult to Interpret:**\n    *   **Black Box Nature:** Although decision trees are relatively interpretable, an ensemble of hundreds or thousands of trees is much harder to interpret. This makes GBDT less explainable than simpler models like linear regression or a single decision tree.\n    *   **Harder for Stakeholders to Understand:** In real-world applications, where explainability is important (e.g., in healthcare or finance), GBDT models may be difficult to justify to non-technical stakeholders.\n4.  **Lack of Online Learning Capability:**\n    *   **Cannot Learn Incrementally:** GBDT models are trained in batches, and once trained, they cannot easily accommodate new data without retraining from scratch. This makes them unsuitable for real-time learning or applications requiring frequent model updates.\n5.  **Sensitivity to Noisy Data:**\n    *   **Noise Amplification:** GBDT can sometimes amplify the effects of noise in the data. Since each tree attempts to fix errors made by the previous tree, any overfitting to noisy patterns can propagate through the model.\n6.  **Requires Careful Handling of Imbalanced Data:**\n    *   **Less Effective on Imbalanced Datasets:** GBDT does not inherently handle class imbalances well. Special techniques like adjusting the loss function, using weighted data, or applying sampling strategies are often needed to mitigate this issue.\n7.  **Long Inference Times:**\n    *   **Prediction Speed:** GBDT’s prediction speed can be slow, especially with a large number of trees or deep trees. This can make it less suitable for low-latency applications, where real-time or near-real-time predictions are required.\n8.  **Limited Extrapolation Beyond Training Data:**\n    *   **Poor Extrapolation:** Like decision trees, GBDT models struggle with data points that fall outside the range of the training data (extrapolation). For example, they are not well-suited for problems where future trends need to be predicted based on past data (e.g., time series forecasting with far horizons).\n\n*   **High Training Time:** GBDT builds trees sequentially, meaning each tree depends on the results of the previous one. This sequential nature increases training time, especially on large datasets.\n*   **Memory Consumption:** Due to the large number of trees generated in the boosting process, GBDT can require significant memory resources, particularly if the depth of trees is large.\n\n*   **Tuning Complexity:** While GBDT can perform well out of the box, fine-tuning is often required to get the best performance. Key hyperparameters like learning rate, number of trees, tree depth, and minimum samples per split need careful optimization.\n*   **Risk of Overfitting:** If the number of trees is too high or the learning rate is too low, the model can overfit to the training data. Thus, finding a good balance between model complexity and regularization is crucial.\n\n*   **Black Box Nature:** Although decision trees are relatively interpretable, an ensemble of hundreds or thousands of trees is much harder to interpret. This makes GBDT less explainable than simpler models like linear regression or a single decision tree.\n*   **Harder for Stakeholders to Understand:** In real-world applications, where explainability is important (e.g., in healthcare or finance), GBDT models may be difficult to justify to non-technical stakeholders.\n\n*   **Cannot Learn Incrementally:** GBDT models are trained in batches, and once trained, they cannot easily accommodate new data without retraining from scratch. This makes them unsuitable for real-time learning or applications requiring frequent model updates.\n\n*   **Noise Amplification:** GBDT can sometimes amplify the effects of noise in the data. Since each tree attempts to fix errors made by the previous tree, any overfitting to noisy patterns can propagate through the model.\n\n*   **Less Effective on Imbalanced Datasets:** GBDT does not inherently handle class imbalances well. Special techniques like adjusting the loss function, using weighted data, or applying sampling strategies are often needed to mitigate this issue.\n\n*   **Prediction Speed:** GBDT’s prediction speed can be slow, especially with a large number of trees or deep trees. This can make it less suitable for low-latency applications, where real-time or near-real-time predictions are required.\n\n*   **Poor Extrapolation:** Like decision trees, GBDT models struggle with data points that fall outside the range of the training data (extrapolation). For example, they are not well-suited for problems where future trends need to be predicted based on past data (e.g., time series forecasting with far horizons).",
      "order": 225,
      "orderInChapter": 26,
      "difficulty": 5,
      "estimatedMinutes": 8,
      "tags": [
        "practice",
        "neural network",
        "machine learning",
        "optimization",
        "loss function",
        "regularization",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1594,
        "contentLength": 13135
      },
      "nextCards": [
        "ai-interview-why-are-gbdts-highly-effective-with-sparse-data-226",
        "ai-interview-why-are-gradient-boosting-decision-trees-inefficie-227"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-boosting-9",
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32",
        "ai-decision-trees-and-ensemble-methods-can-decision-trees-be-fine-tuned-ie-do-they-have-i-18",
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-deepseek-R1-mixture-of-experts-moe-2"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-pros-and-cons-of-gradient-boosting-decision-trees?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-are-gbdts-highly-effective-with-sparse-data-226",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Why are GBDTs Highly Effective with Sparse Data?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>GBDTs are highly effective with sparse data, which is a common scenario in recommender systems. Sparse data arises because not all users interact with all items, leading to a matrix where most entries are empty or zero (the interaction matrix). Sparse data is often composed of categorical features that are one-hot encoded or indicator variables for specific interactions, such as a user clicking on or purchasing an item. Details below:</p>\n\n    <ol>\n      <li>\n        <p><strong>Handling of Categorical Features</strong>: GBDTs can handle sparse data by splitting decision trees based on subsets of categorical features (e.g., item category, user age group, device type) without needing to densify the data. Unlike models that require continuous data or complex transformations, GBDTs can process one-hot encoded categorical features directly, which is useful for large and sparse interaction matrices.</p>\n      </li>\n      <li>\n        <p><strong>Robust to Missing Values</strong>: GBDTs can handle missing data natively. In sparse matrices, many features may be missing or set to zero. GBDT algorithms like XGBoost, LightGBM, and CatBoost include mechanisms to split nodes based on missing values or treat missing values as a distinct feature. This makes them robust and efficient when dealing with datasets where not every feature is fully populated, which is common in recommender systems.</p>\n      </li>\n      <li>\n        <p><strong>Automatic Feature Selection</strong>: GBDTs are naturally good at ignoring irrelevant or less informative features. In sparse data settings, many features (e.g., certain user interactions) might not contribute significantly to the predictive power of the model. GBDTs can automatically focus on the features that provide meaningful splits in the data, effectively managing sparsity without overfitting to noise.</p>\n      </li>\n      <li>\n        <p><strong>Non-linear Interactions</strong>: GBDTs excel in capturing complex, non-linear relationships between sparse features. For example, a user’s interaction with an item might depend on specific, rare combinations of attributes (like purchasing behavior in a specific geographic location for a particular product type). GBDTs can learn these non-linear patterns without needing extensive feature engineering.</p>\n      </li>\n    </ol>\n  </li>\n</ul>\n<p>GBDTs are highly effective with sparse data, which is a common scenario in recommender systems. Sparse data arises because not all users interact with all items, leading to a matrix where most entries are empty or zero (the interaction matrix). Sparse data is often composed of categorical features that are one-hot encoded or indicator variables for specific interactions, such as a user clicking on or purchasing an item. Details below:</p>\n<ol>\n      <li>\n        <p><strong>Handling of Categorical Features</strong>: GBDTs can handle sparse data by splitting decision trees based on subsets of categorical features (e.g., item category, user age group, device type) without needing to densify the data. Unlike models that require continuous data or complex transformations, GBDTs can process one-hot encoded categorical features directly, which is useful for large and sparse interaction matrices.</p>\n      </li>\n      <li>\n        <p><strong>Robust to Missing Values</strong>: GBDTs can handle missing data natively. In sparse matrices, many features may be missing or set to zero. GBDT algorithms like XGBoost, LightGBM, and CatBoost include mechanisms to split nodes based on missing values or treat missing values as a distinct feature. This makes them robust and efficient when dealing with datasets where not every feature is fully populated, which is common in recommender systems.</p>\n      </li>\n      <li>\n        <p><strong>Automatic Feature Selection</strong>: GBDTs are naturally good at ignoring irrelevant or less informative features. In sparse data settings, many features (e.g., certain user interactions) might not contribute significantly to the predictive power of the model. GBDTs can automatically focus on the features that provide meaningful splits in the data, effectively managing sparsity without overfitting to noise.</p>\n      </li>\n      <li>\n        <p><strong>Non-linear Interactions</strong>: GBDTs excel in capturing complex, non-linear relationships between sparse features. For example, a user’s interaction with an item might depend on specific, rare combinations of attributes (like purchasing behavior in a specific geographic location for a particular product type). GBDTs can learn these non-linear patterns without needing extensive feature engineering.</p>\n      </li>\n    </ol>\n<p><strong>Handling of Categorical Features</strong>: GBDTs can handle sparse data by splitting decision trees based on subsets of categorical features (e.g., item category, user age group, device type) without needing to densify the data. Unlike models that require continuous data or complex transformations, GBDTs can process one-hot encoded categorical features directly, which is useful for large and sparse interaction matrices.</p>\n<p><strong>Robust to Missing Values</strong>: GBDTs can handle missing data natively. In sparse matrices, many features may be missing or set to zero. GBDT algorithms like XGBoost, LightGBM, and CatBoost include mechanisms to split nodes based on missing values or treat missing values as a distinct feature. This makes them robust and efficient when dealing with datasets where not every feature is fully populated, which is common in recommender systems.</p>\n<p><strong>Automatic Feature Selection</strong>: GBDTs are naturally good at ignoring irrelevant or less informative features. In sparse data settings, many features (e.g., certain user interactions) might not contribute significantly to the predictive power of the model. GBDTs can automatically focus on the features that provide meaningful splits in the data, effectively managing sparsity without overfitting to noise.</p>\n<p><strong>Non-linear Interactions</strong>: GBDTs excel in capturing complex, non-linear relationships between sparse features. For example, a user’s interaction with an item might depend on specific, rare combinations of attributes (like purchasing behavior in a specific geographic location for a particular product type). GBDTs can learn these non-linear patterns without needing extensive feature engineering.</p>\n<h4 id=\"how-gbdts-handle-sparse-data\">How GBDTs Handle Sparse Data</h4>\n<ol>\n  <li>\n    <p><strong>One-hot Encoding</strong>: GBDTs do not require dense representations of data. Features like user-item interactions can be represented with sparse one-hot encodings, where only a few features are “active” (non-zero) for a given observation. GBDTs can split on any of these one-hot features, allowing them to work directly with the sparse matrix.</p>\n  </li>\n  <li>\n    <p><strong>Efficient Splitting</strong>: During the tree-building process, GBDTs evaluate all possible splits at each node, even when the data is sparse. The decision tree will learn to split on meaningful sparse features, helping the model capture useful patterns from high-dimensional, sparse datasets.</p>\n  </li>\n  <li>\n    <p><strong>Categorical Encoding</strong>: Algorithms like CatBoost are specifically designed to handle categorical variables more efficiently than traditional one-hot encoding, further improving GBDTs’ performance on sparse data by reducing dimensionality and preserving information.</p>\n  </li>\n</ol>\n<p><strong>One-hot Encoding</strong>: GBDTs do not require dense representations of data. Features like user-item interactions can be represented with sparse one-hot encodings, where only a few features are “active” (non-zero) for a given observation. GBDTs can split on any of these one-hot features, allowing them to work directly with the sparse matrix.</p>\n<p><strong>Efficient Splitting</strong>: During the tree-building process, GBDTs evaluate all possible splits at each node, even when the data is sparse. The decision tree will learn to split on meaningful sparse features, helping the model capture useful patterns from high-dimensional, sparse datasets.</p>\n<p><strong>Categorical Encoding</strong>: Algorithms like CatBoost are specifically designed to handle categorical variables more efficiently than traditional one-hot encoding, further improving GBDTs’ performance on sparse data by reducing dimensionality and preserving information.</p>",
      "contentMarkdown": "*   GBDTs are highly effective with sparse data, which is a common scenario in recommender systems. Sparse data arises because not all users interact with all items, leading to a matrix where most entries are empty or zero (the interaction matrix). Sparse data is often composed of categorical features that are one-hot encoded or indicator variables for specific interactions, such as a user clicking on or purchasing an item. Details below:\n    \n    1.  **Handling of Categorical Features**: GBDTs can handle sparse data by splitting decision trees based on subsets of categorical features (e.g., item category, user age group, device type) without needing to densify the data. Unlike models that require continuous data or complex transformations, GBDTs can process one-hot encoded categorical features directly, which is useful for large and sparse interaction matrices.\n        \n    2.  **Robust to Missing Values**: GBDTs can handle missing data natively. In sparse matrices, many features may be missing or set to zero. GBDT algorithms like XGBoost, LightGBM, and CatBoost include mechanisms to split nodes based on missing values or treat missing values as a distinct feature. This makes them robust and efficient when dealing with datasets where not every feature is fully populated, which is common in recommender systems.\n        \n    3.  **Automatic Feature Selection**: GBDTs are naturally good at ignoring irrelevant or less informative features. In sparse data settings, many features (e.g., certain user interactions) might not contribute significantly to the predictive power of the model. GBDTs can automatically focus on the features that provide meaningful splits in the data, effectively managing sparsity without overfitting to noise.\n        \n    4.  **Non-linear Interactions**: GBDTs excel in capturing complex, non-linear relationships between sparse features. For example, a user’s interaction with an item might depend on specific, rare combinations of attributes (like purchasing behavior in a specific geographic location for a particular product type). GBDTs can learn these non-linear patterns without needing extensive feature engineering.\n        \n\nGBDTs are highly effective with sparse data, which is a common scenario in recommender systems. Sparse data arises because not all users interact with all items, leading to a matrix where most entries are empty or zero (the interaction matrix). Sparse data is often composed of categorical features that are one-hot encoded or indicator variables for specific interactions, such as a user clicking on or purchasing an item. Details below:\n\n1.  **Handling of Categorical Features**: GBDTs can handle sparse data by splitting decision trees based on subsets of categorical features (e.g., item category, user age group, device type) without needing to densify the data. Unlike models that require continuous data or complex transformations, GBDTs can process one-hot encoded categorical features directly, which is useful for large and sparse interaction matrices.\n    \n2.  **Robust to Missing Values**: GBDTs can handle missing data natively. In sparse matrices, many features may be missing or set to zero. GBDT algorithms like XGBoost, LightGBM, and CatBoost include mechanisms to split nodes based on missing values or treat missing values as a distinct feature. This makes them robust and efficient when dealing with datasets where not every feature is fully populated, which is common in recommender systems.\n    \n3.  **Automatic Feature Selection**: GBDTs are naturally good at ignoring irrelevant or less informative features. In sparse data settings, many features (e.g., certain user interactions) might not contribute significantly to the predictive power of the model. GBDTs can automatically focus on the features that provide meaningful splits in the data, effectively managing sparsity without overfitting to noise.\n    \n4.  **Non-linear Interactions**: GBDTs excel in capturing complex, non-linear relationships between sparse features. For example, a user’s interaction with an item might depend on specific, rare combinations of attributes (like purchasing behavior in a specific geographic location for a particular product type). GBDTs can learn these non-linear patterns without needing extensive feature engineering.\n    \n\n**Handling of Categorical Features**: GBDTs can handle sparse data by splitting decision trees based on subsets of categorical features (e.g., item category, user age group, device type) without needing to densify the data. Unlike models that require continuous data or complex transformations, GBDTs can process one-hot encoded categorical features directly, which is useful for large and sparse interaction matrices.\n\n**Robust to Missing Values**: GBDTs can handle missing data natively. In sparse matrices, many features may be missing or set to zero. GBDT algorithms like XGBoost, LightGBM, and CatBoost include mechanisms to split nodes based on missing values or treat missing values as a distinct feature. This makes them robust and efficient when dealing with datasets where not every feature is fully populated, which is common in recommender systems.\n\n**Automatic Feature Selection**: GBDTs are naturally good at ignoring irrelevant or less informative features. In sparse data settings, many features (e.g., certain user interactions) might not contribute significantly to the predictive power of the model. GBDTs can automatically focus on the features that provide meaningful splits in the data, effectively managing sparsity without overfitting to noise.\n\n**Non-linear Interactions**: GBDTs excel in capturing complex, non-linear relationships between sparse features. For example, a user’s interaction with an item might depend on specific, rare combinations of attributes (like purchasing behavior in a specific geographic location for a particular product type). GBDTs can learn these non-linear patterns without needing extensive feature engineering.\n\n#### How GBDTs Handle Sparse Data\n\n1.  **One-hot Encoding**: GBDTs do not require dense representations of data. Features like user-item interactions can be represented with sparse one-hot encodings, where only a few features are “active” (non-zero) for a given observation. GBDTs can split on any of these one-hot features, allowing them to work directly with the sparse matrix.\n    \n2.  **Efficient Splitting**: During the tree-building process, GBDTs evaluate all possible splits at each node, even when the data is sparse. The decision tree will learn to split on meaningful sparse features, helping the model capture useful patterns from high-dimensional, sparse datasets.\n    \n3.  **Categorical Encoding**: Algorithms like CatBoost are specifically designed to handle categorical variables more efficiently than traditional one-hot encoding, further improving GBDTs’ performance on sparse data by reducing dimensionality and preserving information.\n    \n\n**One-hot Encoding**: GBDTs do not require dense representations of data. Features like user-item interactions can be represented with sparse one-hot encodings, where only a few features are “active” (non-zero) for a given observation. GBDTs can split on any of these one-hot features, allowing them to work directly with the sparse matrix.\n\n**Efficient Splitting**: During the tree-building process, GBDTs evaluate all possible splits at each node, even when the data is sparse. The decision tree will learn to split on meaningful sparse features, helping the model capture useful patterns from high-dimensional, sparse datasets.\n\n**Categorical Encoding**: Algorithms like CatBoost are specifically designed to handle categorical variables more efficiently than traditional one-hot encoding, further improving GBDTs’ performance on sparse data by reducing dimensionality and preserving information.",
      "order": 226,
      "orderInChapter": 27,
      "difficulty": 4,
      "estimatedMinutes": 6,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1112,
        "contentLength": 8498
      },
      "nextCards": [
        "ai-interview-why-are-gradient-boosting-decision-trees-inefficie-227",
        "ai-interview-are-the-topdeep-layers-of-the-model-closer-to-the--228"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-are-gbdts-highly-effective-with-sparse-data?",
      "scrapedAt": "2025-12-28T11:58:12.846Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-are-gradient-boosting-decision-trees-inefficie-227",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Why are Gradient Boosting Decision Trees Inefficient for Continual/Online Learning?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Gradient Boosting Decision Trees are inefficient for continual or online learning, which is a significant drawback in dynamic environments like recommender systems. In many real-world recommendation applications, user preferences and item availability change frequently. Continual or online learning refers to a model’s ability to adapt to new data in real time, without retraining from scratch. GBDTs, however, are</li>\n  <li>\n    <p>While GBDTs are powerful for handling sparse data and structured features, their inefficiency in continual or online learning environments limits their application in scenarios that require real-time adaptability. This inefficiency arises because GBDTs are typically batch learners that operate on static datasets and need to be retrained fully to incorporate new information. The computational demands of retraining make them less ideal for fast-evolving recommender systems where new data continuously flows in. Details below:</p>\n\n    <ol>\n      <li>\n        <p><strong>Batch Learning Nature</strong>: GBDTs are built in stages by sequentially adding trees, where each new tree corrects the errors made by the previous ones. This is fundamentally a batch learning process because the model is trained on the full dataset, and any new data requires retraining from scratch or restarting the boosting process. This retraining is computationally expensive and time-consuming in systems where new interactions (e.g., user clicks or purchases) are constantly streaming in.</p>\n      </li>\n      <li>\n        <p><strong>Lack of Incremental Updates</strong>: Unlike algorithms such as matrix factorization or certain neural network architectures, GBDTs do not have native support for <strong>incremental learning</strong> (i.e., updating the model without retraining). For every new batch of data, the entire model must be updated to incorporate new patterns, which is not feasible in environments where immediate updates are required.</p>\n      </li>\n      <li>\n        <p><strong>High Computational Overhead</strong>: Training GBDTs involves iterative rounds of tree building, where each tree is constructed based on the residuals of the previous iteration. This requires accessing the entire dataset, making it costly to retrain in real-time or with frequently arriving new data. For example, if a recommender system sees new interactions every minute, retraining a GBDT on each new batch of data would significantly slow down the system’s ability to make timely recommendations.</p>\n      </li>\n    </ol>\n  </li>\n</ul>\n<p>While GBDTs are powerful for handling sparse data and structured features, their inefficiency in continual or online learning environments limits their application in scenarios that require real-time adaptability. This inefficiency arises because GBDTs are typically batch learners that operate on static datasets and need to be retrained fully to incorporate new information. The computational demands of retraining make them less ideal for fast-evolving recommender systems where new data continuously flows in. Details below:</p>\n<ol>\n      <li>\n        <p><strong>Batch Learning Nature</strong>: GBDTs are built in stages by sequentially adding trees, where each new tree corrects the errors made by the previous ones. This is fundamentally a batch learning process because the model is trained on the full dataset, and any new data requires retraining from scratch or restarting the boosting process. This retraining is computationally expensive and time-consuming in systems where new interactions (e.g., user clicks or purchases) are constantly streaming in.</p>\n      </li>\n      <li>\n        <p><strong>Lack of Incremental Updates</strong>: Unlike algorithms such as matrix factorization or certain neural network architectures, GBDTs do not have native support for <strong>incremental learning</strong> (i.e., updating the model without retraining). For every new batch of data, the entire model must be updated to incorporate new patterns, which is not feasible in environments where immediate updates are required.</p>\n      </li>\n      <li>\n        <p><strong>High Computational Overhead</strong>: Training GBDTs involves iterative rounds of tree building, where each tree is constructed based on the residuals of the previous iteration. This requires accessing the entire dataset, making it costly to retrain in real-time or with frequently arriving new data. For example, if a recommender system sees new interactions every minute, retraining a GBDT on each new batch of data would significantly slow down the system’s ability to make timely recommendations.</p>\n      </li>\n    </ol>\n<p><strong>Batch Learning Nature</strong>: GBDTs are built in stages by sequentially adding trees, where each new tree corrects the errors made by the previous ones. This is fundamentally a batch learning process because the model is trained on the full dataset, and any new data requires retraining from scratch or restarting the boosting process. This retraining is computationally expensive and time-consuming in systems where new interactions (e.g., user clicks or purchases) are constantly streaming in.</p>\n<p><strong>Lack of Incremental Updates</strong>: Unlike algorithms such as matrix factorization or certain neural network architectures, GBDTs do not have native support for <strong>incremental learning</strong> (i.e., updating the model without retraining). For every new batch of data, the entire model must be updated to incorporate new patterns, which is not feasible in environments where immediate updates are required.</p>\n<p><strong>High Computational Overhead</strong>: Training GBDTs involves iterative rounds of tree building, where each tree is constructed based on the residuals of the previous iteration. This requires accessing the entire dataset, making it costly to retrain in real-time or with frequently arriving new data. For example, if a recommender system sees new interactions every minute, retraining a GBDT on each new batch of data would significantly slow down the system’s ability to make timely recommendations.</p>\n<h4 id=\"how-this-inefficiency-manifests\">How This Inefficiency Manifests</h4>\n<ol>\n  <li>\n    <p><strong>Latency in Real-Time Systems</strong>: In online or real-time recommender systems, the goal is to quickly adapt to a user’s most recent interactions (e.g., purchases, clicks) to improve the accuracy of recommendations. GBDTs cannot efficiently process this continual stream of new data without retraining the model, leading to latency issues in deploying real-time updates.</p>\n  </li>\n  <li>\n    <p><strong>Resource-Intensive Retraining</strong>: In scenarios where retraining is done to accommodate new data, the process can become computationally expensive. Large-scale recommender systems with millions of users and items can’t afford to constantly retrain GBDTs without slowing down the recommendation process. In contrast, methods like stochastic gradient descent (SGD) in matrix factorization or online learning variants of neural networks can update model parameters with each new data point, providing more agile learning capabilities.</p>\n  </li>\n</ol>\n<p><strong>Latency in Real-Time Systems</strong>: In online or real-time recommender systems, the goal is to quickly adapt to a user’s most recent interactions (e.g., purchases, clicks) to improve the accuracy of recommendations. GBDTs cannot efficiently process this continual stream of new data without retraining the model, leading to latency issues in deploying real-time updates.</p>\n<p><strong>Resource-Intensive Retraining</strong>: In scenarios where retraining is done to accommodate new data, the process can become computationally expensive. Large-scale recommender systems with millions of users and items can’t afford to constantly retrain GBDTs without slowing down the recommendation process. In contrast, methods like stochastic gradient descent (SGD) in matrix factorization or online learning variants of neural networks can update model parameters with each new data point, providing more agile learning capabilities.</p>\n<h4 id=\"workarounds-and-alternatives\">Workarounds and Alternatives</h4>\n<ul>\n  <li>While GBDTs are inherently inefficient for online learning, several workarounds are sometimes employed:\n    <ul>\n      <li><strong>Mini-batch Retraining</strong>: Instead of retraining the model on every new interaction, GBDTs can be retrained periodically (e.g., once every hour or day) in a batch-processing manner. This reduces computational load but sacrifices immediate responsiveness.</li>\n      <li><strong>Hybrid Models</strong>: To tackle the inefficiency of GBDTs in online learning, many recommender systems employ a hybrid approach, where GBDTs are used in combination with models that can perform real-time updates (e.g., online collaborative filtering models or reinforcement learning-based models). GBDTs can handle complex feature interactions offline, while the other models adjust dynamically to recent interactions.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>Mini-batch Retraining</strong>: Instead of retraining the model on every new interaction, GBDTs can be retrained periodically (e.g., once every hour or day) in a batch-processing manner. This reduces computational load but sacrifices immediate responsiveness.</li>\n      <li><strong>Hybrid Models</strong>: To tackle the inefficiency of GBDTs in online learning, many recommender systems employ a hybrid approach, where GBDTs are used in combination with models that can perform real-time updates (e.g., online collaborative filtering models or reinforcement learning-based models). GBDTs can handle complex feature interactions offline, while the other models adjust dynamically to recent interactions.</li>\n    </ul>",
      "contentMarkdown": "*   Gradient Boosting Decision Trees are inefficient for continual or online learning, which is a significant drawback in dynamic environments like recommender systems. In many real-world recommendation applications, user preferences and item availability change frequently. Continual or online learning refers to a model’s ability to adapt to new data in real time, without retraining from scratch. GBDTs, however, are\n*   While GBDTs are powerful for handling sparse data and structured features, their inefficiency in continual or online learning environments limits their application in scenarios that require real-time adaptability. This inefficiency arises because GBDTs are typically batch learners that operate on static datasets and need to be retrained fully to incorporate new information. The computational demands of retraining make them less ideal for fast-evolving recommender systems where new data continuously flows in. Details below:\n    \n    1.  **Batch Learning Nature**: GBDTs are built in stages by sequentially adding trees, where each new tree corrects the errors made by the previous ones. This is fundamentally a batch learning process because the model is trained on the full dataset, and any new data requires retraining from scratch or restarting the boosting process. This retraining is computationally expensive and time-consuming in systems where new interactions (e.g., user clicks or purchases) are constantly streaming in.\n        \n    2.  **Lack of Incremental Updates**: Unlike algorithms such as matrix factorization or certain neural network architectures, GBDTs do not have native support for **incremental learning** (i.e., updating the model without retraining). For every new batch of data, the entire model must be updated to incorporate new patterns, which is not feasible in environments where immediate updates are required.\n        \n    3.  **High Computational Overhead**: Training GBDTs involves iterative rounds of tree building, where each tree is constructed based on the residuals of the previous iteration. This requires accessing the entire dataset, making it costly to retrain in real-time or with frequently arriving new data. For example, if a recommender system sees new interactions every minute, retraining a GBDT on each new batch of data would significantly slow down the system’s ability to make timely recommendations.\n        \n\nWhile GBDTs are powerful for handling sparse data and structured features, their inefficiency in continual or online learning environments limits their application in scenarios that require real-time adaptability. This inefficiency arises because GBDTs are typically batch learners that operate on static datasets and need to be retrained fully to incorporate new information. The computational demands of retraining make them less ideal for fast-evolving recommender systems where new data continuously flows in. Details below:\n\n1.  **Batch Learning Nature**: GBDTs are built in stages by sequentially adding trees, where each new tree corrects the errors made by the previous ones. This is fundamentally a batch learning process because the model is trained on the full dataset, and any new data requires retraining from scratch or restarting the boosting process. This retraining is computationally expensive and time-consuming in systems where new interactions (e.g., user clicks or purchases) are constantly streaming in.\n    \n2.  **Lack of Incremental Updates**: Unlike algorithms such as matrix factorization or certain neural network architectures, GBDTs do not have native support for **incremental learning** (i.e., updating the model without retraining). For every new batch of data, the entire model must be updated to incorporate new patterns, which is not feasible in environments where immediate updates are required.\n    \n3.  **High Computational Overhead**: Training GBDTs involves iterative rounds of tree building, where each tree is constructed based on the residuals of the previous iteration. This requires accessing the entire dataset, making it costly to retrain in real-time or with frequently arriving new data. For example, if a recommender system sees new interactions every minute, retraining a GBDT on each new batch of data would significantly slow down the system’s ability to make timely recommendations.\n    \n\n**Batch Learning Nature**: GBDTs are built in stages by sequentially adding trees, where each new tree corrects the errors made by the previous ones. This is fundamentally a batch learning process because the model is trained on the full dataset, and any new data requires retraining from scratch or restarting the boosting process. This retraining is computationally expensive and time-consuming in systems where new interactions (e.g., user clicks or purchases) are constantly streaming in.\n\n**Lack of Incremental Updates**: Unlike algorithms such as matrix factorization or certain neural network architectures, GBDTs do not have native support for **incremental learning** (i.e., updating the model without retraining). For every new batch of data, the entire model must be updated to incorporate new patterns, which is not feasible in environments where immediate updates are required.\n\n**High Computational Overhead**: Training GBDTs involves iterative rounds of tree building, where each tree is constructed based on the residuals of the previous iteration. This requires accessing the entire dataset, making it costly to retrain in real-time or with frequently arriving new data. For example, if a recommender system sees new interactions every minute, retraining a GBDT on each new batch of data would significantly slow down the system’s ability to make timely recommendations.\n\n#### How This Inefficiency Manifests\n\n1.  **Latency in Real-Time Systems**: In online or real-time recommender systems, the goal is to quickly adapt to a user’s most recent interactions (e.g., purchases, clicks) to improve the accuracy of recommendations. GBDTs cannot efficiently process this continual stream of new data without retraining the model, leading to latency issues in deploying real-time updates.\n    \n2.  **Resource-Intensive Retraining**: In scenarios where retraining is done to accommodate new data, the process can become computationally expensive. Large-scale recommender systems with millions of users and items can’t afford to constantly retrain GBDTs without slowing down the recommendation process. In contrast, methods like stochastic gradient descent (SGD) in matrix factorization or online learning variants of neural networks can update model parameters with each new data point, providing more agile learning capabilities.\n    \n\n**Latency in Real-Time Systems**: In online or real-time recommender systems, the goal is to quickly adapt to a user’s most recent interactions (e.g., purchases, clicks) to improve the accuracy of recommendations. GBDTs cannot efficiently process this continual stream of new data without retraining the model, leading to latency issues in deploying real-time updates.\n\n**Resource-Intensive Retraining**: In scenarios where retraining is done to accommodate new data, the process can become computationally expensive. Large-scale recommender systems with millions of users and items can’t afford to constantly retrain GBDTs without slowing down the recommendation process. In contrast, methods like stochastic gradient descent (SGD) in matrix factorization or online learning variants of neural networks can update model parameters with each new data point, providing more agile learning capabilities.\n\n#### Workarounds and Alternatives\n\n*   While GBDTs are inherently inefficient for online learning, several workarounds are sometimes employed:\n    *   **Mini-batch Retraining**: Instead of retraining the model on every new interaction, GBDTs can be retrained periodically (e.g., once every hour or day) in a batch-processing manner. This reduces computational load but sacrifices immediate responsiveness.\n    *   **Hybrid Models**: To tackle the inefficiency of GBDTs in online learning, many recommender systems employ a hybrid approach, where GBDTs are used in combination with models that can perform real-time updates (e.g., online collaborative filtering models or reinforcement learning-based models). GBDTs can handle complex feature interactions offline, while the other models adjust dynamically to recent interactions.\n\n*   **Mini-batch Retraining**: Instead of retraining the model on every new interaction, GBDTs can be retrained periodically (e.g., once every hour or day) in a batch-processing manner. This reduces computational load but sacrifices immediate responsiveness.\n*   **Hybrid Models**: To tackle the inefficiency of GBDTs in online learning, many recommender systems employ a hybrid approach, where GBDTs are used in combination with models that can perform real-time updates (e.g., online collaborative filtering models or reinforcement learning-based models). GBDTs can handle complex feature interactions offline, while the other models adjust dynamically to recent interactions.",
      "order": 227,
      "orderInChapter": 28,
      "difficulty": 4,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "neural network",
        "reinforcement learning",
        "gradient descent"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1284,
        "contentLength": 9824
      },
      "nextCards": [
        "ai-interview-are-the-topdeep-layers-of-the-model-closer-to-the--228",
        "ai-interview-in-the-context-of-fine-tuning-deep-neural-networks-229"
      ],
      "relatedCards": [
        "ai-diffusion-models-general-overview-4",
        "ai-reinforcement-learning-deep-reinforcement-learning-15",
        "ai-agentic-RL-neural-guided-search-policy-priors-and-value-model-38",
        "ai-reinforcement-learning-deep-actorcritic-methods-18",
        "ai-deepseek-R1-stage-2-rl-5"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-are-gradient-boosting-decision-trees-inefficient-for-continual/online-learning?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-are-the-topdeep-layers-of-the-model-closer-to-the--228",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Are the Top/deep Layers of the Model Closer to the Final Layer or the First Layer?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>In the context of deep neural networks, the <strong>top/deep layers</strong> refer to those layers that are closer to the <strong>final layer</strong> (the output layer), not the first layer (the input layer).</p>\n  </li>\n  <li>\n    <p>Here’s how this terminology is typically understood:</p>\n\n    <ul>\n      <li><strong>Top/Deep Layers</strong>: These are the higher, more specialized layers closer to the output of the model. They learn high-level, task-specific features and representations, such as object classes in image recognition or specific linguistic patterns in text classification.</li>\n      <li><strong>Bottom Layers</strong>: These are the layers closest to the input. They usually capture more general, lower-level features, such as edges, textures, or general linguistic embeddings. These layers are often more universal across tasks and datasets.</li>\n    </ul>\n  </li>\n</ul>\n<p>In the context of deep neural networks, the <strong>top/deep layers</strong> refer to those layers that are closer to the <strong>final layer</strong> (the output layer), not the first layer (the input layer).</p>\n<p>Here’s how this terminology is typically understood:</p>\n<ul>\n      <li><strong>Top/Deep Layers</strong>: These are the higher, more specialized layers closer to the output of the model. They learn high-level, task-specific features and representations, such as object classes in image recognition or specific linguistic patterns in text classification.</li>\n      <li><strong>Bottom Layers</strong>: These are the layers closest to the input. They usually capture more general, lower-level features, such as edges, textures, or general linguistic embeddings. These layers are often more universal across tasks and datasets.</li>\n    </ul>\n<h4 id=\"why-fine-tuning-often-focuses-on-topdeep-layers\">Why Fine-Tuning Often Focuses on Top/Deep Layers</h4>\n<ul>\n  <li>When fine-tuning a pre-trained model, the top/deep layers are typically modified because:\n    <ul>\n      <li>They contain more task-specific information from the original training dataset.</li>\n      <li>Adjusting these layers helps adapt the model to the new task without disrupting the foundational, general features learned by the lower layers.</li>\n    </ul>\n  </li>\n  <li>Freezing the bottom layers while fine-tuning the top/deep layers is common practice, as it can reduce overfitting while allowing the model to adjust to new data.</li>\n</ul>\n<ul>\n      <li>They contain more task-specific information from the original training dataset.</li>\n      <li>Adjusting these layers helps adapt the model to the new task without disrupting the foundational, general features learned by the lower layers.</li>\n    </ul>",
      "contentMarkdown": "*   In the context of deep neural networks, the **top/deep layers** refer to those layers that are closer to the **final layer** (the output layer), not the first layer (the input layer).\n    \n*   Here’s how this terminology is typically understood:\n    \n    *   **Top/Deep Layers**: These are the higher, more specialized layers closer to the output of the model. They learn high-level, task-specific features and representations, such as object classes in image recognition or specific linguistic patterns in text classification.\n    *   **Bottom Layers**: These are the layers closest to the input. They usually capture more general, lower-level features, such as edges, textures, or general linguistic embeddings. These layers are often more universal across tasks and datasets.\n\nIn the context of deep neural networks, the **top/deep layers** refer to those layers that are closer to the **final layer** (the output layer), not the first layer (the input layer).\n\nHere’s how this terminology is typically understood:\n\n*   **Top/Deep Layers**: These are the higher, more specialized layers closer to the output of the model. They learn high-level, task-specific features and representations, such as object classes in image recognition or specific linguistic patterns in text classification.\n*   **Bottom Layers**: These are the layers closest to the input. They usually capture more general, lower-level features, such as edges, textures, or general linguistic embeddings. These layers are often more universal across tasks and datasets.\n\n#### Why Fine-Tuning Often Focuses on Top/Deep Layers\n\n*   When fine-tuning a pre-trained model, the top/deep layers are typically modified because:\n    *   They contain more task-specific information from the original training dataset.\n    *   Adjusting these layers helps adapt the model to the new task without disrupting the foundational, general features learned by the lower layers.\n*   Freezing the bottom layers while fine-tuning the top/deep layers is common practice, as it can reduce overfitting while allowing the model to adjust to new data.\n\n*   They contain more task-specific information from the original training dataset.\n*   Adjusting these layers helps adapt the model to the new task without disrupting the foundational, general features learned by the lower layers.",
      "order": 228,
      "orderInChapter": 29,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "embedding",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 342,
        "contentLength": 2714
      },
      "nextCards": [
        "ai-interview-in-the-context-of-fine-tuning-deep-neural-networks-229",
        "ai-interview-how-does-adding-a-component-to-the-loss-term-preve-230"
      ],
      "relatedCards": [
        "ai-word-vectors-what-does-the-continuous-in-word2vecs-continuous-b-32",
        "ai-word-vectors-how-are-word2vec-glove-and-fasttext-co-occurrence--33",
        "ai-factuality-in-LLMs-dynamic-and-temporal-factuality-18",
        "ai-context-length-extension-ntk-aware-method-4",
        "ai-model-compression-pruning-workflow-35"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#are-the-top/deep-layers-of-the-model-closer-to-the-final-layer-or-the-first-layer?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-in-the-context-of-fine-tuning-deep-neural-networks-229",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "In the Context of Fine-tuning Deep Neural Networks, Can Increasing the Number of Layers Make the Model More Prone to Overfitting?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>In deep neural networks, increasing the number of layers can make the model more prone to overfitting, especially during fine-tuning. Here’s why:</p>\n\n    <ol>\n      <li>\n        <p><strong>Increased Model Capacity</strong>: Adding more layers increases the model’s capacity to learn complex patterns. While this can improve performance on the training set, it can lead the model to “memorize” the training data rather than generalize from it, making it less effective on unseen data.</p>\n      </li>\n      <li>\n        <p><strong>More Parameters</strong>: With more layers, the number of parameters grows significantly. Fine-tuning such a large model can easily lead to overfitting if there’s insufficient data or if the data lacks variability. In cases of limited data, the model might latch onto noisy patterns that aren’t generalizable.</p>\n      </li>\n      <li>\n        <p><strong>Gradient Amplification and Feature Sensitivity</strong>: When fine-tuning deeper layers, gradients tend to amplify, which can make the model overly sensitive to training data. This sensitivity can result in overfitting to specific patterns in the training set that don’t generalize to the test set.</p>\n      </li>\n      <li>\n        <p><strong>Less Regularization on Lower Layers</strong>: Fine-tuning more layers often means adjusting lower layers that originally learned more general features (like edges and textures in images). By fine-tuning them, these layers might lose their general-purpose features, over-specializing them to the fine-tuning dataset.</p>\n      </li>\n    </ol>\n  </li>\n</ul>\n<p>In deep neural networks, increasing the number of layers can make the model more prone to overfitting, especially during fine-tuning. Here’s why:</p>\n<ol>\n      <li>\n        <p><strong>Increased Model Capacity</strong>: Adding more layers increases the model’s capacity to learn complex patterns. While this can improve performance on the training set, it can lead the model to “memorize” the training data rather than generalize from it, making it less effective on unseen data.</p>\n      </li>\n      <li>\n        <p><strong>More Parameters</strong>: With more layers, the number of parameters grows significantly. Fine-tuning such a large model can easily lead to overfitting if there’s insufficient data or if the data lacks variability. In cases of limited data, the model might latch onto noisy patterns that aren’t generalizable.</p>\n      </li>\n      <li>\n        <p><strong>Gradient Amplification and Feature Sensitivity</strong>: When fine-tuning deeper layers, gradients tend to amplify, which can make the model overly sensitive to training data. This sensitivity can result in overfitting to specific patterns in the training set that don’t generalize to the test set.</p>\n      </li>\n      <li>\n        <p><strong>Less Regularization on Lower Layers</strong>: Fine-tuning more layers often means adjusting lower layers that originally learned more general features (like edges and textures in images). By fine-tuning them, these layers might lose their general-purpose features, over-specializing them to the fine-tuning dataset.</p>\n      </li>\n    </ol>\n<p><strong>Increased Model Capacity</strong>: Adding more layers increases the model’s capacity to learn complex patterns. While this can improve performance on the training set, it can lead the model to “memorize” the training data rather than generalize from it, making it less effective on unseen data.</p>\n<p><strong>More Parameters</strong>: With more layers, the number of parameters grows significantly. Fine-tuning such a large model can easily lead to overfitting if there’s insufficient data or if the data lacks variability. In cases of limited data, the model might latch onto noisy patterns that aren’t generalizable.</p>\n<p><strong>Gradient Amplification and Feature Sensitivity</strong>: When fine-tuning deeper layers, gradients tend to amplify, which can make the model overly sensitive to training data. This sensitivity can result in overfitting to specific patterns in the training set that don’t generalize to the test set.</p>\n<p><strong>Less Regularization on Lower Layers</strong>: Fine-tuning more layers often means adjusting lower layers that originally learned more general features (like edges and textures in images). By fine-tuning them, these layers might lose their general-purpose features, over-specializing them to the fine-tuning dataset.</p>\n<h4 id=\"mitigating-overfitting-in-fine-tuning\">Mitigating Overfitting in Fine-Tuning</h4>\n<ul>\n  <li>To reduce overfitting in deep networks during fine-tuning:\n    <ul>\n      <li><strong>Use Dropout</strong>: Introduce dropout layers to prevent co-adaptation of neurons.</li>\n      <li><strong>Regularization</strong>: Apply <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-194-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1623\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.99em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1624\"><span class=\"msubsup\" id=\"MathJax-Span-1625\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1626\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mn\" id=\"MathJax-Span-1627\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.066em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-194\">L_2</script> regularization (weight decay) to discourage excessive weights.</li>\n      <li><strong>Layer Freezing</strong>: Fine-tune fewer layers or only the top layers of the model.</li>\n      <li><strong>Data Augmentation</strong>: Expand the effective size of the training dataset by using transformations like cropping, rotation, and color adjustments, especially for image data.</li>\n    </ul>\n  </li>\n  <li>Fine-tuning deep networks is effective, but managing overfitting is crucial, especially with deeper architectures and smaller datasets.</li>\n</ul>\n<ul>\n      <li><strong>Use Dropout</strong>: Introduce dropout layers to prevent co-adaptation of neurons.</li>\n      <li><strong>Regularization</strong>: Apply <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-194-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1623\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.99em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1624\"><span class=\"msubsup\" id=\"MathJax-Span-1625\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1626\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mn\" id=\"MathJax-Span-1627\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.066em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-194\">L_2</script> regularization (weight decay) to discourage excessive weights.</li>\n      <li><strong>Layer Freezing</strong>: Fine-tune fewer layers or only the top layers of the model.</li>\n      <li><strong>Data Augmentation</strong>: Expand the effective size of the training dataset by using transformations like cropping, rotation, and color adjustments, especially for image data.</li>\n    </ul>",
      "contentMarkdown": "*   In deep neural networks, increasing the number of layers can make the model more prone to overfitting, especially during fine-tuning. Here’s why:\n    \n    1.  **Increased Model Capacity**: Adding more layers increases the model’s capacity to learn complex patterns. While this can improve performance on the training set, it can lead the model to “memorize” the training data rather than generalize from it, making it less effective on unseen data.\n        \n    2.  **More Parameters**: With more layers, the number of parameters grows significantly. Fine-tuning such a large model can easily lead to overfitting if there’s insufficient data or if the data lacks variability. In cases of limited data, the model might latch onto noisy patterns that aren’t generalizable.\n        \n    3.  **Gradient Amplification and Feature Sensitivity**: When fine-tuning deeper layers, gradients tend to amplify, which can make the model overly sensitive to training data. This sensitivity can result in overfitting to specific patterns in the training set that don’t generalize to the test set.\n        \n    4.  **Less Regularization on Lower Layers**: Fine-tuning more layers often means adjusting lower layers that originally learned more general features (like edges and textures in images). By fine-tuning them, these layers might lose their general-purpose features, over-specializing them to the fine-tuning dataset.\n        \n\nIn deep neural networks, increasing the number of layers can make the model more prone to overfitting, especially during fine-tuning. Here’s why:\n\n1.  **Increased Model Capacity**: Adding more layers increases the model’s capacity to learn complex patterns. While this can improve performance on the training set, it can lead the model to “memorize” the training data rather than generalize from it, making it less effective on unseen data.\n    \n2.  **More Parameters**: With more layers, the number of parameters grows significantly. Fine-tuning such a large model can easily lead to overfitting if there’s insufficient data or if the data lacks variability. In cases of limited data, the model might latch onto noisy patterns that aren’t generalizable.\n    \n3.  **Gradient Amplification and Feature Sensitivity**: When fine-tuning deeper layers, gradients tend to amplify, which can make the model overly sensitive to training data. This sensitivity can result in overfitting to specific patterns in the training set that don’t generalize to the test set.\n    \n4.  **Less Regularization on Lower Layers**: Fine-tuning more layers often means adjusting lower layers that originally learned more general features (like edges and textures in images). By fine-tuning them, these layers might lose their general-purpose features, over-specializing them to the fine-tuning dataset.\n    \n\n**Increased Model Capacity**: Adding more layers increases the model’s capacity to learn complex patterns. While this can improve performance on the training set, it can lead the model to “memorize” the training data rather than generalize from it, making it less effective on unseen data.\n\n**More Parameters**: With more layers, the number of parameters grows significantly. Fine-tuning such a large model can easily lead to overfitting if there’s insufficient data or if the data lacks variability. In cases of limited data, the model might latch onto noisy patterns that aren’t generalizable.\n\n**Gradient Amplification and Feature Sensitivity**: When fine-tuning deeper layers, gradients tend to amplify, which can make the model overly sensitive to training data. This sensitivity can result in overfitting to specific patterns in the training set that don’t generalize to the test set.\n\n**Less Regularization on Lower Layers**: Fine-tuning more layers often means adjusting lower layers that originally learned more general features (like edges and textures in images). By fine-tuning them, these layers might lose their general-purpose features, over-specializing them to the fine-tuning dataset.\n\n#### Mitigating Overfitting in Fine-Tuning\n\n*   To reduce overfitting in deep networks during fine-tuning:\n    *   **Use Dropout**: Introduce dropout layers to prevent co-adaptation of neurons.\n    *   **Regularization**: Apply L2L2L\\_2 regularization (weight decay) to discourage excessive weights.\n    *   **Layer Freezing**: Fine-tune fewer layers or only the top layers of the model.\n    *   **Data Augmentation**: Expand the effective size of the training dataset by using transformations like cropping, rotation, and color adjustments, especially for image data.\n*   Fine-tuning deep networks is effective, but managing overfitting is crucial, especially with deeper architectures and smaller datasets.\n\n*   **Use Dropout**: Introduce dropout layers to prevent co-adaptation of neurons.\n*   **Regularization**: Apply L2L2L\\_2 regularization (weight decay) to discourage excessive weights.\n*   **Layer Freezing**: Fine-tune fewer layers or only the top layers of the model.\n*   **Data Augmentation**: Expand the effective size of the training dataset by using transformations like cropping, rotation, and color adjustments, especially for image data.",
      "order": 229,
      "orderInChapter": 30,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "neural network",
        "regularization",
        "dropout",
        "fine-tuning",
        "data augmentation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 730,
        "contentLength": 9707
      },
      "nextCards": [
        "ai-interview-how-does-adding-a-component-to-the-loss-term-preve-230",
        "ai-interview-does-an-llm-produce-different-outputs-for-the-same-231"
      ],
      "relatedCards": [
        "ai-bias-variance-tradeoff-overfitting-and-underfitting-common-challenges-in--13",
        "ai-mixture-of-experts-overview-19",
        "ai-model-compression-why-use-knowledge-distillation-instead-of-training-25",
        "ai-model-compression-pruning-workflow-35",
        "ai-dropout-use-a-larger-network-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#in-the-context-of-fine-tuning-deep-neural-networks,-can-increasing-the-number-of-layers-make-the-model-more-prone-to-overfitting?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-adding-a-component-to-the-loss-term-preve-230",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Does Adding a Component to the Loss Term Prevent Overfitting with Regularization?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Adding a component to the loss term for regularization helps prevent overfitting by penalizing overly complex models, encouraging simpler ones that generalize better to unseen data. Regularization techniques like <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-195-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>1</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1628\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.99em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1629\"><span class=\"msubsup\" id=\"MathJax-Span-1630\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1631\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mn\" id=\"MathJax-Span-1632\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.066em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>1</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-195\">L_1</script> (Lasso) and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-196-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1633\" style=\"width: 1.201em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.305em, 1000.99em, 2.451em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1634\"><span class=\"msubsup\" id=\"MathJax-Span-1635\"><span style=\"display: inline-block; position: relative; width: 0.992em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.58em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1636\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.576em;\"><span class=\"mn\" id=\"MathJax-Span-1637\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.066em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-196\">L_2</script> (Ridge) regularization introduce a penalty term in the loss function, which limits the size or complexity of model parameters. By controlling model complexity, regularization encourages the model to focus on generalizable patterns rather than specific data points, making it less sensitive to the idiosyncrasies of the training data.</li>\n  <li>Here’s how this works in detail:</li>\n</ul>\n<ol>\n  <li><strong>Penalizing Large Weights</strong>:\n    <blockquote>\n      <p>In models like neural networks or linear regressions, overfitting often involves assigning high weights to certain features, which makes the model sensitive to noise in the training data.</p>\n      <ul>\n        <li>Regularization adds a term to the loss function (e.g., <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-197-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1638\" style=\"width: 3.845em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.197em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.206em, 1003.2em, 2.641em, -999.998em); top: -2.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1639\"><span class=\"mi\" id=\"MathJax-Span-1640\" style=\"font-family: STIXGeneral-Italic;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1641\" style=\"padding-left: 0.188em;\"><span style=\"display: inline-block; position: relative; width: 1.206em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.104em, 1000.84em, 4.4em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1642\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.002em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; top: -3.701em; left: 0.928em;\"><span class=\"texatom\" id=\"MathJax-Span-1643\"><span class=\"mrow\" id=\"MathJax-Span-1644\"><span class=\"mi\" id=\"MathJax-Span-1645\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1646\" style=\"padding-left: 0.188em;\"><span style=\"display: inline-block; position: relative; width: 1.113em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.382em, 1000.65em, 4.123em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1647\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; clip: rect(3.382em, 1000.42em, 4.123em, -999.998em); top: -4.303em; left: 0.65em;\"><span class=\"mn\" id=\"MathJax-Span-1648\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; clip: rect(3.382em, 1000.28em, 4.123em, -999.998em); top: -3.701em; left: 0.65em;\"><span class=\"mi\" id=\"MathJax-Span-1649\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.178em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.442em; border-left: 0px solid; width: 0px; height: 1.447em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-197\">\\lambda \\sum_{i} w_i^2</script> for <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-198-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1650\" style=\"width: 1.16em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.975em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.391em, 1000.98em, 2.456em, -999.998em); top: -2.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1651\"><span class=\"msubsup\" id=\"MathJax-Span-1652\"><span style=\"display: inline-block; position: relative; width: 0.975em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.197em, 1000.56em, 4.123em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1653\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.002em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; top: -3.84em; left: 0.558em;\"><span class=\"mn\" id=\"MathJax-Span-1654\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.178em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.219em; border-left: 0px solid; width: 0px; height: 1.058em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-198\">L_2</script> regularization) that penalizes large weights. By keeping weights smaller, the model learns a smoother mapping that’s less likely to fit noise.</li>\n      </ul>\n    </blockquote>\n  </li>\n  <li>\n    <p><strong>Balancing Fit with Complexity</strong>: The regularization term adds a trade-off in the loss function between fitting the training data well and keeping the model complexity in check. For instance, with a regularized loss function <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-199-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Loss</mtext><mo>=</mo><mtext>MSE</mtext><mo>+</mo><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1655\" style=\"width: 11.357em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 9.43em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1009.43em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1656\"><span class=\"mtext\" id=\"MathJax-Span-1657\" style=\"font-family: STIXGeneral-Regular;\">Loss</span><span class=\"mo\" id=\"MathJax-Span-1658\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mtext\" id=\"MathJax-Span-1659\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">MSE</span><span class=\"mo\" id=\"MathJax-Span-1660\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-1661\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1662\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1663\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1664\"><span class=\"mrow\" id=\"MathJax-Span-1665\"><span class=\"mi\" id=\"MathJax-Span-1666\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1667\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.096em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1668\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.42em, 4.169em, -999.997em); top: -4.372em; left: 0.68em;\"><span class=\"mn\" id=\"MathJax-Span-1669\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.26em, 4.169em, -999.997em); top: -3.695em; left: 0.68em;\"><span class=\"mi\" id=\"MathJax-Span-1670\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.503em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Loss</mtext><mo>=</mo><mtext>MSE</mtext><mo>+</mo><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-199\">\\text{Loss} = \\text{MSE} + \\lambda \\sum_{i} w_i^2</script>, the regularization strength <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-200-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1671\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1672\"><span class=\"mi\" id=\"MathJax-Span-1673\" style=\"font-family: STIXGeneral-Italic;\">λ</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-200\">\\lambda</script> controls how much weight is given to reducing error versus limiting model complexity. A well-chosen <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-201-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1674\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1675\"><span class=\"mi\" id=\"MathJax-Span-1676\" style=\"font-family: STIXGeneral-Italic;\">λ</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-201\">\\lambda</script> helps the model to capture only the significant patterns, not the noise.</p>\n  </li>\n  <li>\n    <p><strong>Improved Generalization</strong>: By limiting the capacity of the model to learn very specific mappings, regularization helps the model to generalize better to new data. Overly flexible models tend to memorize training examples, while regularized models are forced to learn broader trends, which results in better performance on validation or test datasets.</p>\n  </li>\n  <li><strong>Types of Regularization Penalties</strong>:\n    <ul>\n      <li><strong><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-202-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1677\" style=\"width: 1.191em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px; font-size: 121%;\"><span style=\"position: absolute; clip: rect(1.294em, 1000.98em, 2.43em, -999.997em); top: -2.115em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1678\"><span class=\"msubsup\" id=\"MathJax-Span-1679\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.153em, 1000.57em, 4.135em, -999.997em); top: -3.975em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1680\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span><span style=\"position: absolute; top: -3.82em; left: 0.571em;\"><span class=\"mn\" id=\"MathJax-Span-1681\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.12em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-202\">L_2</script> Regularization</strong> (Ridge): Penalizes the square of the weights, encouraging the model to spread weight values across many parameters rather than making any one parameter large. This results in smoother models.</li>\n      <li><strong><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-203-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>1</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1682\" style=\"width: 1.191em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px; font-size: 121%;\"><span style=\"position: absolute; clip: rect(1.294em, 1000.98em, 2.43em, -999.997em); top: -2.115em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1683\"><span class=\"msubsup\" id=\"MathJax-Span-1684\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.153em, 1000.57em, 4.135em, -999.997em); top: -3.975em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1685\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span><span style=\"position: absolute; top: -3.82em; left: 0.571em;\"><span class=\"mn\" id=\"MathJax-Span-1686\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.12em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>1</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-203\">L_1</script> Regularization</strong> (Lasso): Adds an absolute penalty (e.g., <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-204-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo><msub><mi>w</mi><mi>i</mi></msub><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1687\" style=\"width: 4.378em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.648em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1003.54em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1688\"><span class=\"mi\" id=\"MathJax-Span-1689\" style=\"font-family: STIXGeneral-Italic;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1690\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1691\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1692\"><span class=\"mrow\" id=\"MathJax-Span-1693\"><span class=\"mi\" id=\"MathJax-Span-1694\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1695\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">‖</span><span class=\"msubsup\" id=\"MathJax-Span-1696\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1697\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.68em;\"><span class=\"mi\" id=\"MathJax-Span-1698\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1699\" style=\"font-family: STIXGeneral-Regular;\">‖</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><mo fence=\"false\" stretchy=\"false\">‖</mo><msub><mi>w</mi><mi>i</mi></msub><mo fence=\"false\" stretchy=\"false\">‖</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-204\">\\lambda \\sum_{i} \\|w_i\\|</script>), encouraging sparse models by pushing some weights to zero. This can also perform feature selection by removing less useful features.</li>\n    </ul>\n  </li>\n</ol>\n<blockquote>\n      <p>In models like neural networks or linear regressions, overfitting often involves assigning high weights to certain features, which makes the model sensitive to noise in the training data.</p>\n      <ul>\n        <li>Regularization adds a term to the loss function (e.g., <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-197-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1638\" style=\"width: 3.845em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.197em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.206em, 1003.2em, 2.641em, -999.998em); top: -2.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1639\"><span class=\"mi\" id=\"MathJax-Span-1640\" style=\"font-family: STIXGeneral-Italic;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1641\" style=\"padding-left: 0.188em;\"><span style=\"display: inline-block; position: relative; width: 1.206em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.104em, 1000.84em, 4.4em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1642\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.002em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; top: -3.701em; left: 0.928em;\"><span class=\"texatom\" id=\"MathJax-Span-1643\"><span class=\"mrow\" id=\"MathJax-Span-1644\"><span class=\"mi\" id=\"MathJax-Span-1645\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1646\" style=\"padding-left: 0.188em;\"><span style=\"display: inline-block; position: relative; width: 1.113em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.382em, 1000.65em, 4.123em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1647\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; clip: rect(3.382em, 1000.42em, 4.123em, -999.998em); top: -4.303em; left: 0.65em;\"><span class=\"mn\" id=\"MathJax-Span-1648\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; clip: rect(3.382em, 1000.28em, 4.123em, -999.998em); top: -3.701em; left: 0.65em;\"><span class=\"mi\" id=\"MathJax-Span-1649\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.178em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.442em; border-left: 0px solid; width: 0px; height: 1.447em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-197\">\\lambda \\sum_{i} w_i^2</script> for <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-198-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1650\" style=\"width: 1.16em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.975em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.391em, 1000.98em, 2.456em, -999.998em); top: -2.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1651\"><span class=\"msubsup\" id=\"MathJax-Span-1652\"><span style=\"display: inline-block; position: relative; width: 0.975em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.197em, 1000.56em, 4.123em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1653\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.002em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; top: -3.84em; left: 0.558em;\"><span class=\"mn\" id=\"MathJax-Span-1654\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.178em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.219em; border-left: 0px solid; width: 0px; height: 1.058em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-198\">L_2</script> regularization) that penalizes large weights. By keeping weights smaller, the model learns a smoother mapping that’s less likely to fit noise.</li>\n      </ul>\n    </blockquote>\n<p>In models like neural networks or linear regressions, overfitting often involves assigning high weights to certain features, which makes the model sensitive to noise in the training data.</p>\n<ul>\n        <li>Regularization adds a term to the loss function (e.g., <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-197-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1638\" style=\"width: 3.845em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.197em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.206em, 1003.2em, 2.641em, -999.998em); top: -2.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1639\"><span class=\"mi\" id=\"MathJax-Span-1640\" style=\"font-family: STIXGeneral-Italic;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1641\" style=\"padding-left: 0.188em;\"><span style=\"display: inline-block; position: relative; width: 1.206em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.104em, 1000.84em, 4.4em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1642\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.002em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; top: -3.701em; left: 0.928em;\"><span class=\"texatom\" id=\"MathJax-Span-1643\"><span class=\"mrow\" id=\"MathJax-Span-1644\"><span class=\"mi\" id=\"MathJax-Span-1645\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1646\" style=\"padding-left: 0.188em;\"><span style=\"display: inline-block; position: relative; width: 1.113em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.382em, 1000.65em, 4.123em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1647\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; clip: rect(3.382em, 1000.42em, 4.123em, -999.998em); top: -4.303em; left: 0.65em;\"><span class=\"mn\" id=\"MathJax-Span-1648\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; clip: rect(3.382em, 1000.28em, 4.123em, -999.998em); top: -3.701em; left: 0.65em;\"><span class=\"mi\" id=\"MathJax-Span-1649\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.178em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.442em; border-left: 0px solid; width: 0px; height: 1.447em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-197\">\\lambda \\sum_{i} w_i^2</script> for <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-198-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1650\" style=\"width: 1.16em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.975em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.391em, 1000.98em, 2.456em, -999.998em); top: -2.174em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1651\"><span class=\"msubsup\" id=\"MathJax-Span-1652\"><span style=\"display: inline-block; position: relative; width: 0.975em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.197em, 1000.56em, 4.123em, -999.998em); top: -3.979em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1653\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.002em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span><span style=\"position: absolute; top: -3.84em; left: 0.558em;\"><span class=\"mn\" id=\"MathJax-Span-1654\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.984em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.178em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.219em; border-left: 0px solid; width: 0px; height: 1.058em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-198\">L_2</script> regularization) that penalizes large weights. By keeping weights smaller, the model learns a smoother mapping that’s less likely to fit noise.</li>\n      </ul>\n<p><strong>Balancing Fit with Complexity</strong>: The regularization term adds a trade-off in the loss function between fitting the training data well and keeping the model complexity in check. For instance, with a regularized loss function <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-199-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Loss</mtext><mo>=</mo><mtext>MSE</mtext><mo>+</mo><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1655\" style=\"width: 11.357em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 9.43em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.201em, 1009.43em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1656\"><span class=\"mtext\" id=\"MathJax-Span-1657\" style=\"font-family: STIXGeneral-Regular;\">Loss</span><span class=\"mo\" id=\"MathJax-Span-1658\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mtext\" id=\"MathJax-Span-1659\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">MSE</span><span class=\"mo\" id=\"MathJax-Span-1660\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.263em;\">+</span><span class=\"mi\" id=\"MathJax-Span-1661\" style=\"font-family: STIXGeneral-Italic; padding-left: 0.263em;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1662\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1663\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1664\"><span class=\"mrow\" id=\"MathJax-Span-1665\"><span class=\"mi\" id=\"MathJax-Span-1666\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"msubsup\" id=\"MathJax-Span-1667\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.096em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1668\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.42em, 4.169em, -999.997em); top: -4.372em; left: 0.68em;\"><span class=\"mn\" id=\"MathJax-Span-1669\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1000.26em, 4.169em, -999.997em); top: -3.695em; left: 0.68em;\"><span class=\"mi\" id=\"MathJax-Span-1670\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.503em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Loss</mtext><mo>=</mo><mtext>MSE</mtext><mo>+</mo><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-199\">\\text{Loss} = \\text{MSE} + \\lambda \\sum_{i} w_i^2</script>, the regularization strength <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-200-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1671\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1672\"><span class=\"mi\" id=\"MathJax-Span-1673\" style=\"font-family: STIXGeneral-Italic;\">λ</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-200\">\\lambda</script> controls how much weight is given to reducing error versus limiting model complexity. A well-chosen <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-201-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1674\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1675\"><span class=\"mi\" id=\"MathJax-Span-1676\" style=\"font-family: STIXGeneral-Italic;\">λ</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-201\">\\lambda</script> helps the model to capture only the significant patterns, not the noise.</p>\n<p><strong>Improved Generalization</strong>: By limiting the capacity of the model to learn very specific mappings, regularization helps the model to generalize better to new data. Overly flexible models tend to memorize training examples, while regularized models are forced to learn broader trends, which results in better performance on validation or test datasets.</p>\n<ul>\n      <li><strong><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-202-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>2</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1677\" style=\"width: 1.191em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px; font-size: 121%;\"><span style=\"position: absolute; clip: rect(1.294em, 1000.98em, 2.43em, -999.997em); top: -2.115em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1678\"><span class=\"msubsup\" id=\"MathJax-Span-1679\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.153em, 1000.57em, 4.135em, -999.997em); top: -3.975em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1680\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span><span style=\"position: absolute; top: -3.82em; left: 0.571em;\"><span class=\"mn\" id=\"MathJax-Span-1681\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">2</span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.12em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>2</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-202\">L_2</script> Regularization</strong> (Ridge): Penalizes the square of the weights, encouraging the model to spread weight values across many parameters rather than making any one parameter large. This results in smoother models.</li>\n      <li><strong><span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-203-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>L</mi><mn>1</mn></msub></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1682\" style=\"width: 1.191em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px; font-size: 121%;\"><span style=\"position: absolute; clip: rect(1.294em, 1000.98em, 2.43em, -999.997em); top: -2.115em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1683\"><span class=\"msubsup\" id=\"MathJax-Span-1684\"><span style=\"display: inline-block; position: relative; width: 0.984em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.153em, 1000.57em, 4.135em, -999.997em); top: -3.975em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1685\" style=\"font-family: STIXGeneral-Italic;\">L<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span><span style=\"position: absolute; top: -3.82em; left: 0.571em;\"><span class=\"mn\" id=\"MathJax-Span-1686\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span style=\"display: inline-block; width: 0px; height: 3.98em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.12em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msub><mi>L</mi><mn>1</mn></msub></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-203\">L_1</script> Regularization</strong> (Lasso): Adds an absolute penalty (e.g., <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-204-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03BB;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi></mrow></munder><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo><msub><mi>w</mi><mi>i</mi></msub><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>&amp;#x2016;</mo></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1687\" style=\"width: 4.378em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.648em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.253em, 1003.54em, 2.659em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1688\"><span class=\"mi\" id=\"MathJax-Span-1689\" style=\"font-family: STIXGeneral-Italic;\">λ</span><span class=\"munderover\" id=\"MathJax-Span-1690\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.201em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.076em, 1000.84em, 4.43em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mo\" id=\"MathJax-Span-1691\" style=\"font-family: STIXGeneral-Regular; vertical-align: 0.003em;\">∑</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.695em; left: 0.94em;\"><span class=\"texatom\" id=\"MathJax-Span-1692\"><span class=\"mrow\" id=\"MathJax-Span-1693\"><span class=\"mi\" id=\"MathJax-Span-1694\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1695\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.211em;\">‖</span><span class=\"msubsup\" id=\"MathJax-Span-1696\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.63em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1697\" style=\"font-family: STIXGeneral-Italic;\">w</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.68em;\"><span class=\"mi\" id=\"MathJax-Span-1698\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">i</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-1699\" style=\"font-family: STIXGeneral-Regular;\">‖</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.434em; border-left: 0px solid; width: 0px; height: 1.378em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>λ</mi><munder><mo>∑</mo><mrow class=\"MJX-TeXAtom-ORD\"><mi>i</mi></mrow></munder><mo fence=\"false\" stretchy=\"false\">‖</mo><msub><mi>w</mi><mi>i</mi></msub><mo fence=\"false\" stretchy=\"false\">‖</mo></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-204\">\\lambda \\sum_{i} \\|w_i\\|</script>), encouraging sparse models by pushing some weights to zero. This can also perform feature selection by removing less useful features.</li>\n    </ul>",
      "contentMarkdown": "*   Adding a component to the loss term for regularization helps prevent overfitting by penalizing overly complex models, encouraging simpler ones that generalize better to unseen data. Regularization techniques like L1L1L\\_1 (Lasso) and L2L2L\\_2 (Ridge) regularization introduce a penalty term in the loss function, which limits the size or complexity of model parameters. By controlling model complexity, regularization encourages the model to focus on generalizable patterns rather than specific data points, making it less sensitive to the idiosyncrasies of the training data.\n*   Here’s how this works in detail:\n\n1.  **Penalizing Large Weights**:\n    \n    > In models like neural networks or linear regressions, overfitting often involves assigning high weights to certain features, which makes the model sensitive to noise in the training data.\n    > \n    > *   Regularization adds a term to the loss function (e.g., λ∑iw2iλ∑iwi2\\\\lambda \\\\sum\\_{i} w\\_i^2 for L2L2L\\_2 regularization) that penalizes large weights. By keeping weights smaller, the model learns a smoother mapping that’s less likely to fit noise.\n    \n2.  **Balancing Fit with Complexity**: The regularization term adds a trade-off in the loss function between fitting the training data well and keeping the model complexity in check. For instance, with a regularized loss function Loss\\=MSE+λ∑iw2iLoss\\=MSE+λ∑iwi2\\\\text{Loss} = \\\\text{MSE} + \\\\lambda \\\\sum\\_{i} w\\_i^2, the regularization strength λλ\\\\lambda controls how much weight is given to reducing error versus limiting model complexity. A well-chosen λλ\\\\lambda helps the model to capture only the significant patterns, not the noise.\n    \n3.  **Improved Generalization**: By limiting the capacity of the model to learn very specific mappings, regularization helps the model to generalize better to new data. Overly flexible models tend to memorize training examples, while regularized models are forced to learn broader trends, which results in better performance on validation or test datasets.\n    \n4.  **Types of Regularization Penalties**:\n    *   **L2L2L\\_2 Regularization** (Ridge): Penalizes the square of the weights, encouraging the model to spread weight values across many parameters rather than making any one parameter large. This results in smoother models.\n    *   **L1L1L\\_1 Regularization** (Lasso): Adds an absolute penalty (e.g., λ∑i‖wi‖λ∑i‖wi‖\\\\lambda \\\\sum\\_{i} \\\\|w\\_i\\\\|), encouraging sparse models by pushing some weights to zero. This can also perform feature selection by removing less useful features.\n\n> In models like neural networks or linear regressions, overfitting often involves assigning high weights to certain features, which makes the model sensitive to noise in the training data.\n> \n> *   Regularization adds a term to the loss function (e.g., λ∑iw2iλ∑iwi2\\\\lambda \\\\sum\\_{i} w\\_i^2 for L2L2L\\_2 regularization) that penalizes large weights. By keeping weights smaller, the model learns a smoother mapping that’s less likely to fit noise.\n\nIn models like neural networks or linear regressions, overfitting often involves assigning high weights to certain features, which makes the model sensitive to noise in the training data.\n\n*   Regularization adds a term to the loss function (e.g., λ∑iw2iλ∑iwi2\\\\lambda \\\\sum\\_{i} w\\_i^2 for L2L2L\\_2 regularization) that penalizes large weights. By keeping weights smaller, the model learns a smoother mapping that’s less likely to fit noise.\n\n**Balancing Fit with Complexity**: The regularization term adds a trade-off in the loss function between fitting the training data well and keeping the model complexity in check. For instance, with a regularized loss function Loss\\=MSE+λ∑iw2iLoss\\=MSE+λ∑iwi2\\\\text{Loss} = \\\\text{MSE} + \\\\lambda \\\\sum\\_{i} w\\_i^2, the regularization strength λλ\\\\lambda controls how much weight is given to reducing error versus limiting model complexity. A well-chosen λλ\\\\lambda helps the model to capture only the significant patterns, not the noise.\n\n**Improved Generalization**: By limiting the capacity of the model to learn very specific mappings, regularization helps the model to generalize better to new data. Overly flexible models tend to memorize training examples, while regularized models are forced to learn broader trends, which results in better performance on validation or test datasets.\n\n*   **L2L2L\\_2 Regularization** (Ridge): Penalizes the square of the weights, encouraging the model to spread weight values across many parameters rather than making any one parameter large. This results in smoother models.\n*   **L1L1L\\_1 Regularization** (Lasso): Adds an absolute penalty (e.g., λ∑i‖wi‖λ∑i‖wi‖\\\\lambda \\\\sum\\_{i} \\\\|w\\_i\\\\|), encouraging sparse models by pushing some weights to zero. This can also perform feature selection by removing less useful features.",
      "order": 230,
      "orderInChapter": 31,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "neural network",
        "loss function",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 674,
        "contentLength": 51720
      },
      "nextCards": [
        "ai-interview-does-an-llm-produce-different-outputs-for-the-same-231",
        "ai-interview-explain-how-random-seed-initialization-works-with--232"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32",
        "ai-decision-trees-and-ensemble-methods-do-gbdts-use-gradient-descent-if-so-how-does-it-di-29",
        "ai-diffusion-models-at-a-high-level-how-do-diffusion-models-work-what--42",
        "ai-diffusion-models-integration-with-mse-46",
        "ai-model-compression-formal-definition-32"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-adding-a-component-to-the-loss-term-prevent-overfitting-with-regularization?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-does-an-llm-produce-different-outputs-for-the-same-231",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Does an LLM Produce Different Outputs for the Same Input Across Different Iterations? If So, How?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Yes, an LLM can produce different outputs for the same input across different iterations, depending on how it’s configured. Here’s a breakdown of why and how this variation can occur:</li>\n</ul>\n<h4 id=\"temperature-setting\">Temperature Setting</h4>\n<ul>\n  <li><strong>What It Is</strong>: “Temperature” is a parameter that controls the randomness of the model’s output. Higher temperatures (e.g., 1.0 or higher) make the output more random, while lower temperatures (e.g., close to 0) make it more deterministic.</li>\n  <li><strong>How It Affects Outputs</strong>: At high temperatures, the model is more likely to choose from a broader range of possible tokens, leading to more varied responses. At low temperatures, it favors the most probable tokens, which tends to produce similar or identical outputs across runs. This allows for tuning between creative, diverse responses and reliable, consistent ones.</li>\n</ul>\n<h4 id=\"top-k-and-top-p-sampling\">Top-k and Top-p Sampling</h4>\n<ul>\n  <li><strong>What It Is</strong>: These are other mechanisms for controlling randomness. Top-k sampling restricts the model to only the top k most probable tokens at each step, while top-p (nucleus) sampling restricts it to the smallest set of tokens whose cumulative probability reaches a certain threshold (like 0.9).</li>\n  <li><strong>How It Affects Outputs</strong>: With higher k or p values, the model has a wider range of tokens to choose from, introducing more variability. With lower values, it restricts to more predictable choices, leading to more consistent responses.</li>\n</ul>\n<h4 id=\"random-seed-initialization\">Random Seed Initialization</h4>\n<ul>\n  <li><strong>What It Is</strong>: The generation of text in many LLMs involves randomization based on a seed. If the seed is different each time (either explicitly or implicitly set), the model can produce varied outputs for the same prompt.</li>\n  <li><strong>How It Affects Outputs</strong>: By changing the seed, you effectively alter the “starting point” for the model’s generation, which can lead to different word choices and sentence structures, even with the same prompt.</li>\n</ul>\n<h4 id=\"context-sensitivity-in-extended-interactions\">Context Sensitivity in Extended Interactions</h4>\n<ul>\n  <li><strong>What It Is</strong>: In a multi-turn conversation, LLMs keep track of previous interactions to maintain context. This means that repeated prompts might lead to varied responses if they follow different conversational histories.</li>\n  <li><strong>How It Affects Outputs</strong>: The same prompt could yield different responses if the surrounding context or conversational “history” changes, as the model adjusts its output to align with the flow of conversation.</li>\n</ul>\n<h4 id=\"model-size-and-fine-tuning\">Model Size and Fine-Tuning</h4>\n<ul>\n  <li><strong>What It Is</strong>: Larger models with more parameters or those that have been fine-tuned on extensive, diverse datasets tend to have richer response variability.</li>\n  <li>\n    <p><strong>How It Affects Outputs</strong>: Larger models, or those fine-tuned for creativity, may naturally produce a broader array of outputs because they have encoded a more nuanced understanding of language patterns and contexts. Smaller or narrowly fine-tuned models may give more predictable results.</p>\n  </li>\n  <li>By adjusting these parameters, users or developers can control how much variety an LLM will exhibit, from highly creative and varied outputs to reliable, nearly identical responses.</li>\n</ul>\n<p><strong>How It Affects Outputs</strong>: Larger models, or those fine-tuned for creativity, may naturally produce a broader array of outputs because they have encoded a more nuanced understanding of language patterns and contexts. Smaller or narrowly fine-tuned models may give more predictable results.</p>",
      "contentMarkdown": "*   Yes, an LLM can produce different outputs for the same input across different iterations, depending on how it’s configured. Here’s a breakdown of why and how this variation can occur:\n\n#### Temperature Setting\n\n*   **What It Is**: “Temperature” is a parameter that controls the randomness of the model’s output. Higher temperatures (e.g., 1.0 or higher) make the output more random, while lower temperatures (e.g., close to 0) make it more deterministic.\n*   **How It Affects Outputs**: At high temperatures, the model is more likely to choose from a broader range of possible tokens, leading to more varied responses. At low temperatures, it favors the most probable tokens, which tends to produce similar or identical outputs across runs. This allows for tuning between creative, diverse responses and reliable, consistent ones.\n\n#### Top-k and Top-p Sampling\n\n*   **What It Is**: These are other mechanisms for controlling randomness. Top-k sampling restricts the model to only the top k most probable tokens at each step, while top-p (nucleus) sampling restricts it to the smallest set of tokens whose cumulative probability reaches a certain threshold (like 0.9).\n*   **How It Affects Outputs**: With higher k or p values, the model has a wider range of tokens to choose from, introducing more variability. With lower values, it restricts to more predictable choices, leading to more consistent responses.\n\n#### Random Seed Initialization\n\n*   **What It Is**: The generation of text in many LLMs involves randomization based on a seed. If the seed is different each time (either explicitly or implicitly set), the model can produce varied outputs for the same prompt.\n*   **How It Affects Outputs**: By changing the seed, you effectively alter the “starting point” for the model’s generation, which can lead to different word choices and sentence structures, even with the same prompt.\n\n#### Context Sensitivity in Extended Interactions\n\n*   **What It Is**: In a multi-turn conversation, LLMs keep track of previous interactions to maintain context. This means that repeated prompts might lead to varied responses if they follow different conversational histories.\n*   **How It Affects Outputs**: The same prompt could yield different responses if the surrounding context or conversational “history” changes, as the model adjusts its output to align with the flow of conversation.\n\n#### Model Size and Fine-Tuning\n\n*   **What It Is**: Larger models with more parameters or those that have been fine-tuned on extensive, diverse datasets tend to have richer response variability.\n*   **How It Affects Outputs**: Larger models, or those fine-tuned for creativity, may naturally produce a broader array of outputs because they have encoded a more nuanced understanding of language patterns and contexts. Smaller or narrowly fine-tuned models may give more predictable results.\n    \n*   By adjusting these parameters, users or developers can control how much variety an LLM will exhibit, from highly creative and varied outputs to reliable, nearly identical responses.\n\n**How It Affects Outputs**: Larger models, or those fine-tuned for creativity, may naturally produce a broader array of outputs because they have encoded a more nuanced understanding of language patterns and contexts. Smaller or narrowly fine-tuned models may give more predictable results.",
      "order": 231,
      "orderInChapter": 32,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "llm",
        "fine-tuning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 514,
        "contentLength": 3852
      },
      "nextCards": [
        "ai-interview-explain-how-random-seed-initialization-works-with--232",
        "ai-interview-what-is-a-seed-233"
      ],
      "relatedCards": [
        "ai-agentic-RL-curriculum-design-7",
        "ai-agentic-RL-why-policy-optimization-for-web-and-computer-use-a-18",
        "ai-parameter-efficient-fine-tuning-practical-use-case-1",
        "ai-parameter-efficient-fine-tuning-qlora-10",
        "ai-parameter-efficient-fine-tuning-mora-17"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#does-an-llm-produce-different-outputs-for-the-same-input-across-different-iterations?-if-so,-how?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explain-how-random-seed-initialization-works-with--232",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Explain How Random Seed Initialization Works with LLMs.",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>In large language models, controlling the random seed is a powerful way to manage and reproduce variations in text generation. Here’s how it works and how you can implement it in code:</li>\n</ul>",
      "contentMarkdown": "*   In large language models, controlling the random seed is a powerful way to manage and reproduce variations in text generation. Here’s how it works and how you can implement it in code:",
      "order": 232,
      "orderInChapter": 33,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 33,
        "contentLength": 206
      },
      "nextCards": [
        "ai-interview-what-is-a-seed-233",
        "ai-interview-how-to-control-the-random-seed-in-code-234"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explain-how-random-seed-initialization-works-with-llms.",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-a-seed-233",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is a Seed?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>A random seed is a starting point for the sequence of random numbers generated by the model. When using a random seed, the model’s token sampling will follow a predictable pattern if the same seed is reused, making it easy to reproduce results. However, when the seed changes, the sequence becomes different, leading to varied outputs.</li>\n</ul>",
      "contentMarkdown": "*   A random seed is a starting point for the sequence of random numbers generated by the model. When using a random seed, the model’s token sampling will follow a predictable pattern if the same seed is reused, making it easy to reproduce results. However, when the seed changes, the sequence becomes different, leading to varied outputs.",
      "order": 233,
      "orderInChapter": 34,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 57,
        "contentLength": 357
      },
      "nextCards": [
        "ai-interview-how-to-control-the-random-seed-in-code-234",
        "ai-interview-explanation-of-how-the-seed-alters-generation-235"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-a-seed?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-to-control-the-random-seed-in-code-234",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How to Control the Random Seed in Code",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Let’s look at two common libraries where setting the seed is possible: OpenAI’s API (for models like GPT-3/4) and Hugging Face’s Transformers library (for local or custom models).</li>\n</ul>\n<h4 id=\"using-openais-api\">Using OpenAI’s API</h4>\n<ul>\n  <li>\n    <p>The OpenAI API currently does not provide direct control over the random seed in text generation calls, but you can simulate the effect by controlling other parameters (like temperature, top-p, etc.) or by pre-generating random seeds in your code and structuring the API call around them.</p>\n  </li>\n  <li>\n    <p>In Python, you could create a function that sets a seed value by manipulating other factors within your code (such as the prompt or randomizing other parameters). Here’s an example of how you might approach it:</p>\n  </li>\n</ul>\n<p>The OpenAI API currently does not provide direct control over the random seed in text generation calls, but you can simulate the effect by controlling other parameters (like temperature, top-p, etc.) or by pre-generating random seeds in your code and structuring the API call around them.</p>\n<p>In Python, you could create a function that sets a seed value by manipulating other factors within your code (such as the prompt or randomizing other parameters). Here’s an example of how you might approach it:</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code29\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code29\"><span class=\"kn\">import</span> <span class=\"nn\">openai</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">seed</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>  <span class=\"c1\"># Set Python's random seed to ensure reproducibility.\n</span>        <span class=\"c1\"># Optional: set a unique suffix based on the seed\n</span>        <span class=\"n\">prompt</span> <span class=\"o\">+=</span> <span class=\"sa\">f</span><span class=\"s\">\" Seed-</span><span class=\"si\">{</span><span class=\"n\">seed</span><span class=\"si\">}</span><span class=\"s\">\"</span>\n    \n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">openai</span><span class=\"p\">.</span><span class=\"n\">Completion</span><span class=\"p\">.</span><span class=\"n\">create</span><span class=\"p\">(</span>\n        <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s\">\"text-davinci-003\"</span><span class=\"p\">,</span>\n        <span class=\"n\">prompt</span><span class=\"o\">=</span><span class=\"n\">prompt</span><span class=\"p\">,</span>\n        <span class=\"n\">max_tokens</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n        <span class=\"n\">temperature</span><span class=\"o\">=</span><span class=\"mf\">0.7</span>  <span class=\"c1\"># adjust this for variability\n</span>    <span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">choices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">text</span>\n\n<span class=\"c1\"># Usage\n</span><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"Once upon a time in a distant land\"</span>\n<span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>  <span class=\"c1\"># Set any integer for reproducibility\n</span><span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code29\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code29\"><span class=\"kn\">import</span> <span class=\"nn\">openai</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">seed</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>  <span class=\"c1\"># Set Python's random seed to ensure reproducibility.\n</span>        <span class=\"c1\"># Optional: set a unique suffix based on the seed\n</span>        <span class=\"n\">prompt</span> <span class=\"o\">+=</span> <span class=\"sa\">f</span><span class=\"s\">\" Seed-</span><span class=\"si\">{</span><span class=\"n\">seed</span><span class=\"si\">}</span><span class=\"s\">\"</span>\n    \n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">openai</span><span class=\"p\">.</span><span class=\"n\">Completion</span><span class=\"p\">.</span><span class=\"n\">create</span><span class=\"p\">(</span>\n        <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s\">\"text-davinci-003\"</span><span class=\"p\">,</span>\n        <span class=\"n\">prompt</span><span class=\"o\">=</span><span class=\"n\">prompt</span><span class=\"p\">,</span>\n        <span class=\"n\">max_tokens</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n        <span class=\"n\">temperature</span><span class=\"o\">=</span><span class=\"mf\">0.7</span>  <span class=\"c1\"># adjust this for variability\n</span>    <span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">choices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">text</span>\n\n<span class=\"c1\"># Usage\n</span><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"Once upon a time in a distant land\"</span>\n<span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>  <span class=\"c1\"># Set any integer for reproducibility\n</span><span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>While OpenAI’s API doesn’t use <code class=\"language-plaintext highlighter-rouge\">seed</code> directly, adding a <code class=\"language-plaintext highlighter-rouge\">seed</code>-specific prompt suffix could effectively simulate a controlled variance.</li>\n</ul>\n<h4 id=\"using-hugging-faces-transformers-library\">Using Hugging Face’s Transformers Library</h4>\n<ul>\n  <li>The Transformers library by Hugging Face allows you to set a seed directly, making it easier to achieve deterministic output. Here’s how it works:</li>\n</ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code30\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code30\"><span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"n\">pipeline</span><span class=\"p\">,</span> <span class=\"n\">set_seed</span>\n\n<span class=\"c1\"># Load a text generation pipeline\n</span><span class=\"n\">generator</span> <span class=\"o\">=</span> <span class=\"n\">pipeline</span><span class=\"p\">(</span><span class=\"s\">'text-generation'</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s\">'gpt2'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">seed</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">set_seed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>  <span class=\"c1\"># This will control randomness in the model's generation\n</span>\n    <span class=\"c1\"># Generate text\n</span>    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">num_return_sequences</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s\">'generated_text'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Usage\n</span><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"Once upon a time in a distant land\"</span>\n<span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>  <span class=\"c1\"># Any integer to set the random seed\n</span><span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code30\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code30\"><span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"n\">pipeline</span><span class=\"p\">,</span> <span class=\"n\">set_seed</span>\n\n<span class=\"c1\"># Load a text generation pipeline\n</span><span class=\"n\">generator</span> <span class=\"o\">=</span> <span class=\"n\">pipeline</span><span class=\"p\">(</span><span class=\"s\">'text-generation'</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s\">'gpt2'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">seed</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">set_seed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>  <span class=\"c1\"># This will control randomness in the model's generation\n</span>\n    <span class=\"c1\"># Generate text\n</span>    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">num_return_sequences</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s\">'generated_text'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Usage\n</span><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"Once upon a time in a distant land\"</span>\n<span class=\"n\">seed</span> <span class=\"o\">=</span> <span class=\"mi\">42</span>  <span class=\"c1\"># Any integer to set the random seed\n</span><span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>In this case, <code class=\"language-plaintext highlighter-rouge\">set_seed(seed)</code> fixes the random seed, ensuring that every time you run the function with the same seed, you’ll get the same output. Changing the seed each time will lead to different outputs.</li>\n</ul>",
      "contentMarkdown": "*   Let’s look at two common libraries where setting the seed is possible: OpenAI’s API (for models like GPT-3/4) and Hugging Face’s Transformers library (for local or custom models).\n\n#### Using OpenAI’s API\n\n*   The OpenAI API currently does not provide direct control over the random seed in text generation calls, but you can simulate the effect by controlling other parameters (like temperature, top-p, etc.) or by pre-generating random seeds in your code and structuring the API call around them.\n    \n*   In Python, you could create a function that sets a seed value by manipulating other factors within your code (such as the prompt or randomizing other parameters). Here’s an example of how you might approach it:\n    \n\nThe OpenAI API currently does not provide direct control over the random seed in text generation calls, but you can simulate the effect by controlling other parameters (like temperature, top-p, etc.) or by pre-generating random seeds in your code and structuring the API call around them.\n\nIn Python, you could create a function that sets a seed value by manipulating other factors within your code (such as the prompt or randomizing other parameters). Here’s an example of how you might approach it:\n\n![](https://aman.ai/images/copy.png)\n\n`import openai import random  def generate_with_seed(prompt, seed=None):     if seed is not None:         random.seed(seed)  # Set Python's random seed to ensure reproducibility.         # Optional: set a unique suffix based on the seed         prompt += f\" Seed-{seed}\"          response = openai.Completion.create(         model=\"text-davinci-003\",         prompt=prompt,         max_tokens=100,         temperature=0.7  # adjust this for variability     )     return response.choices[0].text  # Usage prompt = \"Once upon a time in a distant land\" seed = 42  # Set any integer for reproducibility output = generate_with_seed(prompt, seed) print(output)`\n\n![](https://aman.ai/images/copy.png)\n\n`import openai import random  def generate_with_seed(prompt, seed=None):     if seed is not None:         random.seed(seed)  # Set Python's random seed to ensure reproducibility.         # Optional: set a unique suffix based on the seed         prompt += f\" Seed-{seed}\"          response = openai.Completion.create(         model=\"text-davinci-003\",         prompt=prompt,         max_tokens=100,         temperature=0.7  # adjust this for variability     )     return response.choices[0].text  # Usage prompt = \"Once upon a time in a distant land\" seed = 42  # Set any integer for reproducibility output = generate_with_seed(prompt, seed) print(output)`\n\n*   While OpenAI’s API doesn’t use `seed` directly, adding a `seed`\\-specific prompt suffix could effectively simulate a controlled variance.\n\n#### Using Hugging Face’s Transformers Library\n\n*   The Transformers library by Hugging Face allows you to set a seed directly, making it easier to achieve deterministic output. Here’s how it works:\n\n![](https://aman.ai/images/copy.png)\n\n`from transformers import pipeline, set_seed  # Load a text generation pipeline generator = pipeline('text-generation', model='gpt2')  def generate_with_seed(prompt, seed=None):     if seed is not None:         set_seed(seed)  # This will control randomness in the model's generation     # Generate text     result = generator(prompt, max_length=50, num_return_sequences=1)     return result[0]['generated_text']  # Usage prompt = \"Once upon a time in a distant land\" seed = 42  # Any integer to set the random seed output = generate_with_seed(prompt, seed) print(output)`\n\n![](https://aman.ai/images/copy.png)\n\n`from transformers import pipeline, set_seed  # Load a text generation pipeline generator = pipeline('text-generation', model='gpt2')  def generate_with_seed(prompt, seed=None):     if seed is not None:         set_seed(seed)  # This will control randomness in the model's generation     # Generate text     result = generator(prompt, max_length=50, num_return_sequences=1)     return result[0]['generated_text']  # Usage prompt = \"Once upon a time in a distant land\" seed = 42  # Any integer to set the random seed output = generate_with_seed(prompt, seed) print(output)`\n\n*   In this case, `set_seed(seed)` fixes the random seed, ensuring that every time you run the function with the same seed, you’ll get the same output. Changing the seed each time will lead to different outputs.",
      "order": 234,
      "orderInChapter": 35,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "transformer",
        "gpt"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 583,
        "contentLength": 13682
      },
      "nextCards": [
        "ai-interview-explanation-of-how-the-seed-alters-generation-235",
        "ai-interview-practical-example-changing-seed-for-diverse-output-236"
      ],
      "relatedCards": [
        "ai-transformers-gpt-in-60-lines-of-numpy-49",
        "ai-gpt4o-native-image-generation-mode-switching-during-generation-34",
        "ai-gpt4o-native-image-generation-captioning-image-text-37",
        "ai-gpt4o-native-image-generation-gpt-4o-as-a-foundation-for-future-multimodal-inter-48",
        "ai-gpt4o-native-image-generation-implications-for-gpt-4o-evaluation-52"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-to-control-the-random-seed-in-code",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-explanation-of-how-the-seed-alters-generation-235",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Explanation of How the Seed Alters Generation",
      "subtitle": "Misc",
      "contentHtml": "<ol>\n  <li>\n    <p><strong>Set the Seed</strong>: By calling <code class=\"language-plaintext highlighter-rouge\">set_seed(seed)</code> (or any equivalent method), you initialize the random number generator with a specific value.</p>\n  </li>\n  <li>\n    <p><strong>Sampling</strong>: During text generation, the model selects tokens based on probability distributions. The seed controls how these probabilities are interpreted and which token is chosen at each step.</p>\n  </li>\n  <li>\n    <p><strong>Repeatability</strong>: If you run the code with the same prompt and seed, the model’s choices will follow the same path through the probability distribution, producing identical outputs. Change the seed, and this path shifts, creating a new sequence of tokens and thus different outputs.</p>\n  </li>\n</ol>\n<p><strong>Set the Seed</strong>: By calling <code class=\"language-plaintext highlighter-rouge\">set_seed(seed)</code> (or any equivalent method), you initialize the random number generator with a specific value.</p>\n<p><strong>Sampling</strong>: During text generation, the model selects tokens based on probability distributions. The seed controls how these probabilities are interpreted and which token is chosen at each step.</p>\n<p><strong>Repeatability</strong>: If you run the code with the same prompt and seed, the model’s choices will follow the same path through the probability distribution, producing identical outputs. Change the seed, and this path shifts, creating a new sequence of tokens and thus different outputs.</p>",
      "contentMarkdown": "1.  **Set the Seed**: By calling `set_seed(seed)` (or any equivalent method), you initialize the random number generator with a specific value.\n    \n2.  **Sampling**: During text generation, the model selects tokens based on probability distributions. The seed controls how these probabilities are interpreted and which token is chosen at each step.\n    \n3.  **Repeatability**: If you run the code with the same prompt and seed, the model’s choices will follow the same path through the probability distribution, producing identical outputs. Change the seed, and this path shifts, creating a new sequence of tokens and thus different outputs.\n    \n\n**Set the Seed**: By calling `set_seed(seed)` (or any equivalent method), you initialize the random number generator with a specific value.\n\n**Sampling**: During text generation, the model selects tokens based on probability distributions. The seed controls how these probabilities are interpreted and which token is chosen at each step.\n\n**Repeatability**: If you run the code with the same prompt and seed, the model’s choices will follow the same path through the probability distribution, producing identical outputs. Change the seed, and this path shifts, creating a new sequence of tokens and thus different outputs.",
      "order": 235,
      "orderInChapter": 36,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 187,
        "contentLength": 1541
      },
      "nextCards": [
        "ai-interview-practical-example-changing-seed-for-diverse-output-236",
        "ai-interview-why-this-matters-237"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#explanation-of-how-the-seed-alters-generation",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-practical-example-changing-seed-for-diverse-output-236",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Practical Example: Changing Seed for Diverse Outputs",
      "subtitle": "Misc",
      "contentHtml": "<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code31\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code31\"><span class=\"c1\"># Generate multiple outputs with different seeds\n</span><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"The sun was setting over the calm ocean\"</span>\n<span class=\"n\">seeds</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n\n<span class=\"k\">for</span> <span class=\"n\">seed</span> <span class=\"ow\">in</span> <span class=\"n\">seeds</span><span class=\"p\">:</span>\n    <span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s\">\"Seed </span><span class=\"si\">{</span><span class=\"n\">seed</span><span class=\"si\">}</span><span class=\"s\">: </span><span class=\"si\">{</span><span class=\"n\">output</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code31\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code31\"><span class=\"c1\"># Generate multiple outputs with different seeds\n</span><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"The sun was setting over the calm ocean\"</span>\n<span class=\"n\">seeds</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n\n<span class=\"k\">for</span> <span class=\"n\">seed</span> <span class=\"ow\">in</span> <span class=\"n\">seeds</span><span class=\"p\">:</span>\n    <span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generate_with_seed</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s\">\"Seed </span><span class=\"si\">{</span><span class=\"n\">seed</span><span class=\"si\">}</span><span class=\"s\">: </span><span class=\"si\">{</span><span class=\"n\">output</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>By iterating over different seed values, you’ll see distinct outputs for each seed. Each seed provides a unique “starting point” for the model’s token sampling, which impacts the final response.</li>\n</ul>",
      "contentMarkdown": "![](https://aman.ai/images/copy.png)\n\n`# Generate multiple outputs with different seeds prompt = \"The sun was setting over the calm ocean\" seeds = [1, 2, 3, 4]  for seed in seeds:     output = generate_with_seed(prompt, seed)     print(f\"Seed {seed}: {output}\\n\")`\n\n![](https://aman.ai/images/copy.png)\n\n`# Generate multiple outputs with different seeds prompt = \"The sun was setting over the calm ocean\" seeds = [1, 2, 3, 4]  for seed in seeds:     output = generate_with_seed(prompt, seed)     print(f\"Seed {seed}: {output}\\n\")`\n\n*   By iterating over different seed values, you’ll see distinct outputs for each seed. Each seed provides a unique “starting point” for the model’s token sampling, which impacts the final response.",
      "order": 236,
      "orderInChapter": 37,
      "difficulty": 5,
      "estimatedMinutes": 1,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 101,
        "contentLength": 3282
      },
      "nextCards": [
        "ai-interview-why-this-matters-237",
        "ai-interview-how-does-the-seed-impact-the-llm-sampling-using-tr-238"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#practical-example:-changing-seed-for-diverse-outputs",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-why-this-matters-237",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Why This Matters",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Using seeds effectively allows developers to:\n    <ul>\n      <li><strong>Control variability</strong>: Useful for tests or specific scenarios where repeatability is needed.</li>\n      <li><strong>Generate diverse content</strong>: Varying seeds can create unique responses for creative applications.</li>\n      <li><strong>Debug and analyze outputs</strong>: If a particular output is interesting or problematic, using the same seed helps reproduce and analyze it.</li>\n    </ul>\n  </li>\n  <li>This ability to set and change seeds gives you a robust handle on both predictability and variety in LLM outputs.</li>\n</ul>\n<ul>\n      <li><strong>Control variability</strong>: Useful for tests or specific scenarios where repeatability is needed.</li>\n      <li><strong>Generate diverse content</strong>: Varying seeds can create unique responses for creative applications.</li>\n      <li><strong>Debug and analyze outputs</strong>: If a particular output is interesting or problematic, using the same seed helps reproduce and analyze it.</li>\n    </ul>",
      "contentMarkdown": "*   Using seeds effectively allows developers to:\n    *   **Control variability**: Useful for tests or specific scenarios where repeatability is needed.\n    *   **Generate diverse content**: Varying seeds can create unique responses for creative applications.\n    *   **Debug and analyze outputs**: If a particular output is interesting or problematic, using the same seed helps reproduce and analyze it.\n*   This ability to set and change seeds gives you a robust handle on both predictability and variety in LLM outputs.\n\n*   **Control variability**: Useful for tests or specific scenarios where repeatability is needed.\n*   **Generate diverse content**: Varying seeds can create unique responses for creative applications.\n*   **Debug and analyze outputs**: If a particular output is interesting or problematic, using the same seed helps reproduce and analyze it.",
      "order": 237,
      "orderInChapter": 38,
      "difficulty": 4,
      "estimatedMinutes": 1,
      "tags": [
        "practice",
        "llm"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 124,
        "contentLength": 1059
      },
      "nextCards": [
        "ai-interview-how-does-the-seed-impact-the-llm-sampling-using-tr-238",
        "ai-interview-what-does-it-mean-for-an-ml-model-to-be-non-parame-239"
      ],
      "relatedCards": [
        "ai-prompt-engineering-how-does-react-work-5",
        "ai-prompt-engineering-react-usage-with-langchain-9",
        "ai-token-sampling-logits-and-softmax-3",
        "ai-reinforcement-learning-the-bellman-equation-2",
        "ai-mixture-of-experts-openmoe-71"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#why-this-matters",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-how-does-the-seed-impact-the-llm-sampling-using-tr-238",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "How Does the Seed Impact the LLM Sampling Using Transformers Library?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>When using the Transformers library, the random seed directly impacts the sampling process of a large language model (LLM) by determining how the model selects tokens based on their probability distributions. Here’s a detailed look at how it works and why the seed influences the output:</li>\n</ul>\n<h4 id=\"understanding-token-sampling-in-llms\">Understanding Token Sampling in LLMs</h4>\n<ul>\n  <li>\n    <p>In language generation, an LLM predicts the next word (or token) by assigning probabilities to all possible tokens. For example, given a partial sentence like “The cat sat on the…”, the model calculates probabilities for likely next words, such as “mat,” “sofa,” “floor,” etc. The sampling mechanism then decides which word to choose based on these probabilities.</p>\n  </li>\n  <li><strong>Sampling Methods in Transformers Library</strong>:\n    <ul>\n      <li><strong>Greedy Sampling</strong>: Always picks the most probable token.</li>\n      <li><strong>Beam Search</strong>: Considers multiple top paths to choose a sequence.</li>\n      <li><strong>Top-k Sampling</strong>: Limits choices to the top k tokens, adding randomness by choosing among the k most probable tokens.</li>\n      <li><strong>Top-p Sampling (Nucleus Sampling)</strong>: Selects tokens from the smallest possible set where cumulative probability reaches a threshold (p), often 0.9.</li>\n    </ul>\n  </li>\n  <li>With random sampling (such as top-k or top-p), the selection process is influenced by randomness, which is where the <strong>random seed</strong> comes in.</li>\n</ul>\n<p>In language generation, an LLM predicts the next word (or token) by assigning probabilities to all possible tokens. For example, given a partial sentence like “The cat sat on the…”, the model calculates probabilities for likely next words, such as “mat,” “sofa,” “floor,” etc. The sampling mechanism then decides which word to choose based on these probabilities.</p>\n<ul>\n      <li><strong>Greedy Sampling</strong>: Always picks the most probable token.</li>\n      <li><strong>Beam Search</strong>: Considers multiple top paths to choose a sequence.</li>\n      <li><strong>Top-k Sampling</strong>: Limits choices to the top k tokens, adding randomness by choosing among the k most probable tokens.</li>\n      <li><strong>Top-p Sampling (Nucleus Sampling)</strong>: Selects tokens from the smallest possible set where cumulative probability reaches a threshold (p), often 0.9.</li>\n    </ul>\n<h4 id=\"role-of-the-seed-in-sampling\">Role of the Seed in Sampling</h4>\n<ul>\n  <li>\n    <p>The seed initializes the random number generator that determines which tokens are chosen during sampling. Here’s how it affects each step in the process:</p>\n\n    <ul>\n      <li><strong>Random Initialization</strong>: By setting the seed, you fix the starting point of the random number generator, making the process deterministic for that seed value.</li>\n      <li><strong>Token Choice</strong>: In top-k or top-p sampling, the model picks among several likely tokens. The random seed affects which of these tokens is ultimately chosen. For example, if “mat,” “sofa,” and “floor” are all probable next tokens, the seed influences which one is selected, even though all have similar probabilities.</li>\n      <li><strong>Consistency</strong>: If the seed remains the same, the sequence of “random” choices stays the same, meaning the model will consistently choose the same tokens at each step, leading to identical outputs for the same input prompt. Changing the seed, however, alters these choices and produces a different sentence structure or wording.</li>\n    </ul>\n  </li>\n</ul>\n<p>The seed initializes the random number generator that determines which tokens are chosen during sampling. Here’s how it affects each step in the process:</p>\n<ul>\n      <li><strong>Random Initialization</strong>: By setting the seed, you fix the starting point of the random number generator, making the process deterministic for that seed value.</li>\n      <li><strong>Token Choice</strong>: In top-k or top-p sampling, the model picks among several likely tokens. The random seed affects which of these tokens is ultimately chosen. For example, if “mat,” “sofa,” and “floor” are all probable next tokens, the seed influences which one is selected, even though all have similar probabilities.</li>\n      <li><strong>Consistency</strong>: If the seed remains the same, the sequence of “random” choices stays the same, meaning the model will consistently choose the same tokens at each step, leading to identical outputs for the same input prompt. Changing the seed, however, alters these choices and produces a different sentence structure or wording.</li>\n    </ul>\n<h4 id=\"implementation-in-the-transformers-library\">Implementation in the Transformers Library</h4>\n<ul>\n  <li>\n    <p>In the Transformers library, setting the seed is straightforward, typically done using <code class=\"language-plaintext highlighter-rouge\">transformers.set_seed(seed)</code>. Here’s what happens internally:</p>\n  </li>\n  <li>\n    <p>When you call <code class=\"language-plaintext highlighter-rouge\">set_seed(seed)</code>, it sets the seed for Python’s <code class=\"language-plaintext highlighter-rouge\">random</code> module, NumPy’s random generator, and any other random functions used by the model. This ensures that all parts of the token-sampling process operate with the same random seed.</p>\n  </li>\n</ul>\n<p>In the Transformers library, setting the seed is straightforward, typically done using <code class=\"language-plaintext highlighter-rouge\">transformers.set_seed(seed)</code>. Here’s what happens internally:</p>\n<p>When you call <code class=\"language-plaintext highlighter-rouge\">set_seed(seed)</code>, it sets the seed for Python’s <code class=\"language-plaintext highlighter-rouge\">random</code> module, NumPy’s random generator, and any other random functions used by the model. This ensures that all parts of the token-sampling process operate with the same random seed.</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code32\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code32\"><span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"n\">pipeline</span><span class=\"p\">,</span> <span class=\"n\">set_seed</span>\n\n<span class=\"c1\"># Load a text generation pipeline\n</span><span class=\"n\">generator</span> <span class=\"o\">=</span> <span class=\"n\">pipeline</span><span class=\"p\">(</span><span class=\"s\">'text-generation'</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s\">'gpt2'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Set the seed to control randomness\n</span><span class=\"n\">set_seed</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code32\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code32\"><span class=\"kn\">from</span> <span class=\"nn\">transformers</span> <span class=\"kn\">import</span> <span class=\"n\">pipeline</span><span class=\"p\">,</span> <span class=\"n\">set_seed</span>\n\n<span class=\"c1\"># Load a text generation pipeline\n</span><span class=\"n\">generator</span> <span class=\"o\">=</span> <span class=\"n\">pipeline</span><span class=\"p\">(</span><span class=\"s\">'text-generation'</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s\">'gpt2'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Set the seed to control randomness\n</span><span class=\"n\">set_seed</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n</code></pre>\n<ul>\n  <li>Once the seed is set, any subsequent generation calls will be deterministic for that seed, meaning every time you run the generation with the same prompt and seed, you’ll get the same output.</li>\n</ul>\n<h4 id=\"how-the-seed-changes-output-diversity\">How the Seed Changes Output Diversity</h4>\n<ul>\n  <li>Changing the seed allows you to explore different continuations of the same input prompt without changing the model’s parameters or re-running it. Each unique seed will lead to a different series of “random” choices among the top-k or top-p tokens, producing varied outputs in terms of:\n    <ul>\n      <li><strong>Word choice</strong>: Different synonyms or related terms may be chosen.</li>\n      <li><strong>Sentence structure</strong>: The model may follow different paths in phrasing or sentence continuation.</li>\n      <li><strong>Tone and Style</strong>: Subtle changes in word choice can shift the tone, making it more formal or casual, depending on the sampled tokens.</li>\n    </ul>\n  </li>\n  <li>Here’s an example that illustrates how changing the seed can impact the output:</li>\n</ul>\n<ul>\n      <li><strong>Word choice</strong>: Different synonyms or related terms may be chosen.</li>\n      <li><strong>Sentence structure</strong>: The model may follow different paths in phrasing or sentence continuation.</li>\n      <li><strong>Tone and Style</strong>: Subtle changes in word choice can shift the tone, making it more formal or casual, depending on the sampled tokens.</li>\n    </ul>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code33\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code33\"><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"The future of AI is both exciting and\"</span>\n\n<span class=\"c1\"># Generate with different seeds\n</span><span class=\"k\">for</span> <span class=\"n\">seed</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">42</span><span class=\"p\">,</span> <span class=\"mi\">99</span><span class=\"p\">]:</span>\n    <span class=\"n\">set_seed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n    <span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">num_return_sequences</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s\">\"Seed </span><span class=\"si\">{</span><span class=\"n\">seed</span><span class=\"si\">}</span><span class=\"s\">: </span><span class=\"si\">{</span><span class=\"n\">output</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s\">'generated_text'</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n<pre class=\"highlight\"><div><button class=\"btn-copy\" data-clipboard-action=\"copy\" data-clipboard-target=\"#code33\"><img src=\"https://aman.ai/images/copy.png\" style=\"margin:0; border:none; padding:2px 0px; width:100%; height:18px; width:18px;\"></button></div><code id=\"code33\"><span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"s\">\"The future of AI is both exciting and\"</span>\n\n<span class=\"c1\"># Generate with different seeds\n</span><span class=\"k\">for</span> <span class=\"n\">seed</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">42</span><span class=\"p\">,</span> <span class=\"mi\">99</span><span class=\"p\">]:</span>\n    <span class=\"n\">set_seed</span><span class=\"p\">(</span><span class=\"n\">seed</span><span class=\"p\">)</span>\n    <span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"n\">num_return_sequences</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s\">\"Seed </span><span class=\"si\">{</span><span class=\"n\">seed</span><span class=\"si\">}</span><span class=\"s\">: </span><span class=\"si\">{</span><span class=\"n\">output</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s\">'generated_text'</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n</code></pre>\n<h4 id=\"use-cases-for-seed-control-in-llms\">Use Cases for Seed Control in LLMs</h4>\n<ul>\n  <li>Setting a seed has practical benefits:\n    <ul>\n      <li><strong>Repeatability</strong>: By fixing the seed, you can reproduce specific results, making it easier to test, debug, or analyze certain outputs.</li>\n      <li><strong>Content Variation</strong>: By altering the seed, you can generate diverse outputs from the same model and prompt without re-training or modifying other parameters.</li>\n      <li><strong>Controlled Randomness in Creative Tasks</strong>: You can achieve creative and varied outputs by simply cycling through different seeds, which is especially useful for applications like story generation, marketing copy, or dialogue creation.</li>\n    </ul>\n  </li>\n  <li>In summary, the seed acts as a way to “anchor” the model’s randomness, guiding the token-sampling process in a controlled yet flexible way. By setting and changing seeds, you can explore a spectrum of possible outputs for the same input prompt, balancing predictability and creative variation.</li>\n</ul>\n<ul>\n      <li><strong>Repeatability</strong>: By fixing the seed, you can reproduce specific results, making it easier to test, debug, or analyze certain outputs.</li>\n      <li><strong>Content Variation</strong>: By altering the seed, you can generate diverse outputs from the same model and prompt without re-training or modifying other parameters.</li>\n      <li><strong>Controlled Randomness in Creative Tasks</strong>: You can achieve creative and varied outputs by simply cycling through different seeds, which is especially useful for applications like story generation, marketing copy, or dialogue creation.</li>\n    </ul>",
      "contentMarkdown": "*   When using the Transformers library, the random seed directly impacts the sampling process of a large language model (LLM) by determining how the model selects tokens based on their probability distributions. Here’s a detailed look at how it works and why the seed influences the output:\n\n#### Understanding Token Sampling in LLMs\n\n*   In language generation, an LLM predicts the next word (or token) by assigning probabilities to all possible tokens. For example, given a partial sentence like “The cat sat on the…”, the model calculates probabilities for likely next words, such as “mat,” “sofa,” “floor,” etc. The sampling mechanism then decides which word to choose based on these probabilities.\n    \n*   **Sampling Methods in Transformers Library**:\n    *   **Greedy Sampling**: Always picks the most probable token.\n    *   **Beam Search**: Considers multiple top paths to choose a sequence.\n    *   **Top-k Sampling**: Limits choices to the top k tokens, adding randomness by choosing among the k most probable tokens.\n    *   **Top-p Sampling (Nucleus Sampling)**: Selects tokens from the smallest possible set where cumulative probability reaches a threshold (p), often 0.9.\n*   With random sampling (such as top-k or top-p), the selection process is influenced by randomness, which is where the **random seed** comes in.\n\nIn language generation, an LLM predicts the next word (or token) by assigning probabilities to all possible tokens. For example, given a partial sentence like “The cat sat on the…”, the model calculates probabilities for likely next words, such as “mat,” “sofa,” “floor,” etc. The sampling mechanism then decides which word to choose based on these probabilities.\n\n*   **Greedy Sampling**: Always picks the most probable token.\n*   **Beam Search**: Considers multiple top paths to choose a sequence.\n*   **Top-k Sampling**: Limits choices to the top k tokens, adding randomness by choosing among the k most probable tokens.\n*   **Top-p Sampling (Nucleus Sampling)**: Selects tokens from the smallest possible set where cumulative probability reaches a threshold (p), often 0.9.\n\n#### Role of the Seed in Sampling\n\n*   The seed initializes the random number generator that determines which tokens are chosen during sampling. Here’s how it affects each step in the process:\n    \n    *   **Random Initialization**: By setting the seed, you fix the starting point of the random number generator, making the process deterministic for that seed value.\n    *   **Token Choice**: In top-k or top-p sampling, the model picks among several likely tokens. The random seed affects which of these tokens is ultimately chosen. For example, if “mat,” “sofa,” and “floor” are all probable next tokens, the seed influences which one is selected, even though all have similar probabilities.\n    *   **Consistency**: If the seed remains the same, the sequence of “random” choices stays the same, meaning the model will consistently choose the same tokens at each step, leading to identical outputs for the same input prompt. Changing the seed, however, alters these choices and produces a different sentence structure or wording.\n\nThe seed initializes the random number generator that determines which tokens are chosen during sampling. Here’s how it affects each step in the process:\n\n*   **Random Initialization**: By setting the seed, you fix the starting point of the random number generator, making the process deterministic for that seed value.\n*   **Token Choice**: In top-k or top-p sampling, the model picks among several likely tokens. The random seed affects which of these tokens is ultimately chosen. For example, if “mat,” “sofa,” and “floor” are all probable next tokens, the seed influences which one is selected, even though all have similar probabilities.\n*   **Consistency**: If the seed remains the same, the sequence of “random” choices stays the same, meaning the model will consistently choose the same tokens at each step, leading to identical outputs for the same input prompt. Changing the seed, however, alters these choices and produces a different sentence structure or wording.\n\n#### Implementation in the Transformers Library\n\n*   In the Transformers library, setting the seed is straightforward, typically done using `transformers.set_seed(seed)`. Here’s what happens internally:\n    \n*   When you call `set_seed(seed)`, it sets the seed for Python’s `random` module, NumPy’s random generator, and any other random functions used by the model. This ensures that all parts of the token-sampling process operate with the same random seed.\n    \n\nIn the Transformers library, setting the seed is straightforward, typically done using `transformers.set_seed(seed)`. Here’s what happens internally:\n\nWhen you call `set_seed(seed)`, it sets the seed for Python’s `random` module, NumPy’s random generator, and any other random functions used by the model. This ensures that all parts of the token-sampling process operate with the same random seed.\n\n![](https://aman.ai/images/copy.png)\n\n`from transformers import pipeline, set_seed  # Load a text generation pipeline generator = pipeline('text-generation', model='gpt2')  # Set the seed to control randomness set_seed(42)`\n\n![](https://aman.ai/images/copy.png)\n\n`from transformers import pipeline, set_seed  # Load a text generation pipeline generator = pipeline('text-generation', model='gpt2')  # Set the seed to control randomness set_seed(42)`\n\n*   Once the seed is set, any subsequent generation calls will be deterministic for that seed, meaning every time you run the generation with the same prompt and seed, you’ll get the same output.\n\n#### How the Seed Changes Output Diversity\n\n*   Changing the seed allows you to explore different continuations of the same input prompt without changing the model’s parameters or re-running it. Each unique seed will lead to a different series of “random” choices among the top-k or top-p tokens, producing varied outputs in terms of:\n    *   **Word choice**: Different synonyms or related terms may be chosen.\n    *   **Sentence structure**: The model may follow different paths in phrasing or sentence continuation.\n    *   **Tone and Style**: Subtle changes in word choice can shift the tone, making it more formal or casual, depending on the sampled tokens.\n*   Here’s an example that illustrates how changing the seed can impact the output:\n\n*   **Word choice**: Different synonyms or related terms may be chosen.\n*   **Sentence structure**: The model may follow different paths in phrasing or sentence continuation.\n*   **Tone and Style**: Subtle changes in word choice can shift the tone, making it more formal or casual, depending on the sampled tokens.\n\n![](https://aman.ai/images/copy.png)\n\n`prompt = \"The future of AI is both exciting and\"  # Generate with different seeds for seed in [1, 42, 99]:     set_seed(seed)     output = generator(prompt, max_length=50, num_return_sequences=1)     print(f\"Seed {seed}: {output[0]['generated_text']}\\n\")`\n\n![](https://aman.ai/images/copy.png)\n\n`prompt = \"The future of AI is both exciting and\"  # Generate with different seeds for seed in [1, 42, 99]:     set_seed(seed)     output = generator(prompt, max_length=50, num_return_sequences=1)     print(f\"Seed {seed}: {output[0]['generated_text']}\\n\")`\n\n#### Use Cases for Seed Control in LLMs\n\n*   Setting a seed has practical benefits:\n    *   **Repeatability**: By fixing the seed, you can reproduce specific results, making it easier to test, debug, or analyze certain outputs.\n    *   **Content Variation**: By altering the seed, you can generate diverse outputs from the same model and prompt without re-training or modifying other parameters.\n    *   **Controlled Randomness in Creative Tasks**: You can achieve creative and varied outputs by simply cycling through different seeds, which is especially useful for applications like story generation, marketing copy, or dialogue creation.\n*   In summary, the seed acts as a way to “anchor” the model’s randomness, guiding the token-sampling process in a controlled yet flexible way. By setting and changing seeds, you can explore a spectrum of possible outputs for the same input prompt, balancing predictability and creative variation.\n\n*   **Repeatability**: By fixing the seed, you can reproduce specific results, making it easier to test, debug, or analyze certain outputs.\n*   **Content Variation**: By altering the seed, you can generate diverse outputs from the same model and prompt without re-training or modifying other parameters.\n*   **Controlled Randomness in Creative Tasks**: You can achieve creative and varied outputs by simply cycling through different seeds, which is especially useful for applications like story generation, marketing copy, or dialogue creation.",
      "order": 238,
      "orderInChapter": 39,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice",
        "transformer",
        "gpt",
        "llm"
      ],
      "metadata": {
        "hasCode": true,
        "hasMath": false,
        "hasImages": true,
        "wordCount": 1280,
        "contentLength": 14849
      },
      "nextCards": [
        "ai-interview-what-does-it-mean-for-an-ml-model-to-be-non-parame-239",
        "ai-interview-which-ml-algorithms-are-non-parametric-240"
      ],
      "relatedCards": [
        "ai-on-device-transformers-sequence-length-and-kv-cache-size-24",
        "ai-hallucination-decoding-by-contrasting-layers-dola-4",
        "ai-attention-multi-head-vs-multi-query-vs-grouped-query-attenti-18",
        "ai-model-acceleration-comparative-analysis-19",
        "ai-speculative-decoding-draft-model-based-speculative-decoding-9"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#how-does-the-seed-impact-the-llm-sampling-using-transformers-library?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-does-it-mean-for-an-ml-model-to-be-non-parame-239",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What Does It Mean for an ML Model to be Non-parametric?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>In machine learning, a non-parametric model is one that doesn’t assume a fixed number of parameters. Unlike <em>parametric models</em>, which have a predetermined structure (such as linear regression with fixed coefficients), non-parametric models adapt their structure based on the complexity and amount of data they have. Here are some key points about non-parametric models:</p>\n\n    <ol>\n      <li>\n        <p><strong>Flexibility with Data Size</strong>: Non-parametric models grow more complex as the amount of data increases. Instead of summarizing the data in a fixed set of parameters, they may use the data directly, allowing for a more flexible model that can capture a wide range of patterns and relationships.</p>\n      </li>\n      <li>\n        <p><strong>No Assumptions About Data Distribution</strong>: Non-parametric models don’t require assumptions about the underlying data distribution (such as being linear, Gaussian, etc.). This makes them useful in cases where the relationship between features is complex or unknown.</p>\n      </li>\n      <li><strong>Examples of Non-Parametric Models</strong>:\n        <ul>\n          <li><strong>K-Nearest Neighbors (KNN)</strong>: This model directly uses the training data to make predictions by finding the “k” most similar instances.</li>\n          <li><strong>Decision Trees</strong>: Decision trees can grow in complexity depending on the data, splitting based on criteria that maximize the information gain at each level.</li>\n          <li><strong>Kernel Density Estimation (KDE)</strong>: KDE is used for estimating the probability density function of a random variable without assuming a specific parametric form.</li>\n        </ul>\n      </li>\n      <li><strong>Trade-offs</strong>:\n        <ul>\n          <li><strong>More Data Dependency</strong>: Non-parametric models may require more data to accurately capture patterns, as they rely on the data itself rather than summarizing it in a few parameters.</li>\n          <li><strong>Computationally Intensive</strong>: Since non-parametric models often need to reference or compare to much of the training data at prediction time, they can be slower and more memory-intensive.</li>\n        </ul>\n      </li>\n      <li><strong>Overfitting Risk</strong>: Because non-parametric models can adapt closely to the data, they are sometimes more prone to overfitting, especially if not regulated by techniques like pruning (in trees) or limiting “k” in KNN.</li>\n    </ol>\n  </li>\n  <li>\n    <p>In summary, non-parametric models are powerful for handling complex data patterns without rigid assumptions, but they require careful tuning and enough data to generalize well.</p>\n  </li>\n</ul>\n<p>In machine learning, a non-parametric model is one that doesn’t assume a fixed number of parameters. Unlike <em>parametric models</em>, which have a predetermined structure (such as linear regression with fixed coefficients), non-parametric models adapt their structure based on the complexity and amount of data they have. Here are some key points about non-parametric models:</p>\n<ol>\n      <li>\n        <p><strong>Flexibility with Data Size</strong>: Non-parametric models grow more complex as the amount of data increases. Instead of summarizing the data in a fixed set of parameters, they may use the data directly, allowing for a more flexible model that can capture a wide range of patterns and relationships.</p>\n      </li>\n      <li>\n        <p><strong>No Assumptions About Data Distribution</strong>: Non-parametric models don’t require assumptions about the underlying data distribution (such as being linear, Gaussian, etc.). This makes them useful in cases where the relationship between features is complex or unknown.</p>\n      </li>\n      <li><strong>Examples of Non-Parametric Models</strong>:\n        <ul>\n          <li><strong>K-Nearest Neighbors (KNN)</strong>: This model directly uses the training data to make predictions by finding the “k” most similar instances.</li>\n          <li><strong>Decision Trees</strong>: Decision trees can grow in complexity depending on the data, splitting based on criteria that maximize the information gain at each level.</li>\n          <li><strong>Kernel Density Estimation (KDE)</strong>: KDE is used for estimating the probability density function of a random variable without assuming a specific parametric form.</li>\n        </ul>\n      </li>\n      <li><strong>Trade-offs</strong>:\n        <ul>\n          <li><strong>More Data Dependency</strong>: Non-parametric models may require more data to accurately capture patterns, as they rely on the data itself rather than summarizing it in a few parameters.</li>\n          <li><strong>Computationally Intensive</strong>: Since non-parametric models often need to reference or compare to much of the training data at prediction time, they can be slower and more memory-intensive.</li>\n        </ul>\n      </li>\n      <li><strong>Overfitting Risk</strong>: Because non-parametric models can adapt closely to the data, they are sometimes more prone to overfitting, especially if not regulated by techniques like pruning (in trees) or limiting “k” in KNN.</li>\n    </ol>\n<p><strong>Flexibility with Data Size</strong>: Non-parametric models grow more complex as the amount of data increases. Instead of summarizing the data in a fixed set of parameters, they may use the data directly, allowing for a more flexible model that can capture a wide range of patterns and relationships.</p>\n<p><strong>No Assumptions About Data Distribution</strong>: Non-parametric models don’t require assumptions about the underlying data distribution (such as being linear, Gaussian, etc.). This makes them useful in cases where the relationship between features is complex or unknown.</p>\n<ul>\n          <li><strong>K-Nearest Neighbors (KNN)</strong>: This model directly uses the training data to make predictions by finding the “k” most similar instances.</li>\n          <li><strong>Decision Trees</strong>: Decision trees can grow in complexity depending on the data, splitting based on criteria that maximize the information gain at each level.</li>\n          <li><strong>Kernel Density Estimation (KDE)</strong>: KDE is used for estimating the probability density function of a random variable without assuming a specific parametric form.</li>\n        </ul>\n<ul>\n          <li><strong>More Data Dependency</strong>: Non-parametric models may require more data to accurately capture patterns, as they rely on the data itself rather than summarizing it in a few parameters.</li>\n          <li><strong>Computationally Intensive</strong>: Since non-parametric models often need to reference or compare to much of the training data at prediction time, they can be slower and more memory-intensive.</li>\n        </ul>\n<p>In summary, non-parametric models are powerful for handling complex data patterns without rigid assumptions, but they require careful tuning and enough data to generalize well.</p>",
      "contentMarkdown": "*   In machine learning, a non-parametric model is one that doesn’t assume a fixed number of parameters. Unlike _parametric models_, which have a predetermined structure (such as linear regression with fixed coefficients), non-parametric models adapt their structure based on the complexity and amount of data they have. Here are some key points about non-parametric models:\n    \n    1.  **Flexibility with Data Size**: Non-parametric models grow more complex as the amount of data increases. Instead of summarizing the data in a fixed set of parameters, they may use the data directly, allowing for a more flexible model that can capture a wide range of patterns and relationships.\n        \n    2.  **No Assumptions About Data Distribution**: Non-parametric models don’t require assumptions about the underlying data distribution (such as being linear, Gaussian, etc.). This makes them useful in cases where the relationship between features is complex or unknown.\n        \n    3.  **Examples of Non-Parametric Models**:\n        *   **K-Nearest Neighbors (KNN)**: This model directly uses the training data to make predictions by finding the “k” most similar instances.\n        *   **Decision Trees**: Decision trees can grow in complexity depending on the data, splitting based on criteria that maximize the information gain at each level.\n        *   **Kernel Density Estimation (KDE)**: KDE is used for estimating the probability density function of a random variable without assuming a specific parametric form.\n    4.  **Trade-offs**:\n        *   **More Data Dependency**: Non-parametric models may require more data to accurately capture patterns, as they rely on the data itself rather than summarizing it in a few parameters.\n        *   **Computationally Intensive**: Since non-parametric models often need to reference or compare to much of the training data at prediction time, they can be slower and more memory-intensive.\n    5.  **Overfitting Risk**: Because non-parametric models can adapt closely to the data, they are sometimes more prone to overfitting, especially if not regulated by techniques like pruning (in trees) or limiting “k” in KNN.\n*   In summary, non-parametric models are powerful for handling complex data patterns without rigid assumptions, but they require careful tuning and enough data to generalize well.\n    \n\nIn machine learning, a non-parametric model is one that doesn’t assume a fixed number of parameters. Unlike _parametric models_, which have a predetermined structure (such as linear regression with fixed coefficients), non-parametric models adapt their structure based on the complexity and amount of data they have. Here are some key points about non-parametric models:\n\n1.  **Flexibility with Data Size**: Non-parametric models grow more complex as the amount of data increases. Instead of summarizing the data in a fixed set of parameters, they may use the data directly, allowing for a more flexible model that can capture a wide range of patterns and relationships.\n    \n2.  **No Assumptions About Data Distribution**: Non-parametric models don’t require assumptions about the underlying data distribution (such as being linear, Gaussian, etc.). This makes them useful in cases where the relationship between features is complex or unknown.\n    \n3.  **Examples of Non-Parametric Models**:\n    *   **K-Nearest Neighbors (KNN)**: This model directly uses the training data to make predictions by finding the “k” most similar instances.\n    *   **Decision Trees**: Decision trees can grow in complexity depending on the data, splitting based on criteria that maximize the information gain at each level.\n    *   **Kernel Density Estimation (KDE)**: KDE is used for estimating the probability density function of a random variable without assuming a specific parametric form.\n4.  **Trade-offs**:\n    *   **More Data Dependency**: Non-parametric models may require more data to accurately capture patterns, as they rely on the data itself rather than summarizing it in a few parameters.\n    *   **Computationally Intensive**: Since non-parametric models often need to reference or compare to much of the training data at prediction time, they can be slower and more memory-intensive.\n5.  **Overfitting Risk**: Because non-parametric models can adapt closely to the data, they are sometimes more prone to overfitting, especially if not regulated by techniques like pruning (in trees) or limiting “k” in KNN.\n\n**Flexibility with Data Size**: Non-parametric models grow more complex as the amount of data increases. Instead of summarizing the data in a fixed set of parameters, they may use the data directly, allowing for a more flexible model that can capture a wide range of patterns and relationships.\n\n**No Assumptions About Data Distribution**: Non-parametric models don’t require assumptions about the underlying data distribution (such as being linear, Gaussian, etc.). This makes them useful in cases where the relationship between features is complex or unknown.\n\n*   **K-Nearest Neighbors (KNN)**: This model directly uses the training data to make predictions by finding the “k” most similar instances.\n*   **Decision Trees**: Decision trees can grow in complexity depending on the data, splitting based on criteria that maximize the information gain at each level.\n*   **Kernel Density Estimation (KDE)**: KDE is used for estimating the probability density function of a random variable without assuming a specific parametric form.\n\n*   **More Data Dependency**: Non-parametric models may require more data to accurately capture patterns, as they rely on the data itself rather than summarizing it in a few parameters.\n*   **Computationally Intensive**: Since non-parametric models often need to reference or compare to much of the training data at prediction time, they can be slower and more memory-intensive.\n\nIn summary, non-parametric models are powerful for handling complex data patterns without rigid assumptions, but they require careful tuning and enough data to generalize well.",
      "order": 239,
      "orderInChapter": 40,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 879,
        "contentLength": 7008
      },
      "nextCards": [
        "ai-interview-which-ml-algorithms-are-non-parametric-240",
        "ai-interview-is-k-means-clustering-parametric-241"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-does-it-mean-for-an-ml-model-to-be-non-parametric?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-which-ml-algorithms-are-non-parametric-240",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Which ML Algorithms are Non-parametric?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Non-parametric machine learning models are those that do not make strong assumptions about the form of the underlying data distribution, meaning they do not rely on a fixed number of parameters. Instead, the number of parameters grows with the amount of data, allowing them to adapt more flexibly to the data. Some well-known non-parametric models include:</li>\n</ul>\n<ol>\n  <li><strong>K-Nearest Neighbors (K-NN):</strong>\n    <ul>\n      <li>Does not assume any specific structure in the data. It classifies a new data point based on the classes of its closest neighbors, with the number of neighbors often specified by a hyperparameter.</li>\n    </ul>\n  </li>\n  <li><strong>Decision Trees:</strong>\n    <ul>\n      <li>Can be considered non-parametric since they split data based on feature values without a pre-set structure. The tree grows based on the data until a stopping condition is met, making it highly adaptable.</li>\n    </ul>\n  </li>\n  <li><strong>Random Forests and Bagging:</strong>\n    <ul>\n      <li>Ensembles of decision trees are also non-parametric as they aggregate multiple non-parametric decision trees to make a prediction. Each tree in the forest adjusts based on different subsets of the data.</li>\n    </ul>\n  </li>\n  <li><strong>Support Vector Machines (with non-linear kernels):</strong>\n    <ul>\n      <li>With non-linear kernels, SVMs can be non-parametric, as the number of support vectors used can grow with the data, allowing it to model complex decision boundaries without a fixed parameter set.</li>\n    </ul>\n  </li>\n  <li><strong>Gaussian Processes:</strong>\n    <ul>\n      <li>A flexible, non-parametric Bayesian approach where predictions are distributions that adapt to data patterns. The model complexity grows with the number of data points.</li>\n    </ul>\n  </li>\n  <li><strong>Kernel Density Estimation (KDE):</strong>\n    <ul>\n      <li>Used for estimating the probability density function of a random variable without assuming a particular distribution form. KDE is data-driven and can adapt to complex data structures.</li>\n    </ul>\n  </li>\n  <li><strong>Neural Networks (sometimes considered):</strong>\n    <ul>\n      <li>Though typically seen as parametric, certain architectures, such as deep neural networks with many layers, can approximate non-parametric behavior in practice because they adapt flexibly to data and often have many more parameters than simpler models.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>Does not assume any specific structure in the data. It classifies a new data point based on the classes of its closest neighbors, with the number of neighbors often specified by a hyperparameter.</li>\n    </ul>\n<ul>\n      <li>Can be considered non-parametric since they split data based on feature values without a pre-set structure. The tree grows based on the data until a stopping condition is met, making it highly adaptable.</li>\n    </ul>\n<ul>\n      <li>Ensembles of decision trees are also non-parametric as they aggregate multiple non-parametric decision trees to make a prediction. Each tree in the forest adjusts based on different subsets of the data.</li>\n    </ul>\n<ul>\n      <li>With non-linear kernels, SVMs can be non-parametric, as the number of support vectors used can grow with the data, allowing it to model complex decision boundaries without a fixed parameter set.</li>\n    </ul>\n<ul>\n      <li>A flexible, non-parametric Bayesian approach where predictions are distributions that adapt to data patterns. The model complexity grows with the number of data points.</li>\n    </ul>\n<ul>\n      <li>Used for estimating the probability density function of a random variable without assuming a particular distribution form. KDE is data-driven and can adapt to complex data structures.</li>\n    </ul>\n<ul>\n      <li>Though typically seen as parametric, certain architectures, such as deep neural networks with many layers, can approximate non-parametric behavior in practice because they adapt flexibly to data and often have many more parameters than simpler models.</li>\n    </ul>\n<ul>\n  <li>Non-parametric models are generally more flexible and better at capturing intricate patterns in data, but they may require more data and computational resources than parametric models to make accurate predictions.</li>\n</ul>",
      "contentMarkdown": "*   Non-parametric machine learning models are those that do not make strong assumptions about the form of the underlying data distribution, meaning they do not rely on a fixed number of parameters. Instead, the number of parameters grows with the amount of data, allowing them to adapt more flexibly to the data. Some well-known non-parametric models include:\n\n1.  **K-Nearest Neighbors (K-NN):**\n    *   Does not assume any specific structure in the data. It classifies a new data point based on the classes of its closest neighbors, with the number of neighbors often specified by a hyperparameter.\n2.  **Decision Trees:**\n    *   Can be considered non-parametric since they split data based on feature values without a pre-set structure. The tree grows based on the data until a stopping condition is met, making it highly adaptable.\n3.  **Random Forests and Bagging:**\n    *   Ensembles of decision trees are also non-parametric as they aggregate multiple non-parametric decision trees to make a prediction. Each tree in the forest adjusts based on different subsets of the data.\n4.  **Support Vector Machines (with non-linear kernels):**\n    *   With non-linear kernels, SVMs can be non-parametric, as the number of support vectors used can grow with the data, allowing it to model complex decision boundaries without a fixed parameter set.\n5.  **Gaussian Processes:**\n    *   A flexible, non-parametric Bayesian approach where predictions are distributions that adapt to data patterns. The model complexity grows with the number of data points.\n6.  **Kernel Density Estimation (KDE):**\n    *   Used for estimating the probability density function of a random variable without assuming a particular distribution form. KDE is data-driven and can adapt to complex data structures.\n7.  **Neural Networks (sometimes considered):**\n    *   Though typically seen as parametric, certain architectures, such as deep neural networks with many layers, can approximate non-parametric behavior in practice because they adapt flexibly to data and often have many more parameters than simpler models.\n\n*   Does not assume any specific structure in the data. It classifies a new data point based on the classes of its closest neighbors, with the number of neighbors often specified by a hyperparameter.\n\n*   Can be considered non-parametric since they split data based on feature values without a pre-set structure. The tree grows based on the data until a stopping condition is met, making it highly adaptable.\n\n*   Ensembles of decision trees are also non-parametric as they aggregate multiple non-parametric decision trees to make a prediction. Each tree in the forest adjusts based on different subsets of the data.\n\n*   With non-linear kernels, SVMs can be non-parametric, as the number of support vectors used can grow with the data, allowing it to model complex decision boundaries without a fixed parameter set.\n\n*   A flexible, non-parametric Bayesian approach where predictions are distributions that adapt to data patterns. The model complexity grows with the number of data points.\n\n*   Used for estimating the probability density function of a random variable without assuming a particular distribution form. KDE is data-driven and can adapt to complex data structures.\n\n*   Though typically seen as parametric, certain architectures, such as deep neural networks with many layers, can approximate non-parametric behavior in practice because they adapt flexibly to data and often have many more parameters than simpler models.\n\n*   Non-parametric models are generally more flexible and better at capturing intricate patterns in data, but they may require more data and computational resources than parametric models to make accurate predictions.",
      "order": 240,
      "orderInChapter": 41,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "neural network",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 564,
        "contentLength": 4312
      },
      "nextCards": [
        "ai-interview-is-k-means-clustering-parametric-241",
        "ai-interview-what-are-alpha-experiments-for-feature-selection-i-242"
      ],
      "relatedCards": [
        "ai-decision-trees-and-ensemble-methods-stacking-stacked-generalization-10",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-top-30-papers-neural-message-passing-for-quantum-chemistry-12",
        "ai-AIDetect-stylometry-3",
        "ai-context-length-extension-ntk-neural-tangent-kernel-3"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#which-ml-algorithms-are-non-parametric?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-k-means-clustering-parametric-241",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Is K-means Clustering Parametric?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>Yes, k-means clustering is generally considered a parametric model, not a non-parametric one. Here’s why:</p>\n\n    <ol>\n      <li>\n        <p><strong>Fixed Number of Parameters</strong>: In K-means, the number of clusters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-205-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1700\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1701\"><span class=\"mi\" id=\"MathJax-Span-1702\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-205\">K</script> is predetermined, meaning that the model has a fixed number of parameters (the centroids of the clusters) regardless of the data size. This differs from non-parametric models, which adapt their complexity based on the amount of data available.</p>\n      </li>\n      <li>\n        <p><strong>Centroid-based Structure</strong>: K-means clustering represents each cluster with a centroid, which is computed as the mean of points within the cluster. The model assumes that clusters are roughly spherical around these centroids and that each data point belongs to the nearest centroid.</p>\n      </li>\n      <li>\n        <p><strong>Rigid Assumptions</strong>: K-means clustering makes specific assumptions about the structure of the data, particularly that clusters are isotropic and separable based on distance (typically Euclidean distance).</p>\n      </li>\n    </ol>\n  </li>\n  <li>In contrast, non-parametric clustering techniques, like DBSCAN (Density-Based Spatial Clustering of Applications with Noise) or hierarchical clustering, don’t require a fixed number of clusters. DBSCAN, for instance, identifies clusters based on data density and can adjust to data with varying shapes and densities, which is characteristic of non-parametric models.</li>\n  <li>So, while K-means is a powerful clustering algorithm, it is not considered non-parametric because of its reliance on a fixed, predetermined number of clusters and specific assumptions about data structure.</li>\n</ul>\n<p>Yes, k-means clustering is generally considered a parametric model, not a non-parametric one. Here’s why:</p>\n<ol>\n      <li>\n        <p><strong>Fixed Number of Parameters</strong>: In K-means, the number of clusters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-205-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1700\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1701\"><span class=\"mi\" id=\"MathJax-Span-1702\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-205\">K</script> is predetermined, meaning that the model has a fixed number of parameters (the centroids of the clusters) regardless of the data size. This differs from non-parametric models, which adapt their complexity based on the amount of data available.</p>\n      </li>\n      <li>\n        <p><strong>Centroid-based Structure</strong>: K-means clustering represents each cluster with a centroid, which is computed as the mean of points within the cluster. The model assumes that clusters are roughly spherical around these centroids and that each data point belongs to the nearest centroid.</p>\n      </li>\n      <li>\n        <p><strong>Rigid Assumptions</strong>: K-means clustering makes specific assumptions about the structure of the data, particularly that clusters are isotropic and separable based on distance (typically Euclidean distance).</p>\n      </li>\n    </ol>\n<p><strong>Fixed Number of Parameters</strong>: In K-means, the number of clusters <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-205-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1700\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1701\"><span class=\"mi\" id=\"MathJax-Span-1702\" style=\"font-family: STIXGeneral-Italic;\">K<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>K</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-205\">K</script> is predetermined, meaning that the model has a fixed number of parameters (the centroids of the clusters) regardless of the data size. This differs from non-parametric models, which adapt their complexity based on the amount of data available.</p>\n<p><strong>Centroid-based Structure</strong>: K-means clustering represents each cluster with a centroid, which is computed as the mean of points within the cluster. The model assumes that clusters are roughly spherical around these centroids and that each data point belongs to the nearest centroid.</p>\n<p><strong>Rigid Assumptions</strong>: K-means clustering makes specific assumptions about the structure of the data, particularly that clusters are isotropic and separable based on distance (typically Euclidean distance).</p>\n<h4 id=\"what-is-an-isotropic-cluster\">What is an Isotropic Cluster?</h4>\n<ul>\n  <li>\n    <p>An isotropic cluster is a type of cluster in which data points are distributed uniformly in all directions around a central point, usually forming a roughly spherical or circular shape. The key characteristics of an isotropic cluster are:</p>\n\n    <ol>\n      <li>\n        <p><strong>Equal Variance in All Directions</strong>: In an isotropic cluster, the spread of data points is the same in every direction from the center. This means the variance along any axis or dimension is equal.</p>\n      </li>\n      <li>\n        <p><strong>Spherical (or Circular) Shape</strong>: In a two-dimensional space, isotropic clusters tend to be circular, while in higher dimensions, they form spherical clusters. The data points are distributed around the cluster center at a similar distance, forming a ball-shaped distribution.</p>\n      </li>\n      <li>\n        <p><strong>Distance-based Clustering Assumptions</strong>: Algorithms like K-means clustering assume isotropic clusters because they use Euclidean distance to assign points to the nearest centroid. This assumption works well when clusters are spherical, as Euclidean distance effectively captures proximity to the cluster centers.</p>\n      </li>\n      <li>\n        <p><strong>Contrast with Anisotropic Clusters</strong>: An <em>anisotropic cluster</em> has a spread that varies across different directions, which can result in ellipsoidal shapes or elongated clusters. Anisotropic clusters do not have uniform variance in all directions.</p>\n      </li>\n    </ol>\n  </li>\n</ul>\n<p>An isotropic cluster is a type of cluster in which data points are distributed uniformly in all directions around a central point, usually forming a roughly spherical or circular shape. The key characteristics of an isotropic cluster are:</p>\n<ol>\n      <li>\n        <p><strong>Equal Variance in All Directions</strong>: In an isotropic cluster, the spread of data points is the same in every direction from the center. This means the variance along any axis or dimension is equal.</p>\n      </li>\n      <li>\n        <p><strong>Spherical (or Circular) Shape</strong>: In a two-dimensional space, isotropic clusters tend to be circular, while in higher dimensions, they form spherical clusters. The data points are distributed around the cluster center at a similar distance, forming a ball-shaped distribution.</p>\n      </li>\n      <li>\n        <p><strong>Distance-based Clustering Assumptions</strong>: Algorithms like K-means clustering assume isotropic clusters because they use Euclidean distance to assign points to the nearest centroid. This assumption works well when clusters are spherical, as Euclidean distance effectively captures proximity to the cluster centers.</p>\n      </li>\n      <li>\n        <p><strong>Contrast with Anisotropic Clusters</strong>: An <em>anisotropic cluster</em> has a spread that varies across different directions, which can result in ellipsoidal shapes or elongated clusters. Anisotropic clusters do not have uniform variance in all directions.</p>\n      </li>\n    </ol>\n<p><strong>Equal Variance in All Directions</strong>: In an isotropic cluster, the spread of data points is the same in every direction from the center. This means the variance along any axis or dimension is equal.</p>\n<p><strong>Spherical (or Circular) Shape</strong>: In a two-dimensional space, isotropic clusters tend to be circular, while in higher dimensions, they form spherical clusters. The data points are distributed around the cluster center at a similar distance, forming a ball-shaped distribution.</p>\n<p><strong>Distance-based Clustering Assumptions</strong>: Algorithms like K-means clustering assume isotropic clusters because they use Euclidean distance to assign points to the nearest centroid. This assumption works well when clusters are spherical, as Euclidean distance effectively captures proximity to the cluster centers.</p>\n<p><strong>Contrast with Anisotropic Clusters</strong>: An <em>anisotropic cluster</em> has a spread that varies across different directions, which can result in ellipsoidal shapes or elongated clusters. Anisotropic clusters do not have uniform variance in all directions.</p>\n<h5 id=\"example\">Example</h5>\n<ul>\n  <li>\n    <p>Imagine clustering data points in two dimensions:</p>\n\n    <ul>\n      <li><strong>Isotropic Cluster</strong>: Points are evenly distributed around a central point, forming a circular shape with roughly the same spread in all directions.</li>\n      <li><strong>Anisotropic Cluster</strong>: Points are distributed in an elongated ellipse, with a greater spread in one direction than the other.</li>\n    </ul>\n  </li>\n  <li>\n    <p>Isotropic clusters are simple and computationally convenient, but real-world data often have anisotropic structures, which require more flexible clustering methods, like Gaussian Mixture Models or DBSCAN, that can adapt to clusters with non-spherical shapes.</p>\n  </li>\n</ul>\n<p>Imagine clustering data points in two dimensions:</p>\n<ul>\n      <li><strong>Isotropic Cluster</strong>: Points are evenly distributed around a central point, forming a circular shape with roughly the same spread in all directions.</li>\n      <li><strong>Anisotropic Cluster</strong>: Points are distributed in an elongated ellipse, with a greater spread in one direction than the other.</li>\n    </ul>\n<p>Isotropic clusters are simple and computationally convenient, but real-world data often have anisotropic structures, which require more flexible clustering methods, like Gaussian Mixture Models or DBSCAN, that can adapt to clusters with non-spherical shapes.</p>",
      "contentMarkdown": "*   Yes, k-means clustering is generally considered a parametric model, not a non-parametric one. Here’s why:\n    \n    1.  **Fixed Number of Parameters**: In K-means, the number of clusters KKK is predetermined, meaning that the model has a fixed number of parameters (the centroids of the clusters) regardless of the data size. This differs from non-parametric models, which adapt their complexity based on the amount of data available.\n        \n    2.  **Centroid-based Structure**: K-means clustering represents each cluster with a centroid, which is computed as the mean of points within the cluster. The model assumes that clusters are roughly spherical around these centroids and that each data point belongs to the nearest centroid.\n        \n    3.  **Rigid Assumptions**: K-means clustering makes specific assumptions about the structure of the data, particularly that clusters are isotropic and separable based on distance (typically Euclidean distance).\n        \n*   In contrast, non-parametric clustering techniques, like DBSCAN (Density-Based Spatial Clustering of Applications with Noise) or hierarchical clustering, don’t require a fixed number of clusters. DBSCAN, for instance, identifies clusters based on data density and can adjust to data with varying shapes and densities, which is characteristic of non-parametric models.\n*   So, while K-means is a powerful clustering algorithm, it is not considered non-parametric because of its reliance on a fixed, predetermined number of clusters and specific assumptions about data structure.\n\nYes, k-means clustering is generally considered a parametric model, not a non-parametric one. Here’s why:\n\n1.  **Fixed Number of Parameters**: In K-means, the number of clusters KKK is predetermined, meaning that the model has a fixed number of parameters (the centroids of the clusters) regardless of the data size. This differs from non-parametric models, which adapt their complexity based on the amount of data available.\n    \n2.  **Centroid-based Structure**: K-means clustering represents each cluster with a centroid, which is computed as the mean of points within the cluster. The model assumes that clusters are roughly spherical around these centroids and that each data point belongs to the nearest centroid.\n    \n3.  **Rigid Assumptions**: K-means clustering makes specific assumptions about the structure of the data, particularly that clusters are isotropic and separable based on distance (typically Euclidean distance).\n    \n\n**Fixed Number of Parameters**: In K-means, the number of clusters KKK is predetermined, meaning that the model has a fixed number of parameters (the centroids of the clusters) regardless of the data size. This differs from non-parametric models, which adapt their complexity based on the amount of data available.\n\n**Centroid-based Structure**: K-means clustering represents each cluster with a centroid, which is computed as the mean of points within the cluster. The model assumes that clusters are roughly spherical around these centroids and that each data point belongs to the nearest centroid.\n\n**Rigid Assumptions**: K-means clustering makes specific assumptions about the structure of the data, particularly that clusters are isotropic and separable based on distance (typically Euclidean distance).\n\n#### What is an Isotropic Cluster?\n\n*   An isotropic cluster is a type of cluster in which data points are distributed uniformly in all directions around a central point, usually forming a roughly spherical or circular shape. The key characteristics of an isotropic cluster are:\n    \n    1.  **Equal Variance in All Directions**: In an isotropic cluster, the spread of data points is the same in every direction from the center. This means the variance along any axis or dimension is equal.\n        \n    2.  **Spherical (or Circular) Shape**: In a two-dimensional space, isotropic clusters tend to be circular, while in higher dimensions, they form spherical clusters. The data points are distributed around the cluster center at a similar distance, forming a ball-shaped distribution.\n        \n    3.  **Distance-based Clustering Assumptions**: Algorithms like K-means clustering assume isotropic clusters because they use Euclidean distance to assign points to the nearest centroid. This assumption works well when clusters are spherical, as Euclidean distance effectively captures proximity to the cluster centers.\n        \n    4.  **Contrast with Anisotropic Clusters**: An _anisotropic cluster_ has a spread that varies across different directions, which can result in ellipsoidal shapes or elongated clusters. Anisotropic clusters do not have uniform variance in all directions.\n        \n\nAn isotropic cluster is a type of cluster in which data points are distributed uniformly in all directions around a central point, usually forming a roughly spherical or circular shape. The key characteristics of an isotropic cluster are:\n\n1.  **Equal Variance in All Directions**: In an isotropic cluster, the spread of data points is the same in every direction from the center. This means the variance along any axis or dimension is equal.\n    \n2.  **Spherical (or Circular) Shape**: In a two-dimensional space, isotropic clusters tend to be circular, while in higher dimensions, they form spherical clusters. The data points are distributed around the cluster center at a similar distance, forming a ball-shaped distribution.\n    \n3.  **Distance-based Clustering Assumptions**: Algorithms like K-means clustering assume isotropic clusters because they use Euclidean distance to assign points to the nearest centroid. This assumption works well when clusters are spherical, as Euclidean distance effectively captures proximity to the cluster centers.\n    \n4.  **Contrast with Anisotropic Clusters**: An _anisotropic cluster_ has a spread that varies across different directions, which can result in ellipsoidal shapes or elongated clusters. Anisotropic clusters do not have uniform variance in all directions.\n    \n\n**Equal Variance in All Directions**: In an isotropic cluster, the spread of data points is the same in every direction from the center. This means the variance along any axis or dimension is equal.\n\n**Spherical (or Circular) Shape**: In a two-dimensional space, isotropic clusters tend to be circular, while in higher dimensions, they form spherical clusters. The data points are distributed around the cluster center at a similar distance, forming a ball-shaped distribution.\n\n**Distance-based Clustering Assumptions**: Algorithms like K-means clustering assume isotropic clusters because they use Euclidean distance to assign points to the nearest centroid. This assumption works well when clusters are spherical, as Euclidean distance effectively captures proximity to the cluster centers.\n\n**Contrast with Anisotropic Clusters**: An _anisotropic cluster_ has a spread that varies across different directions, which can result in ellipsoidal shapes or elongated clusters. Anisotropic clusters do not have uniform variance in all directions.\n\n##### Example\n\n*   Imagine clustering data points in two dimensions:\n    \n    *   **Isotropic Cluster**: Points are evenly distributed around a central point, forming a circular shape with roughly the same spread in all directions.\n    *   **Anisotropic Cluster**: Points are distributed in an elongated ellipse, with a greater spread in one direction than the other.\n*   Isotropic clusters are simple and computationally convenient, but real-world data often have anisotropic structures, which require more flexible clustering methods, like Gaussian Mixture Models or DBSCAN, that can adapt to clusters with non-spherical shapes.\n    \n\nImagine clustering data points in two dimensions:\n\n*   **Isotropic Cluster**: Points are evenly distributed around a central point, forming a circular shape with roughly the same spread in all directions.\n*   **Anisotropic Cluster**: Points are distributed in an elongated ellipse, with a greater spread in one direction than the other.\n\nIsotropic clusters are simple and computationally convenient, but real-world data often have anisotropic structures, which require more flexible clustering methods, like Gaussian Mixture Models or DBSCAN, that can adapt to clusters with non-spherical shapes.",
      "order": 241,
      "orderInChapter": 42,
      "difficulty": 5,
      "estimatedMinutes": 6,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 1173,
        "contentLength": 13178
      },
      "nextCards": [
        "ai-interview-what-are-alpha-experiments-for-feature-selection-i-242",
        "ai-interview-what-are-beta-experiments-in-ml-model-training-243"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-k-means-clustering-parametric?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-alpha-experiments-for-feature-selection-i-242",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Alpha Experiments for Feature Selection in ML Model Training?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Alpha experiments, particularly in the context of machine learning and feature selection, refer to early-stage testing and exploration of potential features to include in a predictive model. These experiments are typically used to assess the impact of individual features or combinations of features on model performance before committing to a full model development and evaluation cycle. Here are some common alpha experimental approaches and techniques for feature selection in machine learning:</li>\n</ul>\n<h4 id=\"single-feature-testing\">Single-Feature Testing</h4>\n<ul>\n  <li><strong>Objective:</strong> Quickly assess whether a feature has any predictive power.</li>\n  <li><strong>Method:</strong> Train simple models using only one feature at a time. This can be done with lightweight models (like linear regression or decision trees), using each feature individually to see if it yields any predictive performance. This approach is a quick way to determine whether any given feature adds value on its own.</li>\n</ul>\n<h4 id=\"correlation-analysis\">Correlation Analysis</h4>\n<ul>\n  <li><strong>Objective:</strong> Identify potentially redundant features.</li>\n  <li><strong>Method:</strong> Use correlation matrices or other statistical measures (such as mutual information) to identify pairs of features that are highly correlated. Redundant features can inflate model complexity and may not add value, so alpha experiments can help identify features to drop early on.</li>\n</ul>\n<h4 id=\"forward-and-backward-selection\">Forward and Backward Selection</h4>\n<ul>\n  <li><strong>Objective:</strong> Incrementally add or remove features to see their effect.</li>\n  <li><strong>Method:</strong> In forward selection, start with no features and add them one by one, testing the model’s performance each time. In backward selection, start with all features and remove them one by one. These methods allow for quick experimentation to identify impactful features or subsets.</li>\n</ul>\n<h4 id=\"pca-and-other-dimensionality-reduction-techniques\">PCA and Other Dimensionality Reduction Techniques</h4>\n<ul>\n  <li><strong>Objective:</strong> Explore the underlying structure and redundancy of features.</li>\n  <li><strong>Method:</strong> Principal Component Analysis (PCA) and other dimensionality reduction techniques can help identify which features capture the most variance in the data, potentially reducing the feature space while retaining significant information.</li>\n</ul>\n<h4 id=\"recursive-feature-elimination-rfe\">Recursive Feature Elimination (RFE)</h4>\n<ul>\n  <li><strong>Objective:</strong> Test combinations of features by iteratively removing less important ones.</li>\n  <li><strong>Method:</strong> Use RFE with a simple model to rank features by importance. This method eliminates the least important feature(s) in each iteration and re-evaluates the model. This iterative approach can be a quick way to identify a subset of features that improves performance, making it suitable for alpha-stage feature selection.</li>\n</ul>\n<h4 id=\"univariate-feature-selection\">Univariate Feature Selection</h4>\n<ul>\n  <li><strong>Objective:</strong> Rank features based on statistical significance.</li>\n  <li><strong>Method:</strong> Use statistical tests (such as ANOVA, chi-square, or t-tests) to evaluate the relationship of each feature with the target variable individually. Selecting features with high scores provides a quick, univariate assessment of the feature’s potential value.</li>\n</ul>\n<h4 id=\"feature-importance-with-tree-based-models\">Feature Importance with Tree-Based Models</h4>\n<ul>\n  <li><strong>Objective:</strong> Quickly determine feature importance in nonlinear models.</li>\n  <li><strong>Method:</strong> Use a simple tree-based model (like a Decision Tree or a small Random Forest) to obtain feature importance scores. Many tree-based models automatically rank features based on their importance, allowing you to test which features contribute most to model performance in alpha experiments.</li>\n</ul>\n<h4 id=\"regularization-techniques-l1-and-l2\">Regularization Techniques (L1 and L2)</h4>\n<ul>\n  <li><strong>Objective:</strong> Perform feature selection by penalizing complexity.</li>\n  <li><strong>Method:</strong> Use regularized linear models (such as Lasso for L1 regularization and Ridge for L2 regularization) to identify features that contribute the most predictive power while reducing the effect of less important features. L1 regularization can even reduce the coefficients of some features to zero, effectively performing feature selection.</li>\n</ul>\n<h4 id=\"permutation-feature-importance\">Permutation Feature Importance</h4>\n<ul>\n  <li><strong>Objective:</strong> Test the robustness of each feature’s contribution.</li>\n  <li><strong>Method:</strong> Shuffle the values of each feature in turn and observe the impact on model performance. Features that cause a significant drop in performance when permuted are likely more important, helping identify which features are essential at an early stage.</li>\n</ul>\n<h4 id=\"synthetic-feature-generation-and-interaction-testing\">Synthetic Feature Generation and Interaction Testing</h4>\n<ul>\n  <li><strong>Objective:</strong> Test interaction effects and derived features.</li>\n  <li><strong>Method:</strong> Create new features by combining existing ones (like ratios, sums, or polynomial combinations) and test their impact on the model. This can reveal non-obvious interactions that may improve performance and is especially useful for identifying candidate features for later stages.</li>\n</ul>\n<h4 id=\"feature-selection-based-on-stability-scores\">Feature Selection Based on Stability Scores</h4>\n<ul>\n  <li><strong>Objective:</strong> Test feature consistency across different datasets.</li>\n  <li><strong>Method:</strong> Train the model on different subsets of data or through cross-validation, recording feature importance scores for each subset. Features with high variance in importance scores may be unreliable, so identifying stable features early on can improve model robustness.</li>\n</ul>\n<h4 id=\"best-practices-for-alpha-feature-selection-experiments\">Best Practices for Alpha Feature Selection Experiments</h4>\n<ul>\n  <li><strong>Use lightweight models</strong> to quickly test and iterate over features without overfitting.</li>\n  <li><strong>Automate experiments</strong> where possible, using pipelines that can test multiple feature combinations, track results, and highlight impactful features.</li>\n  <li><strong>Validate across subsets</strong> of data (cross-validation) to avoid overfitting to specific feature subsets.</li>\n  <li>\n    <p><strong>Document results</strong> for each experiment, noting feature performance for future refinement in subsequent beta and production phases.</p>\n  </li>\n  <li>Alpha feature selection experiments aim to narrow down a large feature set to a manageable, high-potential subset that can be tested in depth in later stages, ultimately improving model performance, interpretability, and robustness.</li>\n</ul>\n<p><strong>Document results</strong> for each experiment, noting feature performance for future refinement in subsequent beta and production phases.</p>",
      "contentMarkdown": "*   Alpha experiments, particularly in the context of machine learning and feature selection, refer to early-stage testing and exploration of potential features to include in a predictive model. These experiments are typically used to assess the impact of individual features or combinations of features on model performance before committing to a full model development and evaluation cycle. Here are some common alpha experimental approaches and techniques for feature selection in machine learning:\n\n#### Single-Feature Testing\n\n*   **Objective:** Quickly assess whether a feature has any predictive power.\n*   **Method:** Train simple models using only one feature at a time. This can be done with lightweight models (like linear regression or decision trees), using each feature individually to see if it yields any predictive performance. This approach is a quick way to determine whether any given feature adds value on its own.\n\n#### Correlation Analysis\n\n*   **Objective:** Identify potentially redundant features.\n*   **Method:** Use correlation matrices or other statistical measures (such as mutual information) to identify pairs of features that are highly correlated. Redundant features can inflate model complexity and may not add value, so alpha experiments can help identify features to drop early on.\n\n#### Forward and Backward Selection\n\n*   **Objective:** Incrementally add or remove features to see their effect.\n*   **Method:** In forward selection, start with no features and add them one by one, testing the model’s performance each time. In backward selection, start with all features and remove them one by one. These methods allow for quick experimentation to identify impactful features or subsets.\n\n#### PCA and Other Dimensionality Reduction Techniques\n\n*   **Objective:** Explore the underlying structure and redundancy of features.\n*   **Method:** Principal Component Analysis (PCA) and other dimensionality reduction techniques can help identify which features capture the most variance in the data, potentially reducing the feature space while retaining significant information.\n\n#### Recursive Feature Elimination (RFE)\n\n*   **Objective:** Test combinations of features by iteratively removing less important ones.\n*   **Method:** Use RFE with a simple model to rank features by importance. This method eliminates the least important feature(s) in each iteration and re-evaluates the model. This iterative approach can be a quick way to identify a subset of features that improves performance, making it suitable for alpha-stage feature selection.\n\n#### Univariate Feature Selection\n\n*   **Objective:** Rank features based on statistical significance.\n*   **Method:** Use statistical tests (such as ANOVA, chi-square, or t-tests) to evaluate the relationship of each feature with the target variable individually. Selecting features with high scores provides a quick, univariate assessment of the feature’s potential value.\n\n#### Feature Importance with Tree-Based Models\n\n*   **Objective:** Quickly determine feature importance in nonlinear models.\n*   **Method:** Use a simple tree-based model (like a Decision Tree or a small Random Forest) to obtain feature importance scores. Many tree-based models automatically rank features based on their importance, allowing you to test which features contribute most to model performance in alpha experiments.\n\n#### Regularization Techniques (L1 and L2)\n\n*   **Objective:** Perform feature selection by penalizing complexity.\n*   **Method:** Use regularized linear models (such as Lasso for L1 regularization and Ridge for L2 regularization) to identify features that contribute the most predictive power while reducing the effect of less important features. L1 regularization can even reduce the coefficients of some features to zero, effectively performing feature selection.\n\n#### Permutation Feature Importance\n\n*   **Objective:** Test the robustness of each feature’s contribution.\n*   **Method:** Shuffle the values of each feature in turn and observe the impact on model performance. Features that cause a significant drop in performance when permuted are likely more important, helping identify which features are essential at an early stage.\n\n#### Synthetic Feature Generation and Interaction Testing\n\n*   **Objective:** Test interaction effects and derived features.\n*   **Method:** Create new features by combining existing ones (like ratios, sums, or polynomial combinations) and test their impact on the model. This can reveal non-obvious interactions that may improve performance and is especially useful for identifying candidate features for later stages.\n\n#### Feature Selection Based on Stability Scores\n\n*   **Objective:** Test feature consistency across different datasets.\n*   **Method:** Train the model on different subsets of data or through cross-validation, recording feature importance scores for each subset. Features with high variance in importance scores may be unreliable, so identifying stable features early on can improve model robustness.\n\n#### Best Practices for Alpha Feature Selection Experiments\n\n*   **Use lightweight models** to quickly test and iterate over features without overfitting.\n*   **Automate experiments** where possible, using pipelines that can test multiple feature combinations, track results, and highlight impactful features.\n*   **Validate across subsets** of data (cross-validation) to avoid overfitting to specific feature subsets.\n*   **Document results** for each experiment, noting feature performance for future refinement in subsequent beta and production phases.\n    \n*   Alpha feature selection experiments aim to narrow down a large feature set to a manageable, high-potential subset that can be tested in depth in later stages, ultimately improving model performance, interpretability, and robustness.\n\n**Document results** for each experiment, noting feature performance for future refinement in subsequent beta and production phases.",
      "order": 242,
      "orderInChapter": 43,
      "difficulty": 4,
      "estimatedMinutes": 5,
      "tags": [
        "practice",
        "machine learning",
        "regularization",
        "cross-validation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 835,
        "contentLength": 7225
      },
      "nextCards": [
        "ai-interview-what-are-beta-experiments-in-ml-model-training-243",
        "ai-interview-is-low-bias-and-variance-desirable-what-is-the-bia-244"
      ],
      "relatedCards": [
        "ai-ml-comp-support-vector-machines-5",
        "ai-decision-trees-and-ensemble-methods-stacking-stacked-generalization-10",
        "ai-decision-trees-and-ensemble-methods-are-decision-trees-and-their-ensembles-non-paramet-16",
        "ai-decision-trees-and-ensemble-methods-for-practical-deployments-why-is-boosting-preferre-23",
        "ai-bias-variance-tradeoff-overfitting-and-underfitting-common-challenges-in--13"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-alpha-experiments-for-feature-selection-in-ml-model-training?",
      "scrapedAt": "2025-12-28T11:58:12.847Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-beta-experiments-in-ml-model-training-243",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are Beta Experiments in ML Model Training?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Beta experiments represent a pivotal phase in the ML model development lifecycle, following the initial “alpha” experimentation stage. While alpha experiments are typically exploratory, covering a wide range of possibilities, beta experiments shift focus toward refining and validating the model under more realistic conditions. In this phase, the model is closer to its final form, with selected features and configurations tested in a structured and rigorous manner. The goal of beta experiments is to ensure that the model is robust, generalizable, and suitable for deployment.</li>\n  <li>By thoroughly validating and refining the model, beta experiments act as a bridge from early experimentation to production. This stage is critical to confirm that the model will deliver consistent, high-quality performance in real-world applications, making it reliable, resilient, and ready for deployment.</li>\n</ul>\n<h4 id=\"key-objectives-of-beta-experiments\">Key Objectives of Beta Experiments</h4>\n<ol>\n  <li><strong>Feature Validation and Refinement:</strong>\n    <ul>\n      <li>After selecting promising features in alpha experiments, beta experiments validate their effectiveness in various conditions. This stage confirms that selected features consistently contribute to model performance across diverse data scenarios.</li>\n    </ul>\n  </li>\n  <li><strong>Hyperparameter Tuning:</strong>\n    <ul>\n      <li>Beta experiments involve fine-tuning hyperparameters to optimize model performance. This can include testing different configurations for parameters such as learning rate, regularization strength, maximum depth (in tree models), and others, depending on the model type.</li>\n    </ul>\n  </li>\n  <li><strong>Generalization Testing:</strong>\n    <ul>\n      <li>Beta experiments aim to ensure that the model generalizes well to unseen data. This includes testing on held-out data, cross-validation, and potentially testing on a more representative sample of real-world data to assess performance under conditions that mirror deployment.</li>\n    </ul>\n  </li>\n  <li><strong>Bias and Fairness Evaluation:</strong>\n    <ul>\n      <li>An essential part of beta testing is checking the model for any unintended biases or fairness issues. This might involve analyzing model performance across different demographic groups or other subsets to ensure that the model predictions are fair and equitable.</li>\n    </ul>\n  </li>\n  <li><strong>Stability and Robustness Testing:</strong>\n    <ul>\n      <li>Beta experiments evaluate the model’s stability, checking whether it provides consistent performance across different data subsets and configurations. Techniques like stability testing across random seeds or across different data sampling techniques are commonly used to ensure robustness.</li>\n    </ul>\n  </li>\n  <li><strong>Scalability and Efficiency Testing:</strong>\n    <ul>\n      <li>At this stage, model training and inference performance are assessed for efficiency and scalability. This can include analyzing training time, inference speed, and resource requirements to ensure the model will meet the operational demands in production.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>After selecting promising features in alpha experiments, beta experiments validate their effectiveness in various conditions. This stage confirms that selected features consistently contribute to model performance across diverse data scenarios.</li>\n    </ul>\n<ul>\n      <li>Beta experiments involve fine-tuning hyperparameters to optimize model performance. This can include testing different configurations for parameters such as learning rate, regularization strength, maximum depth (in tree models), and others, depending on the model type.</li>\n    </ul>\n<ul>\n      <li>Beta experiments aim to ensure that the model generalizes well to unseen data. This includes testing on held-out data, cross-validation, and potentially testing on a more representative sample of real-world data to assess performance under conditions that mirror deployment.</li>\n    </ul>\n<ul>\n      <li>An essential part of beta testing is checking the model for any unintended biases or fairness issues. This might involve analyzing model performance across different demographic groups or other subsets to ensure that the model predictions are fair and equitable.</li>\n    </ul>\n<ul>\n      <li>Beta experiments evaluate the model’s stability, checking whether it provides consistent performance across different data subsets and configurations. Techniques like stability testing across random seeds or across different data sampling techniques are commonly used to ensure robustness.</li>\n    </ul>\n<ul>\n      <li>At this stage, model training and inference performance are assessed for efficiency and scalability. This can include analyzing training time, inference speed, and resource requirements to ensure the model will meet the operational demands in production.</li>\n    </ul>\n<h4 id=\"techniques-and-approaches-in-beta-experiments\">Techniques and Approaches in Beta Experiments</h4>\n<ol>\n  <li><strong>Cross-Validation with Hyperparameter Tuning</strong>\n    <ul>\n      <li>Use cross-validation (such as k-fold or stratified k-fold) to evaluate model performance more comprehensively across different subsets of the training data. Coupling this with grid search or random search for hyperparameter tuning ensures optimal parameter values are chosen without overfitting.</li>\n    </ul>\n  </li>\n  <li><strong>Automated Hyperparameter Optimization (Bayesian Optimization)</strong>\n    <ul>\n      <li>Techniques like Bayesian optimization, Hyperband, or Tree-structured Parzen Estimator (TPE) can be employed to find the best hyperparameters more efficiently than a simple grid or random search, especially for complex models or larger datasets.</li>\n    </ul>\n  </li>\n  <li><strong>Feature Interaction and Polynomial Feature Testing</strong>\n    <ul>\n      <li>To ensure no valuable interaction is overlooked, beta experiments often involve generating interaction features (e.g., pairwise products or polynomials) among selected features. Testing these interactions can reveal additional improvements in predictive performance, particularly for complex relationships.</li>\n    </ul>\n  </li>\n  <li><strong>Regularization Tuning and Model Pruning</strong>\n    <ul>\n      <li>Regularization parameters (such as L1, L2 for linear models or tree pruning for tree-based models) are fine-tuned to balance complexity and generalizability. This helps prevent overfitting and keeps the model simpler and more interpretable.</li>\n    </ul>\n  </li>\n  <li><strong>Ensemble Methods and Model Stacking</strong>\n    <ul>\n      <li>If a single model is underperforming, beta experiments may involve creating ensembles of models, such as bagging, boosting, or stacking. These techniques combine predictions from multiple models to improve overall performance and robustness, often yielding better results than individual models.</li>\n    </ul>\n  </li>\n  <li><strong>A/B Testing on Real-World Data</strong>\n    <ul>\n      <li>If possible, beta testing may include limited A/B testing or deploying the model to a small segment of users to evaluate real-world performance. This controlled deployment tests the model’s predictions in live environments, capturing user interactions and feedback that reflect real use cases.</li>\n    </ul>\n  </li>\n  <li><strong>Model Interpretability and Explainability Testing</strong>\n    <ul>\n      <li>Interpretable models or post-hoc explainability techniques (like SHAP or LIME) are used to understand and verify the behavior of model predictions. This step is essential for ensuring stakeholders understand the model’s decision-making process and can identify any potential biases or logical inconsistencies.</li>\n    </ul>\n  </li>\n  <li><strong>Sensitivity Analysis</strong>\n    <ul>\n      <li>Sensitivity analysis tests the model’s reaction to small changes in input data, ensuring stability and robustness. For instance, perturbing inputs slightly and observing if the predictions change drastically can indicate an unstable or overly sensitive model that may not perform reliably in production.</li>\n    </ul>\n  </li>\n  <li><strong>Adversarial Testing</strong>\n    <ul>\n      <li>To assess model robustness, adversarial examples or synthetic variations of inputs can be introduced to evaluate the model’s resilience. Adversarial testing helps ensure the model can handle noise, data shifts, and edge cases without significant performance degradation.</li>\n    </ul>\n  </li>\n  <li><strong>Bias Detection and Fairness Audits</strong>\n    <ul>\n      <li>During beta testing, the model undergoes bias and fairness analysis. Techniques like disparate impact analysis or group fairness metrics are used to ensure that the model does not unfairly favor or disadvantage any group.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>Use cross-validation (such as k-fold or stratified k-fold) to evaluate model performance more comprehensively across different subsets of the training data. Coupling this with grid search or random search for hyperparameter tuning ensures optimal parameter values are chosen without overfitting.</li>\n    </ul>\n<ul>\n      <li>Techniques like Bayesian optimization, Hyperband, or Tree-structured Parzen Estimator (TPE) can be employed to find the best hyperparameters more efficiently than a simple grid or random search, especially for complex models or larger datasets.</li>\n    </ul>\n<ul>\n      <li>To ensure no valuable interaction is overlooked, beta experiments often involve generating interaction features (e.g., pairwise products or polynomials) among selected features. Testing these interactions can reveal additional improvements in predictive performance, particularly for complex relationships.</li>\n    </ul>\n<ul>\n      <li>Regularization parameters (such as L1, L2 for linear models or tree pruning for tree-based models) are fine-tuned to balance complexity and generalizability. This helps prevent overfitting and keeps the model simpler and more interpretable.</li>\n    </ul>\n<ul>\n      <li>If a single model is underperforming, beta experiments may involve creating ensembles of models, such as bagging, boosting, or stacking. These techniques combine predictions from multiple models to improve overall performance and robustness, often yielding better results than individual models.</li>\n    </ul>\n<ul>\n      <li>If possible, beta testing may include limited A/B testing or deploying the model to a small segment of users to evaluate real-world performance. This controlled deployment tests the model’s predictions in live environments, capturing user interactions and feedback that reflect real use cases.</li>\n    </ul>\n<ul>\n      <li>Interpretable models or post-hoc explainability techniques (like SHAP or LIME) are used to understand and verify the behavior of model predictions. This step is essential for ensuring stakeholders understand the model’s decision-making process and can identify any potential biases or logical inconsistencies.</li>\n    </ul>\n<ul>\n      <li>Sensitivity analysis tests the model’s reaction to small changes in input data, ensuring stability and robustness. For instance, perturbing inputs slightly and observing if the predictions change drastically can indicate an unstable or overly sensitive model that may not perform reliably in production.</li>\n    </ul>\n<ul>\n      <li>To assess model robustness, adversarial examples or synthetic variations of inputs can be introduced to evaluate the model’s resilience. Adversarial testing helps ensure the model can handle noise, data shifts, and edge cases without significant performance degradation.</li>\n    </ul>\n<ul>\n      <li>During beta testing, the model undergoes bias and fairness analysis. Techniques like disparate impact analysis or group fairness metrics are used to ensure that the model does not unfairly favor or disadvantage any group.</li>\n    </ul>\n<h4 id=\"key-metrics-and-performance-evaluation-in-beta-experiments\">Key Metrics and Performance Evaluation in Beta Experiments</h4>\n<ul>\n  <li><strong>Precision, Recall, F1-Score, ROC-AUC:</strong> Standard classification metrics are often used in beta testing to gauge accuracy, especially for imbalanced datasets where metrics like F1-score and AUC are more informative than accuracy.</li>\n  <li><strong>Mean Absolute Error (MAE), Mean Squared Error (MSE), R-squared:</strong> These are standard metrics for regression tasks and are crucial for assessing the model’s prediction accuracy.</li>\n  <li><strong>Lift and Gain Analysis:</strong> Lift and gain charts assess how well the model segments data for binary classification, especially useful in marketing or recommendation systems.</li>\n  <li><strong>Calibration:</strong> Evaluates whether the predicted probabilities reflect true likelihoods. Calibration is crucial in applications like risk assessment or medical diagnostics where probability estimates must be reliable.</li>\n  <li><strong>Fairness and Bias Metrics:</strong> Evaluates model performance across different demographic or other critical subgroups, looking for parity or lack of discrimination.</li>\n</ul>\n<h4 id=\"outputs-and-next-steps-after-beta-experiments\">Outputs and Next Steps After Beta Experiments</h4>\n<p>After beta experiments, you should have a well-tested, fine-tuned model with documented performance metrics, known limitations, and, ideally, explanations for its decisions. At this point, the model is ready for final validation and deployment. The outputs include:</p>\n<ul>\n  <li><strong>Refined Model with Optimized Hyperparameters:</strong> A trained model with the best hyperparameter values and selected features ready for production.</li>\n  <li><strong>Performance and Robustness Report:</strong> A comprehensive report detailing the model’s performance metrics, robustness, and stability.</li>\n  <li><strong>Explainability and Interpretability Analysis:</strong> Documentation on model behavior, feature importance, and explainability results to ensure stakeholders understand how and why predictions are made.</li>\n  <li><strong>Deployment Readiness Assessment:</strong> Final evaluations on resource requirements, scalability, and integration needs to ensure smooth deployment.</li>\n</ul>\n<h4 id=\"benefits-of-beta-experiments\">Benefits of Beta Experiments</h4>\n<ul>\n  <li><strong>Risk Reduction:</strong> Beta experiments catch potential issues like overfitting, instability, and biases before deployment.</li>\n  <li><strong>Improved Performance and Robustness:</strong> Through thorough testing and fine-tuning, beta experiments enhance model performance and ensure it generalizes well.</li>\n  <li><strong>Transparency and Trust:</strong> By documenting and explaining model behavior, beta experiments build trust with stakeholders and end-users, especially critical for high-stakes applications.</li>\n  <li><strong>Deployment Confidence:</strong> After passing beta experiments, the model is much more likely to perform as expected in production, reducing post-deployment iterations and adjustments.</li>\n</ul>",
      "contentMarkdown": "*   Beta experiments represent a pivotal phase in the ML model development lifecycle, following the initial “alpha” experimentation stage. While alpha experiments are typically exploratory, covering a wide range of possibilities, beta experiments shift focus toward refining and validating the model under more realistic conditions. In this phase, the model is closer to its final form, with selected features and configurations tested in a structured and rigorous manner. The goal of beta experiments is to ensure that the model is robust, generalizable, and suitable for deployment.\n*   By thoroughly validating and refining the model, beta experiments act as a bridge from early experimentation to production. This stage is critical to confirm that the model will deliver consistent, high-quality performance in real-world applications, making it reliable, resilient, and ready for deployment.\n\n#### Key Objectives of Beta Experiments\n\n1.  **Feature Validation and Refinement:**\n    *   After selecting promising features in alpha experiments, beta experiments validate their effectiveness in various conditions. This stage confirms that selected features consistently contribute to model performance across diverse data scenarios.\n2.  **Hyperparameter Tuning:**\n    *   Beta experiments involve fine-tuning hyperparameters to optimize model performance. This can include testing different configurations for parameters such as learning rate, regularization strength, maximum depth (in tree models), and others, depending on the model type.\n3.  **Generalization Testing:**\n    *   Beta experiments aim to ensure that the model generalizes well to unseen data. This includes testing on held-out data, cross-validation, and potentially testing on a more representative sample of real-world data to assess performance under conditions that mirror deployment.\n4.  **Bias and Fairness Evaluation:**\n    *   An essential part of beta testing is checking the model for any unintended biases or fairness issues. This might involve analyzing model performance across different demographic groups or other subsets to ensure that the model predictions are fair and equitable.\n5.  **Stability and Robustness Testing:**\n    *   Beta experiments evaluate the model’s stability, checking whether it provides consistent performance across different data subsets and configurations. Techniques like stability testing across random seeds or across different data sampling techniques are commonly used to ensure robustness.\n6.  **Scalability and Efficiency Testing:**\n    *   At this stage, model training and inference performance are assessed for efficiency and scalability. This can include analyzing training time, inference speed, and resource requirements to ensure the model will meet the operational demands in production.\n\n*   After selecting promising features in alpha experiments, beta experiments validate their effectiveness in various conditions. This stage confirms that selected features consistently contribute to model performance across diverse data scenarios.\n\n*   Beta experiments involve fine-tuning hyperparameters to optimize model performance. This can include testing different configurations for parameters such as learning rate, regularization strength, maximum depth (in tree models), and others, depending on the model type.\n\n*   Beta experiments aim to ensure that the model generalizes well to unseen data. This includes testing on held-out data, cross-validation, and potentially testing on a more representative sample of real-world data to assess performance under conditions that mirror deployment.\n\n*   An essential part of beta testing is checking the model for any unintended biases or fairness issues. This might involve analyzing model performance across different demographic groups or other subsets to ensure that the model predictions are fair and equitable.\n\n*   Beta experiments evaluate the model’s stability, checking whether it provides consistent performance across different data subsets and configurations. Techniques like stability testing across random seeds or across different data sampling techniques are commonly used to ensure robustness.\n\n*   At this stage, model training and inference performance are assessed for efficiency and scalability. This can include analyzing training time, inference speed, and resource requirements to ensure the model will meet the operational demands in production.\n\n#### Techniques and Approaches in Beta Experiments\n\n1.  **Cross-Validation with Hyperparameter Tuning**\n    *   Use cross-validation (such as k-fold or stratified k-fold) to evaluate model performance more comprehensively across different subsets of the training data. Coupling this with grid search or random search for hyperparameter tuning ensures optimal parameter values are chosen without overfitting.\n2.  **Automated Hyperparameter Optimization (Bayesian Optimization)**\n    *   Techniques like Bayesian optimization, Hyperband, or Tree-structured Parzen Estimator (TPE) can be employed to find the best hyperparameters more efficiently than a simple grid or random search, especially for complex models or larger datasets.\n3.  **Feature Interaction and Polynomial Feature Testing**\n    *   To ensure no valuable interaction is overlooked, beta experiments often involve generating interaction features (e.g., pairwise products or polynomials) among selected features. Testing these interactions can reveal additional improvements in predictive performance, particularly for complex relationships.\n4.  **Regularization Tuning and Model Pruning**\n    *   Regularization parameters (such as L1, L2 for linear models or tree pruning for tree-based models) are fine-tuned to balance complexity and generalizability. This helps prevent overfitting and keeps the model simpler and more interpretable.\n5.  **Ensemble Methods and Model Stacking**\n    *   If a single model is underperforming, beta experiments may involve creating ensembles of models, such as bagging, boosting, or stacking. These techniques combine predictions from multiple models to improve overall performance and robustness, often yielding better results than individual models.\n6.  **A/B Testing on Real-World Data**\n    *   If possible, beta testing may include limited A/B testing or deploying the model to a small segment of users to evaluate real-world performance. This controlled deployment tests the model’s predictions in live environments, capturing user interactions and feedback that reflect real use cases.\n7.  **Model Interpretability and Explainability Testing**\n    *   Interpretable models or post-hoc explainability techniques (like SHAP or LIME) are used to understand and verify the behavior of model predictions. This step is essential for ensuring stakeholders understand the model’s decision-making process and can identify any potential biases or logical inconsistencies.\n8.  **Sensitivity Analysis**\n    *   Sensitivity analysis tests the model’s reaction to small changes in input data, ensuring stability and robustness. For instance, perturbing inputs slightly and observing if the predictions change drastically can indicate an unstable or overly sensitive model that may not perform reliably in production.\n9.  **Adversarial Testing**\n    *   To assess model robustness, adversarial examples or synthetic variations of inputs can be introduced to evaluate the model’s resilience. Adversarial testing helps ensure the model can handle noise, data shifts, and edge cases without significant performance degradation.\n10.  **Bias Detection and Fairness Audits**\n     *   During beta testing, the model undergoes bias and fairness analysis. Techniques like disparate impact analysis or group fairness metrics are used to ensure that the model does not unfairly favor or disadvantage any group.\n\n*   Use cross-validation (such as k-fold or stratified k-fold) to evaluate model performance more comprehensively across different subsets of the training data. Coupling this with grid search or random search for hyperparameter tuning ensures optimal parameter values are chosen without overfitting.\n\n*   Techniques like Bayesian optimization, Hyperband, or Tree-structured Parzen Estimator (TPE) can be employed to find the best hyperparameters more efficiently than a simple grid or random search, especially for complex models or larger datasets.\n\n*   To ensure no valuable interaction is overlooked, beta experiments often involve generating interaction features (e.g., pairwise products or polynomials) among selected features. Testing these interactions can reveal additional improvements in predictive performance, particularly for complex relationships.\n\n*   Regularization parameters (such as L1, L2 for linear models or tree pruning for tree-based models) are fine-tuned to balance complexity and generalizability. This helps prevent overfitting and keeps the model simpler and more interpretable.\n\n*   If a single model is underperforming, beta experiments may involve creating ensembles of models, such as bagging, boosting, or stacking. These techniques combine predictions from multiple models to improve overall performance and robustness, often yielding better results than individual models.\n\n*   If possible, beta testing may include limited A/B testing or deploying the model to a small segment of users to evaluate real-world performance. This controlled deployment tests the model’s predictions in live environments, capturing user interactions and feedback that reflect real use cases.\n\n*   Interpretable models or post-hoc explainability techniques (like SHAP or LIME) are used to understand and verify the behavior of model predictions. This step is essential for ensuring stakeholders understand the model’s decision-making process and can identify any potential biases or logical inconsistencies.\n\n*   Sensitivity analysis tests the model’s reaction to small changes in input data, ensuring stability and robustness. For instance, perturbing inputs slightly and observing if the predictions change drastically can indicate an unstable or overly sensitive model that may not perform reliably in production.\n\n*   To assess model robustness, adversarial examples or synthetic variations of inputs can be introduced to evaluate the model’s resilience. Adversarial testing helps ensure the model can handle noise, data shifts, and edge cases without significant performance degradation.\n\n*   During beta testing, the model undergoes bias and fairness analysis. Techniques like disparate impact analysis or group fairness metrics are used to ensure that the model does not unfairly favor or disadvantage any group.\n\n#### Key Metrics and Performance Evaluation in Beta Experiments\n\n*   **Precision, Recall, F1-Score, ROC-AUC:** Standard classification metrics are often used in beta testing to gauge accuracy, especially for imbalanced datasets where metrics like F1-score and AUC are more informative than accuracy.\n*   **Mean Absolute Error (MAE), Mean Squared Error (MSE), R-squared:** These are standard metrics for regression tasks and are crucial for assessing the model’s prediction accuracy.\n*   **Lift and Gain Analysis:** Lift and gain charts assess how well the model segments data for binary classification, especially useful in marketing or recommendation systems.\n*   **Calibration:** Evaluates whether the predicted probabilities reflect true likelihoods. Calibration is crucial in applications like risk assessment or medical diagnostics where probability estimates must be reliable.\n*   **Fairness and Bias Metrics:** Evaluates model performance across different demographic or other critical subgroups, looking for parity or lack of discrimination.\n\n#### Outputs and Next Steps After Beta Experiments\n\nAfter beta experiments, you should have a well-tested, fine-tuned model with documented performance metrics, known limitations, and, ideally, explanations for its decisions. At this point, the model is ready for final validation and deployment. The outputs include:\n\n*   **Refined Model with Optimized Hyperparameters:** A trained model with the best hyperparameter values and selected features ready for production.\n*   **Performance and Robustness Report:** A comprehensive report detailing the model’s performance metrics, robustness, and stability.\n*   **Explainability and Interpretability Analysis:** Documentation on model behavior, feature importance, and explainability results to ensure stakeholders understand how and why predictions are made.\n*   **Deployment Readiness Assessment:** Final evaluations on resource requirements, scalability, and integration needs to ensure smooth deployment.\n\n#### Benefits of Beta Experiments\n\n*   **Risk Reduction:** Beta experiments catch potential issues like overfitting, instability, and biases before deployment.\n*   **Improved Performance and Robustness:** Through thorough testing and fine-tuning, beta experiments enhance model performance and ensure it generalizes well.\n*   **Transparency and Trust:** By documenting and explaining model behavior, beta experiments build trust with stakeholders and end-users, especially critical for high-stakes applications.\n*   **Deployment Confidence:** After passing beta experiments, the model is much more likely to perform as expected in production, reducing post-deployment iterations and adjustments.",
      "order": 243,
      "orderInChapter": 44,
      "difficulty": 5,
      "estimatedMinutes": 10,
      "tags": [
        "practice",
        "optimization",
        "regularization",
        "fine-tuning",
        "cross-validation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 1806,
        "contentLength": 15152
      },
      "nextCards": [
        "ai-interview-is-low-bias-and-variance-desirable-what-is-the-bia-244",
        "ai-interview-is-high-precision-and-recall-desirable-what-is-the-245"
      ],
      "relatedCards": [
        "ai-deepseek-R1-stage-4-secondary-rl-for-alignment-generalization-7",
        "ai-decision-trees-and-ensemble-methods-boosting-9",
        "ai-mixture-of-experts-overview-19",
        "ai-agentic-RL-foundations-and-theoretical-advancements-in-tir-61",
        "ai-deepseek-R1-grpo-successors-9"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-beta-experiments-in-ml-model-training?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-low-bias-and-variance-desirable-what-is-the-bia-244",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Is Low Bias and Variance Desirable? What is the Bias-Variance Tradeoff?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>\n    <p>Yes, achieving low bias and low variance is generally desirable in machine learning because it indicates that a model is both accurate and generalizable. Here’s why each is important:</p>\n\n    <ul>\n      <li>\n        <p><strong>Low Bias</strong>: Bias refers to the error due to overly simplistic assumptions in the model. Low bias means the model accurately captures the true relationship in the data. High bias, on the other hand, can lead to underfitting, where the model doesn’t capture the underlying patterns well.</p>\n      </li>\n      <li>\n        <p><strong>Low Variance</strong>: Variance refers to the model’s sensitivity to fluctuations in the training data. Low variance means that the model can generalize well to new, unseen data. High variance often leads to overfitting, where the model learns the noise or specific quirks of the training data rather than the underlying patterns, making it less effective on new data.</p>\n      </li>\n    </ul>\n  </li>\n</ul>\n<p>Yes, achieving low bias and low variance is generally desirable in machine learning because it indicates that a model is both accurate and generalizable. Here’s why each is important:</p>\n<ul>\n      <li>\n        <p><strong>Low Bias</strong>: Bias refers to the error due to overly simplistic assumptions in the model. Low bias means the model accurately captures the true relationship in the data. High bias, on the other hand, can lead to underfitting, where the model doesn’t capture the underlying patterns well.</p>\n      </li>\n      <li>\n        <p><strong>Low Variance</strong>: Variance refers to the model’s sensitivity to fluctuations in the training data. Low variance means that the model can generalize well to new, unseen data. High variance often leads to overfitting, where the model learns the noise or specific quirks of the training data rather than the underlying patterns, making it less effective on new data.</p>\n      </li>\n    </ul>\n<p><strong>Low Bias</strong>: Bias refers to the error due to overly simplistic assumptions in the model. Low bias means the model accurately captures the true relationship in the data. High bias, on the other hand, can lead to underfitting, where the model doesn’t capture the underlying patterns well.</p>\n<p><strong>Low Variance</strong>: Variance refers to the model’s sensitivity to fluctuations in the training data. Low variance means that the model can generalize well to new, unseen data. High variance often leads to overfitting, where the model learns the noise or specific quirks of the training data rather than the underlying patterns, making it less effective on new data.</p>\n<h4 id=\"the-bias-variance-tradeoff\">The Bias-Variance Tradeoff</h4>\n<ul>\n  <li>In practice, there’s a tradeoff between bias and variance, as models with low bias (high complexity) often have higher variance, and models with low variance (low complexity) tend to have higher bias. The ideal model is one that balances these two factors, achieving both low bias and low variance to minimize prediction error on unseen data.</li>\n  <li>So, while low bias and low variance are desirable, it can be challenging to achieve both simultaneously, and some balance is often needed based on the specifics of the data and problem.</li>\n</ul>",
      "contentMarkdown": "*   Yes, achieving low bias and low variance is generally desirable in machine learning because it indicates that a model is both accurate and generalizable. Here’s why each is important:\n    \n    *   **Low Bias**: Bias refers to the error due to overly simplistic assumptions in the model. Low bias means the model accurately captures the true relationship in the data. High bias, on the other hand, can lead to underfitting, where the model doesn’t capture the underlying patterns well.\n        \n    *   **Low Variance**: Variance refers to the model’s sensitivity to fluctuations in the training data. Low variance means that the model can generalize well to new, unseen data. High variance often leads to overfitting, where the model learns the noise or specific quirks of the training data rather than the underlying patterns, making it less effective on new data.\n        \n\nYes, achieving low bias and low variance is generally desirable in machine learning because it indicates that a model is both accurate and generalizable. Here’s why each is important:\n\n*   **Low Bias**: Bias refers to the error due to overly simplistic assumptions in the model. Low bias means the model accurately captures the true relationship in the data. High bias, on the other hand, can lead to underfitting, where the model doesn’t capture the underlying patterns well.\n    \n*   **Low Variance**: Variance refers to the model’s sensitivity to fluctuations in the training data. Low variance means that the model can generalize well to new, unseen data. High variance often leads to overfitting, where the model learns the noise or specific quirks of the training data rather than the underlying patterns, making it less effective on new data.\n    \n\n**Low Bias**: Bias refers to the error due to overly simplistic assumptions in the model. Low bias means the model accurately captures the true relationship in the data. High bias, on the other hand, can lead to underfitting, where the model doesn’t capture the underlying patterns well.\n\n**Low Variance**: Variance refers to the model’s sensitivity to fluctuations in the training data. Low variance means that the model can generalize well to new, unseen data. High variance often leads to overfitting, where the model learns the noise or specific quirks of the training data rather than the underlying patterns, making it less effective on new data.\n\n#### The Bias-Variance Tradeoff\n\n*   In practice, there’s a tradeoff between bias and variance, as models with low bias (high complexity) often have higher variance, and models with low variance (low complexity) tend to have higher bias. The ideal model is one that balances these two factors, achieving both low bias and low variance to minimize prediction error on unseen data.\n*   So, while low bias and low variance are desirable, it can be challenging to achieve both simultaneously, and some balance is often needed based on the specifics of the data and problem.",
      "order": 244,
      "orderInChapter": 45,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "machine learning"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 472,
        "contentLength": 3276
      },
      "nextCards": [
        "ai-interview-is-high-precision-and-recall-desirable-what-is-the-245",
        "ai-interview-what-is-the-zipfs-law-ie-power-law-246"
      ],
      "relatedCards": [
        "ai-support-vector-machines-conceptual-overview-5",
        "ai-decision-trees-and-ensemble-methods-pitfalls-of-decision-trees-and-their-ensembles-con-12",
        "ai-ml-comp-k-nearest-neighbors-4",
        "ai-diffusion-models-denoising-diffusion-pytorch-package-35",
        "ai-standardization-vs-normalization-example-1"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-low-bias-and-variance-desirable?-what-is-the-bias-variance-tradeoff?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-is-high-precision-and-recall-desirable-what-is-the-245",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Is High Precision and Recall Desirable? What is the Precision-recall Tradeoff?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Yes, high precision and recall are generally desirable, but they often compete with each other, leading to what is known as the precision-recall tradeoff. Understanding these metrics and their relationship can help clarify this balance.</li>\n  <li><strong>Precision and Recall:</strong>\n    <ul>\n      <li><strong>Precision</strong>: Measures how many of the items classified as positive are actually positive. High precision means few false positives (FP), so the predictions are accurate when the model says “positive.”\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-206-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Precision</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Positives (FP)</mtext></mfrac></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1703\" style=\"width: 20.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 17.294em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.992em, 1017.29em, 2.867em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1704\"><span class=\"mtext\" id=\"MathJax-Span-1705\" style=\"font-family: STIXGeneral-Regular;\">Precision</span><span class=\"mo\" id=\"MathJax-Span-1706\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1707\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 12.138em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1005.52em, 4.273em, -999.997em); top: -4.529em; left: 50%; margin-left: -2.758em;\"><span class=\"mtext\" id=\"MathJax-Span-1708\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1011.98em, 4.273em, -999.997em); top: -3.643em; left: 50%; margin-left: -6.039em;\"><span class=\"mtext\" id=\"MathJax-Span-1709\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP) + False Positives (FP)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1012.14em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 12.138em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.684em; border-left: 0px solid; width: 0px; height: 1.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Precision</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Positives (FP)</mtext></mfrac></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-206\">\\text{Precision} = \\frac{\\text{True Positives (TP)}}{\\text{True Positives (TP) + False Positives (FP)}}</script></li>\n      <li><strong>Recall</strong>: Measures how many actual positive cases the model captures out of all true positive cases. High recall means few false negatives (FN), so the model catches most true positives.\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-207-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Recall</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Negatives (FN)</mtext></mfrac></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1710\" style=\"width: 19.846em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 16.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.992em, 1016.51em, 2.867em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1711\"><span class=\"mtext\" id=\"MathJax-Span-1712\" style=\"font-family: STIXGeneral-Regular;\">Recall</span><span class=\"mo\" id=\"MathJax-Span-1713\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1714\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 12.555em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1005.52em, 4.273em, -999.997em); top: -4.529em; left: 50%; margin-left: -2.758em;\"><span class=\"mtext\" id=\"MathJax-Span-1715\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1012.4em, 4.326em, -999.997em); top: -3.643em; left: 50%; margin-left: -6.195em;\"><span class=\"mtext\" id=\"MathJax-Span-1716\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP) + False Negatives (FN)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1012.55em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 12.555em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.684em; border-left: 0px solid; width: 0px; height: 2.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Recall</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Negatives (FN)</mtext></mfrac></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-207\">\\text{Recall} = \\frac{\\text{True Positives (TP)}}{\\text{True Positives (TP) + False Negatives (FN)}}</script></li>\n    </ul>\n  </li>\n  <li><strong>Why both are desirable:</strong>\n    <ul>\n      <li>In many applications, high precision and recall together mean that:\n        <ul>\n          <li>High precision: Predictions are trustworthy, with minimal false alarms (false positives).</li>\n          <li>High recall: The model catches all or most of the positive cases, minimizing missed detections (false negatives).</li>\n        </ul>\n      </li>\n      <li>However, achieving high precision and recall simultaneously is challenging, which leads to the precision-recall tradeoff.</li>\n    </ul>\n  </li>\n  <li><strong>The precision-recall tradeoff:</strong>\n    <ul>\n      <li>Increasing one often reduces the other, especially in unbalanced datasets where positives are rare. Here’s why:\n        <ol>\n          <li><strong>Threshold Adjustment</strong>: Many models, especially classification models, use a probability threshold to decide between positive and negative. Adjusting this threshold impacts both precision and recall:\n            <ul>\n              <li>A <strong>higher threshold</strong> typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).</li>\n              <li>A <strong>lower threshold</strong> usually increases recall but reduces precision (more predictions overall, with more false positives).</li>\n            </ul>\n          </li>\n          <li><strong>Application Requirements</strong>: Some applications need high precision over recall, while others need high recall over precision:\n            <ul>\n              <li><strong>High Precision Priority</strong>: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.</li>\n              <li><strong>High Recall Priority</strong>: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.</li>\n            </ul>\n          </li>\n          <li><strong>Balancing Precision and Recall</strong>:\n            <ul>\n              <li>For applications that need a balance, metrics like the <strong>F1 Score</strong> can be helpful as it is the harmonic mean of precision and recall.</li>\n              <li><strong>F1 Score</strong> helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.</li>\n            </ul>\n          </li>\n        </ol>\n      </li>\n    </ul>\n  </li>\n  <li><strong>Practical examples of the tradeoff:</strong>\n    <ul>\n      <li>In <strong>fraud detection</strong>, missing a fraud case (low recall) may be more acceptable if it means only clear fraud cases are flagged (high precision).</li>\n      <li>In <strong>information retrieval</strong> or <strong>search engines</strong>, recall may be more important to ensure users see all relevant results, even if some irrelevant ones appear (accepting lower precision).</li>\n    </ul>\n  </li>\n  <li>In short, high precision and recall are desirable, but they must be balanced based on the application’s specific needs and the cost of false positives versus false negatives.</li>\n</ul>\n<ul>\n      <li><strong>Precision</strong>: Measures how many of the items classified as positive are actually positive. High precision means few false positives (FP), so the predictions are accurate when the model says “positive.”\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-206-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Precision</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Positives (FP)</mtext></mfrac></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1703\" style=\"width: 20.784em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 17.294em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.992em, 1017.29em, 2.867em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1704\"><span class=\"mtext\" id=\"MathJax-Span-1705\" style=\"font-family: STIXGeneral-Regular;\">Precision</span><span class=\"mo\" id=\"MathJax-Span-1706\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1707\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 12.138em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1005.52em, 4.273em, -999.997em); top: -4.529em; left: 50%; margin-left: -2.758em;\"><span class=\"mtext\" id=\"MathJax-Span-1708\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1011.98em, 4.273em, -999.997em); top: -3.643em; left: 50%; margin-left: -6.039em;\"><span class=\"mtext\" id=\"MathJax-Span-1709\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP) + False Positives (FP)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1012.14em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 12.138em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.684em; border-left: 0px solid; width: 0px; height: 1.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Precision</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Positives (FP)</mtext></mfrac></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-206\">\\text{Precision} = \\frac{\\text{True Positives (TP)}}{\\text{True Positives (TP) + False Positives (FP)}}</script></li>\n      <li><strong>Recall</strong>: Measures how many actual positive cases the model captures out of all true positive cases. High recall means few false negatives (FN), so the model catches most true positives.\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-207-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>Recall</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Negatives (FN)</mtext></mfrac></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1710\" style=\"width: 19.846em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 16.513em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.992em, 1016.51em, 2.867em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1711\"><span class=\"mtext\" id=\"MathJax-Span-1712\" style=\"font-family: STIXGeneral-Regular;\">Recall</span><span class=\"mo\" id=\"MathJax-Span-1713\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mfrac\" id=\"MathJax-Span-1714\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 12.555em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.388em, 1005.52em, 4.273em, -999.997em); top: -4.529em; left: 50%; margin-left: -2.758em;\"><span class=\"mtext\" id=\"MathJax-Span-1715\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.388em, 1012.4em, 4.326em, -999.997em); top: -3.643em; left: 50%; margin-left: -6.195em;\"><span class=\"mtext\" id=\"MathJax-Span-1716\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">True Positives (TP) + False Negatives (FN)</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1012.55em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 12.555em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.684em; border-left: 0px solid; width: 0px; height: 2.003em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mtext>Recall</mtext><mo>=</mo><mfrac><mtext>True Positives (TP)</mtext><mtext>True Positives (TP) + False Negatives (FN)</mtext></mfrac></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-207\">\\text{Recall} = \\frac{\\text{True Positives (TP)}}{\\text{True Positives (TP) + False Negatives (FN)}}</script></li>\n    </ul>\n<ul>\n      <li>In many applications, high precision and recall together mean that:\n        <ul>\n          <li>High precision: Predictions are trustworthy, with minimal false alarms (false positives).</li>\n          <li>High recall: The model catches all or most of the positive cases, minimizing missed detections (false negatives).</li>\n        </ul>\n      </li>\n      <li>However, achieving high precision and recall simultaneously is challenging, which leads to the precision-recall tradeoff.</li>\n    </ul>\n<ul>\n          <li>High precision: Predictions are trustworthy, with minimal false alarms (false positives).</li>\n          <li>High recall: The model catches all or most of the positive cases, minimizing missed detections (false negatives).</li>\n        </ul>\n<ul>\n      <li>Increasing one often reduces the other, especially in unbalanced datasets where positives are rare. Here’s why:\n        <ol>\n          <li><strong>Threshold Adjustment</strong>: Many models, especially classification models, use a probability threshold to decide between positive and negative. Adjusting this threshold impacts both precision and recall:\n            <ul>\n              <li>A <strong>higher threshold</strong> typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).</li>\n              <li>A <strong>lower threshold</strong> usually increases recall but reduces precision (more predictions overall, with more false positives).</li>\n            </ul>\n          </li>\n          <li><strong>Application Requirements</strong>: Some applications need high precision over recall, while others need high recall over precision:\n            <ul>\n              <li><strong>High Precision Priority</strong>: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.</li>\n              <li><strong>High Recall Priority</strong>: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.</li>\n            </ul>\n          </li>\n          <li><strong>Balancing Precision and Recall</strong>:\n            <ul>\n              <li>For applications that need a balance, metrics like the <strong>F1 Score</strong> can be helpful as it is the harmonic mean of precision and recall.</li>\n              <li><strong>F1 Score</strong> helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.</li>\n            </ul>\n          </li>\n        </ol>\n      </li>\n    </ul>\n<ol>\n          <li><strong>Threshold Adjustment</strong>: Many models, especially classification models, use a probability threshold to decide between positive and negative. Adjusting this threshold impacts both precision and recall:\n            <ul>\n              <li>A <strong>higher threshold</strong> typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).</li>\n              <li>A <strong>lower threshold</strong> usually increases recall but reduces precision (more predictions overall, with more false positives).</li>\n            </ul>\n          </li>\n          <li><strong>Application Requirements</strong>: Some applications need high precision over recall, while others need high recall over precision:\n            <ul>\n              <li><strong>High Precision Priority</strong>: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.</li>\n              <li><strong>High Recall Priority</strong>: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.</li>\n            </ul>\n          </li>\n          <li><strong>Balancing Precision and Recall</strong>:\n            <ul>\n              <li>For applications that need a balance, metrics like the <strong>F1 Score</strong> can be helpful as it is the harmonic mean of precision and recall.</li>\n              <li><strong>F1 Score</strong> helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.</li>\n            </ul>\n          </li>\n        </ol>\n<ul>\n              <li>A <strong>higher threshold</strong> typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).</li>\n              <li>A <strong>lower threshold</strong> usually increases recall but reduces precision (more predictions overall, with more false positives).</li>\n            </ul>\n<ul>\n              <li><strong>High Precision Priority</strong>: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.</li>\n              <li><strong>High Recall Priority</strong>: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.</li>\n            </ul>\n<ul>\n              <li>For applications that need a balance, metrics like the <strong>F1 Score</strong> can be helpful as it is the harmonic mean of precision and recall.</li>\n              <li><strong>F1 Score</strong> helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.</li>\n            </ul>\n<ul>\n      <li>In <strong>fraud detection</strong>, missing a fraud case (low recall) may be more acceptable if it means only clear fraud cases are flagged (high precision).</li>\n      <li>In <strong>information retrieval</strong> or <strong>search engines</strong>, recall may be more important to ensure users see all relevant results, even if some irrelevant ones appear (accepting lower precision).</li>\n    </ul>",
      "contentMarkdown": "*   Yes, high precision and recall are generally desirable, but they often compete with each other, leading to what is known as the precision-recall tradeoff. Understanding these metrics and their relationship can help clarify this balance.\n*   **Precision and Recall:**\n    *   **Precision**: Measures how many of the items classified as positive are actually positive. High precision means few false positives (FP), so the predictions are accurate when the model says “positive.” Precision\\=True Positives (TP)True Positives (TP) + False Positives (FP)Precision\\=True Positives (TP)True Positives (TP) + False Positives (FP)\\\\text{Precision} = \\\\frac{\\\\text{True Positives (TP)}}{\\\\text{True Positives (TP) + False Positives (FP)}}\n    *   **Recall**: Measures how many actual positive cases the model captures out of all true positive cases. High recall means few false negatives (FN), so the model catches most true positives. Recall\\=True Positives (TP)True Positives (TP) + False Negatives (FN)Recall\\=True Positives (TP)True Positives (TP) + False Negatives (FN)\\\\text{Recall} = \\\\frac{\\\\text{True Positives (TP)}}{\\\\text{True Positives (TP) + False Negatives (FN)}}\n*   **Why both are desirable:**\n    *   In many applications, high precision and recall together mean that:\n        *   High precision: Predictions are trustworthy, with minimal false alarms (false positives).\n        *   High recall: The model catches all or most of the positive cases, minimizing missed detections (false negatives).\n    *   However, achieving high precision and recall simultaneously is challenging, which leads to the precision-recall tradeoff.\n*   **The precision-recall tradeoff:**\n    *   Increasing one often reduces the other, especially in unbalanced datasets where positives are rare. Here’s why:\n        1.  **Threshold Adjustment**: Many models, especially classification models, use a probability threshold to decide between positive and negative. Adjusting this threshold impacts both precision and recall:\n            *   A **higher threshold** typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).\n            *   A **lower threshold** usually increases recall but reduces precision (more predictions overall, with more false positives).\n        2.  **Application Requirements**: Some applications need high precision over recall, while others need high recall over precision:\n            *   **High Precision Priority**: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.\n            *   **High Recall Priority**: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.\n        3.  **Balancing Precision and Recall**:\n            *   For applications that need a balance, metrics like the **F1 Score** can be helpful as it is the harmonic mean of precision and recall.\n            *   **F1 Score** helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.\n*   **Practical examples of the tradeoff:**\n    *   In **fraud detection**, missing a fraud case (low recall) may be more acceptable if it means only clear fraud cases are flagged (high precision).\n    *   In **information retrieval** or **search engines**, recall may be more important to ensure users see all relevant results, even if some irrelevant ones appear (accepting lower precision).\n*   In short, high precision and recall are desirable, but they must be balanced based on the application’s specific needs and the cost of false positives versus false negatives.\n\n*   **Precision**: Measures how many of the items classified as positive are actually positive. High precision means few false positives (FP), so the predictions are accurate when the model says “positive.” Precision\\=True Positives (TP)True Positives (TP) + False Positives (FP)Precision\\=True Positives (TP)True Positives (TP) + False Positives (FP)\\\\text{Precision} = \\\\frac{\\\\text{True Positives (TP)}}{\\\\text{True Positives (TP) + False Positives (FP)}}\n*   **Recall**: Measures how many actual positive cases the model captures out of all true positive cases. High recall means few false negatives (FN), so the model catches most true positives. Recall\\=True Positives (TP)True Positives (TP) + False Negatives (FN)Recall\\=True Positives (TP)True Positives (TP) + False Negatives (FN)\\\\text{Recall} = \\\\frac{\\\\text{True Positives (TP)}}{\\\\text{True Positives (TP) + False Negatives (FN)}}\n\n*   In many applications, high precision and recall together mean that:\n    *   High precision: Predictions are trustworthy, with minimal false alarms (false positives).\n    *   High recall: The model catches all or most of the positive cases, minimizing missed detections (false negatives).\n*   However, achieving high precision and recall simultaneously is challenging, which leads to the precision-recall tradeoff.\n\n*   High precision: Predictions are trustworthy, with minimal false alarms (false positives).\n*   High recall: The model catches all or most of the positive cases, minimizing missed detections (false negatives).\n\n*   Increasing one often reduces the other, especially in unbalanced datasets where positives are rare. Here’s why:\n    1.  **Threshold Adjustment**: Many models, especially classification models, use a probability threshold to decide between positive and negative. Adjusting this threshold impacts both precision and recall:\n        *   A **higher threshold** typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).\n        *   A **lower threshold** usually increases recall but reduces precision (more predictions overall, with more false positives).\n    2.  **Application Requirements**: Some applications need high precision over recall, while others need high recall over precision:\n        *   **High Precision Priority**: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.\n        *   **High Recall Priority**: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.\n    3.  **Balancing Precision and Recall**:\n        *   For applications that need a balance, metrics like the **F1 Score** can be helpful as it is the harmonic mean of precision and recall.\n        *   **F1 Score** helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.\n\n1.  **Threshold Adjustment**: Many models, especially classification models, use a probability threshold to decide between positive and negative. Adjusting this threshold impacts both precision and recall:\n    *   A **higher threshold** typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).\n    *   A **lower threshold** usually increases recall but reduces precision (more predictions overall, with more false positives).\n2.  **Application Requirements**: Some applications need high precision over recall, while others need high recall over precision:\n    *   **High Precision Priority**: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.\n    *   **High Recall Priority**: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.\n3.  **Balancing Precision and Recall**:\n    *   For applications that need a balance, metrics like the **F1 Score** can be helpful as it is the harmonic mean of precision and recall.\n    *   **F1 Score** helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.\n\n*   A **higher threshold** typically increases precision but reduces recall (fewer predictions overall, but more accurate ones).\n*   A **lower threshold** usually increases recall but reduces precision (more predictions overall, with more false positives).\n\n*   **High Precision Priority**: In scenarios where false positives are costly (e.g., spam detection, where misclassifying legitimate emails as spam is problematic), precision is prioritized.\n*   **High Recall Priority**: In situations where missing positive cases is costly (e.g., medical diagnoses, where failing to catch a disease is dangerous), recall is prioritized.\n\n*   For applications that need a balance, metrics like the **F1 Score** can be helpful as it is the harmonic mean of precision and recall.\n*   **F1 Score** helps optimize both precision and recall simultaneously and is especially useful when dealing with imbalanced datasets.\n\n*   In **fraud detection**, missing a fraud case (low recall) may be more acceptable if it means only clear fraud cases are flagged (high precision).\n*   In **information retrieval** or **search engines**, recall may be more important to ensure users see all relevant results, even if some irrelevant ones appear (accepting lower precision).",
      "order": 245,
      "orderInChapter": 46,
      "difficulty": 5,
      "estimatedMinutes": 7,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 1260,
        "contentLength": 22093
      },
      "nextCards": [
        "ai-interview-what-is-the-zipfs-law-ie-power-law-246",
        "ai-interview-what-are-the-most-common-methods-to-deal-with-vani-247"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#is-high-precision-and-recall-desirable?-what-is-the-precision-recall-tradeoff?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-zipfs-law-ie-power-law-246",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is the Zipf’s Law (i.e., Power Law)?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Zipf’s Law is an empirical rule that describes the frequency distribution of elements in various datasets, especially in language and social sciences. Named after linguist George Zipf, the law states that in a large dataset, the frequency of any item is inversely proportional to its rank.</li>\n  <li>Here’s how Zipf’s Law typically works:\n    <ul>\n      <li>If you rank elements in a dataset by their frequency (from most to least common), the frequency of the second-ranked item is about half that of the most frequent item, the third is about a third, and so on.</li>\n      <li>\n        <p>Mathematically, it suggests that the frequency <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-208-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1717\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1718\"><span class=\"mi\" id=\"MathJax-Span-1719\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-208\">f</script> of an element with rank <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-209-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1720\" style=\"width: 0.419em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.315em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.32em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1721\"><span class=\"mi\" id=\"MathJax-Span-1722\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>r</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-209\">r</script> follows the formula:</p>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-210-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2248;</mo><mfrac><mi>C</mi><msup><mi>r</mi><mi>s</mi></msup></mfrac></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1723\" style=\"width: 4.638em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.857em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.68em, 1003.86em, 3.023em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1724\"><span class=\"mi\" id=\"MathJax-Span-1725\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1726\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1727\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1728\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1729\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≈</span><span class=\"mfrac\" id=\"MathJax-Span-1730\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.685em; left: 50%; margin-left: -0.362em;\"><span class=\"mi\" id=\"MathJax-Span-1731\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.232em, 1000.84em, 4.169em, -999.997em); top: -3.331em; left: 50%; margin-left: -0.414em;\"><span class=\"msubsup\" id=\"MathJax-Span-1732\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1733\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.32em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1734\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1000.94em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.94em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.566em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo>≈</mo><mfrac><mi>C</mi><msup><mi>r</mi><mi>s</mi></msup></mfrac></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-210\">f(r) \\approx \\frac{C}{r^s}</script>\n\n        <ul>\n          <li>where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-211-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1735\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1736\"><span class=\"mi\" id=\"MathJax-Span-1737\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-211\">C</script> is a constant and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-212-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1738\" style=\"width: 0.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.367em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.37em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1739\"><span class=\"mi\" id=\"MathJax-Span-1740\" style=\"font-family: STIXGeneral-Italic;\">s</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>s</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-212\">s</script> is close to 1 in natural language distributions.</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>If you rank elements in a dataset by their frequency (from most to least common), the frequency of the second-ranked item is about half that of the most frequent item, the third is about a third, and so on.</li>\n      <li>\n        <p>Mathematically, it suggests that the frequency <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-208-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1717\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1718\"><span class=\"mi\" id=\"MathJax-Span-1719\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-208\">f</script> of an element with rank <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-209-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1720\" style=\"width: 0.419em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.315em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.32em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1721\"><span class=\"mi\" id=\"MathJax-Span-1722\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>r</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-209\">r</script> follows the formula:</p>\n\n<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><div class=\"MathJax_Display\" style=\"text-align: center;\"><span class=\"MathJax\" id=\"MathJax-Element-210-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2248;</mo><mfrac><mi>C</mi><msup><mi>r</mi><mi>s</mi></msup></mfrac></math>\" role=\"presentation\" style=\"text-align: center; position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1723\" style=\"width: 4.638em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 3.857em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(0.68em, 1003.86em, 3.023em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1724\"><span class=\"mi\" id=\"MathJax-Span-1725\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1726\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-1727\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span class=\"mo\" id=\"MathJax-Span-1728\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-1729\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≈</span><span class=\"mfrac\" id=\"MathJax-Span-1730\" style=\"padding-left: 0.315em;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.68em, 4.169em, -999.997em); top: -4.685em; left: 50%; margin-left: -0.362em;\"><span class=\"mi\" id=\"MathJax-Span-1731\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(3.232em, 1000.84em, 4.169em, -999.997em); top: -3.331em; left: 50%; margin-left: -0.414em;\"><span class=\"msubsup\" id=\"MathJax-Span-1732\"><span style=\"display: inline-block; position: relative; width: 0.836em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.42em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-1733\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.32em; left: 0.471em;\"><span class=\"mi\" id=\"MathJax-Span-1734\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">s</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; clip: rect(0.836em, 1000.94em, 1.201em, -999.997em); top: -1.247em; left: 0em;\"><span style=\"display: inline-block; overflow: hidden; vertical-align: 0em; border-top: 1.3px solid; width: 0.94em; height: 0px;\"></span><span style=\"display: inline-block; width: 0px; height: 1.044em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.872em; border-left: 0px solid; width: 0px; height: 2.566em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML MJX_Assistive_MathML_Block\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><mi>f</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo stretchy=\"false\">)</mo><mo>≈</mo><mfrac><mi>C</mi><msup><mi>r</mi><mi>s</mi></msup></mfrac></math></span></span></div><script type=\"math/tex; mode=display\" id=\"MathJax-Element-210\">f(r) \\approx \\frac{C}{r^s}</script>\n\n        <ul>\n          <li>where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-211-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1735\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1736\"><span class=\"mi\" id=\"MathJax-Span-1737\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-211\">C</script> is a constant and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-212-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1738\" style=\"width: 0.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.367em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.37em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1739\"><span class=\"mi\" id=\"MathJax-Span-1740\" style=\"font-family: STIXGeneral-Italic;\">s</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>s</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-212\">s</script> is close to 1 in natural language distributions.</li>\n        </ul>\n      </li>\n    </ul>\n<p>Mathematically, it suggests that the frequency <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-208-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1717\" style=\"width: 0.576em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.471em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.47em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1718\"><span class=\"mi\" id=\"MathJax-Span-1719\" style=\"font-family: STIXGeneral-Italic;\">f<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.159em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>f</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-208\">f</script> of an element with rank <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-209-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1720\" style=\"width: 0.419em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.315em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.32em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1721\"><span class=\"mi\" id=\"MathJax-Span-1722\" style=\"font-family: STIXGeneral-Italic;\">r<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.628em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>r</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-209\">r</script> follows the formula:</p>\n<ul>\n          <li>where <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-211-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1735\" style=\"width: 0.836em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.68em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.68em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1736\"><span class=\"mi\" id=\"MathJax-Span-1737\" style=\"font-family: STIXGeneral-Italic;\">C<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>C</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-211\">C</script> is a constant and <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-212-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1738\" style=\"width: 0.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.367em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.37em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-1739\"><span class=\"mi\" id=\"MathJax-Span-1740\" style=\"font-family: STIXGeneral-Italic;\">s</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>s</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-212\">s</script> is close to 1 in natural language distributions.</li>\n        </ul>\n<h4 id=\"example-in-language\">Example in Language</h4>\n<ul>\n  <li>In English, Zipf’s Law applies to word frequency. The most common word (“the”) appears far more frequently than the second most common word (“be”), which appears more frequently than the third (“to”), and so on.</li>\n</ul>\n<h4 id=\"applications-of-zipfs-law\">Applications of Zipf’s Law</h4>\n<ul>\n  <li>Zipf’s Law can be observed in many fields beyond language, including:\n    <ul>\n      <li><strong>City Populations</strong>: The population of the largest city is about twice that of the second-largest, three times that of the third-largest, and so forth.</li>\n      <li><strong>Website Popularity</strong>: The most visited website gets significantly more traffic than the second most popular, and so on.</li>\n      <li><strong>Natural Phenomena</strong>: Earthquake magnitudes, the size of moon craters, and even incomes can sometimes follow Zipfian distributions.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li><strong>City Populations</strong>: The population of the largest city is about twice that of the second-largest, three times that of the third-largest, and so forth.</li>\n      <li><strong>Website Popularity</strong>: The most visited website gets significantly more traffic than the second most popular, and so on.</li>\n      <li><strong>Natural Phenomena</strong>: Earthquake magnitudes, the size of moon craters, and even incomes can sometimes follow Zipfian distributions.</li>\n    </ul>\n<h4 id=\"why-zipfs-law-is-important\">Why Zipf’s Law is Important</h4>\n<ul>\n  <li>Zipf’s Law reveals patterns in complex systems and helps in fields like information theory, linguistics, and data science to make predictions or create models. It highlights an underlying “power-law” distribution common in many natural and social systems, showing that a few items dominate in frequency or size while most others are less frequent or smaller.</li>\n</ul>",
      "contentMarkdown": "*   Zipf’s Law is an empirical rule that describes the frequency distribution of elements in various datasets, especially in language and social sciences. Named after linguist George Zipf, the law states that in a large dataset, the frequency of any item is inversely proportional to its rank.\n*   Here’s how Zipf’s Law typically works:\n    *   If you rank elements in a dataset by their frequency (from most to least common), the frequency of the second-ranked item is about half that of the most frequent item, the third is about a third, and so on.\n    *   Mathematically, it suggests that the frequency fff of an element with rank rrr follows the formula:\n        \n        f(r)≈Crsf(r)≈Crs\n        \n        f(r) \\\\approx \\\\frac{C}{r^s}\n        *   where CCC is a constant and sss is close to 1 in natural language distributions.\n\n*   If you rank elements in a dataset by their frequency (from most to least common), the frequency of the second-ranked item is about half that of the most frequent item, the third is about a third, and so on.\n*   Mathematically, it suggests that the frequency fff of an element with rank rrr follows the formula:\n    \n    f(r)≈Crsf(r)≈Crs\n    \n    f(r) \\\\approx \\\\frac{C}{r^s}\n    *   where CCC is a constant and sss is close to 1 in natural language distributions.\n\nMathematically, it suggests that the frequency fff of an element with rank rrr follows the formula:\n\n*   where CCC is a constant and sss is close to 1 in natural language distributions.\n\n#### Example in Language\n\n*   In English, Zipf’s Law applies to word frequency. The most common word (“the”) appears far more frequently than the second most common word (“be”), which appears more frequently than the third (“to”), and so on.\n\n#### Applications of Zipf’s Law\n\n*   Zipf’s Law can be observed in many fields beyond language, including:\n    *   **City Populations**: The population of the largest city is about twice that of the second-largest, three times that of the third-largest, and so forth.\n    *   **Website Popularity**: The most visited website gets significantly more traffic than the second most popular, and so on.\n    *   **Natural Phenomena**: Earthquake magnitudes, the size of moon craters, and even incomes can sometimes follow Zipfian distributions.\n\n*   **City Populations**: The population of the largest city is about twice that of the second-largest, three times that of the third-largest, and so forth.\n*   **Website Popularity**: The most visited website gets significantly more traffic than the second most popular, and so on.\n*   **Natural Phenomena**: Earthquake magnitudes, the size of moon craters, and even incomes can sometimes follow Zipfian distributions.\n\n#### Why Zipf’s Law is Important\n\n*   Zipf’s Law reveals patterns in complex systems and helps in fields like information theory, linguistics, and data science to make predictions or create models. It highlights an underlying “power-law” distribution common in many natural and social systems, showing that a few items dominate in frequency or size while most others are less frequent or smaller.",
      "order": 246,
      "orderInChapter": 47,
      "difficulty": 5,
      "estimatedMinutes": 3,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": true,
        "hasImages": false,
        "wordCount": 483,
        "contentLength": 26826
      },
      "nextCards": [
        "ai-interview-what-are-the-most-common-methods-to-deal-with-vani-247",
        "ai-interview-what-are-the-most-common-methods-to-deal-with-expl-248"
      ],
      "relatedCards": [
        "ai-linear-logistic-regression-model-evaluation-the-log-loss-function-16",
        "ai-linear-logistic-regression-estimating-coefficients-gradient-descent-and-maxim-17",
        "ai-linear-logistic-regression-interpreting-logistic-regression-coefficients-18",
        "ai-linear-logistic-regression-the-role-of-the-sigmoid-function-20",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-zipf’s-law-(i.e.,-power-law)?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-most-common-methods-to-deal-with-vani-247",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are the Most Common Methods to Deal with Vanishing Gradients?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>The vanishing gradient problem occurs in deep neural networks when gradients become very small during backpropagation, preventing the model from updating effectively and causing layers near the beginning to train very slowly or not at all.</li>\n  <li>Each of the below techniques can help address vanishing gradients, either by ensuring gradients don’t diminish as much or by structurally enabling them to bypass challenging parts of the network.</li>\n</ul>\n<h4 id=\"using-relu-and-variants\">Using ReLU and Variants</h4>\n<ul>\n  <li><strong>ReLU (Rectified Linear Unit)</strong> and its variants like <strong>Leaky ReLU</strong>, <strong>Parametric ReLU (PReLU)</strong>, and <strong>Exponential Linear Units (ELU)</strong> help reduce the vanishing gradient problem because they avoid saturation for positive values, unlike sigmoid and tanh activations. ReLU maintains gradients for positive values, allowing better gradient flow through the network.</li>\n</ul>\n<h4 id=\"batch-normalization\">Batch Normalization</h4>\n<ul>\n  <li><strong>Batch Normalization</strong> normalizes inputs for each layer, keeping activations within a standard range and reducing internal covariate shift. This normalization helps stabilize gradients during backpropagation, making training more efficient and addressing gradient vanishing.</li>\n</ul>\n<h4 id=\"residual-connections-skip-connections\">Residual Connections (Skip Connections)</h4>\n<ul>\n  <li><strong>Residual networks (ResNets)</strong> use skip connections, where the input to a layer is added directly to its output. This setup enables gradients to flow more easily back to earlier layers, helping to maintain strong gradient signals even in very deep networks.</li>\n</ul>\n<h4 id=\"careful-weight-initialization\">Careful Weight Initialization</h4>\n<ul>\n  <li>Initializing weights properly can mitigate vanishing (and exploding) gradients. <strong>Xavier (Glorot) initialization</strong> and <strong>He initialization</strong> (for ReLU and variants) are two techniques that set initial weights to appropriate values based on the network’s architecture. These methods help maintain consistent gradient magnitudes as they propagate through layers.</li>\n</ul>\n<h4 id=\"using-lstm-or-gru-in-recurrent-networks\">Using LSTM or GRU in Recurrent Networks</h4>\n<ul>\n  <li>In recurrent neural networks (RNNs), <strong>Long Short-Term Memory (LSTM)</strong> units and <strong>Gated Recurrent Units (GRU)</strong> are designed to mitigate vanishing gradients. They include mechanisms for remembering and forgetting information, which helps gradients flow across time steps without vanishing.</li>\n</ul>\n<h4 id=\"layer-normalization\">Layer Normalization</h4>\n<ul>\n  <li><strong>Layer normalization</strong> is similar to batch normalization but normalizes across features within each layer individually. It is often used in sequential models and RNNs, providing stability to gradients and improving training efficiency.</li>\n</ul>\n<h4 id=\"smaller-learning-rates\">Smaller Learning Rates</h4>\n<ul>\n  <li>A smaller learning rate can help prevent the gradients from becoming too small or too large. While it slows down learning, it can make gradients more stable, especially in networks prone to vanishing gradient issues.</li>\n</ul>",
      "contentMarkdown": "*   The vanishing gradient problem occurs in deep neural networks when gradients become very small during backpropagation, preventing the model from updating effectively and causing layers near the beginning to train very slowly or not at all.\n*   Each of the below techniques can help address vanishing gradients, either by ensuring gradients don’t diminish as much or by structurally enabling them to bypass challenging parts of the network.\n\n#### Using ReLU and Variants\n\n*   **ReLU (Rectified Linear Unit)** and its variants like **Leaky ReLU**, **Parametric ReLU (PReLU)**, and **Exponential Linear Units (ELU)** help reduce the vanishing gradient problem because they avoid saturation for positive values, unlike sigmoid and tanh activations. ReLU maintains gradients for positive values, allowing better gradient flow through the network.\n\n#### Batch Normalization\n\n*   **Batch Normalization** normalizes inputs for each layer, keeping activations within a standard range and reducing internal covariate shift. This normalization helps stabilize gradients during backpropagation, making training more efficient and addressing gradient vanishing.\n\n#### Residual Connections (Skip Connections)\n\n*   **Residual networks (ResNets)** use skip connections, where the input to a layer is added directly to its output. This setup enables gradients to flow more easily back to earlier layers, helping to maintain strong gradient signals even in very deep networks.\n\n#### Careful Weight Initialization\n\n*   Initializing weights properly can mitigate vanishing (and exploding) gradients. **Xavier (Glorot) initialization** and **He initialization** (for ReLU and variants) are two techniques that set initial weights to appropriate values based on the network’s architecture. These methods help maintain consistent gradient magnitudes as they propagate through layers.\n\n#### Using LSTM or GRU in Recurrent Networks\n\n*   In recurrent neural networks (RNNs), **Long Short-Term Memory (LSTM)** units and **Gated Recurrent Units (GRU)** are designed to mitigate vanishing gradients. They include mechanisms for remembering and forgetting information, which helps gradients flow across time steps without vanishing.\n\n#### Layer Normalization\n\n*   **Layer normalization** is similar to batch normalization but normalizes across features within each layer individually. It is often used in sequential models and RNNs, providing stability to gradients and improving training efficiency.\n\n#### Smaller Learning Rates\n\n*   A smaller learning rate can help prevent the gradients from becoming too small or too large. While it slows down learning, it can make gradients more stable, especially in networks prone to vanishing gradient issues.",
      "order": 247,
      "orderInChapter": 48,
      "difficulty": 5,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "rnn",
        "lstm",
        "gru",
        "backpropagation",
        "activation",
        "batch normalization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 381,
        "contentLength": 3263
      },
      "nextCards": [
        "ai-interview-what-are-the-most-common-methods-to-deal-with-expl-248",
        "ai-interview-are-variational-autoencoders-vaes-and-autoencoders-249"
      ],
      "relatedCards": [
        "ai-transformers-why-is-the-transformer-architecture-not-as-suscept-59",
        "ai-speech-processing-automatic-speech-recognition-20",
        "ai-model-compression-quantization-with-pytorch-10",
        "ai-architectures-how-does-a-gru-work-internally-10",
        "ai-architectures-vanishing-gradients-27"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-most-common-methods-to-deal-with-vanishing-gradients?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-are-the-most-common-methods-to-deal-with-expl-248",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What are the Most Common Methods to Deal with Exploding Gradients?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Exploding gradients are a common issue in deep neural networks, especially recurrent neural networks (RNNs) and deep feedforward networks, where gradients during backpropagation become excessively large, leading to instability in training and poor model performance.</li>\n  <li>The methods listed below are often used in combination to manage gradient magnitudes and stabilize training. In practice, gradient clipping and proper initialization are particularly popular choices, especially in recurrent neural network training where exploding gradients are a more frequent concern.</li>\n</ul>\n<h4 id=\"gradient-clipping\">Gradient Clipping</h4>\n<ul>\n  <li>Gradient clipping involves setting a threshold value and scaling the gradients if they exceed this threshold. This prevents the gradients from becoming excessively large.</li>\n  <li>Common types of clipping include <strong>global norm clipping</strong>, where gradients are clipped if the overall norm exceeds a certain value, and <strong>element-wise clipping</strong>, where individual gradient components are clipped to be within a specified range.</li>\n  <li>This method is straightforward and widely used in practice, especially in RNNs and other deep architectures.</li>\n</ul>\n<h4 id=\"weight-regularization-l2-regularization\">Weight Regularization (L2 Regularization)</h4>\n<ul>\n  <li>L2 regularization (weight decay) applies a penalty proportional to the square of the magnitude of weights, which discourages excessively large weights and thus indirectly controls large gradients.</li>\n  <li>This technique helps keep weights smaller and gradients more manageable, though it may not be as directly effective on gradient magnitude as gradient clipping.</li>\n</ul>\n<h4 id=\"using-proper-initialization\">Using Proper Initialization</h4>\n<ul>\n  <li>Proper weight initialization can prevent gradients from exploding (or vanishing) at the start of training.</li>\n  <li>Techniques like <strong>Xavier/Glorot initialization</strong> and <strong>He initialization</strong> help set initial weights in a range that maintains stable gradient magnitudes across layers.</li>\n  <li>Choosing the initialization method based on the activation function (e.g., He initialization for ReLU-based networks) can be particularly beneficial.</li>\n</ul>\n<h4 id=\"batch-normalization-1\">Batch Normalization</h4>\n<ul>\n  <li>Batch normalization normalizes the inputs to each layer within a minibatch, keeping activations in a stable range.</li>\n  <li>It helps mitigate exploding and vanishing gradient issues by maintaining a consistent distribution of layer inputs, which reduces the likelihood of extremely large or small gradient values.</li>\n</ul>\n<h4 id=\"use-of-appropriate-activation-functions\">Use of Appropriate Activation Functions</h4>\n<ul>\n  <li>Certain activation functions, such as <strong>ReLU</strong>, tend to exacerbate gradient issues in deeper networks due to unbounded positive outputs.</li>\n  <li>Choosing more stable activation functions (e.g., <strong>Leaky ReLU</strong>, <strong>ELU</strong>) or even <strong>tanh</strong> for some RNNs can help by keeping activation values in a more controlled range.</li>\n</ul>\n<h4 id=\"gradient-norm-penalty\">Gradient Norm Penalty</h4>\n<ul>\n  <li>This method involves adding a penalty term to the loss function based on the gradient norm.</li>\n  <li>The penalty discourages excessively large gradients during training by making it costly for the model to reach high gradient values.</li>\n  <li>Gradient norm penalties are particularly useful when using generative models or reinforcement learning, where gradient stability is crucial.</li>\n</ul>\n<h4 id=\"layer-normalization-for-rnns\">Layer Normalization (for RNNs)</h4>\n<ul>\n  <li>In RNNs, <strong>layer normalization</strong> (or <strong>batch normalization adapted for recurrent structures</strong>) helps stabilize training by normalizing across hidden states, preventing gradients from exploding over long sequences.</li>\n  <li>Layer normalization is effective when batch normalization is challenging to apply, as is often the case with recurrent networks.</li>\n</ul>\n<h4 id=\"reduce-learning-rate\">Reduce Learning Rate</h4>\n<ul>\n  <li>A high learning rate can amplify the problem of exploding gradients. By reducing the learning rate, the network’s parameter updates become more gradual, reducing the risk of large gradient values.</li>\n  <li>This approach is often used in conjunction with other methods, such as adaptive learning rate optimizers like <strong>Adam</strong> or <strong>RMSprop</strong>, which help adjust learning rates during training.</li>\n</ul>\n<h4 id=\"skip-connections--residual-networks\">Skip Connections / Residual Networks</h4>\n<ul>\n  <li>For very deep networks, skip connections (as in residual networks or ResNets) help gradients bypass layers, allowing for more direct gradient flow and reducing the likelihood of exploding gradients in deeper networks.</li>\n  <li>By allowing information to skip certain layers, gradients are less likely to be amplified excessively across layers.</li>\n</ul>",
      "contentMarkdown": "*   Exploding gradients are a common issue in deep neural networks, especially recurrent neural networks (RNNs) and deep feedforward networks, where gradients during backpropagation become excessively large, leading to instability in training and poor model performance.\n*   The methods listed below are often used in combination to manage gradient magnitudes and stabilize training. In practice, gradient clipping and proper initialization are particularly popular choices, especially in recurrent neural network training where exploding gradients are a more frequent concern.\n\n#### Gradient Clipping\n\n*   Gradient clipping involves setting a threshold value and scaling the gradients if they exceed this threshold. This prevents the gradients from becoming excessively large.\n*   Common types of clipping include **global norm clipping**, where gradients are clipped if the overall norm exceeds a certain value, and **element-wise clipping**, where individual gradient components are clipped to be within a specified range.\n*   This method is straightforward and widely used in practice, especially in RNNs and other deep architectures.\n\n#### Weight Regularization (L2 Regularization)\n\n*   L2 regularization (weight decay) applies a penalty proportional to the square of the magnitude of weights, which discourages excessively large weights and thus indirectly controls large gradients.\n*   This technique helps keep weights smaller and gradients more manageable, though it may not be as directly effective on gradient magnitude as gradient clipping.\n\n#### Using Proper Initialization\n\n*   Proper weight initialization can prevent gradients from exploding (or vanishing) at the start of training.\n*   Techniques like **Xavier/Glorot initialization** and **He initialization** help set initial weights in a range that maintains stable gradient magnitudes across layers.\n*   Choosing the initialization method based on the activation function (e.g., He initialization for ReLU-based networks) can be particularly beneficial.\n\n#### Batch Normalization\n\n*   Batch normalization normalizes the inputs to each layer within a minibatch, keeping activations in a stable range.\n*   It helps mitigate exploding and vanishing gradient issues by maintaining a consistent distribution of layer inputs, which reduces the likelihood of extremely large or small gradient values.\n\n#### Use of Appropriate Activation Functions\n\n*   Certain activation functions, such as **ReLU**, tend to exacerbate gradient issues in deeper networks due to unbounded positive outputs.\n*   Choosing more stable activation functions (e.g., **Leaky ReLU**, **ELU**) or even **tanh** for some RNNs can help by keeping activation values in a more controlled range.\n\n#### Gradient Norm Penalty\n\n*   This method involves adding a penalty term to the loss function based on the gradient norm.\n*   The penalty discourages excessively large gradients during training by making it costly for the model to reach high gradient values.\n*   Gradient norm penalties are particularly useful when using generative models or reinforcement learning, where gradient stability is crucial.\n\n#### Layer Normalization (for RNNs)\n\n*   In RNNs, **layer normalization** (or **batch normalization adapted for recurrent structures**) helps stabilize training by normalizing across hidden states, preventing gradients from exploding over long sequences.\n*   Layer normalization is effective when batch normalization is challenging to apply, as is often the case with recurrent networks.\n\n#### Reduce Learning Rate\n\n*   A high learning rate can amplify the problem of exploding gradients. By reducing the learning rate, the network’s parameter updates become more gradual, reducing the risk of large gradient values.\n*   This approach is often used in conjunction with other methods, such as adaptive learning rate optimizers like **Adam** or **RMSprop**, which help adjust learning rates during training.\n\n#### Skip Connections / Residual Networks\n\n*   For very deep networks, skip connections (as in residual networks or ResNets) help gradients bypass layers, allowing for more direct gradient flow and reducing the likelihood of exploding gradients in deeper networks.\n*   By allowing information to skip certain layers, gradients are less likely to be amplified excessively across layers.",
      "order": 248,
      "orderInChapter": 49,
      "difficulty": 5,
      "estimatedMinutes": 4,
      "tags": [
        "practice",
        "neural network",
        "rnn",
        "reinforcement learning",
        "backpropagation",
        "loss function",
        "activation",
        "regularization"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 614,
        "contentLength": 5074
      },
      "nextCards": [
        "ai-interview-are-variational-autoencoders-vaes-and-autoencoders-249",
        "ai-interview-what-is-the-relationship-between-lda-and-vae-in-te-250"
      ],
      "relatedCards": [
        "ai-top-30-papers-stanfords-cs231n-convolutional-neural-networks-for-26",
        "ai-diffusion-models-at-a-high-level-how-do-diffusion-models-work-what--42",
        "ai-deepseek-R1-mixture-of-experts-moe-2",
        "ai-reinforcement-learning-deep-actorcritic-methods-18",
        "ai-decision-trees-and-ensemble-methods-in-the-context-of-decision-trees-how-does-a-small--32"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-are-the-most-common-methods-to-deal-with-exploding-gradients?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-are-variational-autoencoders-vaes-and-autoencoders-249",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "Are Variational Autoencoders (VAEs) and Autoencoders (AEs) Typically Non-linear?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Yes, Variational Autoencoders (VAEs) and Autoencoders (AEs) are typically non-linear. Here’s why:</li>\n</ul>\n<h4 id=\"autoencoders-aes\">Autoencoders (AEs)</h4>\n<ul>\n  <li>Autoencoders consist of an <strong>encoder</strong> and a <strong>decoder</strong>, which are usually implemented as neural networks.</li>\n  <li>The encoder compresses the input into a latent space representation (bottleneck), and the decoder reconstructs the original input from this latent space.</li>\n  <li>Non-linear activation functions (e.g., ReLU, sigmoid, tanh) are commonly used between layers of the encoder and decoder. These non-linearities allow the model to capture complex relationships in the data.</li>\n  <li>If only linear transformations were used, the Autoencoder would essentially perform a simple Principal Component Analysis (PCA), which is linear. Non-linearity enables AEs to model more complex data distributions.</li>\n</ul>\n<h4 id=\"variational-autoencoders-vaes\">Variational Autoencoders (VAEs)</h4>\n<ul>\n  <li>VAEs extend the concept of Autoencoders by incorporating probabilistic modeling, where the latent space is represented as a distribution rather than a fixed vector.</li>\n  <li>VAEs also use neural networks for the encoder (which estimates parameters of the latent distribution) and the decoder (which generates samples from the latent space to reconstruct the data).</li>\n  <li>Non-linearities in the neural networks enable the VAE to learn and generate from complex, non-linear data distributions.</li>\n  <li>In both cases, non-linearity is a fundamental feature that makes these models powerful for tasks like dimensionality reduction, generative modeling, and capturing intricate data patterns.</li>\n</ul>",
      "contentMarkdown": "*   Yes, Variational Autoencoders (VAEs) and Autoencoders (AEs) are typically non-linear. Here’s why:\n\n#### Autoencoders (AEs)\n\n*   Autoencoders consist of an **encoder** and a **decoder**, which are usually implemented as neural networks.\n*   The encoder compresses the input into a latent space representation (bottleneck), and the decoder reconstructs the original input from this latent space.\n*   Non-linear activation functions (e.g., ReLU, sigmoid, tanh) are commonly used between layers of the encoder and decoder. These non-linearities allow the model to capture complex relationships in the data.\n*   If only linear transformations were used, the Autoencoder would essentially perform a simple Principal Component Analysis (PCA), which is linear. Non-linearity enables AEs to model more complex data distributions.\n\n#### Variational Autoencoders (VAEs)\n\n*   VAEs extend the concept of Autoencoders by incorporating probabilistic modeling, where the latent space is represented as a distribution rather than a fixed vector.\n*   VAEs also use neural networks for the encoder (which estimates parameters of the latent distribution) and the decoder (which generates samples from the latent space to reconstruct the data).\n*   Non-linearities in the neural networks enable the VAE to learn and generate from complex, non-linear data distributions.\n*   In both cases, non-linearity is a fundamental feature that makes these models powerful for tasks like dimensionality reduction, generative modeling, and capturing intricate data patterns.",
      "order": 249,
      "orderInChapter": 50,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice",
        "neural network",
        "activation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 218,
        "contentLength": 1727
      },
      "nextCards": [
        "ai-interview-what-is-the-relationship-between-lda-and-vae-in-te-250",
        "ai-interview-when-do-you-use-cohens-kappa-vs-kripendorffs-alpha-251"
      ],
      "relatedCards": [
        "ai-support-vector-machines-sigmoid-kernel-12",
        "ai-mixture-of-experts-definition-and-taxonomy-59",
        "ai-xavier-init-case-2-a-too-small-initialization-leads-to-vanishi-2",
        "ai-LLaMA-swiglu-activation-function-swish-gated-linear-unit-2",
        "ai-model-compression-how-far-can-quantization-be-pushed-20"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#are-variational-autoencoders-(vaes)-and-autoencoders-(aes)-typically-non-linear?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-what-is-the-relationship-between-lda-and-vae-in-te-250",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "What is the Relationship Between LDA and VAE in Terms of Representing the Latent Space As a Distribution Rather Than a Fixed Vector?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>The relationship between Latent Dirichlet Allocation (LDA) and Variational Autoencoders (VAEs) in terms of representing the latent space as a distribution rather than a fixed vector lies in their shared probabilistic framework and how they approach latent representation:</li>\n</ul>\n<h4 id=\"latent-representation-as-a-distribution\">Latent Representation As a Distribution</h4>\n<ul>\n  <li>Both LDA and VAE represent the latent space as a <strong>probabilistic distribution</strong> rather than a single deterministic fixed vector.</li>\n</ul>\n<h5 id=\"lda\">LDA</h5>\n<ul>\n  <li>In LDA, the latent space represents the distribution over topics for a document.</li>\n  <li>Each document is modeled as a mixture of topics, and each topic is represented as a distribution over words.</li>\n  <li>The latent space is explicitly modeled using <strong>Dirichlet distributions</strong>:\n    <ul>\n      <li>A Dirichlet distribution is used to assign probabilities to topics for each document.</li>\n      <li>The probabilistic nature allows LDA to express uncertainty in topic assignments.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>A Dirichlet distribution is used to assign probabilities to topics for each document.</li>\n      <li>The probabilistic nature allows LDA to express uncertainty in topic assignments.</li>\n    </ul>\n<h5 id=\"vae\">VAE</h5>\n<ul>\n  <li>In VAEs, the latent space is modeled as a <strong>multivariate Gaussian distribution</strong>.</li>\n  <li>The encoder learns to map the input data to the parameters of this Gaussian distribution (mean and variance), creating a distribution in the latent space.</li>\n  <li>The decoder generates new data by sampling from this distribution.</li>\n  <li>This probabilistic latent representation enables VAEs to model the uncertainty and variability in the data.</li>\n</ul>\n<h4 id=\"generative-nature\">Generative Nature</h4>\n<ul>\n  <li>Both LDA and VAEs are generative models, but they work on different types of data and use different underlying assumptions:</li>\n</ul>\n<h5 id=\"lda-1\">LDA</h5>\n<ul>\n  <li>Designed for discrete data, especially text data.</li>\n  <li>Generates documents by sampling from topic distributions (latent space) and word distributions for each topic.</li>\n  <li>Latent space captures relationships between topics and their distributions over words.</li>\n</ul>\n<h5 id=\"vae-1\">VAE</h5>\n<ul>\n  <li>Designed for continuous or structured data, such as images or tabular data.</li>\n  <li>Generates data by sampling from the latent Gaussian distribution and passing it through the decoder.</li>\n  <li>Latent space captures abstract features or variations in the data.</li>\n</ul>\n<h4 id=\"optimization-and-learning\">Optimization and Learning</h4>\n<ul>\n  <li>While both models aim to optimize a probabilistic objective, the techniques differ:</li>\n</ul>\n<h5 id=\"lda-2\">LDA</h5>\n<ul>\n  <li>Uses variational inference or Gibbs sampling to approximate the posterior over the latent variables (topics).</li>\n  <li>The posterior is typically intractable due to the Dirichlet priors, so approximations are necessary.</li>\n</ul>\n<h5 id=\"vae-2\">VAE</h5>\n<ul>\n  <li>Uses a reparameterization trick to enable backpropagation through the stochastic layers.</li>\n  <li>The objective is to maximize a variational lower bound on the log-likelihood of the data.</li>\n</ul>\n<h4 id=\"similarities-in-variational-inference\">Similarities in Variational Inference</h4>\n<ul>\n  <li>\n    <p>Both LDA and VAE employ variational inference to optimize the latent space representation.</p>\n  </li>\n  <li>In LDA, variational inference is used to approximate the posterior distribution over the latent topic variables.</li>\n  <li>In VAEs, the encoder network is trained to approximate the posterior distribution over the latent variables using a variational lower bound.</li>\n</ul>\n<p>Both LDA and VAE employ variational inference to optimize the latent space representation.</p>\n<h4 id=\"difference-type-of-latent-space-distribution\">Difference: Type of Latent Space Distribution</h4>\n<ul>\n  <li><strong>LDA:</strong> Latent space uses Dirichlet distributions suited for discrete, sparse data like text.</li>\n  <li><strong>VAE:</strong> Latent space uses Gaussian distributions suited for continuous and smooth data representations.</li>\n</ul>\n<h4 id=\"unifying-insight\">Unifying Insight</h4>\n<ul>\n  <li>Both LDA and VAEs share a common probabilistic philosophy: modeling data with latent variables as distributions to capture uncertainty and variability. However, their choice of distribution and application domains differ:</li>\n  <li>LDA is tailored for topic modeling in discrete, textual data.</li>\n  <li>VAE is a general framework for modeling and generating continuous or complex structured data.</li>\n</ul>",
      "contentMarkdown": "*   The relationship between Latent Dirichlet Allocation (LDA) and Variational Autoencoders (VAEs) in terms of representing the latent space as a distribution rather than a fixed vector lies in their shared probabilistic framework and how they approach latent representation:\n\n#### Latent Representation As a Distribution\n\n*   Both LDA and VAE represent the latent space as a **probabilistic distribution** rather than a single deterministic fixed vector.\n\n##### LDA\n\n*   In LDA, the latent space represents the distribution over topics for a document.\n*   Each document is modeled as a mixture of topics, and each topic is represented as a distribution over words.\n*   The latent space is explicitly modeled using **Dirichlet distributions**:\n    *   A Dirichlet distribution is used to assign probabilities to topics for each document.\n    *   The probabilistic nature allows LDA to express uncertainty in topic assignments.\n\n*   A Dirichlet distribution is used to assign probabilities to topics for each document.\n*   The probabilistic nature allows LDA to express uncertainty in topic assignments.\n\n##### VAE\n\n*   In VAEs, the latent space is modeled as a **multivariate Gaussian distribution**.\n*   The encoder learns to map the input data to the parameters of this Gaussian distribution (mean and variance), creating a distribution in the latent space.\n*   The decoder generates new data by sampling from this distribution.\n*   This probabilistic latent representation enables VAEs to model the uncertainty and variability in the data.\n\n#### Generative Nature\n\n*   Both LDA and VAEs are generative models, but they work on different types of data and use different underlying assumptions:\n\n##### LDA\n\n*   Designed for discrete data, especially text data.\n*   Generates documents by sampling from topic distributions (latent space) and word distributions for each topic.\n*   Latent space captures relationships between topics and their distributions over words.\n\n##### VAE\n\n*   Designed for continuous or structured data, such as images or tabular data.\n*   Generates data by sampling from the latent Gaussian distribution and passing it through the decoder.\n*   Latent space captures abstract features or variations in the data.\n\n#### Optimization and Learning\n\n*   While both models aim to optimize a probabilistic objective, the techniques differ:\n\n##### LDA\n\n*   Uses variational inference or Gibbs sampling to approximate the posterior over the latent variables (topics).\n*   The posterior is typically intractable due to the Dirichlet priors, so approximations are necessary.\n\n##### VAE\n\n*   Uses a reparameterization trick to enable backpropagation through the stochastic layers.\n*   The objective is to maximize a variational lower bound on the log-likelihood of the data.\n\n#### Similarities in Variational Inference\n\n*   Both LDA and VAE employ variational inference to optimize the latent space representation.\n    \n*   In LDA, variational inference is used to approximate the posterior distribution over the latent topic variables.\n*   In VAEs, the encoder network is trained to approximate the posterior distribution over the latent variables using a variational lower bound.\n\nBoth LDA and VAE employ variational inference to optimize the latent space representation.\n\n#### Difference: Type of Latent Space Distribution\n\n*   **LDA:** Latent space uses Dirichlet distributions suited for discrete, sparse data like text.\n*   **VAE:** Latent space uses Gaussian distributions suited for continuous and smooth data representations.\n\n#### Unifying Insight\n\n*   Both LDA and VAEs share a common probabilistic philosophy: modeling data with latent variables as distributions to capture uncertainty and variability. However, their choice of distribution and application domains differ:\n*   LDA is tailored for topic modeling in discrete, textual data.\n*   VAE is a general framework for modeling and generating continuous or complex structured data.",
      "order": 250,
      "orderInChapter": 51,
      "difficulty": 4,
      "estimatedMinutes": 3,
      "tags": [
        "practice",
        "optimization",
        "backpropagation"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 581,
        "contentLength": 4753
      },
      "nextCards": [
        "ai-interview-when-do-you-use-cohens-kappa-vs-kripendorffs-alpha-251"
      ],
      "relatedCards": [
        "ai-mixture-of-experts-architectural-alternatives-27",
        "ai-distributed-training-parallelism-deepspeed-zero-33",
        "ai-reinforcement-finetuning-coupling-grpo-and-lora-15",
        "ai-support-vector-machines-optimization-problem-4",
        "ai-support-vector-machines-model-16"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#what-is-the-relationship-between-lda-and-vae-in-terms-of-representing-the-latent-space-as-a-distribution-rather-than-a-fixed-vector?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    },
    {
      "id": "ai-interview-when-do-you-use-cohens-kappa-vs-kripendorffs-alpha-251",
      "domain": "ai_primers",
      "category": "Practice",
      "article": "Interview Questions",
      "articleSlug": "interview",
      "chapter": "Misc",
      "title": "When Do You Use Cohen’s Kappa V/s Kripendorff’s Alpha?",
      "subtitle": "Misc",
      "contentHtml": "<ul>\n  <li>Use Cohen’s Kappa for simple, clean, two-rater, categorical tasks. Use Krippendorff’s Alpha for complex tasks with multiple raters, different data types, or missing values. Specifics below.</li>\n  <li><strong>Cohen’s Kappa</strong>:\n    <ul>\n      <li>Use when you have two raters (or coders).</li>\n      <li>Designed for nominal data (i.e., categories without a natural order), though weighted versions can handle ordinal data.</li>\n      <li>Assumes that both raters label all items (no missing data).</li>\n      <li>Easier to compute and interpret in small, straightforward settings.</li>\n    </ul>\n  </li>\n  <li><strong>Krippendorff’s Alpha</strong>:\n    <ul>\n      <li>More flexible and general-purpose.</li>\n      <li>Use when you have more than two raters (but it also works with two).</li>\n      <li>Handles nominal, ordinal, interval, and ratio data.</li>\n      <li>Can accommodate missing data (raters don’t need to rate every item).</li>\n      <li>Preferred in content analysis or studies where data might be messy or raters may not all evaluate the same items.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>Use when you have two raters (or coders).</li>\n      <li>Designed for nominal data (i.e., categories without a natural order), though weighted versions can handle ordinal data.</li>\n      <li>Assumes that both raters label all items (no missing data).</li>\n      <li>Easier to compute and interpret in small, straightforward settings.</li>\n    </ul>\n<ul>\n      <li>More flexible and general-purpose.</li>\n      <li>Use when you have more than two raters (but it also works with two).</li>\n      <li>Handles nominal, ordinal, interval, and ratio data.</li>\n      <li>Can accommodate missing data (raters don’t need to rate every item).</li>\n      <li>Preferred in content analysis or studies where data might be messy or raters may not all evaluate the same items.</li>\n    </ul>",
      "contentMarkdown": "*   Use Cohen’s Kappa for simple, clean, two-rater, categorical tasks. Use Krippendorff’s Alpha for complex tasks with multiple raters, different data types, or missing values. Specifics below.\n*   **Cohen’s Kappa**:\n    *   Use when you have two raters (or coders).\n    *   Designed for nominal data (i.e., categories without a natural order), though weighted versions can handle ordinal data.\n    *   Assumes that both raters label all items (no missing data).\n    *   Easier to compute and interpret in small, straightforward settings.\n*   **Krippendorff’s Alpha**:\n    *   More flexible and general-purpose.\n    *   Use when you have more than two raters (but it also works with two).\n    *   Handles nominal, ordinal, interval, and ratio data.\n    *   Can accommodate missing data (raters don’t need to rate every item).\n    *   Preferred in content analysis or studies where data might be messy or raters may not all evaluate the same items.\n\n*   Use when you have two raters (or coders).\n*   Designed for nominal data (i.e., categories without a natural order), though weighted versions can handle ordinal data.\n*   Assumes that both raters label all items (no missing data).\n*   Easier to compute and interpret in small, straightforward settings.\n\n*   More flexible and general-purpose.\n*   Use when you have more than two raters (but it also works with two).\n*   Handles nominal, ordinal, interval, and ratio data.\n*   Can accommodate missing data (raters don’t need to rate every item).\n*   Preferred in content analysis or studies where data might be messy or raters may not all evaluate the same items.",
      "order": 251,
      "orderInChapter": 52,
      "difficulty": 4,
      "estimatedMinutes": 2,
      "tags": [
        "practice"
      ],
      "metadata": {
        "hasCode": false,
        "hasMath": false,
        "hasImages": false,
        "wordCount": 251,
        "contentLength": 1906
      },
      "nextCards": [],
      "relatedCards": [
        "ai-linear-logistic-regression-the-general-equation-of-linear-regression-3",
        "ai-linear-logistic-regression-key-concepts-4",
        "ai-linear-logistic-regression-model-fitting-estimating-the-coefficients-5",
        "ai-linear-logistic-regression-evaluation-of-linear-regression-models-6",
        "ai-linear-logistic-regression-optimization-techniques-finding-the-best-coefficie-7"
      ],
      "prerequisites": [],
      "sourceUrl": "https://aman.ai/primers/ai/interview/#when-do-you-use-cohen’s-kappa-v/s-kripendorff’s-alpha?",
      "scrapedAt": "2025-12-28T11:58:12.848Z",
      "siblings": [
        "ai-interview-what-are-some-drawbacks-of-the-transformer-1",
        "ai-interview-why-do-we-initialize-weights-randomly-what-if-we-i-2",
        "ai-interview-describe-learning-rate-scheduleannealing-3",
        "ai-interview-explain-meanaverage-in-terms-of-attention-4",
        "ai-interview-what-is-convergence-in-k-means-clustering-5"
      ]
    }
  ]
}