<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/146988" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><p>Thank you for your participation!</p><p>Problem A, B were authored by <a class="rated-user user-orange" href="https://codeforces.com/profile/djm03178" title="Master djm03178">djm03178</a>.</p><p>Problem C was authored by <a class="rated-user user-red" href="https://codeforces.com/profile/as_dfsdf" title="International Grandmaster as_dfsdf">as_dfsdf</a>.</p><p>Problem D was authored by <a class="rated-user user-red" href="https://codeforces.com/profile/qwerasdfzxcl" title="Grandmaster qwerasdfzxcl">qwerasdfzxcl</a>.</p><p>Problem E, F, G, H1, H2 were authored by <a class="rated-user user-legendary" href="https://codeforces.com/profile/ko_osaga" title="Legendary Grandmaster ko_osaga"><span class="legendary-user-first-letter">k</span>o_osaga</a>.</p><p><a href="https://codeforces.com/contest/2152/problem/A">2152A - Increase or Smash</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/A" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152A - Increase or Smash</a></h3><div class="ttypography"><div class="problem-statement"><div><p>For simplicity, we'll define $$$m$$$ as the number of distinct elements in the array $$$a$$$; i.e. $$$m = |set(a)|$$$.</p><p>Observe that it is never optimal to perform the same operation in a row, because they can be done in one operation. Also, because all elements are $$$0$$$ initially and the target array contains no $$$0$$$, the first and the last operation will be <span class="tex-font-style-bf">increase</span> operations. Therefore, any optimal order of operation will repeat (<span class="tex-font-style-bf">increase</span> — <span class="tex-font-style-bf">smash</span>) $$$0$$$ or more times and then end with an <span class="tex-font-style-bf">increase</span> operation.</p><p>Because <span class="tex-font-style-bf">increase</span> operations do not affect $$$m$$$, we need to use a <span class="tex-font-style-bf">smash</span> operation to increase $$$m$$$ by at most $$$1$$$. With these constraints, the lower bound of the answer is $$$2m-1$$$ for the given target array. We will show a process to find a possible order of operations to achieve this lower bound.</p><p>Let arrays $$$t$$$ and $$$s$$$ be the target array. $$$a$$$ starts with $$$n$$$ zeros. </p><ol> <li> Remove all duplicates from $$$s$$$. </li><li> Sort $$$s$$$ in decreasing order. </li><li> For $$$i=1 ... m-1$$$: <ol> <li> Perform an <span class="tex-font-style-bf">increase</span> operation with $$$x=s_i-s_{i+1}$$$. </li><li> Perform a <span class="tex-font-style-bf">smash</span> operation on all $$$a_j$$$ where $$$t_j = s_{i+1}$$$. </li></ol> </li><li> Perform an <span class="tex-font-style-bf">increase</span> operation with $$$x=s_m$$$. </li></ol><p>Note that $$$s_i = s_m + \sum_{j=i}^{m-1}{s_j-s_{j+1}}$$$, and the <span class="tex-font-style-bf">increase</span> operation is applied to all $$$a_j$$$ where $$$t_j=s_i$$$ just as the formula after the last <span class="tex-font-style-bf">smash</span> operation applied to them.</p><p>Since we do not actually need to perform these operations, simply finding $$$m$$$ and printing $$$2m-1$$$ suffice. Some ways to find $$$m$$$ are: </p><ul> <li> Insert all elements in a set and get its size. For example, 'std::set' in C++ or 'set' in Python. </li><li> Sort the array and count the number of $$$a_i$$$ where $$$i=n$$$ or $$$a_i \ne a_{i+1}$$$. Library functions such as 'std::unique' in C++ can also be used. </li><li> Make an array $$$c_1 ... c_{100}$$$ and mark all $$$c_{a_i}$$$ with $$$1$$$, then find the sum of $$$c$$$. </li></ul></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
	ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	
	</span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln">
	</span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">set</span><span class="str">&lt;int&gt;</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
		</span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
			s</span><span class="pun">.</span><span class="pln">insert</span><span class="pun">(</span><span class="pln">x</span><span class="pun">);</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> s</span><span class="pun">.</span><span class="pln">size</span><span class="pun">()</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/B">2152B - Catching the Krug</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/B" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152B - Catching the Krug</a></h3><div class="ttypography"><div class="problem-statement"><div><p>We will find the lower and upper bound for the Krug's <span class="tex-font-style-it">survival time</span> with simple strategies for the Krug and Doran, and show that these bounds overlap at a single point.</p><p>Assume that $$$r_K &lt; r_D$$$. In this case, the Krug can always run all the way to the $$$0$$$-th row before getting <span class="tex-font-style-it">caught</span>, and it takes $$$r_D$$$ time for Doran to reach the same row as the Krug. Similarly, if $$$r_K &gt; r_D$$$, it takes $$$n - r_D$$$ time for Doran to reach the same row as Krug if the Krug runs to the $$$n$$$-th row. The same strategy can be applied column-wise too. Therefore, the lower bound of the Krug's <span class="tex-font-style-it">survival time</span> is:</p><p>$$$$$$ \max{ \begin{cases} \begin{cases} r_D, &amp; (r_K &lt; r_D) \\ n-r_D, &amp; (r_K &gt; r_D) \\ 0 &amp; (r_K = r_D) \end{cases}\\ \begin{cases} c_D, &amp; (c_K &lt; c_D) \\ n-c_D, &amp; (c_K &gt; c_D) \\ 0 &amp; (c_K = c_D) \end{cases}\\ \end{cases} } $$$$$$</p><p>Now assume a greedy strategy for Doran; i.e. Doran always moves to a cell that minimizes the absolute difference of row and column between Doran and the Krug. Let these differences be $$$d_r$$$ and $$$d_c$$$, respectively. Then after each pair of the Krug and Doran's moves, each of $$$d_r$$$ and $$$d_c$$$ is reduced (or remains at $$$0$$$) unless the Krug moved to the opposite direction of Doran for the respective axis. Since the Krug can make such move only until she reaches the edge of the grid of each axis (possibly not both, but does not matter), the upper bound of the Krug's <span class="tex-font-style-it">survival time</span> is also maximum of the time until Doran reaches that edge.</p><p>On a side note, the answer remains the same even if the Krug can choose only one direction to move at the beginning, or if the Krug can also move diagonally.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
	ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">

	</span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln">
	</span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> ra</span><span class="pun">,</span><span class="pln"> ca</span><span class="pun">,</span><span class="pln"> rb</span><span class="pun">,</span><span class="pln"> cb</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> ra </span><span class="pun">&gt;&gt;</span><span class="pln"> ca </span><span class="pun">&gt;&gt;</span><span class="pln"> rb </span><span class="pun">&gt;&gt;</span><span class="pln"> cb</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rb </span><span class="pun">&gt;</span><span class="pln"> ra</span><span class="pun">)</span><span class="pln">
			ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> rb</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rb </span><span class="pun">&lt;</span><span class="pln"> ra</span><span class="pun">)</span><span class="pln">
			ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> rb</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cb </span><span class="pun">&gt;</span><span class="pln"> ca</span><span class="pun">)</span><span class="pln">
			ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> cb</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cb </span><span class="pun">&lt;</span><span class="pln"> ca</span><span class="pun">)</span><span class="pln">
			ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> cb</span><span class="pun">);</span><span class="pln">
		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/C">2152C - Triple Removal</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/C" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152C - Triple Removal</a></h3><div class="ttypography"><div class="problem-statement"><div><p>The answer to the query is $$$-1$$$ if either the number of zeros or the number of ones is not a multiple of $$$3$$$. If it is possible to make the array $$$[a_l, \cdots, a_r]$$$ empty, the minimum total cost is at least $$$(r-l+1)/3$$$, since each operation costs at least $$$1$$$ and removes exactly three elements.</p><p>An operation of cost 1 can be viewed as removing two adjacent elements along with a third element.</p><p>Observation 1. Suppose it is possible to make an array $$$A$$$ empty, and $$$A$$$ contains at least one pair of adjacent identical elements. Then, the minimum total cost is $$$|A|/3$$$.</p><p>Based on the observation, the answer to the query $$$[l, r]$$$ is as follows: </p><ul><li> If the number of zeros or ones in $$$[l, r]$$$ is not a multiple of $$$3$$$, the answer is $$$-1$$$. </li><li> If the number of zeros or ones in $$$[l, r]$$$ is a multiple of $$$3$$$ and $$$a_i = a_{i+1}$$$ for some $$$l \le i &lt; r$$$, the answer is $$$(r-l+1)/3$$$. </li><li> Otherwise, the subarray is alternating ($$$0101\cdots 01$$$ or $$$1010\cdots 10$$$). In this case, after applying one operation with cost $$$2$$$, some pair of identical elements becomes adjacent. Thus, the minimum cost is $$$2 + (r-l-2)/3$$$. </li></ul><p>Detailed proof of the observation:</p><p>It is sufficient to show that we can perform operations of cost $$$1$$$ in such a way that either the array becomes empty or there is at least one pair of identical adjacent elements in the remaining array.</p><p>First, consider the case where there are adjacent zeros and adjacent ones. In this situation, we can remove all pairs of adjacent zeros (or ones) with cost $$$1$$$ operations. Therefore, we can reduce to the case where either zeros or ones are not adjacent to each other. Without loss of generality, assume that all ones in the array are not adjacent.</p><p>Let $$$3k$$$ denote the total number of ones in the array. Define $$$c_i$$$ as the number of zeros between the $$$i$$$-th one and the $$$(i+1)$$$-th one for $$$i = 1, \dots, 3k-1$$$. Let $$$c_0$$$ and $$$c_{3k}$$$ denote the number of zeros before the first one and after the last one, respectively. Since no two ones are adjacent in the array, we have $$$c_1, \dots, c_{3k-1} \ge 1$$$. </p><ul> <li> Suppose that there are two indices $$$i, j$$$ such that $$$c_j \ge 2, 0 &lt; i &lt; 3k, 0 \le j \le 3k$$$, and $$$i\ne j$$$. Then it is possible to perform the operations of cost $$$1$$$ to remove every $$$0$$$s between $$$i$$$-th $$$1$$$ and $$$(i+1)$$$-th $$$1$$$. </li><li> Otherwise, $$$c_1=c_2 =\cdots =c_{3k-1}=1$$$ and $$$c_0, c_{3k} \le 1$$$. In this case, every pair of adjacent elements in $$$[a_l, a_{l+1}, \cdots, a_r]$$$ is different. </li></ul></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">/*
* T1 Thanks Round
* Problem triple-removal
* Main Correct Solution
*/</span><span class="pln">

</span><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MAX </span><span class="pun">=</span><span class="pln"> </span><span class="lit">250</span><span class="str">'010;

int A[MAX];

int diff[MAX];
int diffsum[MAX];

int sum[2][MAX];

void solve() {
	int N, Q;
	cin &gt;&gt; N &gt;&gt; Q;
	int i;
	for (i = 1; i &lt;= N; i++) cin &gt;&gt; A[i];
	for (i = 1; i &lt;= N; i++) {
		sum[0][i] = sum[0][i - 1];
		sum[1][i] = sum[1][i - 1];
		sum[A[i]][i]++;

		diff[i] = A[i] != A[i - 1];
		diffsum[i] = diffsum[i - 1] + diff[i];
	}
	int l, r;
	for (i = 1; i &lt;= Q; i++) {
		cin &gt;&gt; l &gt;&gt; r;

		int z, o;
		z = sum[0][r] - sum[0][l - 1];
		o = sum[1][r] - sum[1][l - 1];
		if (z % 3) {
			cout &lt;&lt; -1 &lt;&lt; '</span><span class="pln">\n</span><span class="str">';
			continue;
		}
		if (o % 3) {
			cout &lt;&lt; -1 &lt;&lt; '</span><span class="pln">\n</span><span class="str">';
			continue;
		}

		int sum = z / 3 + o / 3;
		if (diffsum[r] - diffsum[l] == (r - l)) sum++;
		cout &lt;&lt; sum &lt;&lt; '</span><span class="pln">\n</span><span class="str">';
	}
}

signed main() {
	ios::sync_with_stdio(false), cin.tie(0);
	int t, T;
	cin &gt;&gt; T;
	for (t = 1; t &lt;= T; t++) solve();
}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/D">2152D - Division Versus Addition</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/D" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152D - Division Versus Addition</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Lemma: For a single integer $$$x_0 \ge 2$$$, repeatedly applying $$$x \mapsto \left\lfloor \frac{x+1}{2}\right\rfloor$$$ takes exactly $$$\lfloor\log_2 x_0\rfloor$$$ steps if $$$x_0$$$ is a power of two and $$$\lfloor\log_2 x_0\rfloor+1$$$ otherwise (can be proved by induction). </p><p>Classify each array element by its initial value: Type A if $$$a_i=2^k$$$, Type B if $$$a_i=2^k+1$$$, Type C otherwise. Let $$$|B|$$$ and $$$|C|$$$ be the counts of types B and C. The answer is $$$\text{ans}=\sum_i \lfloor \log_2 a_i\rfloor+\left\lfloor\frac{|B|}{2}\right\rfloor+|C|.$$$</p><p>Upper bound (strategy for Poby). Whenever Rekkles plays on an untouched type B for the first time, Poby immediately responds on some other untouched type B (B-mirror); otherwise Poby simply follows Rekkles on the same position on the next move. With this policy, when Poby returns to any previously touched position, its value has increased by at most 1 since his last touch, so from Poby's perspective each revisit applies $$$x\mapsto\big\lfloor\frac{x+1}{2}\big\rfloor$$$; the only worse one-time jump $$$x\mapsto\big\lfloor\frac{x+2}{2}\big\rfloor$$$ can occur on a Type B that Rekkles touched before Poby's first touch. Type A costs $$$\lfloor\log_2 a_i\rfloor$$$; Type C costs $$$\lfloor\log_2 a_i\rfloor+1$$$; Type B costs $$$\lfloor\log_2 a_i\rfloor$$$ if Poby first-touches it and $$$\lfloor\log_2 a_i\rfloor+1$$$ if Rekkles first-touches it. The B-mirror ensures that at most half of the Bs can be stolen by Rekkles, so the total Poby moves are at most $$$\sum_i \lfloor \log_2 a_i\rfloor+\lfloor|B|/2\rfloor+|C|.$$$</p><p>Lower bound (strategy for Rekkles). If Poby just first-touched a fresh B, Rekkles first-touches another fresh B when possible; otherwise he follows Poby on the same position. This keeps every A and C behaving, from Poby's viewpoint, as repeated $$$x\mapsto\big\lfloor\frac{x+1}{2}\big\rfloor$$$ after the initial halving step, giving costs $$$\lfloor\log_2 a_i\rfloor$$$ for A and $$$\lfloor\log_2 a_i\rfloor+1$$$ for C, and guarantees at least $$$\lfloor|B|/2\rfloor$$$ stolen Bs each costing the +1 version. Hence Poby must make at least $$$\sum_i \lfloor \log_2 a_i\rfloor+\lfloor|B|/2\rfloor+|C|$$$ moves.</p><p>Both bounds match, so under optimal play $$$ans=\sum_i \lfloor \log_2 a_i\rfloor+\left\lfloor\frac{|B|}{2}\right\rfloor+|C|$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">

</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> ll </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">constexpr</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MAXN </span><span class="pun">=</span><span class="pln"> </span><span class="lit">250000</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">MAXN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">100</span><span class="pun">];</span><span class="pln">
ll prf</span><span class="pun">[</span><span class="pln">MAXN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">100</span><span class="pun">][</span><span class="lit">4</span><span class="pun">];</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">(){</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
    scanf</span><span class="pun">(</span><span class="str">"%d %d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">q</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">1</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&lt;=</span><span class="pln">n</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++)</span><span class="pln"> scanf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">+</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
    
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">1</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&lt;=</span><span class="pln">n</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++){</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">j</span><span class="pun">&lt;</span><span class="lit">3</span><span class="pun">;</span><span class="pln">j</span><span class="pun">++)</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
        
        </span><span class="kwd">int</span><span class="pln"> typ </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">popcount</span><span class="pun">((</span><span class="kwd">unsigned</span><span class="pun">)</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> typ </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">popcount</span><span class="pun">((</span><span class="kwd">unsigned</span><span class="pun">)</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> typ </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">

        prf</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">typ</span><span class="pun">]++;</span><span class="pln">

        prf</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">][</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="lit">31</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> countl_zero</span><span class="pun">((</span><span class="kwd">unsigned</span><span class="pun">)</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]));</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">q</span><span class="pun">--){</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">;</span><span class="pln">
        scanf</span><span class="pun">(</span><span class="str">"%d %d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">l</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">r</span><span class="pun">);</span><span class="pln">

        ll cnt</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">0</span><span class="pun">};</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">j</span><span class="pun">&lt;</span><span class="lit">3</span><span class="pun">;</span><span class="pln">j</span><span class="pun">++)</span><span class="pln"> cnt</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">r</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">l</span><span class="pun">-</span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">

        ll ans </span><span class="pun">=</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">r</span><span class="pun">][</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> prf</span><span class="pun">[</span><span class="pln">l</span><span class="pun">-</span><span class="lit">1</span><span class="pun">][</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cnt</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cnt</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
        printf</span><span class="pun">(</span><span class="str">"%lld\n"</span><span class="pun">,</span><span class="pln"> ans</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(){</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    scanf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">t</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> solve</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/E">2152E - Monotone Subsequence</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/E" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152E - Monotone Subsequence</a></h3><div class="ttypography"><div class="problem-statement"><div><p>First, note that the set of visible skyscrapers forms an increasing subsequence. As a result, if the interactor ever returns a set with at least $$$n+1$$$ skyscrapers, we are immediately done. On the other hand, for a sequence like $$$[n^2 + 1, n^2, \ldots, 1]$$$, any query will yield exactly one visible skyscraper, so we cannot count on the interactor alone to find the answer. This suggests that the hard case is when a long increasing subsequence does not exist, and we must find a decreasing subsequence instead.</p><p>Start with the set $$$A = \{1, 2, \ldots, n^2+1\}$$$ and repeat the following procedure for up to $$$n$$$ times: </p><ul> <li> Make a skyscraper query on the current set $$$A$$$. </li><li> Let $$$B \subseteq A$$$ be the set of visible skyscrapers. If $$$|B| \ge n+1$$$, report $$$B$$$ and terminate. </li><li> Otherwise, remove the elements of $$$B$$$ from $$$A$$$ and repeat. </li></ul><p>Suppose the algorithm completes all $$$n$$$ iterations without terminating. Let $$$B_i$$$ be the set of visible skyscrapers returned in the $$$i$$$-th iteration, for $$$i=1, \ldots, n$$$. Let $$$B_{n+1}$$$ be the set of all elements remaining in $$$A$$$ after the $$$n$$$-th iteration. Note that $$$B_{n+1}$$$ is not empty.</p><p>We will construct a decreasing sequence by picking indices $$$j_1, j_2, \ldots, j_{n+1}$$$ such that each $$$j_k \in B_k$$$. The following observation is key.</p><p><span class="tex-font-style-bf">Claim.</span> Let $$$dp[j]$$$ be the length of the longest decreasing subsequence ending with the element at index $$$j$$$. For each $$$k \in \{1, \ldots, n\}$$$, the set is $$$B_k = \{j \mid dp[j] = k\}$$$.</p><p><span class="tex-font-style-it">Proof.</span> We use induction on $$$k$$$. For any $$$j \in B_k$$$: </p><ol> <li> <span class="tex-font-style-bf">$$$dp[j] \ge k$$$</span>: Since $$$j \in B_k$$$, it was not visible in the previous iteration. This implies there exists an element $$$m \in B_{k-1}$$$ such that $$$m &lt; j$$$ and its value $$$p_m &gt; p_j$$$. By the inductive hypothesis, $$$dp[m] = k-1$$$. We can append the element at index $$$j$$$ to the decreasing subsequence ending at $$$m$$$ to get a new sequence of length $$$k$$$. Therefore, $$$dp[j] \ge k$$$.<p> </p></li><li> <span class="tex-font-style-bf">$$$dp[j] \le k$$$</span>: Consider any decreasing subsequence that ends at $$$j$$$. Since each of the sets $$$B_1, B_2, \ldots, B_{k-1}$$$ is an increasing subsequence, the decreasing subsequence can contain at most one element from each of these sets. Therefore, its total length is at most $$$(k-1)$$$ elements from those sets, plus the element at index $$$j$$$, giving a maximum length of $$$k$$$. </li></ol> Since $$$dp[j] \ge k$$$ and $$$dp[j] \le k$$$, we must have $$$dp[j] = k$$$. $$$\blacksquare$$$<p>This claim allows us to construct the final sequence. Start with any element $$$j_{n+1} \in B_{n+1}$$$. We know $$$dp[j_{n+1}] \ge n+1$$$. By the definition of $$$dp$$$, there must be a predecessor index $$$j_n &lt; j_{n+1}$$$ with $$$p_{j_n} &gt; p_{j_{n+1}}$$$ and $$$dp[j_n] = dp[j_{n+1}]-1$$$. From our claim, this means $$$j_n \in B_n$$$. We can repeat this process backward to find a $$$j_k \in B_k$$$ for each $$$k$$$, which gives us the desired decreasing subsequence of length $$$n+1$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> lint </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> all</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">end</span><span class="pun">()</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> cr</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">clear</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ord</span><span class="pun">(</span><span class="pln">n </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
	iota</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">ord</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">auto</span><span class="pln"> query </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[&amp;](</span><span class="pln">vector</span><span class="str">&lt;int&gt;</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"? "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> v</span><span class="pun">)</span><span class="pln">
			cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> x </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
		v</span><span class="pun">.</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">y</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> v</span><span class="pun">)</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> x</span><span class="pun">--;</span><span class="pln">
		</span><span class="kwd">return</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">};</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> dp</span><span class="pun">(</span><span class="pln">n </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">auto</span><span class="pln"> cur_ord </span><span class="pun">=</span><span class="pln"> query</span><span class="pun">(</span><span class="pln">ord</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">cur_ord</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"!"</span><span class="pun">;</span><span class="pln">
			</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
				cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> cur_ord</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
			cout </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
			</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		vector</span><span class="str">&lt;int&gt;</span><span class="pln"> new_ord</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> ord</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">binary_search</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">cur_ord</span><span class="pun">),</span><span class="pln"> x</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				new_ord</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">x</span><span class="pun">);</span><span class="pln">
			</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		ord </span><span class="pun">=</span><span class="pln"> new_ord</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> cur </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ans</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">*</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> cur</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			ans</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
			cur</span><span class="pun">--;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	</span><span class="kwd">if</span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">){</span><span class="pln">
	    cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> cur </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
	    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> dp</span><span class="pun">)</span><span class="pln"> cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> x </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">" "</span><span class="pun">;</span><span class="pln">
	    cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	reverse</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">));</span><span class="pln">
	</span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
	cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"!"</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> ans</span><span class="pun">)</span><span class="pln">
		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> x </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
	cout </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> tc</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> tc</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tc</span><span class="pun">--)</span><span class="pln">
		solve</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/F">2152F - Triple Attack</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/F" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152F - Triple Attack</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let $$$Y = \{y_1, y_2, \ldots, y_m\}$$$ be a <span class="tex-font-style-it">sorted</span> multiset of $$$m$$$ timestamps (i.e., $$$y_1 \le y_2 \le \ldots \le y_m$$$). Observe that $$$Y$$$ is <span class="tex-font-style-bf">safe</span> if and only if $$$y_{i+2} &gt; y_i + z$$$ for all $$$1 \le i \le m - 2$$$, since the condition is most constrained by triplets of the form $$$\{y_i, y_{i+1}, y_{i+2}\}$$$. A naive greedy algorithm based on this would be to iterate through the elements $$$x_l, \ldots, x_r$$$ and add each element to a candidate set if the safe property is maintained. This approach takes $$$O(n)$$$ time per query, which is too slow.</p><p>To build an efficient solution, let's first consider a simplified case where $$$Y$$$ is safe if and only if $$$y_{i+1} &gt; y_i + z$$$. Here, a greedy algorithm works by considering the last element instead of the second-to-last. The algorithm on a range $$$[l, r]$$$ starts by picking the $$$l$$$-th element, then repeatedly picks the first subsequent element with a value greater by more than $$$t$$$. For each $$$1 \le i \le n$$$, let $$$f(i)$$$ be the first index $$$j &gt; i$$$ such that $$$x_j &gt; x_i + z$$$ (or $$$n+1$$$ if none exists). These $$$f(i)$$$ values can be precomputed for all $$$i$$$ in $$$O(n)$$$ time using a two-pointer approach. The greedy algorithm then picks elements at indices $$$l, f(l), f^2(l), \ldots$$$ until the index goes beyond $$$r$$$. By building a sparse table for this successor function $$$f$$$, one can find the number of elements picked in $$$O(\log n)$$$ time per query, after an $$$O(n \log n)$$$ initialization.</p><p>Going back to the original problem, the greedy algorithm is equivalent to picking elements from two parallel chains starting at indices $$$l$$$ and $$$l+1$$$: one chain is $$$l, f(l), f^2(l), \ldots$$$ and the other is $$$l+1, f(l+1), f^2(l+1), \ldots$$$. This continues until the chains conflict by reaching the same element. We can model this relationship as a successor tree, where each node $$$i$$$ ($$$1 \le i \le n$$$) has $$$f(i)$$$ as its parent and $$$n+1$$$ is the root. The first conflict point for chains starting at $$$l$$$ and $$$l+1$$$ is their Lowest Common Ancestor, $$$\text{LCA}(l, l+1)$$$. After the chains merge at this node, the process can be reinitialized from the LCA and the node following it.</p><p>This observation allows for an efficient simulation. Starting from $$$l$$$, we repeatedly perform a "big jump" to the next conflict point, $$$\text{LCA}(l, l + 1)$$$. For each jump, we can compute the number of elements picked, which corresponds to the number of nodes on the tree paths from $$$l$$$ and $$$l+1$$$ to their LCA. If the next big jump would take us beyond $$$r$$$, we simulate each chain separately to the end. While performing each big jump naively is slow, we can again use the sparse table to find the destination of multiple big jumps at once. The total time complexity is $$$O((n + q) \log n)$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> lint </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> all</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">end</span><span class="pun">()</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> cr</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">clear</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MAXN </span><span class="pun">=</span><span class="pln"> </span><span class="lit">500005</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="lit">20</span><span class="pun">][</span><span class="pln">MAXN</span><span class="pun">],</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">];</span><span class="pln">
pi nxt2</span><span class="pun">[</span><span class="lit">20</span><span class="pun">][</span><span class="pln">MAXN</span><span class="pun">];</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	
	</span><span class="kwd">int</span><span class="pln"> T</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> T</span><span class="pun">;</span><span class="pln">
	
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">T</span><span class="pun">--){</span><span class="pln">
    	</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    	t</span><span class="pun">++;</span><span class="pln">
    	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> a</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
    		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    	
    	</span><span class="com">// EDIT: added init statements for globals</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">+</span><span class="lit">5</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><span class="pln">
    	    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">20</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">j</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]=</span><span class="lit">0</span><span class="pun">,</span><span class="pln">nxt2</span><span class="pun">[</span><span class="pln">j</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]={</span><span class="lit">0</span><span class="pun">,</span><span class="lit">0</span><span class="pun">};</span><span class="pln">
    	    dep1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]=</span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
    		
    	</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">&amp;&amp;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> t</span><span class="pun">)</span><span class="pln">
    			j</span><span class="pun">++;</span><span class="pln">
    		nxt1</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> j</span><span class="pun">;</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
    	nxt1</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln">
    		dep1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">nxt1</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">20</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln">
    			nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">nxt1</span><span class="pun">[</span><span class="pln">i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]];</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
    	</span><span class="kwd">auto</span><span class="pln"> lca </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[&amp;](</span><span class="kwd">int</span><span class="pln"> u</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dep1</span><span class="pun">[</span><span class="pln">u</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">v</span><span class="pun">])</span><span class="pln">
    			swap</span><span class="pun">(</span><span class="pln">u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">);</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> dx </span><span class="pun">=</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">u</span><span class="pun">];</span><span class="pln">
    		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> dx</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dx </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    				v </span><span class="pun">=</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
    			</span><span class="pun">}</span><span class="pln">
    			dx </span><span class="pun">&gt;&gt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    		</span><span class="pun">}</span><span class="pln">
    		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">u </span><span class="pun">==</span><span class="pln"> v</span><span class="pun">)</span><span class="pln">
    			</span><span class="kwd">return</span><span class="pln"> u</span><span class="pun">;</span><span class="pln">
    		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">19</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">u</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">v</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    				u </span><span class="pun">=</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">u</span><span class="pun">];</span><span class="pln">
    				v </span><span class="pun">=</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
    			</span><span class="pun">}</span><span class="pln">
    		</span><span class="pun">}</span><span class="pln">
    		</span><span class="kwd">return</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">u</span><span class="pun">];</span><span class="pln">
    	</span><span class="pun">};</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> z </span><span class="pun">=</span><span class="pln"> lca</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    		nxt2</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pi</span><span class="pun">{</span><span class="pln">z</span><span class="pun">,</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> dep1</span><span class="pun">[</span><span class="pln">z</span><span class="pun">]};</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
    	nxt2</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pi</span><span class="pun">{</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">};</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">20</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    			</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">[</span><span class="pln">n1</span><span class="pun">,</span><span class="pln"> d1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nxt2</span><span class="pun">[</span><span class="pln">i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
    			</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">[</span><span class="pln">n2</span><span class="pun">,</span><span class="pln"> d2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nxt2</span><span class="pun">[</span><span class="pln">i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">n1</span><span class="pun">];</span><span class="pln">
    			nxt2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pi</span><span class="pun">{</span><span class="pln">n2</span><span class="pun">,</span><span class="pln"> d1 </span><span class="pun">+</span><span class="pln"> d2</span><span class="pun">};</span><span class="pln">
    		</span><span class="pun">}</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
    	</span><span class="kwd">auto</span><span class="pln"> gp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[&amp;](</span><span class="kwd">int</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">19</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">l</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    				l </span><span class="pun">=</span><span class="pln"> nxt1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">l</span><span class="pun">];</span><span class="pln">
    				ans </span><span class="pun">+=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> i</span><span class="pun">);</span><span class="pln">
    			</span><span class="pun">}</span><span class="pln">
    		</span><span class="pun">}</span><span class="pln">
    		</span><span class="kwd">return</span><span class="pln"> ans </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    	</span><span class="pun">};</span><span class="pln">
    	</span><span class="kwd">int</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
    	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">q</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">;</span><span class="pln">
    		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> l </span><span class="pun">&gt;&gt;</span><span class="pln"> r</span><span class="pun">;</span><span class="pln">
    		l</span><span class="pun">--;</span><span class="pln">
    		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">r </span><span class="pun">-</span><span class="pln"> l </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    			cout </span><span class="pun">&lt;&lt;</span><span class="pln"> r </span><span class="pun">-</span><span class="pln"> l </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
    			</span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
    		</span><span class="pun">}</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">19</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nxt2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">l</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    				ans </span><span class="pun">+=</span><span class="pln"> nxt2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">l</span><span class="pun">][</span><span class="lit">1</span><span class="pun">];</span><span class="pln">
    				l </span><span class="pun">=</span><span class="pln"> nxt2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">l</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
    			</span><span class="pun">}</span><span class="pln">
    		</span><span class="pun">}</span><span class="pln">
    		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">l </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> r</span><span class="pun">)</span><span class="pln">
    			ans </span><span class="pun">+=</span><span class="pln"> gp</span><span class="pun">(</span><span class="pln">l</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">);</span><span class="pln">
    		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">l </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> r</span><span class="pun">)</span><span class="pln">
    			ans </span><span class="pun">+=</span><span class="pln"> gp</span><span class="pun">(</span><span class="pln">l </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">);</span><span class="pln">
    		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/G">2152G - Query Jungle</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/G" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152G - Query Jungle</a></h3><div class="ttypography"><div class="problem-statement"><div><p>We find an efficient characterization of the minimum number of paths, which allows subtree updates to be supported by standard data structures.</p><p><span class="tex-font-style-bf">Claim 1.</span> The minimum number of paths required to cover all monsters is equal to the size of the largest ancestor-free subset of monsters. (An ancestor-free subset is one where no monster is an ancestor of another).</p><p><span class="tex-font-style-it">Proof.</span> An ancestor-free subset of size $$$m$$$ clearly requires $$$m$$$ paths to cover. Conversely, consider a minimum-sized set of paths that covers all monsters. If an endpoint of a path does not contain a monster, the path can be shortened towards the root until its endpoint is a monster (or the path becomes empty, contradicting minimality). Thus, we can assume every path endpoint contains a monster. Furthermore, because the path set is of minimum size, no path can be a subpath of another. Therefore, the endpoints of these paths form an ancestor-free subset of monsters of the same size. $$$\blacksquare$$$</p><p>Next, we generate an Euler tour sequence $$$S$$$ of length $$$2n$$$ via a DFS traversal from the root. We assume familiarity with basic properties of Euler tours on trees, such as the interval representation of subtrees.</p><pre class="lstlisting"><code class="prettyprint prettyprinted" style=""><span class="pln">dfs</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><br><span class="pln">	S</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><br><span class="pln">	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">all childs w </span><span class="kwd">of</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> dfs</span><span class="pun">(</span><span class="pln">w</span><span class="pun">);</span><br><span class="pln">	S</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="lit">1</span><span class="pun">);</span><br><span class="pun">}</span><br></code></pre><p>This generates a sequence of length $$$2n$$$, where each node is associated with one $$$0$$$ (marking entry into its subtree) and one $$$1$$$ (marking exit). For each vertex that contains a monster, we replace its corresponding $$$0$$$ and $$$1$$$ in the sequence with $$$2$$$ and $$$3$$$, respectively.</p><p><span class="tex-font-style-bf">Claim 2.</span> The size of the largest ancestor-free subset of monsters is half the length of the longest subsequence of $$$S$$$ of the form $$$2, 3, 2, 3, \ldots$$$.</p><p><span class="tex-font-style-it">Proof.</span> </p><ul> <li> Given a maximum-sized ancestor-free subset of size $$$k$$$, we can construct a subsequence of $$$S$$$ by taking the corresponding $$$2$$$ and $$$3$$$ for each monster in the subset. This subsequence will have the form $$$2, 3, 2, 3, \ldots$$$ because, for any monster $$$v$$$ in the subset, the DFS enters its subtree (producing a $$$2$$$) and must exit it (producing a $$$3$$$) before visiting any other monster in the ancestor-free set. Thus, the length of the longest such subsequence is at least $$$2k$$$. </li><li> Given a maximum-length subsequence of the form $$$2, 3, \ldots$$$ with length $$$2k$$$, it can be transformed into a subsequence corresponding to $$$k$$$ vertices that form an ancestor-free set. For each adjacent pair of $$$2, 3$$$ that does not correspond to the same vertex, you can move either one of them (specifically, the one that is closer to the root) to the other vertex's matching position. The subsequence now corresponds to $$$k$$$ vertices that are ancestor-free. Hence, the subset size is at least half of the length. $$$\blacksquare$$$ </li></ul><p>Subtree updates are handled as follows. A flip query on a subtree corresponds to XORing all values in the corresponding range of $$$S$$$ by $$$2$$$. This operation swaps $$$0 \leftrightarrow 2$$$ and $$$1 \leftrightarrow 3$$$. By maintaining the lengths of the longest alternating subsequences for each possible starting element and character set, we can answer queries efficiently. Specifically, each node in our data structure will store four values: </p><ul> <li> The maximum length of a subsequence of the form $$$0, 1, 0, 1, \ldots$$$ </li><li> The maximum length of a subsequence of the form $$$1, 0, 1, 0, \ldots$$$ </li><li> The maximum length of a subsequence of the form $$$2, 3, 2, 3, \ldots$$$ </li><li> The maximum length of a subsequence of the form $$$3, 2, 3, 2, \ldots$$$ </li></ul> This allows us to solve the problem using a segment tree with lazy propagation. The total time complexity is $$$O((n + q) \log n)$$$.</div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> lint </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">a</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> all</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">).</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">).</span><span class="kwd">end</span><span class="pun">()</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MAXN </span><span class="pun">=</span><span class="pln"> </span><span class="lit">250005</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MAXT </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1050000</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">struct</span><span class="pln"> mtrx </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> nxt</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">
	mtrx</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> nxt</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nxt</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
	mtrx</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		nxt</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
		nxt</span><span class="pun">[</span><span class="lit">1</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	mtrx </span><span class="kwd">operator</span><span class="pun">+(</span><span class="kwd">const</span><span class="pln"> mtrx </span><span class="pun">&amp;</span><span class="pln">m</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		mtrx ret</span><span class="pun">;</span><span class="pln">
		ret</span><span class="pun">.</span><span class="pln">nxt</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nxt</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> m</span><span class="pun">.</span><span class="pln">nxt</span><span class="pun">[</span><span class="pln">nxt</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pun">];</span><span class="pln">
		ret</span><span class="pun">.</span><span class="pln">nxt</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nxt</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> m</span><span class="pun">.</span><span class="pln">nxt</span><span class="pun">[(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> nxt</span><span class="pun">[</span><span class="lit">1</span><span class="pun">])</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pun">];</span><span class="pln">
		</span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">{</span><span class="pln">
	mtrx M</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> lazy</span><span class="pun">;</span><span class="pln">
	node </span><span class="kwd">operator</span><span class="pun">+(</span><span class="kwd">const</span><span class="pln"> node </span><span class="pun">&amp;</span><span class="pln">nd</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		node ret</span><span class="pun">;</span><span class="pln">
		ret</span><span class="pun">.</span><span class="pln">M</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> M</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> nd</span><span class="pun">.</span><span class="pln">M</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
		ret</span><span class="pun">.</span><span class="pln">M</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> M</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> nd</span><span class="pun">.</span><span class="pln">M</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><span class="pln">
		ret</span><span class="pun">.</span><span class="pln">lazy </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">return</span><span class="pln"> ret</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> tree</span><span class="pun">[</span><span class="pln">MAXT</span><span class="pun">];</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> init</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> e</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> p</span><span class="pun">,</span><span class="pln"> vector</span><span class="str">&lt;pi&gt;</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">seq</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">==</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="pln">seq</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mtrx</span><span class="pun">(</span><span class="pln">seq</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
		tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="lit">1</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> seq</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mtrx</span><span class="pun">();</span><span class="pln">
		</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">+</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
	init</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">,</span><span class="pln"> seq</span><span class="pun">);</span><span class="pln">
	init</span><span class="pun">(</span><span class="pln">m </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> seq</span><span class="pun">);</span><span class="pln">
	tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> tree</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> tree</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> lazydown</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">lazy</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			tree</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">lazy </span><span class="pun">^=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
			swap</span><span class="pun">(</span><span class="pln">tree</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> tree</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">lazy </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> update</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> e</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> ps</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> pe</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> p</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e </span><span class="pun">&lt;</span><span class="pln"> ps </span><span class="pun">||</span><span class="pln"> pe </span><span class="pun">&lt;</span><span class="pln"> s</span><span class="pun">)</span><span class="pln">
		</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">&lt;=</span><span class="pln"> ps </span><span class="pun">&amp;&amp;</span><span class="pln"> pe </span><span class="pun">&lt;=</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">lazy </span><span class="pun">^=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
		swap</span><span class="pun">(</span><span class="pln">tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
		</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> pm </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ps </span><span class="pun">+</span><span class="pln"> pe</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
	lazydown</span><span class="pun">(</span><span class="pln">p</span><span class="pun">);</span><span class="pln">
	update</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">,</span><span class="pln"> ps</span><span class="pun">,</span><span class="pln"> pm</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">);</span><span class="pln">
	update</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">,</span><span class="pln"> pm </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> pe</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
	tree</span><span class="pun">[</span><span class="pln">p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> tree</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> tree</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> query</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> tree</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">M</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">nxt</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

vector</span><span class="str">&lt;int&gt;</span><span class="pln"> gph</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">];</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">],</span><span class="pln"> din</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">],</span><span class="pln"> dout</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">];</span><span class="pln">
vector</span><span class="str">&lt;pi&gt;</span><span class="pln"> seq</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> dfs</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	din</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">seq</span><span class="pun">);</span><span class="pln">
	seq</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">({</span><span class="pln">a</span><span class="pun">[</span><span class="pln">x</span><span class="pun">],</span><span class="pln"> </span><span class="lit">0</span><span class="pun">});</span><span class="pln">
	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">y </span><span class="pun">:</span><span class="pln"> gph</span><span class="pun">[</span><span class="pln">x</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">y </span><span class="pun">!=</span><span class="pln"> p</span><span class="pun">)</span><span class="pln">
			dfs</span><span class="pun">(</span><span class="pln">y</span><span class="pun">,</span><span class="pln"> x</span><span class="pun">);</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	seq</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">({</span><span class="pln">a</span><span class="pun">[</span><span class="pln">x</span><span class="pun">],</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
	dout</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">seq</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> T</span><span class="pun">;</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> T</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">T</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    	</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
    		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    		
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> gph</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">clear</span><span class="pun">();</span><span class="pln">
    	seq</span><span class="pun">.</span><span class="pln">clear</span><span class="pun">();</span><span class="pln">
    	
    	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
    		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> u </span><span class="pun">&gt;&gt;</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
    		u</span><span class="pun">--;</span><span class="pln">
    		v</span><span class="pun">--;</span><span class="pln">
    		gph</span><span class="pun">[</span><span class="pln">u</span><span class="pun">].</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln">
    		gph</span><span class="pun">[</span><span class="pln">v</span><span class="pun">].</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">u</span><span class="pun">);</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
    	dfs</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    	init</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">seq</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> seq</span><span class="pun">);</span><span class="pln">
    	cout </span><span class="pun">&lt;&lt;</span><span class="pln"> query</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">int</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
    	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
    	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">q</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    		</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
    		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
    		v</span><span class="pun">--;</span><span class="pln">
    		update</span><span class="pun">(</span><span class="pln">din</span><span class="pun">[</span><span class="pln">v</span><span class="pun">],</span><span class="pln"> dout</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">seq</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> query</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
    	</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/H1">2152H1 - Victorious Coloring (Easy Version)</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/H1" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152H1 - Victorious Coloring (Easy Version)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>WLOG, we assume all edge weights are distinct; ties can be broken arbitrarily.</p><p>We first consider the problem of computing $$$f([x_1, x_2, \ldots, x_n])$$$ when the vector $$$x$$$ is known. The solution is based on the following key observation:</p><p><span class="tex-font-style-bf">Claim 1.</span> There exists a minimum-cost victorious coloring where the following properties hold: </p><ul> <li> The subgraph induced by the red vertices is connected. </li><li> For any edge $$$e_1$$$ with both endpoints colored red and any edge $$$e_2$$$ with exactly one endpoint colored red, it holds that $$$w(e_1) &gt; w(e_2)$$$. </li></ul><p><span class="tex-font-style-it">Proof.</span> If the subgraph induced by the red vertices is disconnected, we can recolor any connected component from red to yellow to reduce the total cost. Suppose there is a pair of edges $$$e_1, e_2$$$ with $$$w(e_1) \le w(e_2)$$$. Removing edge $$$e_1$$$ disconnects the red subgraph into two parts. If we recolor the part not containing the red endpoint of $$$e_2$$$, the cost is reduced by at least $$$w(e_2) - w(e_1) \ge 0$$$. $$$\blacksquare$$$</p><p>A non-empty subset of vertices is called <span class="tex-font-style-it">strong</span> if it corresponds to a red set in a coloring that satisfies the conditions in Claim 1. Clearly, every singleton set $$$\{v\}$$$ is strong. A strong set of size at least two is uniquely determined by its minimum-weight internal edge $$$e$$$; the set consists of all vertices reachable from $$$e$$$ using only edges with weight at least $$$w(e)$$$.</p><p>An immediate corollary is that there are at most $$$2n-1$$$ strong sets. We can characterize this structure further by considering Kruskal's algorithm on the tree edges in decreasing order of weight. Each component maintained by the DSU structure corresponds to a strong set. Specifically, a union operation merges two strong sets $$$A$$$ and $$$B$$$ along an edge $$$e$$$ to form a new strong set $$$A \cup B$$$.</p><p>From this observation, we build a binary tree of strong sets: leaves are singleton sets, and each non-leaf node has two children, representing the two sets that were merged to form it.</p><p>Additionally, for each strong set $$$S$$$ in this tree, we compute its cut value $$$c(S)$$$, which is the sum of weights of edges with exactly one endpoint in $$$S$$$. A naive computation would take $$$O(n^2)$$$ time. However, an edge $$$(u, v)$$$ contributes to $$$c(S)$$$ if and only if $$$S$$$ contains exactly one of $$$u$$$ or $$$v$$$. These set $$$S$$$ will form a simple path from $$$\{u\}$$$ to $$$\{v\}$$$, so we need to add a value to a simple path, which can be done with prefix-sum arrays since LCA is easy to find (the LCA is the node corresponding to the edge $$$e$$$).</p><p>With this structure, we can solve the original problem. The condition $$$f(x) \ge l$$$ is equivalent to requiring $$$c(S) + \sum_{i \in S} x_i \ge l$$$ for every strong set $$$S$$$. To find an optimal assignment, we use a greedy algorithm in a bottom-up fashion on the strong set tree. For a given strong set $$$S$$$, we first recursively find the minimum sums for its children. Then, if the current assignments result in $$$c(S) + \sum_{i \in S} x_i &lt; l$$$, we increase the $$$x_j$$$ value for an arbitrary leaf $$$j \in S$$$ to meet the bound exactly. Processing each query this way takes linear time, leading to a total time complexity of $$$O(n \log n + qn)$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> lint </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> all</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">end</span><span class="pun">()</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> cr</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">clear</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">

vector</span><span class="str">&lt;int&gt;</span><span class="pln"> pa</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> find</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> pa</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pa</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> x </span><span class="pun">?</span><span class="pln"> x </span><span class="pun">:</span><span class="pln"> find</span><span class="pun">(</span><span class="pln">pa</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]));</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> T</span><span class="pun">;</span><span class="pln"> cin</span><span class="pun">&gt;&gt;</span><span class="pln">T</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">T</span><span class="pun">--){</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
		vector</span><span class="pun">&lt;</span><span class="pln">array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">&gt;&gt;</span><span class="pln"> edges</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			lint u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">,</span><span class="pln"> w</span><span class="pun">;</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> u </span><span class="pun">&gt;&gt;</span><span class="pln"> v </span><span class="pun">&gt;&gt;</span><span class="pln"> w</span><span class="pun">;</span><span class="pln">
			u</span><span class="pun">--;</span><span class="pln">
			v</span><span class="pun">--;</span><span class="pln">
			edges</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">({</span><span class="pln">w</span><span class="pun">,</span><span class="pln"> u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">});</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		sort</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">));</span><span class="pln">
		reverse</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">));</span><span class="pln">
		cr</span><span class="pun">(</span><span class="pln">pa</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		vector</span><span class="str">&lt;lint&gt;</span><span class="pln"> cost</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		vector</span><span class="str">&lt;pi&gt;</span><span class="pln"> ch</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		iota</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">pa</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> find</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
			</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> find</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">2</span><span class="pun">]);</span><span class="pln">
			pa</span><span class="pun">[</span><span class="pln">u</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
			pa</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
			ch</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">};</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">2</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-=</span><span class="pln"> edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]];</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">q</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			lint x</span><span class="pun">;</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
			vector</span><span class="str">&lt;lint&gt;</span><span class="pln"> dp</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
			lint dap </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
			</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">&gt;=</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
					dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]];</span><span class="pln">
				</span><span class="pun">}</span><span class="pln">
				</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
					dap </span><span class="pun">+=</span><span class="pln"> x </span><span class="pun">-</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
					dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> x </span><span class="pun">-</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
				</span><span class="pun">}</span><span class="pln">
			</span><span class="pun">}</span><span class="pln">
			cout </span><span class="pun">&lt;&lt;</span><span class="pln"> dap </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2152/problem/H2">2152H2 - Victorious Coloring (Hard Version)</a></p> <div class="spoiler"><b class="spoiler-title">Spoiler</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2152/problem/H2" title="Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)">2152H2 - Victorious Coloring (Hard Version)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Essentially, the computation from the first part of our solution can be restated as follows: Given a static rooted tree $$$T$$$ where each vertex $$$v$$$ has a value $$$f_v \ge 0$$$, we compute the recurrence $$$dp_v$$$ for all vertices: </p><ul> <li> If $$$v$$$ is a leaf, $$$dp_v = \max(0, l - f_v)$$$. </li><li> If $$$v$$$ is a non-leaf with children $$$a$$$ and $$$b$$$, $$$dp_v = \max(dp_a + dp_b, l - f_v)$$$. </li></ul><p>To support queries for multiple values of $$$l$$$, we represent each $$$dp_v$$$ as a function of $$$l$$$. We observe that $$$dp_v(l)$$$ is a convex, piecewise linear function with non-decreasing slopes. This is trivially true for leaves. For a non-leaf node, the sum of two convex piecewise linear functions is also convex, and this property is preserved by the $$$\max(\dots, l - f_v)$$$ operation.</p><p>We represent each function by storing its breakpoints as pairs $$$(p, d)$$$, signifying that the slope increases by $$$d$$$ at point $$$p$$$. These breakpoints are stored in a min-heap for each vertex, ordered by $$$p$$$. The sum of two functions corresponds to the union of their breakpoint sets, which can be computed efficiently using small-to-large merging. To apply the $$$\max(\dots, l - f_v)$$$ operation, we find the intersection of the current function and the line $$$y = l - f_v$$$. We then remove all breakpoints below this intersection and add at most two new ones to define the updated function. This update process adds $$$O(1)$$$ new breakpoints, so the cost is amortized.</p><p>The time complexity is $$$O((n + q) \log n)$$$ using a mergeable heap, or $$$O(n \log^2 n + q \log n)$$$ using a priority queue with small-to-large merging, which is sufficient to pass.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Code</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> lint </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> pi </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">((</span><span class="kwd">int</span><span class="pun">)(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> all</span><span class="pun">(</span><span class="pln">v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="kwd">end</span><span class="pun">()</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> cr</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">clear</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v</span><span class="pun">).</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">

vector</span><span class="str">&lt;int&gt;</span><span class="pln"> pa</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> find</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> pa</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pa</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> x </span><span class="pun">?</span><span class="pln"> x </span><span class="pun">:</span><span class="pln"> find</span><span class="pun">(</span><span class="pln">pa</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]));</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> T</span><span class="pun">;</span><span class="pln"> cin</span><span class="pun">&gt;&gt;</span><span class="pln">T</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">T</span><span class="pun">--){</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
		vector</span><span class="pun">&lt;</span><span class="pln">array</span><span class="pun">&lt;</span><span class="pln">lint</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">&gt;&gt;</span><span class="pln"> edges</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			lint u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">,</span><span class="pln"> w</span><span class="pun">;</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> u </span><span class="pun">&gt;&gt;</span><span class="pln"> v </span><span class="pun">&gt;&gt;</span><span class="pln"> w</span><span class="pun">;</span><span class="pln">
			u</span><span class="pun">--;</span><span class="pln">
			v</span><span class="pun">--;</span><span class="pln">
			edges</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">({</span><span class="pln">w</span><span class="pun">,</span><span class="pln"> u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">});</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		sort</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">));</span><span class="pln">
		reverse</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">));</span><span class="pln">
		cr</span><span class="pun">(</span><span class="pln">pa</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		vector</span><span class="str">&lt;lint&gt;</span><span class="pln"> cost</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		vector</span><span class="str">&lt;pi&gt;</span><span class="pln"> ch</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		iota</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">pa</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> find</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
			</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> find</span><span class="pun">(</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">2</span><span class="pun">]);</span><span class="pln">
			pa</span><span class="pun">[</span><span class="pln">u</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
			pa</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
			ch</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">u</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">};</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">2</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-=</span><span class="pln"> edges</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]];</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="com">// (point, slope increase)</span><span class="pln">
		vector</span><span class="pun">&lt;</span><span class="pln">priority_queue</span><span class="pun">&lt;</span><span class="pln">pi</span><span class="pun">,</span><span class="pln"> vector</span><span class="str">&lt;pi&gt;</span><span class="pun">,</span><span class="pln"> greater</span><span class="str">&lt;pi&gt;</span><span class="pun">&gt;&gt;</span><span class="pln"> pq</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
		vector</span><span class="str">&lt;int&gt;</span><span class="pln"> idx</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
		iota</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">idx</span><span class="pun">),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				pq</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">push</span><span class="pun">({</span><span class="pln">cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
				</span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
			</span><span class="pun">}</span><span class="pln">
			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]]])</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]]]))</span><span class="pln">
				swap</span><span class="pun">(</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
			idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> idx</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]];</span><span class="pln">
			</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]]]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				</span><span class="kwd">auto</span><span class="pln"> tp </span><span class="pun">=</span><span class="pln"> pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]]].</span><span class="pln">top</span><span class="pun">();</span><span class="pln">
				pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]]].</span><span class="pln">pop</span><span class="pun">();</span><span class="pln">
				pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">push</span><span class="pun">(</span><span class="pln">tp</span><span class="pun">);</span><span class="pln">
			</span><span class="pun">}</span><span class="pln">
			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">top</span><span class="pun">()[</span><span class="lit">0</span><span class="pun">])</span><span class="pln">
				</span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;=</span><span class="pln"> lint</span><span class="pun">(</span><span class="lit">2e9</span><span class="pun">))</span><span class="pln">
				</span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
			lint A </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> B </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
			lint pv </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
			</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">[</span><span class="pln">point</span><span class="pun">,</span><span class="pln"> slope</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">top</span><span class="pun">();</span><span class="pln">
				pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">pop</span><span class="pun">();</span><span class="pln">
				B </span><span class="pun">+=</span><span class="pln"> A </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="pln">point </span><span class="pun">-</span><span class="pln"> pv</span><span class="pun">);</span><span class="pln">
				pv </span><span class="pun">=</span><span class="pln"> point</span><span class="pun">;</span><span class="pln">
				A </span><span class="pun">+=</span><span class="pln"> slope</span><span class="pun">;</span><span class="pln">
				</span><span class="com">// A x - A * pv + B = x - cost[i]</span><span class="pln">
				</span><span class="com">// (A - 1) x = A * pv - B - cost[i]</span><span class="pln">
				lint U </span><span class="pun">=</span><span class="pln"> A </span><span class="pun">*</span><span class="pln"> pv </span><span class="pun">-</span><span class="pln"> B </span><span class="pun">-</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
				lint L </span><span class="pun">=</span><span class="pln"> A </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
				</span><span class="com">// point &lt;= U / L, so no need to dedup</span><span class="pln">
				</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">L </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
					</span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">point </span><span class="pun">*</span><span class="pln"> L </span><span class="pun">&lt;=</span><span class="pln"> U</span><span class="pun">);</span><span class="pln">
					</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]])</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> U </span><span class="pun">&lt;</span><span class="pln"> pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">top</span><span class="pun">()[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> L</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
						lint f1 </span><span class="pun">=</span><span class="pln"> U </span><span class="pun">/</span><span class="pln"> L </span><span class="pun">-</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
						lint f2 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">U </span><span class="pun">/</span><span class="pln"> L </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> pv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> A </span><span class="pun">+</span><span class="pln"> B</span><span class="pun">;</span><span class="pln">
						</span><span class="com">// (cost[i], 0) -&gt; (U / L, f1) -&gt; (U / L + 1, f2) -&gt; increase w/ speed A</span><span class="pln">
						pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">push</span><span class="pun">({</span><span class="pln">cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
						pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">push</span><span class="pun">({</span><span class="pln">U </span><span class="pun">/</span><span class="pln"> L</span><span class="pun">,</span><span class="pln"> f2 </span><span class="pun">-</span><span class="pln"> f1 </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
						pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">push</span><span class="pun">({</span><span class="pln">U </span><span class="pun">/</span><span class="pln"> L </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> A </span><span class="pun">-</span><span class="pln"> </span><span class="pun">(</span><span class="pln">f2 </span><span class="pun">-</span><span class="pln"> f1</span><span class="pun">)});</span><span class="pln">
						</span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
					</span><span class="pun">}</span><span class="pln">
				</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]])</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
					pq</span><span class="pun">[</span><span class="pln">idx</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]].</span><span class="pln">push</span><span class="pun">({</span><span class="pln">cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> </span><span class="lit">1</span><span class="pun">});</span><span class="pln">
					</span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
				</span><span class="pun">}</span><span class="pln">
			</span><span class="pun">}</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">
		vector</span><span class="str">&lt;pi&gt;</span><span class="pln"> queries</span><span class="pun">(</span><span class="pln">q</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> q</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> queries</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">
			queries</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		sort</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">queries</span><span class="pun">));</span><span class="pln">
		vector</span><span class="str">&lt;lint&gt;</span><span class="pln"> ans</span><span class="pun">(</span><span class="pln">q</span><span class="pun">);</span><span class="pln">
		lint A </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> B </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> pv </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">auto</span><span class="pln"> T </span><span class="pun">=</span><span class="pln"> idx</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">];</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;[</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> queries</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">pq</span><span class="pun">[</span><span class="pln">T</span><span class="pun">])</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> pq</span><span class="pun">[</span><span class="pln">T</span><span class="pun">].</span><span class="pln">top</span><span class="pun">()[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">[</span><span class="pln">point</span><span class="pun">,</span><span class="pln"> slope</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pq</span><span class="pun">[</span><span class="pln">T</span><span class="pun">].</span><span class="pln">top</span><span class="pun">();</span><span class="pln">
				pq</span><span class="pun">[</span><span class="pln">T</span><span class="pun">].</span><span class="pln">pop</span><span class="pun">();</span><span class="pln">
				B </span><span class="pun">+=</span><span class="pln"> A </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="pln">point </span><span class="pun">-</span><span class="pln"> pv</span><span class="pun">);</span><span class="pln">
				pv </span><span class="pun">=</span><span class="pln"> point</span><span class="pun">;</span><span class="pln">
				A </span><span class="pun">+=</span><span class="pln"> slope</span><span class="pun">;</span><span class="pln">
			</span><span class="pun">}</span><span class="pln">
			ans</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">x </span><span class="pun">-</span><span class="pln"> pv</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> A </span><span class="pun">+</span><span class="pln"> B</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">v </span><span class="pun">:</span><span class="pln"> ans</span><span class="pun">)</span><span class="pln">
			cout </span><span class="pun">&lt;&lt;</span><span class="pln"> v </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2152" class="notice" style="text-decoration: none;">Squarepoint Challenge (Codeforces Round 1055, Div. 1 + Div. 2)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>