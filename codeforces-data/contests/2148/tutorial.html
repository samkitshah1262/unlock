<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/146112" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><h4><a href="https://codeforces.com/contest/2148/problem/A" title="Codeforces Round 1050 (Div. 4)">2148A - Sublime Sequence</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by cry)</b><div class="spoiler-content" style="display: block;"><p>Notice that if we pair each odd-indexed element with an even-indexed element, it sums to <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2">0</span></span></span><script type="math/tex" id="MathJax-Element-1">0</script>. </p><p>Therefore, our strategy is to pair the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mn" id="MJXp-Span-4">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">i</span></span></span><script type="math/tex" id="MathJax-Element-2">2i</script>'th element with the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-6"><span class="MJXp-mo" id="MJXp-Span-7" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-8">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">i</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-11">1</span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-3">(2i+1)</script>th element until there are no more elements to pair. Note that if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">n</span></span></span><script type="math/tex" id="MathJax-Element-4">n</script> is odd, then there exists an unpaired odd element at the end. In this case, the answer will just be that ending element, which will be <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">x</span></span></span><script type="math/tex" id="MathJax-Element-5">x</script>. Otherwise, when <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">n</span></span></span><script type="math/tex" id="MathJax-Element-6">n</script> is even, we paired every element perfectly and the sum will be <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mn" id="MJXp-Span-20">0</span></span></span><script type="math/tex" id="MathJax-Element-7">0</script>.</p><p>Time complexity: <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-mrow" id="MJXp-Span-22"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-23">O</span></span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-25">1</span><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-8">\mathcal{O}(1)</script> per test case.</p></div></div> <div class="spoiler"><b class="spoiler-title">Code (C++) (MikeMirzayanov)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">

</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="com">#define</span><span class="pln"> </span><span class="kwd">forn</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">forn</span><span class="pun">(</span><span class="pln">tt</span><span class="pun">,</span><span class="pln"> t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
        cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
            cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln">
            cout </span><span class="pun">&lt;&lt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
        cout </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><h4><a href="https://codeforces.com/contest/2148/problem/B" title="Codeforces Round 1050 (Div. 4)">2148B - Lasers</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by cry)</b><div class="spoiler-content" style="display: block;"><p>Since our path is continuous, whatever route we take will always pass through all vertical and horizontal lasers in the region from <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-29">0</span><span class="MJXp-mo" id="MJXp-Span-30" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-31">0</span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-9">(0,0)</script> to <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">x</span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">y</span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-10">(x,y)</script> since our movement is bounded inside the region. Therefore, the answer is simply <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">m</span></span></span><script type="math/tex" id="MathJax-Element-11">n + m</script>.</p><p>Time complexity: <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-43"><span class="MJXp-mrow" id="MJXp-Span-44"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-45">O</span></span><span class="MJXp-mo" id="MJXp-Span-46" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-47">1</span><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-12">\mathcal{O}(1)</script> per test case.</p></div></div> <div class="spoiler"><b class="spoiler-title">Code (C++) (MikeMirzayanov)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">

</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="com">#define</span><span class="pln"> </span><span class="kwd">forn</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">forn</span><span class="pun">(</span><span class="pln">tt</span><span class="pun">,</span><span class="pln"> t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">,</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">,</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
        cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> m </span><span class="pun">&gt;&gt;</span><span class="pln"> x </span><span class="pun">&gt;&gt;</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">

        </span><span class="kwd">forn</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln">
            cin </span><span class="pun">&gt;&gt;</span><span class="pln"> s</span><span class="pun">;</span><span class="pln"> 
        </span><span class="kwd">forn</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">)</span><span class="pln">
            cin </span><span class="pun">&gt;&gt;</span><span class="pln"> s</span><span class="pun">;</span><span class="pln"> 

        cout </span><span class="pun">&lt;&lt;</span><span class="pln"> n </span><span class="pun">+</span><span class="pln"> m </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">

    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><h4><a href="https://codeforces.com/contest/2148/problem/C" title="Codeforces Round 1050 (Div. 4)">2148C - Pacer</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by cry)</b><div class="spoiler-content" style="display: block;"><p>In this problem, we want to maximize the amount of points between consecutive requirements. We can ask ourselves the following questions:</p><p>What is the maximum number of points we can obtain between requirements <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-49"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">i</span></span></span><script type="math/tex" id="MathJax-Element-13">i</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-51"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">i</span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-54">1</span></span></span><script type="math/tex" id="MathJax-Element-14">i+1</script>? The answer is <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-msubsup" id="MJXp-Span-56"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-58" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">i</span><span class="MJXp-mo" id="MJXp-Span-60">+</span><span class="MJXp-mn" id="MJXp-Span-61">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-62" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-63"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-65" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-15">a_{i+1} - a_i</script>, by running every minute. When can we run every minute? Only if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-68"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-70" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">i</span><span class="MJXp-mo" id="MJXp-Span-72">+</span><span class="MJXp-mn" id="MJXp-Span-73">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-75"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-77" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-16">(a_{i+1} - a_i)</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-79"><span class="MJXp-mrow" id="MJXp-Span-80"><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-msubsup" id="MJXp-Span-82"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83" style="margin-right: 0.05em;">b</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-84" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">i</span><span class="MJXp-mo" id="MJXp-Span-86">+</span><span class="MJXp-mn" id="MJXp-Span-87">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-89"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-91" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mrow" id="MJXp-Span-92"><span class="MJXp-mo" id="MJXp-Span-93" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span></span></span><script type="math/tex" id="MathJax-Element-17">|b_{i+1} - b_i|</script> have the same parity.</p><p>What if they don't have the same parity? Well we can stay in place for one minute, then we can gain <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-msubsup" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-97" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">i</span><span class="MJXp-mo" id="MJXp-Span-99">+</span><span class="MJXp-mn" id="MJXp-Span-100">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-101" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-102"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-104" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-105" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-106">1</span></span></span><script type="math/tex" id="MathJax-Element-18">a_{i+1} - a_i - 1</script> points.</p><p>The start can be represented by a requirement where <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-msubsup" id="MJXp-Span-108"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-110" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-111" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-112">0</span></span></span><script type="math/tex" id="MathJax-Element-19">a_0 = 0</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;">b</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-116" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-117" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-118">0</span></span></span><script type="math/tex" id="MathJax-Element-20">b_0 = 0</script>. Summing up the number of points between all consecutive requirements yields the answer. Remember to add <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-119"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">m</span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-122"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-124" style="vertical-align: -0.4em;">n</span></span></span></span><script type="math/tex" id="MathJax-Element-21">m - a_n</script> to the answer, since we are running until the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">m</span></span></span><script type="math/tex" id="MathJax-Element-22">m</script>'th minute.</p><p>Time complexity: <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-127"><span class="MJXp-mrow" id="MJXp-Span-128"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-129">O</span></span><span class="MJXp-mo" id="MJXp-Span-130" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">n</span><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-23">\mathcal{O}(n)</script> per test case.</p></div></div> <div class="spoiler"><b class="spoiler-title">Code (C++) (litfan)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">


</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(){</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> T</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> T</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pun">(</span><span class="pln">T</span><span class="pun">--){</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">,</span><span class="pln"> x </span><span class="pun">,</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> m</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> px </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> py </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> points </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">while</span><span class="pun">(</span><span class="pln">n</span><span class="pun">--){</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x </span><span class="pun">&gt;&gt;</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
			points </span><span class="pun">+=</span><span class="pln"> x </span><span class="pun">-</span><span class="pln"> px</span><span class="pun">;</span><span class="pln">
			</span><span class="kwd">if</span><span class="pun">(((</span><span class="pln">x </span><span class="pun">-</span><span class="pln"> px </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="pun">((</span><span class="pln">y </span><span class="pun">-</span><span class="pln"> py </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pun">))</span><span class="pln">points</span><span class="pun">--;</span><span class="pln">
			px </span><span class="pun">=</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
			py </span><span class="pun">=</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">if</span><span class="pun">(</span><span class="pln">px </span><span class="pun">!=</span><span class="pln"> m</span><span class="pun">){</span><span class="pln">
			points </span><span class="pun">+=</span><span class="pln"> m </span><span class="pun">-</span><span class="pln"> px</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		cout </span><span class="pun">&lt;&lt;</span><span class="pln"> points </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">	 </span></code></pre></div></div><h4><a href="https://codeforces.com/contest/2148/problem/D" title="Codeforces Round 1050 (Div. 4)">2148D - Destruction of the Dandelion Fields</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by cry)</b><div class="spoiler-content" style="display: block;"><p>Firstly, if there is no odd farm, then the answer is <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-133"><span class="MJXp-mn" id="MJXp-Span-134">0</span></span></span><script type="math/tex" id="MathJax-Element-24">0</script> by default since we can never turn the lawnmower on.</p><p>Otherwise, let's first visit an odd farm to turn the lawnmower on. To maximize the number of grass, let's visit the odd farm with the maximum number of grass. Now that the lawnmower is on, we can visit any farm. Since the lawnmower can never turn off when we visit an even farm, let's take advantage of this and visit all the even farms. </p><p>Finally, we are forced to visit odd farms. Note that every other odd farm we visit will turn the lawnmower off. From this, we can see that it is optimal to visit the half of the odd farms with the largest amounts; we will visit them when the lawnmower is on.</p><p>Time complexity: <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-135"><span class="MJXp-mrow" id="MJXp-Span-136"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-137">O</span></span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">n</span><span class="MJXp-mi" id="MJXp-Span-140">log</span><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">n</span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-25">\mathcal{O}(n \log n)</script> per test case. The <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-144"><span class="MJXp-mi" id="MJXp-Span-145">log</span><span class="MJXp-mo" id="MJXp-Span-146" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">n</span></span></span><script type="math/tex" id="MathJax-Element-26">\log n</script> complexity comes from sorting.</p></div></div> <div class="spoiler"><b class="spoiler-title">Code (C++) (AksLolCoding)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> a</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">i</span><span class="pun">:</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> i</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> p</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">:</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">i</span><span class="pun">%</span><span class="lit">2</span><span class="pun">].</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">size</span><span class="pun">())</span><span class="pln"> ans </span><span class="pun">+=</span><span class="pln"> accumulate</span><span class="pun">(</span><span class="pln">p</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> p</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="kwd">end</span><span class="pun">(),</span><span class="pln"> </span><span class="lit">0LL</span><span class="pun">);</span><span class="pln">
    sort</span><span class="pun">(</span><span class="pln">p</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">rbegin</span><span class="pun">(),</span><span class="pln"> p</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">rend</span><span class="pun">());</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">size</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)/</span><span class="lit">2</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> ans </span><span class="pun">+=</span><span class="pln"> p</span><span class="pun">[</span><span class="lit">1</span><span class="pun">][</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">signed</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)-&gt;</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> solve</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><h4><a href="https://codeforces.com/contest/2148/problem/E" title="Codeforces Round 1050 (Div. 4)">2148E - Split</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by cry)</b><div class="spoiler-content" style="display: block;"><p>First, let's highlight the important parts of the statement. In my opinion, the most important part is the actual condition for determining whether subarray <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-148"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149">a</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151">l</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">r</span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-27">a[l, r]</script> is awesome, That is: there is some way to place items outside the subarray such that <em>all multisets contain must the exact same elements</em> (ignoring ordering).</p><p>There can only be one way that all multisets can contain must the exact same elements. Let <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-155"><span class="MJXp-msubsup" id="MJXp-Span-156"><span class="MJXp-mrow" id="MJXp-Span-157" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-158">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-159" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-28">\texttt{cnt}_i</script> denote the number of times element <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-160"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161">i</span></span></span><script type="math/tex" id="MathJax-Element-29">i</script> occurs in <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-162"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-163">a</span></span></span><script type="math/tex" id="MathJax-Element-30">a</script>. Then all multisets must contain exactly <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-164"><span class="MJXp-mfrac" id="MJXp-Span-165" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-166"><span class="MJXp-mrow" id="MJXp-Span-167" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-168">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-169" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-31">\frac{\texttt{cnt}_i}{k}</script> copies of element <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-171"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">i</span></span></span><script type="math/tex" id="MathJax-Element-32">i</script>.</p><p>Now, let's find a closed form for how we determine <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-174">a</span><span class="MJXp-mo" id="MJXp-Span-175" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176">l</span><span class="MJXp-mo" id="MJXp-Span-177" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178">r</span><span class="MJXp-mo" id="MJXp-Span-179" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-33">a[l, r]</script> is awesome. Firstly, we can note that the ordering of elements in the subarray does not matter; only the counts matter. Therefore, let's denote <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-180"><span class="MJXp-msubsup" id="MJXp-Span-181"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-183" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-34">c_i</script> as the number of elements with value <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-184"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185">i</span></span></span><script type="math/tex" id="MathJax-Element-35">i</script> in the subarray. The claim is that the subarray is awesome if and only if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-186"><span class="MJXp-msubsup" id="MJXp-Span-187"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-189" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mfrac" id="MJXp-Span-191" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-192"><span class="MJXp-mrow" id="MJXp-Span-193" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-194">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-195" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-36">c_i \leq \frac{\texttt{cnt}_i}{k}</script> over all <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-197"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">i</span></span></span><script type="math/tex" id="MathJax-Element-37">i</script>. We can show this through some casework:</p> <ul>   <li><p>If <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-199"><span class="MJXp-msubsup" id="MJXp-Span-200"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-202" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-203" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mfrac" id="MJXp-Span-204" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-205"><span class="MJXp-mrow" id="MJXp-Span-206" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-207">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-208" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-209">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-38">c_i \leq \frac{\texttt{cnt}_i}{k}</script>, then we can place <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-210"><span class="MJXp-mfrac" id="MJXp-Span-211" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-212"><span class="MJXp-mrow" id="MJXp-Span-213" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-214">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-215" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216">k</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-217" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-220" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-39">\frac{\texttt{cnt}_i}{k} - c_i</script> occurrences inside multiset <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-221"><span class="MJXp-mn" id="MJXp-Span-222">1</span></span></span><script type="math/tex" id="MathJax-Element-40">1</script>. We can place the other elements such that there are exactly <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-223"><span class="MJXp-mfrac" id="MJXp-Span-224" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-225"><span class="MJXp-mrow" id="MJXp-Span-226" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-227">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-228" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-41">\frac{\texttt{cnt}_i}{k}</script> occurrences in all other multisets as well.</p></li>   <li><p>Otherwise, if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-230"><span class="MJXp-msubsup" id="MJXp-Span-231"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-232" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-233" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-234" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mfrac" id="MJXp-Span-235" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-236"><span class="MJXp-mrow" id="MJXp-Span-237" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-238">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-239" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-240">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-42">c_i > \frac{\texttt{cnt}_i}{k}</script>. We can never make the other multisets have <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-241"><span class="MJXp-mfrac" id="MJXp-Span-242" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-243"><span class="MJXp-mrow" id="MJXp-Span-244" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-245">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-246" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-247">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-43">\frac{\texttt{cnt}_i}{k}</script> occurrences because we don't have enough occurrences to do so.</p></li> </ul><p>Therefore, the problem simplifies to: Count the number of subarrays such that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-248"><span class="MJXp-msubsup" id="MJXp-Span-249"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-250" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-251" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-252" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mfrac" id="MJXp-Span-253" style="vertical-align: 0.25em;"><span class="MJXp-box MJXp-script"><span class="MJXp-msubsup" id="MJXp-Span-254"><span class="MJXp-mrow" id="MJXp-Span-255" style="margin-right: 0.05em;"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-256">cnt</span></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-257" style="vertical-align: -0.4em;">i</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-258">k</span></span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-44">c_i \leq \frac{\texttt{cnt}_i}{k}</script> over all <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-259"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-260">i</span></span></span><script type="math/tex" id="MathJax-Element-45">i</script>. We can do so using two-pointers. </p><p>Say our left pointer <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-261"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-262">l</span></span></span><script type="math/tex" id="MathJax-Element-46">l</script> is fixed. Until the inequality is satisfied, we will keep increasing the right pointer <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-263"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-264">r</span></span></span><script type="math/tex" id="MathJax-Element-47">r</script>. Then, we will add <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-265"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-266">r</span><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-268">l</span></span></span><script type="math/tex" id="MathJax-Element-48">r - l</script> to the answer since all subarrays <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-269"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-270">a</span><span class="MJXp-mo" id="MJXp-Span-271" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-272">l</span><span class="MJXp-mo" id="MJXp-Span-273" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-274">l</span><span class="MJXp-mo" id="MJXp-Span-275" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-276" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-277">a</span><span class="MJXp-mo" id="MJXp-Span-278" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-279">l</span><span class="MJXp-mo" id="MJXp-Span-280" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-281">l</span><span class="MJXp-mo" id="MJXp-Span-282" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-283">1</span><span class="MJXp-mo" id="MJXp-Span-284" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-285" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-286" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-287" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-288">a</span><span class="MJXp-mo" id="MJXp-Span-289" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-290">l</span><span class="MJXp-mo" id="MJXp-Span-291" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-292">r</span><span class="MJXp-mo" id="MJXp-Span-293" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-294">1</span><span class="MJXp-mo" id="MJXp-Span-295" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-49">a[l, l], a[l, l+1], \ldots, a[l, r - 1]</script> are satisfied. Then, increment the left pointer by <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-296"><span class="MJXp-mn" id="MJXp-Span-297">1</span></span></span><script type="math/tex" id="MathJax-Element-50">1</script> and repeat. </p></div></div> <div class="spoiler"><b class="spoiler-title">Code (C++) (kwant)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> a</span><span class="pun">(</span><span class="pln">n</span><span class="pun">),</span><span class="pln"> cnt</span><span class="pun">(</span><span class="pln">n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> ct</span><span class="pun">(</span><span class="pln">n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        cin </span><span class="pun">&gt;&gt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
        cnt</span><span class="pun">[</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]]++;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cnt</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> k</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">void</span><span class="pun">(</span><span class="pln">cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            cnt</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">/=</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> res </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> l </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> r </span><span class="pun">&gt;=</span><span class="pln"> l </span><span class="kwd">and</span><span class="pln"> r </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> r</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        ct</span><span class="pun">[</span><span class="pln">a</span><span class="pun">[</span><span class="pln">r</span><span class="pun">]]++;</span><span class="pln">
        </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ct</span><span class="pun">[</span><span class="pln">a</span><span class="pun">[</span><span class="pln">r</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> cnt</span><span class="pun">[</span><span class="pln">a</span><span class="pun">[</span><span class="pln">r</span><span class="pun">]])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            ct</span><span class="pun">[</span><span class="pln">a</span><span class="pun">[</span><span class="pln">l</span><span class="pun">]]--;</span><span class="pln">
            l</span><span class="pun">++;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        res </span><span class="pun">+=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">r </span><span class="pun">-</span><span class="pln"> l </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> res </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="typ">int32_t</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)-&gt;</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> tc </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> tc</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tc</span><span class="pun">--)</span><span class="pln"> solve</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><h4><a href="https://codeforces.com/contest/2148/problem/F" title="Codeforces Round 1050 (Div. 4)">2148F - Gravity Falls</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by cry)</b><div class="spoiler-content" style="display: block;"><p>Firstly, note the last row must have a length of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-298"><span class="MJXp-mrow" id="MJXp-Span-299"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-300">max_k</span></span></span></span><script type="math/tex" id="MathJax-Element-51">\texttt{max_k}</script>, the maximum <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-301"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-302">k</span></span></span><script type="math/tex" id="MathJax-Element-52">k</script> among all arrays. Next, we can think about stacking as appending a suffix of the array on top to the array on the bottom. For example, if we stack an array <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-303"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-304">p</span></span></span><script type="math/tex" id="MathJax-Element-53">p</script> of length <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-305"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-306">y</span></span></span><script type="math/tex" id="MathJax-Element-54">y</script> on top of an array <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-307"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-308">q</span></span></span><script type="math/tex" id="MathJax-Element-55">q</script> of length <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-309"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-310">x</span></span></span><script type="math/tex" id="MathJax-Element-56">x</script> where <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-311"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-312">y</span><span class="MJXp-mo" id="MJXp-Span-313" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-314">x</span></span></span><script type="math/tex" id="MathJax-Element-57">y > x</script>, then we append the suffix of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-315"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-316">p</span></span></span><script type="math/tex" id="MathJax-Element-58">p</script> that starts at index <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-317"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-318">x</span><span class="MJXp-mo" id="MJXp-Span-319" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-320">1</span></span></span><script type="math/tex" id="MathJax-Element-59">x + 1</script> to <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-321"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-322">q</span></span></span><script type="math/tex" id="MathJax-Element-60">q</script> after gravity takes place. </p><p>Let <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-323"><span class="MJXp-msubsup" id="MJXp-Span-324"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-325" style="margin-right: 0.05em;">b</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-326" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-327" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-328"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-329" style="margin-right: 0.05em;">b</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-330" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-331" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-332" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-333" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-334"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-335" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-336" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-61">b_1, b_2, \ldots, b_i</script> denote the lexicographically minimum possible bottom row if we have a prefix of length <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-337"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-338">i</span></span></span><script type="math/tex" id="MathJax-Element-62">i</script> already fixed. From what array (out of the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-339"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-340">n</span></span></span><script type="math/tex" id="MathJax-Element-63">n</script> given arrays) should we append next to <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-341"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-342">b</span></span></span><script type="math/tex" id="MathJax-Element-64">b</script>? </p><p>The answer is: among all arrays with length greater than <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-343"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-344">i</span></span></span><script type="math/tex" id="MathJax-Element-65">i</script>, we want to append the array with the lexicographically minimum suffix starting at index <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-345"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-346">i</span><span class="MJXp-mo" id="MJXp-Span-347" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-348">1</span></span></span><script type="math/tex" id="MathJax-Element-66">i+1</script>. We must append the entire suffix of that array to <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-349"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-350">b</span></span></span><script type="math/tex" id="MathJax-Element-67">b</script>. </p><p>We will repeat this process until <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-351"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-352">b</span></span></span><script type="math/tex" id="MathJax-Element-68">b</script> has <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-353"><span class="MJXp-mrow" id="MJXp-Span-354"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-355">max_k</span></span></span></span><script type="math/tex" id="MathJax-Element-69">\texttt{max_k}</script> elements. Now, we just need to find the array to append at each step efficiently. </p><p><strong>Approach 1: <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-356"><span class="MJXp-mrow" id="MJXp-Span-357"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-358">O</span></span><span class="MJXp-mo" id="MJXp-Span-359" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-360" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-361">k</span><span class="MJXp-mi" id="MJXp-Span-362">log</span><span class="MJXp-mo" id="MJXp-Span-363" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-364">n</span><span class="MJXp-mo" id="MJXp-Span-365" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-70">\mathcal{O}(\sum k \log n)</script></strong></p><p>Iterate <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-366"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-367">i</span></span></span><script type="math/tex" id="MathJax-Element-71">i</script>, denoting the current length of prefix, backwards from <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-368"><span class="MJXp-mrow" id="MJXp-Span-369"><span class="MJXp-mtext MJXp-mono" id="MJXp-Span-370">max_k</span></span></span></span><script type="math/tex" id="MathJax-Element-72">\texttt{max_k}</script>. We will keep track of the indices of all arrays that have length at least <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-371"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-372">i</span></span></span><script type="math/tex" id="MathJax-Element-73">i</script>. At each <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-373"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-374">i</span></span></span><script type="math/tex" id="MathJax-Element-74">i</script>, sort the array with the indices using a comparator with the following priority, from high to low:</p> <ul>   <li><p>the element at index <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-375"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-376">i</span></span></span><script type="math/tex" id="MathJax-Element-75">i</script>.</p></li>   <li><p>The "rank" of the suffix starting at index <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-377"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-378">i</span><span class="MJXp-mo" id="MJXp-Span-379" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-380">1</span></span></span><script type="math/tex" id="MathJax-Element-76">i+1</script> (i.e. its relative order in the previous sorting). If the rank doesn't exist (i.e. the array is exactly length <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-381"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-382">i</span></span></span><script type="math/tex" id="MathJax-Element-77">i</script>), then we can denote the rank as <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-383"><span class="MJXp-mo" id="MJXp-Span-384" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-385">1</span></span></span><script type="math/tex" id="MathJax-Element-78">-1</script> as shorter arrays are more optimal when suffix are tied.</p></li> </ul><p>After the sorting, update the "rank" of each array with the current relative ordering. The first element in the sorted array will be the array you choose to append, if you ever end up with a fixed prefix of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-386"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-387">i</span></span></span><script type="math/tex" id="MathJax-Element-79">i</script> when you build <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-388"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-389">b</span></span></span><script type="math/tex" id="MathJax-Element-80">b</script>.</p><p>Now that we have the "next array to append" precalculated for every length, we build <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-390"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-391">b</span></span></span><script type="math/tex" id="MathJax-Element-81">b</script> from left to right. Since we are sorting at most <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-392"><span class="MJXp-mo" id="MJXp-Span-393" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-394">k</span></span></span><script type="math/tex" id="MathJax-Element-82">\sum k</script> elements and at most <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-395"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-396">n</span></span></span><script type="math/tex" id="MathJax-Element-83">n</script> array indices can be tracked, the complexity is <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-397"><span class="MJXp-mrow" id="MJXp-Span-398"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-399">O</span></span><span class="MJXp-mo" id="MJXp-Span-400" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-401" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-402">k</span><span class="MJXp-mi" id="MJXp-Span-403">log</span><span class="MJXp-mo" id="MJXp-Span-404" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-405">n</span><span class="MJXp-mo" id="MJXp-Span-406" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-84">\mathcal{O}(\sum k \log n)</script></p><p><strong>Approach 2: <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-407"><span class="MJXp-mrow" id="MJXp-Span-408"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-409">O</span></span><span class="MJXp-mo" id="MJXp-Span-410" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-411" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-412">k</span><span class="MJXp-msqrt" id="MJXp-Span-413"><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mo" id="MJXp-Span-414" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-415">k</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-416" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-85">\mathcal{O}(\sum k \sqrt{\sum k})</script></strong></p><p>Every time we want to append the suffix starting at index <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-417"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-418">i</span></span></span><script type="math/tex" id="MathJax-Element-86">i</script> of some array, let's say array <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-419"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-420">c</span></span></span><script type="math/tex" id="MathJax-Element-87">c</script>, then <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-421"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-422">c</span></span></span><script type="math/tex" id="MathJax-Element-88">c</script> must have at least <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-423"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-424">i</span></span></span><script type="math/tex" id="MathJax-Element-89">i</script> elements. Additionally, the sum of lengths of all arrays (i.e. <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-425"><span class="MJXp-mo" id="MJXp-Span-426" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-427">k</span></span></span><script type="math/tex" id="MathJax-Element-90">\sum k</script>) is bounded by <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-428"><span class="MJXp-mn" id="MJXp-Span-429">2</span><span class="MJXp-mo" id="MJXp-Span-430" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-431"><span class="MJXp-mn" id="MJXp-Span-432" style="margin-right: 0.05em;">10</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-433" style="vertical-align: 0.5em;">5</span></span></span></span><script type="math/tex" id="MathJax-Element-91">2 \cdot 10^5</script>.</p><p>The essential observation is: There exist at most <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-434"><span class="MJXp-msqrt" id="MJXp-Span-435"><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mo" id="MJXp-Span-436" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-437">k</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-92">\sqrt{\sum k}</script> distinct values of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-438"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-439">k</span></span></span><script type="math/tex" id="MathJax-Element-93">k</script> among the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-440"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-441">n</span></span></span><script type="math/tex" id="MathJax-Element-94">n</script> arrays. This also means that we are appending a non-empty suffix of some array at most <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-442"><span class="MJXp-msqrt" id="MJXp-Span-443"><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mo" id="MJXp-Span-444" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-445">k</span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-95">\sqrt{\sum k}</script> times. </p><p>You can think of this as: if we have multiple arrays with the same length, then we only care to append the lexicographically minimum out of those arrays. Besides the array we will append, we don't care about any other arrays with that length. </p><p>Now, at each iteration of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-446"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-447">i</span></span></span><script type="math/tex" id="MathJax-Element-96">i</script>, it suffices to manually iterate through all the suffixes of all <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-448"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-449">n</span></span></span><script type="math/tex" id="MathJax-Element-97">n</script> arrays with lengths at least <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-450"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-451">i</span><span class="MJXp-mo" id="MJXp-Span-452" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-453">1</span></span></span><script type="math/tex" id="MathJax-Element-98">i+ 1</script> to find the lexicographically minimum one. You are iterating through at most <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-454"><span class="MJXp-mo" id="MJXp-Span-455" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-456">k</span></span></span><script type="math/tex" id="MathJax-Element-99">\sum k</script> elements per step, so the complexity is<br><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-457"><span class="MJXp-mrow" id="MJXp-Span-458"><span class="MJXp-mi MJXp-cal" id="MJXp-Span-459">O</span></span><span class="MJXp-mo" id="MJXp-Span-460" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-461" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-462">k</span><span class="MJXp-msqrt" id="MJXp-Span-463"><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mo" id="MJXp-Span-464" style="margin-left: 0.111em; margin-right: 0.167em;">∑</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-465">k</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-466" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-100">\mathcal{O}(\sum k \sqrt{\sum k})</script>.</p></div></div> <div class="spoiler"><b class="spoiler-title">Code 1 (C++) (cry)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="com">#define</span><span class="pln"> all</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> x</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> x</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">()</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> pb push_back
</span><span class="com">#define</span><span class="pln"> FOR</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">);</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> ROF</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln">a</span><span class="pun">,</span><span class="pln">b</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">);</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span><span class="pun">--</span><span class="pln">i</span><span class="pun">)</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> trav</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pun">&amp;</span><span class="pln"> a</span><span class="pun">:</span><span class="pln"> x</span><span class="pun">)</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pun">)</span><span class="pln">x</span><span class="pun">.</span><span class="pln">size</span><span class="pun">()</span><span class="pln">
</span><span class="kwd">template</span><span class="pun">&lt;</span><span class="kwd">class</span><span class="pln"> T</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> ckmax</span><span class="pun">(</span><span class="pln">T</span><span class="pun">&amp;</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> T</span><span class="pun">&amp;</span><span class="pln"> b</span><span class="pun">){</span><span class="kwd">return</span><span class="pln"> a</span><span class="pun">&lt;</span><span class="pln">b</span><span class="pun">?</span><span class="pln">a</span><span class="pun">=</span><span class="pln">b</span><span class="pun">,</span><span class="lit">1</span><span class="pun">:</span><span class="lit">0</span><span class="pun">;}</span><span class="pln">
</span><span class="kwd">template</span><span class="pun">&lt;</span><span class="kwd">typename</span><span class="pln"> T</span><span class="pun">&gt;</span><span class="pln"> ostream</span><span class="pun">&amp;</span><span class="pln"> </span><span class="kwd">operator</span><span class="pun">&lt;&lt;(</span><span class="pln">ostream</span><span class="pun">&amp;</span><span class="pln"> </span><span class="kwd">out</span><span class="pun">,</span><span class="pln"> vector</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&amp;</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">out</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> x </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">' '</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">out</span><span class="pun">;};</span><span class="pln">
 
</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
	vector</span><span class="pun">&lt;</span><span class="pln">vector</span><span class="str">&lt;int&gt;</span><span class="pun">&gt;</span><span class="pln"> g</span><span class="pun">(</span><span class="pln">n</span><span class="pun">),</span><span class="pln"> relevant</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> max_k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
	FOR</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="pln">n</span><span class="pun">){</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> k</span><span class="pun">;</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
		g</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">k</span><span class="pun">);</span><span class="pln">
		ckmax</span><span class="pun">(</span><span class="pln">max_k</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">);</span><span class="pln">
		FOR</span><span class="pun">(</span><span class="pln">j</span><span class="pun">,</span><span class="lit">0</span><span class="pun">,</span><span class="pln">k</span><span class="pun">){</span><span class="pln">
			cin </span><span class="pun">&gt;&gt;</span><span class="pln"> g</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
			</span><span class="kwd">if</span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">relevant</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> j</span><span class="pun">)</span><span class="pln"> relevant</span><span class="pun">.</span><span class="pln">pb</span><span class="pun">({});</span><span class="pln">
			relevant</span><span class="pun">[</span><span class="pln">j</span><span class="pun">].</span><span class="pln">pb</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> lex_min</span><span class="pun">(</span><span class="pln">max_k</span><span class="pun">),</span><span class="pln"> rank</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
	ROF</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln">max_k</span><span class="pun">-</span><span class="lit">1</span><span class="pun">,</span><span class="lit">0</span><span class="pun">){</span><span class="pln">
		vector</span><span class="pun">&lt;</span><span class="pln">array</span><span class="pun">&lt;</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">&gt;&gt;</span><span class="pln"> cur</span><span class="pun">;</span><span class="pln">
		trav</span><span class="pun">(</span><span class="pln">j</span><span class="pun">,</span><span class="pln"> relevant</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]){</span><span class="pln">
			cur</span><span class="pun">.</span><span class="pln">pb</span><span class="pun">({</span><span class="pln">g</span><span class="pun">[</span><span class="pln">j</span><span class="pun">][</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> rank</span><span class="pun">[</span><span class="pln">j</span><span class="pun">],</span><span class="pln"> j</span><span class="pun">});</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		sort</span><span class="pun">(</span><span class="pln">all</span><span class="pun">(</span><span class="pln">cur</span><span class="pun">));</span><span class="pln">
		lex_min</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">2</span><span class="pun">];</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> rk </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
		trav</span><span class="pun">(</span><span class="pln">j</span><span class="pun">,</span><span class="pln"> cur</span><span class="pun">)</span><span class="pln"> rank</span><span class="pun">[</span><span class="pln">j</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> rk</span><span class="pun">++;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ans</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> max_k</span><span class="pun">){</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> tmp </span><span class="pun">=</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">);</span><span class="pln">
		</span><span class="kwd">auto</span><span class="pun">&amp;</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> g</span><span class="pun">[</span><span class="pln">lex_min</span><span class="pun">[</span><span class="pln">tmp</span><span class="pun">]];</span><span class="pln">
		FOR</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln">tmp</span><span class="pun">,</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">v</span><span class="pun">))</span><span class="pln"> ans</span><span class="pun">.</span><span class="pln">pb</span><span class="pun">(</span><span class="pln">v</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	</span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> max_k</span><span class="pun">);</span><span class="pln">
	cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"\n"</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">signed</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-&gt;</span><span class="pln"> sync_with_stdio</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
	cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> test </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> test </span><span class="pun">&lt;=</span><span class="pln"> t</span><span class="pun">;</span><span class="pln"> test</span><span class="pun">++){</span><span class="pln">
		solve</span><span class="pun">();</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="com">/*   /\_/\
*   (= ._.)
*   / &gt;  \&gt;
*/</span></code></pre></div></div> <div class="spoiler"><b class="spoiler-title">Code 2 (Python) (Vladosiya)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="kwd">from</span><span class="pln"> collections </span><span class="kwd">import</span><span class="pln"> deque


</span><span class="kwd">def</span><span class="pln"> solve</span><span class="pun">():</span><span class="pln">
    n </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">input</span><span class="pun">())</span><span class="pln">
    a </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="pln">deque</span><span class="pun">(</span><span class="pln">list</span><span class="pun">(</span><span class="pln">map</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> input</span><span class="pun">().</span><span class="pln">split</span><span class="pun">()))[</span><span class="lit">1</span><span class="pun">:])</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="pln">n</span><span class="pun">)]</span><span class="pln">
    a</span><span class="pun">.</span><span class="pln">sort</span><span class="pun">(</span><span class="pln">key</span><span class="pun">=</span><span class="kwd">lambda</span><span class="pln"> x</span><span class="pun">:</span><span class="pln"> </span><span class="pun">-</span><span class="pln">len</span><span class="pun">(</span><span class="pln">x</span><span class="pun">))</span><span class="pln">
    ans </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[]</span><span class="pln">
    </span><span class="kwd">while</span><span class="pln"> a</span><span class="pun">:</span><span class="pln">
        cur </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln">
        ans </span><span class="pun">+=</span><span class="pln"> cur
        </span><span class="kwd">while</span><span class="pln"> a </span><span class="kwd">and</span><span class="pln"> len</span><span class="pun">(</span><span class="pln">a</span><span class="pun">[-</span><span class="lit">1</span><span class="pun">])</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> len</span><span class="pun">(</span><span class="pln">cur</span><span class="pun">):</span><span class="pln">
            a</span><span class="pun">.</span><span class="pln">pop</span><span class="pun">()</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)):</span><span class="pln">
            </span><span class="kwd">for</span><span class="pln"> j </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">cur</span><span class="pun">)):</span><span class="pln">
                a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">popleft</span><span class="pun">()</span><span class="pln">
    </span><span class="kwd">print</span><span class="pun">(*</span><span class="pln">ans</span><span class="pun">)</span><span class="pln">


</span><span class="kwd">for</span><span class="pln"> _ </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">(</span><span class="pln">input</span><span class="pun">())):</span><span class="pln">
    solve</span><span class="pun">()</span></code></pre></div></div><h4><a href="https://codeforces.com/contest/2148/problem/G" title="Codeforces Round 1050 (Div. 4)">2148G - Farmer John's Last Wish</a></h4> <div class="spoiler"><b class="spoiler-title">Solution (written by avighankc)</b><div class="spoiler-content" style="display: block;"><p>Let's start by understanding how <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-467"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-468">f</span><span class="MJXp-mo" id="MJXp-Span-469" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-470">a</span><span class="MJXp-mo" id="MJXp-Span-471" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-101">f(a)</script> works. The definition essentially asks for the largest index <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-472"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-473">k</span></span></span><script type="math/tex" id="MathJax-Element-102">k</script> such that the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-476"><span class="MJXp-mo" id="MJXp-Span-477" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span></span></span><script type="math/tex" id="MathJax-Element-103">\gcd</script> of the first <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-478"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-479">k</span></span></span><script type="math/tex" id="MathJax-Element-104">k</script> elements is strictly greater than the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-480"><span class="MJXp-mo" id="MJXp-Span-481" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span></span></span><script type="math/tex" id="MathJax-Element-105">\gcd</script> of the first <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-482"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-483">k</span><span class="MJXp-mo" id="MJXp-Span-484" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-485">1</span></span></span><script type="math/tex" id="MathJax-Element-106">k+1</script>. In other words, we're looking for the <em>last</em> point at which the running gcd 'drops'.</p><p>A useful observation is that scaling the entire array (multiplying or dividing every element by the same integer) does not affect where this drop occurs; each <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-486"><span class="MJXp-mo" id="MJXp-Span-487" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span></span></span><script type="math/tex" id="MathJax-Element-107">\gcd</script> value is just scaled accordingly. This allows us to 'normalize' the problem: divide each <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-488"><span class="MJXp-msubsup" id="MJXp-Span-489"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-490" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-491" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-108">a_i</script> by the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-492"><span class="MJXp-mo" id="MJXp-Span-493" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span></span></span><script type="math/tex" id="MathJax-Element-109">\gcd</script> of the whole array. After this, the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-494"><span class="MJXp-mo" id="MJXp-Span-495" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span></span></span><script type="math/tex" id="MathJax-Element-110">\gcd</script> of the full array becomes <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-496"><span class="MJXp-mn" id="MJXp-Span-497">1</span></span></span><script type="math/tex" id="MathJax-Element-111">1</script>, and the question reduces to:</p> <blockquote><p>What is the last index where the prefix GCD is still greater than <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-498"><span class="MJXp-mn" id="MJXp-Span-499">1</span></span></span><script type="math/tex" id="MathJax-Element-112">1</script>?</p> </blockquote><p>Now, note that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-500"><span class="MJXp-mo" id="MJXp-Span-501" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span><span class="MJXp-mo" id="MJXp-Span-502" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-503">1</span></span></span><script type="math/tex" id="MathJax-Element-113">\gcd > 1</script> for a prefix means there exists some integer <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-504"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-505">d</span><span class="MJXp-mo" id="MJXp-Span-506" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mn" id="MJXp-Span-507">1</span></span></span><script type="math/tex" id="MathJax-Element-114">d>1</script> that divides every element in that prefix. So, the problem boils down to constructing the largest prefix that shares a common divisor greater than <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-508"><span class="MJXp-mn" id="MJXp-Span-509">1</span></span></span><script type="math/tex" id="MathJax-Element-115">1</script>.</p><p>To handle this, let’s think in terms of divisors. For each number <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-510"><span class="MJXp-msubsup" id="MJXp-Span-511"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-512" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-513" style="vertical-align: -0.4em;">i</span></span></span></span><script type="math/tex" id="MathJax-Element-116">a_i</script>, compute all of its divisors. Maintain a frequency array <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-514"><span class="MJXp-mtext" id="MJXp-Span-515">div</span></span></span><script type="math/tex" id="MathJax-Element-117">\text{div}</script>, where <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-516"><span class="MJXp-mtext" id="MJXp-Span-517">div</span><span class="MJXp-mo" id="MJXp-Span-518" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-519">d</span><span class="MJXp-mo" id="MJXp-Span-520" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-118">\text{div}[d]</script> stores how many elements seen so far are divisible by <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-521"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-522">d</span></span></span><script type="math/tex" id="MathJax-Element-119">d</script>. The maximum value of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-523"><span class="MJXp-mtext" id="MJXp-Span-524">div</span><span class="MJXp-mo" id="MJXp-Span-525" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-526">d</span><span class="MJXp-mo" id="MJXp-Span-527" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-120">\text{div}[d]</script> tells us the largest prefix size where all elements share divisor <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-528"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-529">d</span></span></span><script type="math/tex" id="MathJax-Element-121">d</script>. That gives us <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-530"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-531">f</span><span class="MJXp-mo" id="MJXp-Span-532" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-533">a</span><span class="MJXp-mo" id="MJXp-Span-534" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-122">f(a)</script>.</p> <hr><h2>Extending to Prefixes</h2><p>The problem, however, doesn’t just ask for <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-535"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-536">f</span><span class="MJXp-mo" id="MJXp-Span-537" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-538">a</span><span class="MJXp-mo" id="MJXp-Span-539" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-123">f(a)</script> of the entire array. We need <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-540"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-541">g</span><span class="MJXp-mo" id="MJXp-Span-542" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-543">p</span><span class="MJXp-mo" id="MJXp-Span-544" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-124">g(p)</script> for every prefix <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-545"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-546">p</span><span class="MJXp-mo" id="MJXp-Span-547" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-548" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-msubsup" id="MJXp-Span-549"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-550" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-551" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-552" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-553"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-554" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-555" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-556" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-557" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-558" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-559"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-560" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-561" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-562" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-125">p = [a_1, a_2, \dots, a_i]</script>, considering all permutations. Fortunately, the divisor-counting approach extends naturally: as we iterate through the array from left to right, we update the divisor frequencies for each new element and recompute the maximum.</p><p>There is a subtle edge case here. Suppose the array is <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-563"><span class="MJXp-mo" id="MJXp-Span-564" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-565">8</span><span class="MJXp-mo" id="MJXp-Span-566" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-567">4</span><span class="MJXp-mo" id="MJXp-Span-568" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-569">2</span><span class="MJXp-mo" id="MJXp-Span-570" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-571">1</span><span class="MJXp-mo" id="MJXp-Span-572" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-126">[8,4,2,1]</script> and we are at prefix <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-573"><span class="MJXp-mo" id="MJXp-Span-574" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-575">8</span><span class="MJXp-mo" id="MJXp-Span-576" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-577">4</span><span class="MJXp-mo" id="MJXp-Span-578" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-579">2</span><span class="MJXp-mo" id="MJXp-Span-580" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-127">[8, 4, 2]</script>. All three numbers are divisible by 2, so <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-581"><span class="MJXp-mo" id="MJXp-Span-582" style="margin-left: 0.333em; margin-right: 0.333em;">max</span><span class="MJXp-mo" id="MJXp-Span-583" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mtext" id="MJXp-Span-584">div</span><span class="MJXp-mo" id="MJXp-Span-585" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-586" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-587">3</span></span></span><script type="math/tex" id="MathJax-Element-128">\max(\text{div}) = 3</script>. But the true answer is not 3, it’s 2, because the gcd only drops <em>before</em> the last element (the full prefix always ends with <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-588"><span class="MJXp-mo" id="MJXp-Span-589" style="margin-left: 0.333em; margin-right: 0.333em;">gcd</span><span class="MJXp-mo" id="MJXp-Span-590" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-591">1</span></span></span><script type="math/tex" id="MathJax-Element-129">\gcd = 1</script> by normalization). To handle this, we should ignore the trivial case where every element of the prefix shares a divisor. In other words, the correct answer is</p> <center><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-592"><span class="MJXp-mo" id="MJXp-Span-593" style="margin-left: 0.333em; margin-right: 0.333em;">max</span><span class="MJXp-mo" id="MJXp-Span-594" style="margin-left: 0em; margin-right: 0em;">{</span><span class="MJXp-mtext" id="MJXp-Span-595">div</span><span class="MJXp-mo" id="MJXp-Span-596" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-597">d</span><span class="MJXp-mo" id="MJXp-Span-598" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-599" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mtext" id="MJXp-Span-600">div</span><span class="MJXp-mo" id="MJXp-Span-601" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-602">d</span><span class="MJXp-mo" id="MJXp-Span-603" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-604" style="margin-left: 0.333em; margin-right: 0.333em;">≠</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-605">i</span><span class="MJXp-mo" id="MJXp-Span-606" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-607">1</span><span class="MJXp-mo" id="MJXp-Span-608" style="margin-left: 0em; margin-right: 0em;">}</span></span></span><script type="math/tex" id="MathJax-Element-130">\max\{\text{div}[d], \text{div}[d] \neq i+1\}</script></center><p>ensuring we don’t mistakenly include the full prefix.</p> <hr><h3>Complexity</h3><p>For each element, computing divisors takes <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-609"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-610">O</span><span class="MJXp-mo" id="MJXp-Span-611" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msqrt" id="MJXp-Span-612"><span class="MJXp-surd"><span class="MJXp-right MJXp-scale9" style="font-size: 169%; margin-top: 0.083em; margin-left: -0.055em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.084em solid;"></span><span class="MJXp-box"><span class="MJXp-msubsup" id="MJXp-Span-613"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-614" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-615" style="vertical-align: -0.4em;">i</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-616" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-131">O(\sqrt{a_i})</script>. Updating frequencies and maintaining the maximum is <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-617"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-618">O</span><span class="MJXp-mo" id="MJXp-Span-619" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-620">1</span><span class="MJXp-mo" id="MJXp-Span-621" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-132">O(1)</script> per divisor. Across all elements, the time complexity is:</p> <center><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-622"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-623">O</span><span class="MJXp-mspace" id="MJXp-Span-624" style="margin-left: -0.167em; width: 0em; height: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-625"><span class="MJXp-mo" id="MJXp-Span-626" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.289em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.156em; margin-left: -0.09em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-627"><span class="MJXp-mo" id="MJXp-Span-628" style="margin-left: 0.111em; margin-right: 0.05em;">∑</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-633">n</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mrow" id="MJXp-Span-629"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-630">i</span><span class="MJXp-mo" id="MJXp-Span-631">=</span><span class="MJXp-mn" id="MJXp-Span-632">1</span></span></span></span></span></span></span><span class="MJXp-msqrt" id="MJXp-Span-634"><span class="MJXp-surd"><span class="MJXp-right MJXp-scale9" style="font-size: 169%; margin-top: 0.083em; margin-left: -0.055em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.084em solid;"></span><span class="MJXp-box"><span class="MJXp-msubsup" id="MJXp-Span-635"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-636" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-637" style="vertical-align: -0.4em;">i</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-638" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.289em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.156em; margin-left: -0.09em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-639" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-640">O</span><span class="MJXp-mo" id="MJXp-Span-641" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-642">n</span><span class="MJXp-msqrt" id="MJXp-Span-643"><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-644">A</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-645" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-646" style="margin-left: 0em; margin-right: 0.222em;">,</span></span></span><script type="math/tex" id="MathJax-Element-133">  O\!\left( \sum_{i=1}^n \sqrt{a_i} \right) \leq O(n \sqrt{A}),  </script></center><p>where <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-647"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-648">A</span></span></span><script type="math/tex" id="MathJax-Element-134">A</script> is the maximum element. This is efficient enough given the constraints.</p></div></div> <div class="spoiler"><b class="spoiler-title">Solution 2 (written by Jteh)</b><div class="spoiler-content" style="display: block;"><p>For every prefix of length <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-649"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-650">i</span></span></span><script type="math/tex" id="MathJax-Element-135">i</script> (<span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-651"><span class="MJXp-mn" id="MJXp-Span-652">1</span><span class="MJXp-mo" id="MJXp-Span-653" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-654">i</span><span class="MJXp-mo" id="MJXp-Span-655" style="margin-left: 0.333em; margin-right: 0.333em;">≤</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-656">n</span></span></span><script type="math/tex" id="MathJax-Element-136">1 \leq i \leq n</script>), the most optimal reordering is to reorder all prefix elements such that the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-657"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-658">k</span></span></span><script type="math/tex" id="MathJax-Element-137">k</script> first elements of <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-659"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-660">a</span></span></span><script type="math/tex" id="MathJax-Element-138">a</script> can all be divided by the same divisor while the <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-661"><span class="MJXp-mo" id="MJXp-Span-662" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-663">k</span><span class="MJXp-mo" id="MJXp-Span-664" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-665">1</span><span class="MJXp-mo" id="MJXp-Span-666" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-139">(k+1)</script>'th element can't. This ensures that <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-667"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-668">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-669">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-670">d</span><span class="MJXp-mo" id="MJXp-Span-671" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-672"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-673" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-674" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-675" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-676" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-677" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-678" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-679" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-680"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-681" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-682" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-683" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-684" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-685">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-686">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-687">d</span><span class="MJXp-mo" id="MJXp-Span-688" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-689"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-690" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-691" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-692" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-693" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-694" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-695" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-696" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-697"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-698" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-699" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-700">k</span><span class="MJXp-mo" id="MJXp-Span-701">+</span><span class="MJXp-mn" id="MJXp-Span-702">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-703" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-140">gcd(a_1,...,a_k)>gcd(a_1,...,a_{k+1})</script> is always true.</p><p>Thus, we have reduced the problem to : <b>Find a divisor that can divide the most elements for every prefix of length <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-704"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-705">i</span></span></span><script type="math/tex" id="MathJax-Element-141">i</script>.</b> To solve this, we can simply precompute divisors of all numbers and increase their count by <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-706"><span class="MJXp-mn" id="MJXp-Span-707">1</span></span></span><script type="math/tex" id="MathJax-Element-142">1</script> as we iterate through the array and take the maximum <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-708"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-709">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-710">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-711">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-712">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-713">t</span><span class="MJXp-mo" id="MJXp-Span-714" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-715">x</span><span class="MJXp-mo" id="MJXp-Span-716" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><script type="math/tex" id="MathJax-Element-143">count[x]</script> as answer.</p><p>A special case where maximum <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-717"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-718">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-719">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-720">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-721">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-722">t</span><span class="MJXp-mo" id="MJXp-Span-723" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-724">x</span><span class="MJXp-mo" id="MJXp-Span-725" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-726" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-727">i</span></span></span><script type="math/tex" id="MathJax-Element-144">count[x] = i</script> is invalid, as <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-728"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-729">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-730">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-731">d</span><span class="MJXp-mo" id="MJXp-Span-732" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-733"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-734" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-735" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-736" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-737" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-738" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-739" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-740" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-741"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-742" style="margin-right: 0.05em;">a</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-743" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-744" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-745" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-746">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-747">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-748">d</span><span class="MJXp-mo" id="MJXp-Span-749" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-750"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-751" style="margin-right: 0.05em;">a</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-752" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-753" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-754" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-755" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-756" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mo" id="MJXp-Span-757" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-758"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-759" style="margin-right: 0.05em;">a</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-760" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-761">k</span><span class="MJXp-mo" id="MJXp-Span-762">+</span><span class="MJXp-mn" id="MJXp-Span-763">1</span></span></span><span class="MJXp-mo" id="MJXp-Span-764" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-145">gcd(a_1, ..., a_k) > gcd(a_1, ..., a_{k+1})</script> is no longer true. We can save all such <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-765"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-766">x</span></span></span><script type="math/tex" id="MathJax-Element-146">x</script> into an array and check for every <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-767"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-768">i</span></span></span><script type="math/tex" id="MathJax-Element-147">i</script> if <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-769"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-770">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-771">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-772">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-773">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-774">t</span><span class="MJXp-mo" id="MJXp-Span-775" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-776">x</span><span class="MJXp-mo" id="MJXp-Span-777" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-778" style="margin-left: 0.333em; margin-right: 0.333em;">&lt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-779">i</span></span></span><script type="math/tex" id="MathJax-Element-148">count[x] < i</script> is true with bruteforce, since the number of divisors for a number <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-780"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-781">x</span></span></span><script type="math/tex" id="MathJax-Element-149">x</script> is roughly at most <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-782"><span class="MJXp-mroot" id="MJXp-Span-783"><span class="MJXp-script" style="margin-right: -0.67em; vertical-align: 0.854em; margin-left: 0.27em;"><span class="MJXp-mn" id="MJXp-Span-785">3</span></span><span><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-784">x</span></span></span></span></span></span></span><script type="math/tex" id="MathJax-Element-150">\sqrt[3]{x}</script>.</p><p>The final complexity will be <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-786"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-787">O</span><span class="MJXp-mo" id="MJXp-Span-788" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-789">N</span><span class="MJXp-mi" id="MJXp-Span-790">log</span><span class="MJXp-mo" id="MJXp-Span-791" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-792">N</span><span class="MJXp-mo" id="MJXp-Span-793" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-794">N</span><span class="MJXp-mroot" id="MJXp-Span-795"><span class="MJXp-script" style="margin-right: -0.67em; vertical-align: 0.854em; margin-left: 0.27em;"><span class="MJXp-mn" id="MJXp-Span-797">3</span></span><span><span class="MJXp-surd"><span style="font-size: 134%; margin-top: 0.104em;">√</span></span><span class="MJXp-root"><span class="MJXp-rule" style="border-top: 0.08em solid;"></span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-796">N</span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-798" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-151">O(N \log N + N \sqrt[3]{N})</script>.</p></div></div> <div class="spoiler"><b class="spoiler-title">Code (C++) (Jteh)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">

</span><span class="com">#define</span><span class="pln"> pb push_back 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> mxN </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2e5</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">

vector</span><span class="str">&lt;int&gt;</span><span class="pln"> divs</span><span class="pun">[</span><span class="pln">mxN</span><span class="pun">];</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> pre</span><span class="pun">(){</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">mxN</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><span class="pln">
        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;</span><span class="pln">mxN</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">+=</span><span class="pln">i</span><span class="pun">)</span><span class="pln">divs</span><span class="pun">[</span><span class="pln">j</span><span class="pun">].</span><span class="pln">pb</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">(){</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    cin</span><span class="pun">&gt;&gt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> a</span><span class="pun">(</span><span class="pln">n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">),</span><span class="pln"> cnt</span><span class="pun">(</span><span class="pln">n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">),</span><span class="pln"> max_nums</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;bool&gt;</span><span class="pln"> vis</span><span class="pun">(</span><span class="pln">n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;=</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">cin</span><span class="pun">&gt;&gt;</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">

    </span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;=</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
        vector</span><span class="str">&lt;int&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">num </span><span class="pun">:</span><span class="pln"> divs</span><span class="pun">[</span><span class="pln">x</span><span class="pun">]){</span><span class="pln">
            cnt</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]++;</span><span class="pln">
            </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">cnt</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> i</span><span class="pun">)</span><span class="pln">ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> cnt</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]);</span><span class="pln">
            </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln">vis</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]){</span><span class="pln">
                </span><span class="kwd">next</span><span class="pun">.</span><span class="pln">pb</span><span class="pun">(</span><span class="pln">num</span><span class="pun">);</span><span class="pln">
                vis</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">num </span><span class="pun">:</span><span class="pln"> max_nums</span><span class="pun">){</span><span class="pln">
            </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">cnt</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> i</span><span class="pun">){</span><span class="pln">
                ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> cnt</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]);</span><span class="pln">
                vis</span><span class="pun">[</span><span class="pln">num</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
            </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">.</span><span class="pln">pb</span><span class="pun">(</span><span class="pln">num</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        max_nums </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">;</span><span class="pln">
        cout</span><span class="pun">&lt;&lt;</span><span class="pln">ans</span><span class="pun">&lt;&lt;</span><span class="str">" \n"</span><span class="pun">[</span><span class="pln">i </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">];</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(){</span><span class="pln">
    ios_base</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="kwd">nullptr</span><span class="pun">);</span><span class="pln">

    </span><span class="com">#ifndef</span><span class="pln"> ONLINE_JUDGE
        freopen</span><span class="pun">(</span><span class="str">"input.txt"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"r"</span><span class="pun">,</span><span class="pln"> stdin</span><span class="pun">);</span><span class="pln">
        freopen</span><span class="pun">(</span><span class="str">"output.txt"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"w"</span><span class="pun">,</span><span class="pln"> stdout</span><span class="pun">);</span><span class="pln">
    </span><span class="com">#endif</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    cin</span><span class="pun">&gt;&gt;</span><span class="pln">t</span><span class="pun">;</span><span class="pln">
    pre</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln">solve</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2148" class="notice" style="text-decoration: none;">Codeforces Round 1050 (Div. 4)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>