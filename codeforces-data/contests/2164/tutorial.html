<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/148126" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><h2>A Sequence Game</h2><p>Idea from <a class="rated-user user-legendary" href="https://codeforces.com/profile/cmk666" title="Legendary Grandmaster cmk666"><span class="legendary-user-first-letter">c</span>mk666</a>, Prepared by <a class="rated-user user-legendary" href="https://codeforces.com/profile/cmk666" title="Legendary Grandmaster cmk666"><span class="legendary-user-first-letter">c</span>mk666</a></p> <div class="spoiler"><b class="spoiler-title">Hint 1</b><div class="spoiler-content" style="display: block;"><p>Think some straightforward necessary conditions. They are also sufficient.</p></div></div> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/A" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164A - Sequence Game</a></h3><div class="ttypography"><div class="problem-statement"><div><p>It is obvious that we cannot obtain any numbers less that $$$\min_{i=1}^n a_i$$$, or greater that $$$\max_{i=1}^n a_i$$$.</p><p>In fact, all other $$$x$$$ can be obtained. One possible construction is, we can pick two distinct indices $$$i$$$ and $$$j$$$ such that $$$a_i \le x$$$ and $$$a_j \ge x$$$. Then every turn, we either pick one number adjacent to $$$a_i$$$ and replace these two numbers with $$$a_i$$$, or pick one number adjacent to $$$a_j$$$ and replace these two numbers with $$$a_j$$$. Eventually only $$$a_i$$$ and $$$a_j$$$ will remain and we can obtain $$$x$$$ by replacing them with $$$x$$$.</p></div></div></div></div></div></div><h2>B Even Modulo Pair</h2><p>Idea from <a class="rated-user user-legendary" href="https://codeforces.com/profile/244mhq" title="Legendary Grandmaster 244mhq"><span class="legendary-user-first-letter">2</span>44mhq</a>, Prepared by <a class="rated-user user-legendary" href="https://codeforces.com/profile/NetSpeed1" title="Legendary Grandmaster NetSpeed1"><span class="legendary-user-first-letter">N</span>etSpeed1</a></p> <div class="spoiler"><b class="spoiler-title">Hint 1</b><div class="spoiler-content" style="display: block;"><p>Consider a brute force solution. What's the actual complexity of it?</p></div></div> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/B" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164B - Even Modulo Pair</a></h3><div class="ttypography"><div class="problem-statement"><div><p>If the sequence contains at least two even numbers, let these two even numbers be $$$x &lt; y$$$. Then $$$y \bmod x$$$ must be even, and we have found a valid solution. </p><p>Otherwise, there is at most one even number in the sequence. We can try taking the modulo of each number in the sequence with this even number to determine whether a solution involving this even number exists. </p><p>Otherwise, the solution can only exist among pairs of odd numbers. Arrange all odd numbers in the sequence in ascending order as $$$b_1, b_2, \cdots, b_m$$$. </p><ul> <li> If $$$b_2 &lt; 2 \cdot b_1$$$, then $$$b_2 \bmod b_1 = b_2 - b_1$$$, which must be even. </li><li> If $$$b_3 &lt; 2 \cdot b_2$$$, then $$$b_3 \bmod b_2 = b_3 - b_2$$$, which must be even. </li><li> $$$\cdots$$$ </li></ul><p>Therefore, if for $$$i = 1, 2, \cdots, k$$$, all $$$b_{i+1} \bmod b_i$$$ are odd, then it must hold that $$$b_2 \ge 2 \cdot b_1$$$, $$$b_3 \ge 2 \cdot b_2$$$, $$$\cdots$$$, meaning $$$b_k \ge 2^{k-1}$$$. </p><p>Thus, if $$$k \ge \log V$$$, we can definitely find a valid solution among the first $$$\log V$$$ numbers using the above method. Otherwise, if $$$k &lt; \log V$$$, we only need to enumerate all pairs with $$$O(k^2)$$$ complexity. </p><p>The time complexity of this approach is $$$O(\sum n \log V)$$$. </p><p>Alternatively, we can directly write a double for-loop to enumerate all pairs and exit immediately once a valid solution is found. It can be proven that the complexity of this approach is the same as the one described above.</p></div></div></div></div></div></div><h2>C Dungeon</h2><p>Idea from <a class="rated-user user-red" href="https://codeforces.com/profile/Link_Cut_qwq" title="Grandmaster Link_Cut_qwq">Link_Cut_qwq</a>, Prepared by <a class="rated-user user-orange" href="https://codeforces.com/profile/Xiaohuba" title="Master Xiaohuba">Xiaohuba</a></p> <div class="spoiler"><b class="spoiler-title">Hint 1</b><div class="spoiler-content" style="display: block;"><p>If you gain a new sword after killing a monster, its damage will be greater or equal than the previous sword.</p></div></div> <div class="spoiler"><b class="spoiler-title">Hint 2</b><div class="spoiler-content" style="display: block;"><p>When will we attempt to kill monsters with <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-msubsup" id="MJXp-Span-2"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3" style="margin-right: 0.05em;">c</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-4" style="vertical-align: -0.4em;">i</span></span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-6">0</span></span></span><script type="math/tex" id="MathJax-Element-1">c_i = 0</script>?</p></div></div> <div class="spoiler"><b class="spoiler-title">Hint 3</b><div class="spoiler-content" style="display: block;"><p>Consider a greedy approach.</p></div></div> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/C" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164C - Dungeon</a></h3><div class="ttypography"><div class="problem-statement"><div><p>We will call "killing monster $$$i$$$ with a certain sword" <span class="tex-font-style-it">operation</span> $$$i$$$, and call the sword with smaller damage "the smaller sword".</p><p><span class="tex-font-style-bf">Lemma 1</span></p><p>It's optimal to attempt to kill monsters with $$$c_i = 0$$$ <span class="tex-font-style-bf">after</span> every attempt to kill monsters with $$$c_i &gt; 0$$$.</p><p><span class="tex-font-style-bf">Proof</span></p><p>Suppose we kill monster $$$j$$$ ($$$c_j = 0$$$) before killing monster $$$k$$$ ($$$c_k &gt; 0$$$). Since we will not gain any swords after killing a monster with $$$c_j = 0$$$, the sword used for killing monster $$$k$$$ must exist before we kill monster $$$j$$$, thus we can defer <span class="tex-font-style-it">operation</span> $$$j$$$ until <span class="tex-font-style-it">operation</span> $$$k$$$. $$$\square$$$</p><p>Next, we will call the process of killing monsters with $$$c_i &gt; 0$$$ <span class="tex-font-style-bf">Stage 1</span>, and the process of killing monsters with $$$c_i = 0$$$ <span class="tex-font-style-bf">Stage 2</span>.</p><p><span class="tex-font-style-bf">Lemma 2</span></p><p>In Stage 1, it's optimal to kill them in increasing order with respect to $$$b_i$$$.</p><p><span class="tex-font-style-bf">Proof</span></p><p>Suppose <span class="tex-font-style-it">operation</span> $$$i$$$ and <span class="tex-font-style-it">operation</span> $$$j$$$ are <span class="tex-font-style-bf">adjacent</span> (i.e. we kill monster $$$j$$$ immediately after killing monster $$$i$$$). If $$$b_i &gt; b_j$$$:</p><ul> <li> If will kill monster $$$j$$$ using the sword gained from killing monster $$$i$$$, then the sword $$$p$$$ used in operation $$$i$$$ should have a damage $$$a_p \ge b_i$$$, thus $$$a_p \ge b_j$$$. Since the damage of the gained new sword will not be less than the damage of the previous one, it is always valid for us to kill monster $$$j$$$ before monster $$$i$$$. </li><li> Otherwise, the two operations are independent and can be freely swapped. </li></ul><p>$$$\square$$$</p><p><span class="tex-font-style-bf">Lemma 3</span></p><p>In stage 1, it's optimal to use the smallest possible sword in <span class="tex-font-style-it">operation</span> $$$i$$$ (i.e. we will choose the sword with the smallest damage greater than $$$b_i$$$).</p><p><span class="tex-font-style-bf">Proof</span></p><p>Suppose in <span class="tex-font-style-it">operation</span> $$$i$$$, two swords with damage $$$x$$$ and $$$y$$$ can be used ($$$b_i \le x &lt; y$$$). </p><p>Denote $$$S_i$$$ as the $$$i$$$-th smallest element in a multiset $$$S$$$. For two multiset $$$S$$$ and $$$T$$$ with the same size, we call $$$S$$$ <span class="tex-font-style-bf">dominates</span> $$$T$$$, if and only if $$$\forall i \in [1,|S|], S_i \ge T_i$$$. </p><p>If we can prove that, the multiset of all swords after we finish <span class="tex-font-style-it">operation</span> $$$i$$$ using the smaller sword, <span class="tex-font-style-bf">dominates</span> that multiset when we use the bigger one, we can prove the correctness of the lemma, since for every subsequent <span class="tex-font-style-it">operation</span> we will have a better or equivalent sword to use.</p><p>This can be proved by some casework. Denote the original multiset of swords as $$$S$$$, the one obtained by choosing the smaller sword as $$$A$$$, and the other one as $$$B$$$. </p><ul> <li> If $$$c_i \le x$$$, then the multiset of all swords won't change no matter which sword we choose, so $$$A$$$ = $$$B$$$. </li><li> Otherwise if $$$x &lt; c_i \le y$$$, then when we choose the smaller sword we will obtain a better multiset (since one element is increased) while the bigger sword do not change the multiset, thus $$$A$$$ dominates $$$B$$$. </li><li> Otherwise, we have $$$c_i &gt; y$$$. Suppose the $$$o$$$ is the largest index which satisfies $$$S_o \le c_i$$$, $$$S_p = x$$$, $$$S_q = y$$$. For $$$j \ge q$$$ and $$$j &lt; p$$$, we have $$$A_j = B_j$$$. For $$$j \in [p, q)$$$, we have $$$A_j = S_{j+1}$$$ and $$$B_j = S_j$$$, so $$$A_j \ge B_j$$$. Thus, $$$A$$$ dominates $$$B$$$. </li></ul><p>$$$\square$$$</p><p><span class="tex-font-style-bf">Lemma 4</span></p><p>In stage 2, the order of monsters to consider does not matter.</p><p><span class="tex-font-style-bf">Proof</span></p><p>It can be proved by the fact that in this stage every sword can be used at most once.</p><p><span class="tex-font-style-bf">Lemma 5</span></p><p>In stage 2, it's also optimal to use the smallest possible sword in an <span class="tex-font-style-it">operation</span>.</p><p><span class="tex-font-style-bf">Proof</span></p><p>This lemma is quite straightforward: since in Stage 2 every sword can be only used once, using a smaller sword will leave a better set of available swords for later <span class="tex-font-style-it">operations</span>. $$$\square$$$</p><p>Using the above lemmas we can implement the following greedy approach:</p><ul> <li> In Stage 1, we use a min heap to maintain all the available swords. Enumerate every monster in an increasing order with respect to $$$b_i$$$: extract the sword with the smallest damage, if its damage is smaller than $$$b_i$$$, pop it and store it for Stage 2, since it cannot be used anymore in Stage 1; otherwise use it to kill monster $$$i$$$, update the damage of it and insert it back to the heap. If the heap is empty, exit this stage immediately. </li><li> In Stage 2, we gather all the current swords. Enumerate all monsters with $$$c_i = 0$$$ in an arbitrary order, and kill it with the smallest possible sword. This can be implemented by using a BST (or <span class="tex-font-style-tt">std::set</span>) or by sorting these monsters and using the two-pointers method. </li></ul><p>The time complexity is $$$O(n \log n)$$$ and the space complexity is $$$O(n)$$$.</p></div></div></div></div></div></div><h2>D Copy String</h2><p>Idea from <a class="rated-user user-legendary" href="https://codeforces.com/profile/JoesSR" title="Legendary Grandmaster JoesSR"><span class="legendary-user-first-letter">J</span>oesSR</a>, Prepared by <a class="rated-user user-legendary" href="https://codeforces.com/profile/JoesSR" title="Legendary Grandmaster JoesSR"><span class="legendary-user-first-letter">J</span>oesSR</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/D" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164D - Copy String</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Suppose we need to determine if we can obtain string $$$t$$$ from string $$$s$$$ in no more than $$$k$$$ operations.</p><p>Let $$$s_i$$$ be the string $$$s$$$ after $$$i$$$ operations. Then $$$s_0=s$$$, and for all $$$i \ge 1$$$, the conditions $$$s_{i,1}=s_{i-1,1}$$$ and $$$\forall 2 \le j \le n, (s_{i,j}=s_{i-1,j} \lor s_{i,j}=s_{i-1,j-1})$$$ must be met. The goal is to make $$$s_k=t$$$.</p><p>It is easy to see that for any $$$1 \le j \le n$$$, there exists some $$$1 \le j' \le n$$$ such that $$$s_{i,j}=s_{0,j'}$$$. Let's denote this mapping as $$$p_{i,j}=j'$$$. Then, necessarily, for all $$$1 \le j \le n$$$, we have $$$p_{0,j}=j$$$. Since each $$$s_{i,j}$$$ will be the same as either $$$s_{i-1,j-1}$$$ or $$$s_{i-1,j}$$$ (if they exist), we can consider that $$$p_{i,j}$$$ must be the same as either $$$p_{i-1,j-1}$$$ or $$$p_{i-1,j}$$$.</p><p>The problem is now equivalent to determining $$$p_i$$$ at each step, with the target objective being $$$\forall 1 \le j \le n, s_{0,p_{k,j}}=t_j$$$.</p><p>It can be easily derived by induction that for all $$$0 \le i \le k$$$, $$$p_i$$$ is a non-decreasing sequence, and for all $$$0 \le i \le k$$$ and $$$1 \le j \le n$$$, we have $$$p_{i,j} \in [\max(1,j-i),j]$$$.</p><p><span class="tex-font-style-bf">Key observation:</span> If there exists a $$$p_k$$$ that satisfies the above conditions and achieves the target objective, then it is possible to obtain $$$t$$$ from $$$s$$$ in $$$k$$$ operations.</p><p>We use mathematical induction. When $$$k=0$$$, the claim is obviously true. For the case $$$k&gt;0$$$, we directly construct $$$s_1$$$ based on $$$s_0$$$ and show that we can obtain $$$t$$$ from $$$s_1$$$ in at most $$$k-1$$$ operations.</p><p>Construction: If $$$p_{k,i}=i$$$, let $$$s_{1,i}=s_{0,i}$$$. Otherwise, let $$$s_{1,i}=s_{0,i-1}$$$.</p><p>According to the induction hypothesis, we only need to construct a sequence $$$q$$$ that is non-decreasing, satisfies $$$\forall 1 \le j \le n, s_{1,q_j}=t_j$$$, and $$$\forall 1 \le j \le n, q_j \in [\max(1,j-(k-1)),j]$$$ to show that $$$t$$$ can be obtained from $$$s_1$$$ in at most $$$k-1$$$ operations.</p><p>Based on $$$p_k$$$, we can construct a suitable $$$q$$$. Consider any $$$1 \le j \le n$$$:</p><ul> <li> If $$$p_{k,j}=j$$$, then $$$s_{1,j}=s_{0,j}$$$. We can simply set $$$q_j=j$$$. </li><li> If $$$p_{k,j}&lt;j$$$, because $$$p_k$$$ is a non-decreasing sequence and $$$p_{k,i} \le i$$$ for any $$$i$$$, it must be that $$$p_{k,p_{k,j}+1} \le p_{k,j}$$$. This implies $$$p_{k,p_{k,j}+1} &lt; p_{k,j}+1$$$. By our construction rule for $$$s_1$$$, it follows that $$$s_{1,p_{k,j}+1} = s_{0,p_{k,j}}$$$. We can therefore set $$$q_j=p_{k,j}+1$$$. </li></ul><p>This construction naturally shows that $$$q$$$ satisfies the condition of matching $$$t$$$, as well as the condition $$$q_j \ge j-(k-1)$$$. As for the non-decreasing condition on $$$q$$$, $$$q$$$ is equivalent to copying $$$p$$$ and incrementing its value by 1 at every position $$$j$$$ where $$$p_j &lt; j$$$. Since $$$p$$$ is non-decreasing, it is easy to see that $$$q$$$ is also non-decreasing.</p><p>Thus, by mathematical induction, the key observation is proven. At the same time, this construction allows us to transform a $$$k$$$-step problem into a $$$(k-1)$$$-step subproblem.</p><p>Finally, we can use a greedy algorithm for a fixed pair of $$$s,t$$$ to determine if a valid $$$p_k$$$ exists: iterate through $$$j$$$ in increasing order, and for each $$$p_{k,j}$$$, pick the smallest value that does not violate any constraints. The time complexity of the greedy algorithm is $$$\Theta(n)$$$.</p><p>Our final algorithm is: iterate through $$$k$$$ from $$$0$$$ to $$$k_{max}$$$. For each $$$k$$$, use the greedy algorithm to check if a valid $$$p_k$$$ exists. If none exist for any $$$k$$$, output -1. After finding the smallest $$$k$$$ for which a $$$p_k$$$ exists, initialize $$$q=p_k$$$ and repeat the following operation $$$k$$$ times: in the $$$i$$$-th round, construct $$$s_i$$$ from $$$s_{i-1}$$$ based on $$$q$$$, and then update $$$q$$$ by adding 1 to all its values at indices where the value is less than the index.</p><p>Total time complexity: $$$\Theta(nk_{max})$$$.</p></div></div></div></div></div></div><h2>E Journey</h2><p>Idea from <a class="rated-user user-red" href="https://codeforces.com/profile/Link_Cut_qwq" title="Grandmaster Link_Cut_qwq">Link_Cut_qwq</a>, Prepared by <a class="rated-user user-orange" href="https://codeforces.com/profile/Xiaohuba" title="Master Xiaohuba">Xiaohuba</a></p> <div class="spoiler"><b class="spoiler-title">Hint 1</b><div class="spoiler-content" style="display: block;"><p>Consider when we do not need <em>transferring</em>.</p></div></div> <div class="spoiler"><b class="spoiler-title">Hint 2</b><div class="spoiler-content" style="display: block;"><p>How to calculate the minimum cost when <em>transferring</em> between two vertices?</p></div></div> <div class="spoiler"><b class="spoiler-title">Hint 3</b><div class="spoiler-content" style="display: block;"><p>Come up with a greedy approach.</p></div></div> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/E" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164E - Journey</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Since we need to <span class="tex-font-style-it">mark</span> every edge at least once, the minimum cost is $$$\sum_{i=1}^m w_i$$$. In fact, if the graph has an Eulerian circuit (i.e. every vertex has an even degree), this minimum cost can be achieved by simply traversing on such a circuit. Otherwise, we can imagine we add some "virtual" edges to this graph, where the cost of such an edge is the minimum cost of transferring between its two endpoints. It's not hard to show that we only need to pair up all the vertices with odd degree and add exactly one "virtual" edge between each pair, which is optimal. Further, we only need to calculate the minimum cost of adding those "virtual" edges.</p><p>Consider how to effectively calculate the cost of <span class="tex-font-style-it">transferring</span>. Build a reconstruction-tree $$$T$$$ of G, where edges $$$1 \ldots m$$$ are added in this order.</p><p>Suppose we want to transfer to $$$v$$$ from $$$u$$$. If the LCA of $$$u$$$ and $$$v$$$ is $$$o$$$, then the edge with the maximum index on every possible path from $$$u$$$ to $$$v$$$ should be $$$o$$$, or one of the ancestors of $$$o$$$. This is because of the basic properties of a reconstruction tree.</p><p>So for every vertex $$$i$$$ on $$$T$$$ which is not a leaf (i.e. it represents an edge in the original graph), precompute the minimum weight, $$$f_i$$$, among every edge that is $$$i$$$ or $$$i$$$'s ancestor. Now we have $$$f_i \le f_{fa_i}$$$, which means it is optimal to pair up two vertices in the same subtree $$$p$$$ with cost $$$f_p$$$ as soon as possible. </p><p>In particular, perform a depth-first search on the tree. For every vertex $$$x$$$, enumerate its every child $$$y$$$ and recursively determine whether a leave (i.e. it represents a vertex in the original graph) in the subtree of $$$y$$$ with odd degree (in the original graph) remains unmatched. Match these vertices using cost $$$f_x$$$ immediately when possible. In the end at most one leaf (with odd degree) in the subtree of $$$x$$$ will remain unmatched when we leave $$$x$$$.</p><p>Implement this greedy approach and you will pass this problem. Time complexity is $$$O(n \alpha(n))$$$ (since we need union find when building the reconstruction-tree) and space complexity is $$$O(n)$$$.</p></div></div></div></div></div></div><h2>F1/F2 Chain Prefix Rank</h2><p>Idea from <a class="rated-user user-legendary" href="https://codeforces.com/profile/JoesSR" title="Legendary Grandmaster JoesSR"><span class="legendary-user-first-letter">J</span>oesSR</a>, Prepared by <a class="rated-user user-legendary" href="https://codeforces.com/profile/JoesSR" title="Legendary Grandmaster JoesSR"><span class="legendary-user-first-letter">J</span>oesSR</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/F2" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164F2 - Chain Prefix Rank (Hard Version)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>First, if there exists a node $$$u$$$ such that $$$a_u \ge dep_u$$$, where $$$dep_u$$$ is the depth of $$$u$$$ (with the root's depth being $$$1$$$), then the number of valid permutations is clearly $$$0$$$. The problem guarantees that at least one valid permutation exists, so it must be that for all $$$1 \le u \le n$$$, we have $$$a_u &lt; dep_u$$$.</p><p>We add two more nodes above node $$$1$$$, which we will call $$$0$$$ and $$$n+1$$$. Specifically, we set $$$fa_1=n+1$$$ and $$$fa_{n+1}=0$$$, making $$$0$$$ the-root of this new tree with $$$n+2$$$ nodes. We define $$$a_0=0, a_{n+1}=1$$$ and increment all $$$a_u$$$ values by $$$1$$$ for all $$$1 \le u \le n$$$. For this $$$n+2$$$ node problem, we can see that its answer is identical to the original problem's. This is because the transformation is equivalent to constraining $$$p_0$$$ to be the minimum value and $$$p_{n+1}$$$ to be the maximum.</p><p>For all $$$0 \le u \le n+1$$$, the relative order of the $$$p$$$ values for all nodes on the path from $$$u$$$ to the root $$$0$$$ is completely determined. We can prove this by induction. The base cases $$$u=0$$$ and $$$u=n+1$$$ are clearly true. For the inductive step, if the relative order of the $$$p$$$ values for all nodes on the path from $$$fa_u$$$ to the root is determined—for example, let the nodes sorted by their $$$p$$$ values be $$$0=s_1, s_2, \dots, s_k=n+1$$$—then considering the definition of $$$a_u$$$, the relative order of $$$p$$$ values for all nodes on the path from $$$u$$$ to the root must be $$$0=s_1, s_2, \dots, s_{a_u}, u, s_{a_{u}+1}, \dots, s_k=n+1$$$.</p><p>Let's consider how to better describe the constraint "on the path from $$$u$$$ to the root, there are $$$a_u$$$ nodes whose $$$p$$$ value is smaller than $$$p_u$$$". In fact, we can find that if we have already described these constraints for all ancestors $$$v$$$ of $$$u$$$, then simply adding the two constraints $$$p_{s_{a_u}} &lt; p_u$$$ and $$$p_u &lt; p_{s_{a_{u+1}}}$$$ is sufficient.</p><p>Thus, the problem can be viewed as counting the number of topological sorts of a special directed graph. Initially, we can consider the tree to have only two nodes, $$$0$$$ and $$$n+1$$$. The corresponding directed graph has only one directed edge $$$0 \to n+1$$$ (corresponding to the constraint $$$p_0 &lt; p_{n+1}$$$). Each time we attach a new node $$$u$$$ to an existing node $$$v$$$ in the tree, we determine the relative order of $$$p$$$ values for all nodes on the path from $$$u$$$ to the root as described above. Let the node that must precede $$$u$$$ in the permutation on this path be $$$s$$$, and the node that must succeed it be $$$t$$$. It can be shown that the edge $$$s \to t$$$ must already exist in the new graph (this conclusion can be proved by applying mathematical induction to this construction process). At this point, we need to add two new edges: $$$s \to u$$$ and $$$u \to t$$$.</p><p>This is a special type of generalized series-parallel graph, which can be reduced to a single directed edge by applying a 2-degree node reduction operation. Specifically, this operation consists of selecting a node $$$u$$$ that has exactly one incoming edge from a node $$$s$$$ and exactly one outgoing edge to a node $$$t$$$, and where an edge $$$s \to t$$$ also exists. We then delete the node $$$u$$$. This is precisely the reverse of the process used to construct the graph.</p><p>After performing this operation multiple times, each edge $$$s \to t$$$ will represent a certain subgraph of the original graph. All nodes within this subgraph are indirectly reachable from $$$s$$$ and must therefore be placed after $$$s$$$ in the topological sort. Similarly, all nodes in this subgraph can indirectly reach $$$t$$$, so they must be placed before $$$t$$$ in the topological sort. We can record the number of topological sorts for this subgraph as $$$dp_{(s,t)}$$$ and the number of nodes in this subgraph as $$$val_{(s,t)}$$$.</p><p>Initially, all edges in the original graph satisfy $$$dp_{(s,t)}=1$$$ and $$$val_{(s,t)}=0$$$, because these edges do not yet represent any nodes from the original problem. When we reduce node $$$u$$$ with edges $$$s \to u, u \to t, s \to t$$$, we can see that the nodes in the subgraph corresponding to $$$(s,u)$$$ must be placed before the nodes in the subgraph corresponding to $$$(u,t)$$$ in the topological sort. The nodes in the subgraph for $$$(s,t)$$$ can be arranged independently of the nodes in the subgraphs for $$$(s,u)$$$ and $$$(u,t)$$$. Therefore, after deleting $$$u$$$, we can update $$$dp_{(s,t)}$$$ and $$$val_{(s,t)}$$$ as follows: $$$$$$dp_{(s,t)} \leftarrow dp_{(s,t)} \cdot dp_{(s,u)} \cdot dp_{(u,t)} \cdot \binom{val_{(s,t)}+val_{(s,u)}+val_{(u,t)}+1}{val_{(s,t)}}$$$$$$ $$$$$$val_{(s,t)} \leftarrow val_{(s,t)}+val_{(s,u)}+val_{(u,t)}+1$$$$$$ This is because we have additionally removed the node $$$u$$$.</p><p>When the graph is finally reduced to the single edge $$$0 \to n+1$$$, its $$$dp_{(0,n+1)}$$$ value will be the answer to the original problem.</p><p>After the graph is constructed, the process of repeatedly deleting nodes and maintaining $$$dp$$$ and $$$val$$$ can easily be completed in $$$\Theta(n \log n)$$$ time.</p><p>Finally, regarding the graph construction process: finding the sorted sequence of nodes by their $$$p$$$ values on the path from $$$u$$$ to the root is equivalent to inserting $$$u$$$ after the $$$a_u$$$-th element in the sorted sequence for the path from $$$fa_u$$$ to the root. This also requires querying for the two values that are now adjacent to $$$u$$$. After performing a DFS on the tree, this becomes a problem of maintaining a sequence that supports inserting/deleting a number at a specific position and querying the $$$k$$$-th number in the sequence. A brute-force insertion can yield an algorithm with $$$\Theta(n^2)$$$ time complexity. Using any balanced binary search tree can achieve a time complexity of $$$\Theta(n \log n)$$$.</p><p>Other algorithms with a time complexity of $$$\Theta(n^2)$$$ also exist, all of which can pass subtask F1. Some of these can be optimized to $$$\Theta(n \log n)$$$ to pass subtask F2, while others may be more difficult to optimize.</p></div></div></div></div></div></div><h2>G Pointless Machine</h2><p>Idea from <a class="rated-user user-red" href="https://codeforces.com/profile/Daniel777" title="International Grandmaster Daniel777">Daniel777</a>, Prepared by <a class="rated-user user-legendary" href="https://codeforces.com/profile/zjy2008" title="Legendary Grandmaster zjy2008"><span class="legendary-user-first-letter">z</span>jy2008</a></p> <div class="spoiler"><b class="spoiler-title">Hint 1</b><div class="spoiler-content" style="display: block;"><p>We can know the degree of each vertex within two queries.</p></div></div> <div class="spoiler"><b class="spoiler-title">Hint 2</b><div class="spoiler-content" style="display: block;"><p>First come up with an solution that require <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mn" id="MJXp-Span-8">2</span><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0em; margin-right: 0em;">⌈</span><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi" id="MJXp-Span-11" style="margin-right: 0.05em;">log</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">n</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0em; margin-right: 0em;">⌉</span><span class="MJXp-mo" id="MJXp-Span-18" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-19">1</span></span></span><script type="math/tex" id="MathJax-Element-2">2\lceil\log_2(n)\rceil+1</script> queries.</p></div></div> <div class="spoiler"><b class="spoiler-title">Hint 3</b><div class="spoiler-content" style="display: block;"><p>Partition the vertex to 3 groups instead of 2.</p></div></div> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/G" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164G - Pointless Machine</a></h3><div class="ttypography"><div class="problem-statement"><div><p>By taking the difference of the query results, we can obtain for each node the number of edges connecting it to the nodes that appeared before it in the sequence.</p><p>We find that by querying a permutation of the nodes and then querying its reverse, we can obtain the degree of every node in the tree. Once the degrees are known, we can consider performing a topological sort. The problem then becomes how to find the parent of a leaf node.</p><p>Convert the ID of each node to binary. For each bit position $$$i$$$, partition the nodes $$$1,2,\dots,n$$$ into a subsequence $$$a_1,a_2,\dots,a_m$$$ of nodes whose $$$i$$$-th bit is 0, and a subsequence $$$b_1,b_2,\dots,b_k$$$ of nodes whose $$$i$$$-th bit is 1. Then, make two queries with the sequences $$$a_1,a_2,\dots,a_m,b_1,b_2,\dots,b_k$$$ and $$$b_1,b_2,\dots,b_k,a_1,a_2,\dots,a_m$$$. For each node $$$u$$$, by taking the absolute difference of the number of preceding edges returned from the two queries, we can find the number of nodes adjacent to $$$u$$$ that have a different $$$i$$$-th bit. Let's denote this count by $$$f_{u,i}$$$. After repeating this for every bit position, when we remove a leaf node $$$x$$$ during our topological sort, we can use the values $$$f_{x,i}$$$ to determine the value of the $$$i$$$-th bit of its parent's ID, thereby identifying the parent node $$$y$$$. We then update the degree of $$$y$$$ and the values of $$$f_{y,i}$$$.</p><p>Since obtaining the degrees only requires one sequence and its reverse, we only need one additional query on top of the ones for bit partitioning. The total number of operations is $$$2\lceil\log_2n\rceil + 1$$$, which is $$$33$$$ when $$$n = 5\times 10^4$$$.</p><p>Consider extending the binary partition method to a ternary one. For each trit (ternary digit) position $$$i$$$, partition the nodes into three subsequences, $$$a_1,a_2,\dots,a_{len_1}$$$, $$$b_1,b_2,\dots,b_{len_2}$$$, and $$$c_1,c_2,\dots,c_{len_3}$$$, based on whether their $$$i$$$-th trit is 0, 1, or 2. Then, perform three queries with the concatenated sequences $$$(a,b,c)$$$, $$$(b,c,a)$$$, and $$$(c,a,b)$$$. For any given node, this allows us to find the number of its neighbors whose $$$i$$$-th trit is 0, 1, and 2, respectively. The rest of the procedure is the same as above. The number of operations becomes $$$3\lceil\log_3n\rceil + 1$$$, which is $$$31$$$ for $$$n = 5\times 10^4$$$.</p></div></div></div></div></div></div><h2>H PalindromePalindrome</h2><p>Idea from <a class="rated-user user-legendary" href="https://codeforces.com/profile/zjy2008" title="Legendary Grandmaster zjy2008"><span class="legendary-user-first-letter">z</span>jy2008</a>, Prepared by <a class="rated-user user-legendary" href="https://codeforces.com/profile/zjy2008" title="Legendary Grandmaster zjy2008"><span class="legendary-user-first-letter">z</span>jy2008</a></p><p><strong>UPD: Unfortunately, the original analysis regarding the number of "relevant" pairs of disjoint substrings was incorrect. The proof was derived from an online blog concerning the range distinct palindrome substring query problem, but that proof turned out to be flawed. Consequently, we previously believed the complexity of the standard solution to be <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">O</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">n</span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">q</span><span class="MJXp-mo" id="MJXp-Span-27" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi" id="MJXp-Span-28">log</span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">n</span><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax MathJax_Processed" id="MathJax-Element-3-Frame" tabindex="0" style=""><nobr><span class="math" id="MathJax-Span-22"><span style="display: inline-block; position: relative; width: 0em; height: 0px; font-size: 132%;"><span style="position: absolute;"><span class="mrow" id="MathJax-Span-23"><span class="mi" id="MathJax-Span-24" style="font-family: MathJax_Math-italic;">O</span><span class="mo" id="MathJax-Span-25" style="font-family: MathJax_Main;">(</span><span class="mo" id="MathJax-Span-26" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-27" style="font-family: MathJax_Math-italic;">n</span><span class="mo" id="MathJax-Span-28" style="font-family: MathJax_Main; padding-left: 0.219em;">+</span><span class="mi" id="MathJax-Span-29" style="font-family: MathJax_Math-italic; padding-left: 0.219em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-30" style="font-family: MathJax_Main;">)</span><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Main; padding-left: 0.165em;">log</span><span class="mo" id="MathJax-Span-32"></span><span class="mi" id="MathJax-Span-33" style="font-family: MathJax_Math-italic; padding-left: 0.165em;">n</span><span class="mo" id="MathJax-Span-34" style="font-family: MathJax_Main;">)</span></span></span></span></span></nobr></span><script type="math/tex" id="MathJax-Element-3">O((n + q) \log n)</script>; however, after the contest, we discovered that it is actually <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi" id="MJXp-Span-33">Θ</span><span class="MJXp-mo" id="MJXp-Span-34" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">n</span><span class="MJXp-msubsup" id="MJXp-Span-36"><span class="MJXp-mi" id="MJXp-Span-37" style="margin-right: 0.05em;">log</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-38" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">q</span><span class="MJXp-mi" id="MJXp-Span-43">log</span><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">n</span><span class="MJXp-mo" id="MJXp-Span-46" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax MathJax_Processed" id="MathJax-Element-4-Frame" tabindex="0" style=""><nobr><span class="math" id="MathJax-Span-35"><span style="display: inline-block; position: relative; width: 0em; height: 0px; font-size: 132%;"><span style="position: absolute;"><span class="mrow" id="MathJax-Span-36"><span class="mi" id="MathJax-Span-37" style="font-family: MathJax_Main;">Θ</span><span class="mo" id="MathJax-Span-38" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-39" style="font-family: MathJax_Math-italic;">n</span><span class="msubsup" id="MathJax-Span-40" style="padding-left: 0.165em;"><span style="display: inline-block; position: relative; width: 1.734em; height: 0px;"><span style="position: absolute; clip: rect(3.141em, 1001.25em, 4.386em, -999.997em); top: -4.002em; left: 0em;"><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Main;">log</span><span style="display: inline-block; width: 0px; height: 4.007em;"></span></span><span style="position: absolute; top: -4.435em; left: 1.301em;"><span class="mn" id="MathJax-Span-42" style="font-size: 70.7%; font-family: MathJax_Main;">2</span><span style="display: inline-block; width: 0px; height: 4.007em;"></span></span></span></span><span class="mo" id="MathJax-Span-43"></span><span class="mi" id="MathJax-Span-44" style="font-family: MathJax_Math-italic; padding-left: 0.165em;">n</span><span class="mo" id="MathJax-Span-45" style="font-family: MathJax_Main; padding-left: 0.219em;">+</span><span class="mi" id="MathJax-Span-46" style="font-family: MathJax_Math-italic; padding-left: 0.219em;">q<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-47" style="font-family: MathJax_Main; padding-left: 0.165em;">log</span><span class="mo" id="MathJax-Span-48"></span><span class="mi" id="MathJax-Span-49" style="font-family: MathJax_Math-italic; padding-left: 0.165em;">n</span><span class="mo" id="MathJax-Span-50" style="font-family: MathJax_Main;">)</span></span></span></span></span></nobr></span><script type="math/tex" id="MathJax-Element-4">\Theta(n \log^2 n + q \log n)</script> (and this lower bound is reachable). We apologize for any confusion caused.</strong></p> <div class="spoiler"><b class="spoiler-title">Hint 1</b><div class="spoiler-content" style="display: block;"><p>Consider classifying the cases based on the relative positions of two palindromic substrings.</p></div></div> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2164/problem/H" title="Codeforces Global Round 30 (Div. 1 + Div. 2)">2164H - PalindromePalindrome</a></h3><div class="ttypography"><div class="problem-statement"><div><p><span class="tex-font-style-bf">Part 1: Intersecting Palindromes</span></p><p>If the index ranges of two palindromes, $$$S[l_1, r_1]$$$ and $$$S[l_2, r_2]$$$, intersect (e.g., $$$l_1 \le l_2 \le r_1 \le r_2$$$), and both strings are palindromes, then they must be a <span class="tex-font-style-it">border</span> of the encompassing string $$$S[l_1, r_2]$$$, and this encompassing string is also a palindrome. Consequently, we only need to account for the longest border of all possible strings $$$S[l_1, r_2]$$$ with $$$l \le l_1 \le r_2 \le r$$$ to add to our answer.</p><p>Consider the following fact: for a string $$$S[l,r]$$$, let $$$S[l, l']$$$ be its longest palindromic prefix and $$$S[r', r]$$$ be its longest palindromic suffix. We only need to consider the following 3 cases:</p><ul> <li> Palindromes $$$S[l_1,r_2]$$$ whose centers lie between the centers of $$$S[l,l']$$$ and $$$S[r',r]$$$, i.e., between $$$(\dfrac{l+l'}2, \dfrac{r'+r}2)$$$. </li><li> All palindromes $$$S[l_1,r_2]$$$ that are fully contained within $$$S[l,l']$$$. </li><li> All palindromes $$$S[l_1,r_2]$$$ that are fully contained within $$$S[r',r]$$$. </li></ul><p>We can obtain all the necessary information by preprocessing with a <span class="tex-font-style-it">Palindromic Automaton (PAM)</span> and the <span class="tex-font-style-it">Manacher's algorithm</span>.</p><p><span class="tex-font-style-bf">Part 2: Disjoint Palindromes</span></p><p>If two palindromic substrings have disjoint indices, we can prove that there are only $$$O(n \log n)$$$ such pairs that are "relevant" to the problem.</p><p>Let's use a scanline approach, iterating $$$r$$$ from $$$1$$$ to $$$n$$$. The palindromic suffixes of the prefix $$$S[1, r]$$$ can be partitioned into a few maximal sequences of palindromes whose lengths form an arithmetic progression. These sequences have the form:</p><p>$$$A, BA, BBA, BBBA, \ldots$$$ where $$$B=AC$$$, and $$$A$$$ and $$$C$$$ are palindromes.</p><p>Let $$$B^k$$$ denote string $$$B$$$ concatenated $$$k$$$ times. Since $$$B^kA$$$ is a border of $$$B^{k+1}A$$$, any pair of palindromes from the same arithmetic progression will overlap. Their contribution is already handled in Part 1. Therefore, for each such sequence, we only need to consider the contribution of pairs involving the first and the last string. $$$\square$$$</p><p>In summary, this problem can be solved in $$$O(n \log^2 n + q\log n)$$$ time complexity.</p></div></div></div></div></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2164" class="notice" style="text-decoration: none;">Codeforces Global Round 30 (Div. 1 + Div. 2)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>