<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/149003" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><p>The harder 4 problems are from the Yandex Cup Finals.</p> <div><h3><a href="https://codeforces.com/contest/2175/problem/A" title="Codeforces Round 1069 (Div. 2)">2175A - Little Fairy's Painting</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let's first find out the color of the $$$(n+1)$$$-st cell. As per the statement, it is the number of distinct elements in the given array $$$a$$$. We can compute that by directly, or by sorting the array, or using a set. Let this number of $$$d$$$, it is the color of the $$$(n + 1)$$$-st cell.</p><p>What happens next? If this color is already in the array, then nothing changes, and each next color will be $$$d$$$. If $$$d$$$ was not present in the array initially, then it's a new color, and the color of the $$$(n + 2)$$$-nd cell becomes $$$d + 1$$$, then $$$d + 2$$$, and so on, until it coincides with an existing color. At that point, the number of distinct colors does not increase, and all further cells will be colored in the same color. This will always happen at some point, because $$$\max(a) \ge \operatorname{distinct}(a)$$$.</p><p>Thus, the answer is the smallest number present in the original array that is greater than or equal to the number of distinct colors.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2175/problem/B" title="Codeforces Round 1069 (Div. 2)">2175B - XOR Array</a></h3><div class="ttypography"><div class="problem-statement"><div><p>When talking about XOR of a subsegment, it's usually useful to think about prefix XORs. Then, if $$$b_i = a_1 \oplus a_2 \oplus \ldots \oplus a_i$$$ is the array or prefix XORs, the subsegment XOR $$$f$$$ is simply $$$f(x, y) = b_y \oplus b_{x-1}$$$. That means, for $$$f(l, r)$$$ to be zero, $$$b_{l - 1}$$$ has to be equal to $$$b_r$$$, while all other values of $$$b$$$ should be distinct. The easiest construction is then $$$b_i = i$$$, with the exception that $$$b_r = l - 1$$$. The array $$$a$$$ can be then reconstructed as $$$a_i = b_i \oplus b_{i - 1}$$$.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2174/problem/A" title="Codeforces Round 1069 (Div. 1)">2174A - Иголка в стоге сена</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let's first extract from $$$t$$$ all letters that are needed to build $$$s$$$, and sort all the others to get the string $$$t'$$$. If there are not enough letters to build $$$s$$$, the answer is <span class="tex-font-style-tt">Impossible</span>.</p><p>Then, it turns out that the greedy algorithm works: we can simply build the resulting string letter by letter, each time taking the smallest of the first letter s from $$$s$$$ and $$$t'$$$, and preferring taking from $$$s$$$ if they are equal. In other words, this is the standard "merge" algorithm, even though $$$s$$$ is not sorted.</p><p>The proof is as follows. Consider one step, let $$$x$$$ be the front letter in $$$s$$$, and $$$y$$$ be the front letter in $$$t'$$$. $$$$$$ \begin{align} s &amp;= \mathrm{x...}, \\ t' &amp;= \mathrm{y...}. \end{align} $$$$$$ If $$$x \ne y$$$, it's obvious why our algorithm works: it's clear that we can always finish the resulting string no matter what we take, and thus we can follow the greedy algorithm to obtain the lexmin answer. If $$$x = y$$$, we have to look at the first position where the remaining parts of $$$s$$$ and $$$t'$$$ differ, let the corresponding letters be $$$z$$$ and $$$w$$$: $$$$$$ \begin{align} s &amp;= \mathrm{xxxxz...}, \\ t' &amp;= \mathrm{xxxxw...}. \end{align} $$$$$$ </p><ul> <li> If both are greater than $$$x$$$, then it does not matter from which string to take, as we'll take all letters equal to $$$x$$$ prior to both $$$z$$$ and $$$w$$$. </li><li> If $$$z &lt; x &lt;= w$$$, then it's better to take from $$$s$$$, as we'll reach the smaller letter earlier. </li><li> $$$w &lt; x$$$ can't be, because $$$t'$$$ is sorted. </li></ul> This ends the proof.</div></div></div></div> <div class="problemTutorial" problemcode="2174B">Tutorial is loading...</div> <div><h3><a href="https://codeforces.com/contest/2174/problem/C2" title="Codeforces Round 1069 (Div. 1)">2174C2 - Красивые узоры (сложная версия)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>We need to calculate $$$\mathbb{E}[f^2]$$$. Let's see what $$$f$$$ is — it is the number of non-empty palindromic substrings, that is, $$$f = \sum x_{l,r}$$$ over all non-empty substrings $$$[l,r]$$$, where $$$x_{l,r}$$$ is an indicator variable that corresponds to the substring $$$[l,r]$$$ being a palindrome.</p><p>Thus, $$$\mathbb{E}[f^2] = \mathbb{E}[\sum^2 x_{l,r}] = \mathbb{E}[\sum x_{l,r}^2 + 2\sum x_{l_1,r_1} \cdot x_{l_2,r_2}] = \mathbb{E}[\sum x_{l,r}] + 2\mathbb{E}[\sum x_{l_1,r_1} \cdot x_{l_2,r_2}]$$$. Next, we need to learn how to calculate $$$\mathbb{E}[x_{l,r}]$$$. The probability that a string of length $$$s$$$ is a palindrome is the probability that the first $$$(s+1)/2$$$ letters are arbitrary, while the rest are determined (that is, $$${\frac {m^{(s+1)/2}}{m^s}}$$$).</p><p>Now we need to calculate $$$\mathbb{E}[x_{l_1,r_1} \cdot x_{l_2,r_2}]$$$, which is the probability that both substrings are palindromes simultaneously. If they are concentric (have the same center and parity), then the answer is also obvious — it is simply the probability for the longer of the two strings. If they are not concentric, it is claimed$$$^*$$$ that the events "substring is a palindrome" are independent for these two strings. Therefore, $$$\mathbb{E}[x_{l_1,r_1} \cdot x_{l_2,r_2}] = \frac{m^{(s_1 + 1)/2 + (s_2 + 1)/2}}{m^{s_1 + s_2}}$$$.</p><p>Thus, we need to separately analyze the cases when the substrings have the same centers and when they do not. Then the solution for the fourth degree can be written obviously (by iterating through all pairs of substrings). To obtain a solution that passes the first subtask, it is sufficient to optimize the enumeration somehow. For example, for the case of concentric strings, we can iterate only over the length of the longer string, and for the case of non-concentric strings, we can iterate over their lengths and multiply the probability by the number of pairs of non-concentric substrings with those lengths. This results in a solution with a complexity of $$$O(n^2)$$$.</p><p>To achieve a solution with a complexity of $$$O(n)$$$, it is sufficient to notice the following: when we calculate the answer for non-concentric substrings, we compute $$$\sum 1/m^{s_1 - (s_1 + 1) / 2 + s_2 - (s_2 + 1) / 2}=\sum m ^ {-(s_1/2 + s_2/2)}$$$. If we fix the parities of $$$s_1$$$ and $$$s_2$$$, it will be enough to iterate simply over $$$s = s_1 + s_2$$$ and multiply $$$m ^ {-(s/2 - flag)} $$$ by the number of pairs of non-concentric substrings with a total length of $$$s$$$, where $$$flag$$$ is equal to one if and only if both strings have an odd length.</p><p>It remains to prove *: if the strings do not intersect, then the statement is obvious. Let them intersect and the length of the intersection be $$$len$$$. Any point in the intersection subsegment has two symmetric points: one relative to the center of the first string, and the other relative to the center of the second. Moreover, these points are always distinct because the strings are not concentric; furthermore, all such pairs of points do not intersect with each other. Thus, if we have assigned $$$(s_1 + 1)/2$$$ symbols in the first string arbitrarily, then in the second we can only choose $$$(s_2 + 1)/2 - len$$$, because $$$len$$$ symbols are already automatically determined. Therefore, the probability for these two strings will be equal to $$$ \frac{m^{(s_1 + 1)/2 + (s_2 + 1)/2 - len}}{m^{s_1 + s_2 - len}} = \frac{m^{(s_1 + 1)/2 + (s_2 + 1)/2}}{m^{s_1 + s_2}}$$$ — which is what we needed to prove.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2174/problem/D" title="Codeforces Round 1069 (Div. 1)">2174D - Secret Message</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let's sort the edges by weight and take the first $$$n - 1$$$ of them. In case they already do not form a spanning tree, we are done. Otherwise, they form a spanning tree, let's call it $$$T$$$. Denote the sum of their weights $$$S$$$.</p><p>Let's consider a case when the answer is formed by $$$n - 2$$$ edges from $$$T$$$, plus one extra edge $$$e$$$, which isn't present in $$$T$$$. Fix this edge $$$e$$$. Let's call the edges from $$$T$$$, which form a cycle joined with $$$e$$$, $$$e$$$'s fundamental cycle. We need to remove an edge from $$$T$$$ that doesn't belong to that fundamental cycle. In this case, the answer is $$$S + w(e) - \mathrm{mx}$$$, where $$$\mathrm{mx}$$$ is the maximum weight of edges of $$$T$$$ out of a given path (connecting the endpoints of $$$e$$$).</p><p>There are several ways to answer these queries "maximum weight of edges out of a given path". The easiest to come up with is to use heavy-light decomposition. To discard a path, one needs to subtract infinity on the path, and then to answer a query it suffices to take the global maximum. There is also another way to answer these queries. Consider a maximum edge $$$(u, v, w)$$$ of the tree. In case the given path doesn't contain that edge, the maximum out of the path is clearly $$$w$$$. Otherwise, the given path passes through the edge $$$(u, v)$$$, and we can cut the tree at it. In that way, one obtains two independent problems of finding the maximum of edges out of a given path from the root (which is either $$$u$$$ or $$$v$$$). The answers to these queries could be precalculated (let's traverse the tree twice, visiting children of a vertex in a reversed order the second time, and maintain the maximum of edges that are already visited).</p><p>It remains to deal with the case when the answer differs from $$$T$$$ by more than one edge. Let $$$w_1 \le \ldots \le w_m$$$ be the weights of $$$e_1, \ldots, e_m$$$ correspondingly. Since we need to exchange two edges, the answer is at least $$$S - w_{n-1} - w_{n-2} + w_{n} + w_{n+1}$$$. Let's show that this estimate is always achievable. Note that both $$$e_{n-2}$$$ and $$$e_{n-1}$$$ are present in the fundamental cycles of $$$e_n$$$ and $$$e_{n+1}$$$ (otherwise, it is possible to achieve $$$S - w_{n - 1\text{ or }n-2} + w_{n\text{ or }n+1}$$$, which is good enough). Therefore, one could replace both $$$e_{n-1}$$$ and $$$e_{n-2}$$$ with $$$e_n$$$ and $$$e_{n+1}$$$, which solves the problem.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2174/problem/E2" title="Codeforces Round 1069 (Div. 1)">2174E2 - Игра учёных (версия 2)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>One important idea: if we know the sum of digits of number $$$x$$$ in base $$$b$$$, we know $$$x \bmod (b - 1)$$$. So, after some queries we will know remainders of the secret number $$$x$$$ by some modulos, which could be combined into one modulo with CRT (Chineese Remainders Theorem).</p><p>Let's define the following function $$$f(m, k)$$$ — the maximum number $$$d$$$, such that the numbers $$$r, r+m, r+2m, \ldots, r + dm$$$ can be distinguished with at most $$$k$$$ queries for any possible remainder $$$0 \leq r &lt; m$$$. The remainder is unknown and is not a function parameter, we should be able to distinguish for any possible remainder value. One more important detail: if $$$m = 1$$$ and the first number is less than $$$1$$$, we do not consider it, if $$$m \geq 2$$$ and the first number is less than $$$2$$$, we do not consider it.</p><p>Let's make the following observations:</p><ul> <li> $$$f(1, 1) = 3$$$, because we can distinguish $$$1, 2, 3$$$ by asking $$$b=2$$$.</li><li> $$$f(m, 1) = m + 1$$$, because we can distinguish $$$r, r + m, r + 2m, \ldots, r + (m+1)\cdot m$$$ by asking $$$m+2$$$.<p>Proof. We will know that the number is less than $$$m+2$$$, or the remainder by modulo $$$m+1$$$. Let's note, that at most one number in the sequence is less than $$$m+2$$$ (because if $$$r \geq 2$$$, than $$$r+m \geq m + 2$$$, otherwise if $$$r &lt; 2$$$, the first number in the sequence is $$$r+m$$$, the second is $$$r+2m \geq m+2$$$. All other numbers have different remainders by modulo $$$m+1$$$, because $$$m \equiv -1 \, (\bmod m + 1)$$$.</p></li><li> Let's calculate $$$f(m, k)$$$ for $$$k \geq 2$$$.<p>Let's define $$$s = f(m, k - 1)$$$. Let's ask $$$b = (s + 1) m$$$. As a result, we will know that the number is $$$&lt; (s + 1)m$$$, or the remainder by modulo $$$\text{mod} = (s + 1)m - 1$$$. If the number is $$$&lt; (s + 1)m$$$, we can find it in $$$k-1$$$ queries by definition of $$$f$$$, because $$$s = f(m, k - 1)$$$. Otherwise, by CRT we now know the remainder of the number by modulo $$$\text{mod} \cdot m$$$ ($$$\text{mod}$$$ and $$$m$$$ are co-prime). So, we can distinguish numbers up to $$$\text{mod} \cdot m \cdot f(\text{mod} \cdot m, k - 1)$$$.</p><p>So, we get the following formula:</p><p>$$$$$$f(m, k) = (f(m, k - 1) + 1) m - 1) f((f(m, k - 1) + 1) m - 1) m, k - 1)$$$$$$</p></li><li> Required only for $$$k=3$$$ to solve. We can pre-calculate with bruteforce that $$$1, 2, 3, \ldots, 35$$$ can be distinguished. So $$$f(1, 2) = 35$$$. This is the only place where we will use that in our query we get the sum of digits instead of just remainder by modulo.</li></ul><p>The code on Python:</p><pre class="verbatim"><br>def f(m, k):<br>    if k == 1:<br>        if m == 1:<br>            return 3<br>        return m + 1<br>    if m == 1 and k == 2:<br>        return 35<br>    s = f(m, k - 1)<br>    mod = (s + 1) * m - 1<br>    return f(mod * m, k - 1) * mod<br></pre><p>To solve the problem, we need $$$f(1, 3) \geq 2 \cdot 10^9$$$ and $$$f(1, 4) \geq 4 \cdot 10^{18}$$$. It holds because the function grows very fast, it is similar to Ackermann function. Values are:</p><ul> <li> $$$f(1, 3) = 2051229390$$$ </li><li> $$$f(1, 4) \approx 10^{391}$$$ </li></ul><p>To make interactive guess, we can just distingush the number by the same logic we used to prove how $$$f$$$ is calculated.</p><p>Time complexity of one guess: $$$O(k \log{c})$$$, because we use CRT at most $$$k$$$ times.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2174/problem/F" title="Codeforces Round 1069 (Div. 1)">2174F - Мозаичное дерево</a></h3><div class="ttypography"><div class="problem-statement"><div><p>The key insight is to use <span class="tex-font-style-it">Prüfer codes</span> to enumerate all labeled trees. Each labeled tree with $$$n$$$ vertices corresponds bijectively to a sequence $$$p = (p_1, p_2, \ldots, p_{n-2})$$$, $$$p_j \in \{1, \ldots, n\}$$$.</p><p>For a vertex $$$v$$$, its degree in the tree is $$$\deg(v) = occurences(p, v) + 1$$$, where $$$occurences(p, v)$$$ is the number of occurrences of $$$v$$$ in the Prüfer code $$$p$$$.</p><p>A tree is <span class="tex-font-style-it">beautiful</span> if for each color $$$c$$$: $$$mask_c = (count_c + \sum_{v, col_v = c} occurences(p, v)) \text{ mod } 2$$$, where $$$count_c$$$ is the number of vertices with color $$$c$$$.</p><p>For a fixed tree, let's define $$$S_c(p) := \sum_{v, col_v = c} occurences(p, v) \text{ mod } 2$$$.</p><p>For a beautiful tree, the following applies: $$$S(p) = r$$$, where $$$r_c = mask_c \oplus (count_c \text{ mod } 2)$$$. We need $$$\frac{1}{2}\sum_{\varepsilon \in \{-1, 1\}} \varepsilon^{S_c(p) - r_c} = 1$$$ for each color:</p><p>$$$$$$ \prod_{c=1}^{m}\frac{1}{2} \sum_{\varepsilon \in \{-1, 1\}} \varepsilon^{S_c(p) - r_c} = \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \prod_{c=1}^m \varepsilon_c^{S_c(p) - r_c} = \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \prod_{c=1}^m \varepsilon_c^{S_c(p)} \prod_{c=1}^m \varepsilon_c^{-r_c} $$$$$$ where $$$\{\pm 1\}^m$$$ denotes all sequences of length $$$m$$$ consisting of $$$-1, 1$$$.</p><p>Let $$$P(n)$$$ be the set of all Prüfer codes for $$$n$$$ vertices. Now we need to sum the previous indicator over all trees:</p><p>$$$$$$ \begin{align} Ans &amp;= \sum_{p \in P(n)} \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \prod_{c=1}^m \varepsilon_c^{S_c(p)} \prod_{c=1}^m \varepsilon_c^{-r_c} = \nonumber \\ &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \sum_{p \in P(n)} \prod_{c=1}^m \varepsilon_c^{S_c(p)} \prod_{c=1}^m \varepsilon_c^{-r_c} = \nonumber \\ &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \prod_{c=1}^m \varepsilon_c^{-r_c} \cdot \sum_{p \in P(n)} \prod_{c=1}^m \varepsilon_c^{S_c(p)} = \nonumber \\ &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \prod_{c=1}^m \varepsilon_c^{-r_c} \cdot \sum_{p \in P(n)} \prod_{c=1}^m \prod_{v, col_v = c} \varepsilon_{c}^{occurences(p, v)} = \nonumber \\ &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \prod_{c=1}^m \varepsilon_c^{r_c} \cdot \sum_{p \in P(n)} \prod_{j=1}^{n-2} \varepsilon_{col_{p_j}} \nonumber \end{align} $$$$$$ Here, each vertex in $$$p$$$ multiplies the expression by $$$\varepsilon$$$ of its color. Let's simplify the second part: $$$$$$ \sum_{p \in P(n)} \prod_{j=1}^{n-2} \varepsilon_{col_{p_j}} = \left(\sum_{v=1}^n \varepsilon_{col_v} \right)^{n-2} = \left( \sum_{c=1}^m \varepsilon_c \cdot count_c \right)^{n-2} $$$$$$ because we iterate through all Prüfer codes for $$$n$$$ vertices.</p><p>Let's return to the overall sum: $$$$$$ \begin{align} Ans &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \left( \sum_{c=1}^m \varepsilon_c \cdot count_c \right)^{n-2}\cdot \prod_{c=1}^m \varepsilon_c^{r_c} = \nonumber \\ &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \left( \sum_{c=1}^m \varepsilon_c \cdot count_c \right)^{n-2}\left( \prod_{c=1}^m \varepsilon_c^{mask_c \oplus count_c} \right) = \nonumber \\ &amp;= \frac{1}{2^m}\sum_{\varepsilon \in \{\pm 1\}^m} \left(n - 2\sum_{c, eps_c = -1} count_c\right)^{n-2} \left( \prod_{c, eps_c = -1} (-1)^{mask_c \oplus count_c} \right) \nonumber \end{align} $$$$$$ Now we need to group the $$$\varepsilon$$$ sequences by $$$\sum_{\varepsilon_c = -1}count_c = k$$$; let's denote this set as $$$Neg(m, k)$$$: $$$$$$ Ans = \frac{1}{2^m}\sum_{k=0}^n \sum_{\varepsilon \in Neg(m, k)} \left( \prod_{c, eps_c = -1} (-1)^{mask_c \oplus count_c} \cdot (n - 2k)^{n-2} \right) $$$$$$ Let's construct the polynomial $$$A(t) = \prod_{c=1}^m (1 + (-1)^{mask_c \oplus count_c}\cdot t^{count_c})$$$ and use its coefficients to calculate the answer: $$$$$$ Ans = \frac{1}{2^m} \sum_{k=0}^n A_k(t) \cdot (n-2k)^{n-2}. $$$$$$ (consider the case $$$count_c = 0$$$ separately).</p><p>For the given problem constraints, $$$O(m \cdot n)$$$ polynomial multiplication time complexity is sufficient. It can be optimized further.</p></div></div></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2174" class="notice" style="text-decoration: none;">Codeforces Round 1069 (Div. 1)</a> </span>
        </div>
        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2175" class="notice" style="text-decoration: none;">Codeforces Round 1069 (Div. 2)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>