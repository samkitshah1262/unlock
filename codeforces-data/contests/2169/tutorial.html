<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/148390" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><p><a href="https://codeforces.com/contest/2169/problem/A" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169A - Alice and Bob</a></p><p>Idea: <a class="rated-user user-orange" href="https://codeforces.com/profile/Roms" title="Master Roms">Roms</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/A" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169A - Alice and Bob</a></h3><div class="ttypography"><div class="problem-statement"><div><p>It is never optimal for Bob to choose $$$b = a$$$. So, either $$$b &lt; a$$$, or $$$b &gt; a$$$.</p><p>Among all possible $$$b &lt; a$$$, we can show that it is always correct to choose $$$b = a - 1$$$: for every integer $$$v_i &lt; a$$$, $$$a - 1$$$ will be closer to $$$v_i$$$ than $$$a$$$; and for every integer $$$v_i \ge a$$$, $$$a$$$ will always be closer than any $$$b &lt; a$$$. So, if we use $$$b = a - 1$$$, the number of points Bob gets will be equal to the number of marbles having $$$v_i &lt; a$$$; and if we use any $$$b &lt; a - 1$$$, the answer won't become better.</p><p>Similarly, if $$$b &gt; a$$$, it is always optimal to choose $$$b = a + 1$$$, and the number of points will be equal to the number of marbles having $$$v_i &gt; a$$$.</p><p>So, it is enough to check only $$$b = a-1$$$ and $$$b = a+1$$$. For both of these values of $$$b$$$, the number of points Bob gets can be calculated easily.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (Roms)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> tc </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> tc </span><span class="pun">&lt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">tc</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">;</span><span class="pln">
        cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> a</span><span class="pun">;</span><span class="pln">
        vector </span><span class="str">&lt;int&gt;</span><span class="pln"> v</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> l </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            cin </span><span class="pun">&gt;&gt;</span><span class="pln"> v</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a </span><span class="pun">&gt;</span><span class="pln"> v</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">++</span><span class="pln">l</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a </span><span class="pun">&lt;</span><span class="pln"> v</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">++</span><span class="pln">r</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        
        cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">l </span><span class="pun">&gt;</span><span class="pln"> r </span><span class="pun">?</span><span class="pln"> a </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> a </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2169/problem/B" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169B - Drifting Away</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/B" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169B - Drifting Away</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let's simplify the problem&nbsp;— assume the string contains only the characters '<span class="tex-font-style-tt">&lt;</span>' and '<span class="tex-font-style-tt">&gt;</span>'.</p><p>Let's figure out when the answer is $$$-1$$$. If there is a substring <span class="tex-font-style-tt">&gt;&lt;</span> somewhere in the string, then the answer is definitely $$$-1$$$, because Monocarp can start in one of those cells and sail back and forth between them indefinitely.</p><p>If such a substring does not exist, then all the '<span class="tex-font-style-tt">&lt;</span>' characters are before all the '<span class="tex-font-style-tt">&gt;</span>' characters, which means the string looks like <span class="tex-font-style-tt">&lt;&lt;...&lt;&lt;&gt;&gt;...&gt;&gt;</span>. Obviously, no matter where Monocarp starts, he will end up on the shore. To sail for as long as possible, Monocarp can either sail through all the cells with the leftward current or through all the cells with the rightward current. Thus, the answer is the maximum of their counts.</p><p>How to solve the problem if there are '<span class="tex-font-style-tt">*</span>' characters? The statement states that Monocarp can choose the direction of rowing each time he lands on an asterisk. However, it should be quite clear that if Monocarp visits an asterisk, choose a direction, and then returns to it again, it is optimal to choose the same direction. If this is done for all visited asterisks, then this cycle will be infinite. Therefore, we are asked to replace all '<span class="tex-font-style-tt">*</span>' with '<span class="tex-font-style-tt">&lt;</span>' or '<span class="tex-font-style-tt">&gt;</span>' in a way as that maximizes the answer to the problem without '<span class="tex-font-style-tt">*</span>'.</p><p>So, if there exists a pair of neighboring symbols that can form <span class="tex-font-style-tt">&gt;&lt;</span>, then the answer is $$$-1$$$. What does the string look like if such a pair does not exist? Obviously, there are no two consecutive '<span class="tex-font-style-tt">*</span>' characters in the string. However, a stronger assertion can be made&nbsp;— there can be at most one '<span class="tex-font-style-tt">*</span>' in the string. Let's prove this. Consider two asterisks with some arrows in between. First, there are arrows to the left, then arrows to the right. If there is at least one arrow to the left, then the left asterisk can be replaced with '<span class="tex-font-style-tt">&gt;</span>'. If there is at least one arrow to the right, then the right asterisk can be replaced with '<span class="tex-font-style-tt">&lt;</span>'. Thus, there should be no arrows at all, but then the asterisks are adjacent, and they can be replaced with <span class="tex-font-style-tt">&gt;&lt;</span>.</p><p>Thus, the string can look like <span class="tex-font-style-tt">&lt;&lt;...&lt;&lt;&gt;&gt;...&gt;&gt;</span> or <span class="tex-font-style-tt">&lt;&lt;...&lt;&lt;*&gt;&gt;...&gt;&gt;</span>. In the second case, the asterisk can be replaced with an arrow that appears more times. Therefore, to solve the problem, it is enough to count the number of arrows of each kind.</p><p>Overall complexity: $$$O(|s|)$$$ per test case.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (awoo)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="kwd">for</span><span class="pln"> _ </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">(</span><span class="pln">input</span><span class="pun">())):</span><span class="pln">
    s </span><span class="pun">=</span><span class="pln"> input</span><span class="pun">()</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">):</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> s</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="str">'&lt;'</span><span class="pln"> </span><span class="kwd">and</span><span class="pln"> s</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="str">'&gt;'</span><span class="pun">:</span><span class="pln">
            </span><span class="kwd">print</span><span class="pun">(-</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
            </span><span class="kwd">break</span><span class="pln">
    </span><span class="kwd">else</span><span class="pun">:</span><span class="pln">
        </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">len</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">s</span><span class="pun">.</span><span class="pln">count</span><span class="pun">(</span><span class="str">'&lt;'</span><span class="pun">),</span><span class="pln"> s</span><span class="pun">.</span><span class="pln">count</span><span class="pun">(</span><span class="str">'&gt;'</span><span class="pun">)))</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2169/problem/C" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169C - Range Operation</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/C" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169C - Range Operation</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let's define $$$S_i$$$ as the sum of the first $$$i$$$ elements in array $$$a$$$. When we perform an operation on the range $$$[l, r]$$$, the total sum changes by $$$(l + r)(r - l + 1) - (S_r - S_{l-1})$$$. This expression can be simplified to $$$f(r) - f(l-1)$$$, where $$$f(x) = x^2 + x - S_x$$$.</p><p>So, we can iterate through the values of $$$r$$$, keeping track of the minimum value of $$$f(l)$$$ we've encountered so far (let's call it $$$mn$$$). Then we can update the answer with $$$S_n + f(r) - mn$$$.</p><p>There is also another solution: if you replace every element on segment $$$[l, r]$$$ with $$$(l + r)$$$, the sum on the segment becomes equal to the $$$2l + 2(l+1) + \dots + 2r$$$ (because $$$(l + r)(r - l + 1)$$$ can be treated as the sum of the arithmetic progression from $$$2l$$$ to $$$2r$$$ with step $$$2$$$). So, you can treat the operation as replacing $$$a_i$$$ with $$$2i$$$. </p><p>You can use this to form another array $$$b$$$, where $$$b_i = 2i - a_i$$$, and find the subsegment with maximum sum in it. And to solve this problem, you can use either Kadane's algorithm or prefix sums.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (Neon)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> li </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
    li s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> mn </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> bst </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
      cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
      s </span><span class="pun">+=</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
      li cur </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> li</span><span class="pun">(</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">
      mn </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">mn</span><span class="pun">,</span><span class="pln"> cur</span><span class="pun">);</span><span class="pln">
      bst </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">bst</span><span class="pun">,</span><span class="pln"> cur </span><span class="pun">-</span><span class="pln"> mn</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> s </span><span class="pun">+</span><span class="pln"> bst </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2169/problem/D1" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169D1 - Removal of a Sequence (Easy Version)</a></p><p>Idea: <a class="rated-user user-orange" href="https://codeforces.com/profile/FelixArg" title="Master FelixArg">FelixArg</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/D1" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169D1 - Removal of a Sequence (Easy Version)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>In many problems where it is necessary to find the $$$k$$$-th element, binary search appears. Let's try to apply binary search on the answer in this problem as well. We just need to understand how the checking function will look.</p><p>Let's fix a number $$$p$$$, and we would like to understand how many numbers will remain in the end if the initial sequence consisted of all natural numbers from $$$1$$$ to $$$p$$$. Since in each action Polycarp removes all elements of the sequence whose index is a multiple of $$$y$$$, the number of removed elements after one action can be calculated using the formula $$$\lfloor\frac{p}{y}\rfloor$$$. The constraints in the simple version of the problem allow us to compute the length of the remaining sequence after each action of Polycarp, so the length of the resulting sequence can be calculated as follows:</p><pre class="lstlisting"><code class="prettyprint prettyprinted" style=""><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><br><span class="pln">    p </span><span class="pun">-=</span><span class="pln"> p </span><span class="pun">/</span><span class="pln"> y</span><span class="pun">;</span><br><span class="pun">}</span><br></code></pre><p>If we find such a minimum $$$p$$$ that after all of Polycarp's actions exactly $$$k$$$ elements remain, then this $$$p$$$ will be the answer.</p><p>It is not difficult to show that our function is monotonic, so we can justifiably use binary search.</p><p>Asymptotic time complexity: $$$O(x \log A)$$$, where $$$A$$$ depends on the length of the initial sequence, in this problem $$$A = 10^{12}$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (FelixArg)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> INF </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1000000000000LL</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">(){</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> y</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
 
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x </span><span class="pun">&gt;&gt;</span><span class="pln"> y </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
 
    </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> l </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> INF</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> m</span><span class="pun">;</span><span class="pln">
 
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">l </span><span class="pun">&lt;=</span><span class="pln"> r</span><span class="pun">){</span><span class="pln">
        m </span><span class="pun">=</span><span class="pln"> l </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">r </span><span class="pun">-</span><span class="pln"> l</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> ost </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++){</span><span class="pln">
            ost </span><span class="pun">-=</span><span class="pln"> ost </span><span class="pun">/</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ost </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> k</span><span class="pun">){</span><span class="pln">
            r </span><span class="pun">=</span><span class="pln"> m </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
        </span><span class="kwd">else</span><span class="pun">{</span><span class="pln">
            l </span><span class="pun">=</span><span class="pln"> m </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
 
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">r </span><span class="pun">==</span><span class="pln"> INF</span><span class="pun">){</span><span class="pln">
        cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">else</span><span class="pun">{</span><span class="pln">
        cout </span><span class="pun">&lt;&lt;</span><span class="pln"> r </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">signed</span><span class="pln"> main</span><span class="pun">()</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
</span><span class="com">#ifdef</span><span class="pln"> FELIX
  </span><span class="kwd">auto</span><span class="pln"> _clock_start </span><span class="pun">=</span><span class="pln"> chrono</span><span class="pun">::</span><span class="pln">high_resolution_clock</span><span class="pun">::</span><span class="pln">now</span><span class="pun">();</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
  ios_base</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
  cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
  cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
 
  </span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
  cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">t</span><span class="pun">--){</span><span class="pln">
    solve</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
 
</span><span class="com">#ifdef</span><span class="pln"> FELIX
  cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"Executed in "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> chrono</span><span class="pun">::</span><span class="pln">duration_cast</span><span class="pun">&lt;</span><span class="pln">chrono</span><span class="pun">::</span><span class="pln">milliseconds</span><span class="pun">&gt;(</span><span class="pln">
    chrono</span><span class="pun">::</span><span class="pln">high_resolution_clock</span><span class="pun">::</span><span class="pln">now</span><span class="pun">()</span><span class="pln">
      </span><span class="pun">-</span><span class="pln"> _clock_start</span><span class="pun">).</span><span class="pln">count</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"ms."</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2169/problem/D2" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169D2 - Removal of a Sequence (Hard Version)</a></p><p>Idea: <a class="rated-user user-orange" href="https://codeforces.com/profile/FelixArg" title="Master FelixArg">FelixArg</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/D2" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169D2 - Removal of a Sequence (Hard Version)</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Please read the explanation of the easy version of this problem.</p><p>Unlike the easy version, we cannot compute the length of the sequence after each action of Polycarp, as $$$x$$$ can be quite large. However, we can note the following: we subtract the number $$$\left\lfloor\frac{p}{y}\right\rfloor$$$ each time, and since $$$y$$$ is fixed, it follows that there are at most $$$\sqrt{p}$$$ different values of the subtracted numbers. Therefore, we can combine Polycarp's actions and subtract them in groups at once:</p><pre class="lstlisting"><code class="prettyprint prettyprinted" style=""><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> x</span><span class="pun">;){</span><br><span class="pln">    </span><span class="kwd">int</span><span class="pln"> cur_value </span><span class="pun">=</span><span class="pln"> p </span><span class="pun">/</span><span class="pln"> y</span><span class="pun">;</span><br><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cur_value </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">){</span><br><span class="pln">        </span><span class="kwd">break</span><span class="pun">;</span><br><span class="pln">    </span><span class="pun">}</span><br><span class="pln">    </span><span class="kwd">int</span><span class="pln"> where_cur_value_changes </span><span class="pun">=</span><span class="pln"> cur_value </span><span class="pun">*</span><span class="pln"> y </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><br><span class="pln">    </span><span class="kwd">int</span><span class="pln"> actions_in_group </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">-</span><span class="pln"> where_cur_value_changes </span><span class="pun">+</span><span class="pln"> cur_value </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> cur_value</span><span class="pun">;</span><br><span class="pln">    actions_in_group </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">x </span><span class="pun">-</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> actions_in_group</span><span class="pun">);</span><br><span class="pln">    p </span><span class="pun">-=</span><span class="pln"> actions_in_group </span><span class="pun">*</span><span class="pln"> cur_value</span><span class="pun">;</span><br><span class="pln">    i </span><span class="pun">+=</span><span class="pln"> actions_in_group</span><span class="pun">;</span><br><span class="pun">}</span><br></code></pre><p>This optimization will allow us to write a solution in $$$O(\sqrt A \cdot \log A)$$$. However, this solution is still too slow to get an <span class="tex-font-style-tt">Accepted</span>.</p><p>It turns out we can eliminate the binary search for the answer. To do this, let's consider the reverse problem.</p><p>Previously, we fixed $$$p$$$ and subtracted the removed elements, that is, after one operation:</p><p>$$$$$$p' = p - \left\lfloor\frac{p}{y}\right\rfloor$$$$$$</p><p>But we can try to find $$$p$$$ from $$$p'$$$, and it turns out we can do this as follows:</p><p>$$$$$$p = p' + \left\lfloor\frac{p' - 1}{y - 1}\right\rfloor$$$$$$</p><p>The correctness of this transition can be proven mathematically, but here I will explain it more intuitively:</p><p>Among every $$$y$$$ consecutive positions, one multiple of $$$y$$$ is removed, while $$$y - 1$$$ remain. Thus, to obtain the $$$p'$$$-th remaining element, we take:</p><ul> <li> $$$p'$$$ of the remaining elements; </li><li> plus one removed for each complete block of $$$y - 1$$$ remaining. </li></ul><p>The number of such complete blocks is exactly $$$\left\lfloor\frac{p' - 1}{y - 1}\right\rfloor$$$.</p><p>Thus, if we start from position $$$k$$$ and apply $$$x$$$ such reverse operations, we will find the answer.</p><p>In the implementation of the solution, it is important to watch for overflow; if at any point the current $$$p$$$ exceeds $$$10^{12}$$$, the answer is $$$-1$$$.</p><p>Asymptotic time complexity: $$$O(\sqrt A)$$$, where $$$A$$$ depends on the length of the original sequence; in this problem, $$$A = 10^{12}$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (FelixArg)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="com">#define</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> INF </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="str">'000'</span><span class="lit">000</span><span class="str">'000'</span><span class="lit">000LL</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">(){</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
  cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x </span><span class="pun">&gt;&gt;</span><span class="pln"> y </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
 
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">y </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pun">){</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
 
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln"> </span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> cur </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="pln">y </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cur </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">){</span><span class="pln">
      </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> fk </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cur </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="pln">y </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> cnt </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fk </span><span class="pun">-</span><span class="pln"> k </span><span class="pun">+</span><span class="pln"> cur </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> cur</span><span class="pun">;</span><span class="pln">
    cnt </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">x </span><span class="pun">-</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> cnt</span><span class="pun">);</span><span class="pln">
    k </span><span class="pun">+=</span><span class="pln"> cnt </span><span class="pun">*</span><span class="pln"> cur</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">&gt;</span><span class="pln"> INF</span><span class="pun">){</span><span class="pln">
      cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> 
    i </span><span class="pun">+=</span><span class="pln"> cnt</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
 
  cout </span><span class="pun">&lt;&lt;</span><span class="pln"> k </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">signed</span><span class="pln"> main</span><span class="pun">()</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
</span><span class="com">#ifdef</span><span class="pln"> FELIX
    </span><span class="kwd">auto</span><span class="pln"> _clock_start </span><span class="pun">=</span><span class="pln"> chrono</span><span class="pun">::</span><span class="pln">high_resolution_clock</span><span class="pun">::</span><span class="pln">now</span><span class="pun">();</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
    ios_base</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
 
    </span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">t</span><span class="pun">--){</span><span class="pln">
        solve</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
 
</span><span class="com">#ifdef</span><span class="pln"> FELIX
    cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"Executed in "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> chrono</span><span class="pun">::</span><span class="pln">duration_cast</span><span class="pun">&lt;</span><span class="pln">chrono</span><span class="pun">::</span><span class="pln">milliseconds</span><span class="pun">&gt;(</span><span class="pln">
        chrono</span><span class="pun">::</span><span class="pln">high_resolution_clock</span><span class="pun">::</span><span class="pln">now</span><span class="pun">()</span><span class="pln">
            </span><span class="pun">-</span><span class="pln"> _clock_start</span><span class="pun">).</span><span class="pln">count</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"ms."</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2169/problem/E" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169E - Points Selection</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/E" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169E - Points Selection</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Firstly, note that since Bob wants to minimize the answer, it is optimal for him to draw a rectangle with the smallest possible perimeter. Therefore, he always chooses the bounding box of the remaining points. Thus, the answer to the problem is the sum of the removed points plus the bounding box of the remaining points.</p><p>The second observation: if a point does not lie on any side of the rectangle, it is always optimal to remove it&nbsp;— the rectangle will not change, and the answer will only improve. From this, it follows that each point we decide to keep must lie on some side (or several sides) of the rectangle, meaning its coordinates "define the position" of that side (i.&nbsp;e., they determine which specific horizontal or vertical line the side should lie on).</p><p>At the same time, this point can "define" a rather arbitrary set of sides: potentially, any subset of sides.</p><p>The third observation: if we know the coordinates of the lines on which the sides of the rectangle should lie, we also know its perimeter. Indeed, let the left and right sides lie on the lines $$$x=x_1$$$ and $$$x=x_2$$$, and the bottom and top&nbsp;— on $$$y=y_1$$$ and $$$y=y_2$$$. Then the perimeter of the rectangle will be $$$2(x_2 - x_1) + 2(y_2 - y_1)$$$ or $$$-2 x_1 - 2 y_1 + 2 x_2 + 2 y_2$$$.</p><p>The fourth observation: if some side is already "defined" by some point, it is pointless to "define" it again by another point.</p><p>Thus, we can construct the following dynamic programming array $$$d[n][2^4]$$$, where $$$d[i][mask]$$$ is the answer to the problem if we have already processed $$$i$$$ points and "defined" $$$mask$$$ of sides. The transitions look like this: </p><ul> <li> The $$$i$$$-th point can be removed. In this case, the mask of sides does not change, and we add $$$c_i$$$ to the current score. </li><li> The $$$i$$$-th point can be kept. Then we will decide which mask of still undefined sides this point will define, and for each newly defined side, we will add $$$\pm x_i$$$ (or $$$\pm y_i$$$ for horizontal), where the sign depends on whether it is the left (bottom) or right (top) side. </li></ul><p>This dynamic programming approach will accurately handle all valid constructions, meaning it will definitely contain the answer to the problem. However, it can also construct invalid configurations. For example, a rectangle where the left side is to the right of the right side, or the bottom is above the top. However, note that these invalid states yield negative side lengths and will not be optimal answers. Therefore, the maximum answer will definitely be valid.</p><p>This dynamic programming can be implemented in time on the order of $$$T(n (2^4 \cdot 2^4 + 3^4 \cdot 4))$$$, which is already enough to pass, but it can be improved to $$$T(n (2^4 \cdot 4 + 3^4))$$$ with the help of precomputation and additional memory.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (BledDest)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="com">#define</span><span class="pln"> fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">l</span><span class="pun">);</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">r</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">((</span><span class="pln">a</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
 
</span><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> li</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> INF </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="lit">1e9</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> li INF64 </span><span class="pun">=</span><span class="pln"> li</span><span class="pun">(</span><span class="lit">1e18</span><span class="pun">);</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
vector</span><span class="str">&lt;li&gt;</span><span class="pln"> x</span><span class="pun">[</span><span class="lit">3</span><span class="pun">];</span><span class="pln">
 
</span><span class="kwd">bool</span><span class="pln"> read</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(!(</span><span class="pln">cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">))</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    fore </span><span class="pun">(</span><span class="pln">k</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        x</span><span class="pun">[</span><span class="pln">k</span><span class="pun">].</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
        fore </span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln">
            cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    vector</span><span class="pun">&lt;</span><span class="pln"> vector</span><span class="str">&lt;li&gt;</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> w</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> vector</span><span class="str">&lt;li&gt;</span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">));</span><span class="pln">
    fore </span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        fore </span><span class="pun">(</span><span class="pln">mask</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            fore </span><span class="pun">(</span><span class="pln">k</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">mask </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln">
                w</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">mask</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> x</span><span class="pun">[</span><span class="pln">k </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
 
    vector</span><span class="pun">&lt;</span><span class="pln"> vector</span><span class="str">&lt;li&gt;</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> d</span><span class="pun">(</span><span class="pln">n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> vector</span><span class="str">&lt;li&gt;</span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">INF64</span><span class="pun">));</span><span class="pln">
    d</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    fore </span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> fore </span><span class="pun">(</span><span class="pln">mask</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">d</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">mask</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">-</span><span class="pln">INF64 </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln">
            </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
        
        d</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">mask</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">d</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">mask</span><span class="pun">],</span><span class="pln"> d</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">mask</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> x</span><span class="pun">[</span><span class="lit">2</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">
 
        </span><span class="kwd">int</span><span class="pln"> filter </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> mask</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> cmask </span><span class="pun">=</span><span class="pln"> filter</span><span class="pun">;</span><span class="pln"> cmask </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> cmask </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cmask </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> filter</span><span class="pun">)</span><span class="pln">
            d</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">mask </span><span class="pun">|</span><span class="pln"> cmask</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">d</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">mask </span><span class="pun">|</span><span class="pln"> cmask</span><span class="pun">],</span><span class="pln"> d</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">mask</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2ll</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> w</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">cmask</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> d</span><span class="pun">[</span><span class="pln">n</span><span class="pun">][(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
</span><span class="com">#ifdef</span><span class="pln"> _DEBUG
    freopen</span><span class="pun">(</span><span class="str">"input.txt"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"r"</span><span class="pun">,</span><span class="pln"> stdin</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> tt </span><span class="pun">=</span><span class="pln"> clock</span><span class="pun">();</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
    ios_base</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
 
    </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        read</span><span class="pun">();</span><span class="pln">
        solve</span><span class="pun">();</span><span class="pln">
        
</span><span class="com">#ifdef</span><span class="pln"> _DEBUG
        cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"TIME = "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> clock</span><span class="pun">()</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> tt </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
        tt </span><span class="pun">=</span><span class="pln"> clock</span><span class="pun">();</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2169/problem/F" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169F - Subsequence Problem</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2169/problem/F" title="Educational Codeforces Round 184 (Rated for Div. 2)">2169F - Subsequence Problem</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Before we count ideal arrays, let's understand how to check whether a given array $$$c$$$ is ideal or not. We will do this as follows: we will try to construct a beautiful array $$$b$$$ that is <span class="tex-font-style-bf">not</span> a subsequence of the array $$$c$$$.</p><p>Let's try to understand where the first element of the array $$$b$$$ will be in the array $$$c$$$. To do this, we will find the first occurrences of the numbers $$$a_{1,1}, a_{1,2}, \dots, a_{1,l_1}$$$ in the array $$$c$$$. If we do not find at least one of them, we can choose it as $$$b_1$$$, and $$$b$$$ will not be a subsequence of the array $$$c$$$. Otherwise, we will choose $$$b_1$$$ a way that limits the "extension" of the subsequence — that is, we will choose an element from the array $$$a_1$$$ whose first occurrence in $$$c$$$ appears the latest (because the subsequence can be continued only after this occurrence).</p><p>How do we choose $$$b_2$$$? In fact, we have the same problem, but now we are constructing the array $$$b$$$ starting from the $$$2$$$-nd element, and only some suffix of the array $$$c$$$ remains. We will find the nearest occurrences of the elements from the array $$$a_2$$$, choose the last of them, move on to choosing $$$b_3$$$ on some shorter suffix of $$$c$$$, and so on.</p><p>However, it will be more convenient to slightly reformulate this algorithm. Let's go through the array $$$c$$$ from left to right and maintain the following:</p><ul> <li> $$$x$$$ ($$$0 \le x \le k$$$) — the number of the first elements of the array $$$b$$$ for which we have already found the necessary occurrences for all options to choose them; </li><li> $$$s$$$ — the set of elements from the array $$$a_{x+1}$$$ (candidates for $$$b_{x+1}$$$) whose occurrences we are currently searching for. </li></ul><p>Then, each element of the array $$$c$$$ that we encounter will either belong to the set $$$s$$$ (in which case it needs to be removed from $$$s$$$, and if $$$s$$$ becomes empty, we move to $$$x+1$$$ and add all elements of the array $$$a_{x+2}$$$ to $$$s$$$), or it will be absent from this set (in which case we can simply skip it).</p><p>In fact, this already allows us to count the number of ideal arrays $$$c$$$. Let's write the dynamic programming for this process: $$$dp_{i,x,|s|}$$$ — the number of ways to choose the first $$$i$$$ elements of the array $$$c$$$ such that after processing them, we obtain a given value $$$x$$$ and a given size of the set $$$s$$$ (we are actually only interested in the number of elements in the set, not the elements themselves). The transitions are quite simple:</p><ul> <li> either we choose a number from the set $$$s$$$ (it can be chosen in $$$|s|$$$ ways), transitioning to $$$dp_{i+1,x,|s|-1}$$$ or $$$dp_{i+1,x+1,l_2}$$$; </li><li> or we choose a number not from this set (it can be chosen in $$$m - |s|$$$ ways), transitioning to $$$dp_{i+1,x,|s|}$$$. </li></ul><p>Unfortunately, this is too slow. Let's try to understand how to speed this dynamic programming up.</p><p>Suppose we divided all elements from $$$c$$$ into two groups: those that decreased the size $$$|s|$$$ when processed (group A), and those that did not decrease it (group B). If we only consider the elements of group A, there should be exactly $$$\sum l_i$$$ of them, and the number of ways to choose them will be $$$\prod (l_i)!$$$ — we choose the order in which we encounter elements from each array $$$a_i$$$ in $$$c$$$.</p><p>But we may also have elements from group B: there will be exactly $$$n - \sum l_i$$$ of them. The overall structure of the array $$$c$$$ will look like this: B* A B* A B* ... B* A B*, where A denotes an element from group A, and B* denotes a block (possibly empty) of elements from group B. In total, the blocks B* must contain $$$n - \sum l_i$$$ elements.</p><p>For each block B*, we know which numbers can be used in it and which cannot: the only numbers that cannot be used are those that are currently in the set $$$s$$$. They depend on the order in which we encounter the elements of the corresponding array $$$a_i$$$ in $$$c$$$, but their <span class="tex-font-style-it">number</span> for each block B* is uniquely determined. That is, for each block B*, we know how many ways there are to choose each element in that block.</p><p>And the last observation we need: for each block B*, the number of ways to choose each element lies in the interval ([m-5, m]). That's it, now we can solve the problem.</p><p>We will divide all blocks B* into 6 categories depending on how many elements are "forbidden" in them: let $$$d_i$$$ be the number of blocks in the $$$i$$$-th category, for which the number of forbidden elements equals $$$i$$$ ($$$i \in [0, 5]$$$). Suppose there are $$$e_i$$$ elements in the $$$i$$$-th category; then the number of ways to choose them is $$$(m-i)^{e_i}$$$, and the number of ways to distribute them across the blocks is $$${{e_i + d_i - 1}\choose{e_i}}$$$.</p><p>Now we just need to somehow calculate the answer among all the ways to represent $$$n - \sum l_i$$$ as the sum of $$$6$$$ integers $$$e_0, e_1, \dots, e_5$$$. To do this, for each category $$$i$$$, we will form a polynomial of degree $$$n - \sum l_i$$$, where the coefficient for the $$$j$$$-th term will be $$${{j + d_i - 1}\choose{j}} \cdot (m-i)^j$$$. If we multiply all these polynomials together, the coefficient for the term $$$(n - \sum l_i)$$$ will be exactly what we need: the sum of the products $$${{e_i + d_i - 1}\choose{e_i}} \cdot (m-i)^{e_i}$$$ for all ways to break the number $$$(n - \sum l_i)$$$ into non-negative summands $$$e_i$$$.</p><p>Naturally, to multiply the polynomials here, we need to use FFT (or NTT, since the modulus is suitable for NTT). When multiplying the polynomials, we can each time "trim" the result to the degree $$$(n - \sum l_i)$$$, as we do not need higher degrees.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (BledDest)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="com">#define</span><span class="pln"> fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">l</span><span class="pun">);</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">r</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">((</span><span class="pln">a</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> LOGN </span><span class="pun">=</span><span class="pln"> </span><span class="lit">19</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MOD </span><span class="pun">=</span><span class="pln"> </span><span class="lit">998244353</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> g </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> mul</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">a </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1ll</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> b </span><span class="pun">%</span><span class="pln"> MOD</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> norm</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">a </span><span class="pun">&gt;=</span><span class="pln"> MOD</span><span class="pun">)</span><span class="pln"> a </span><span class="pun">-=</span><span class="pln"> MOD</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">a </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> a </span><span class="pun">+=</span><span class="pln"> MOD</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> a</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> binPow </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> k</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(;</span><span class="pln"> k </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k </span><span class="pun">&gt;&gt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln">
            ans </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">);</span><span class="pln">
        a </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> ans</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> inv</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> binPow</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> MOD </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
vector</span><span class="str">&lt;int&gt;</span><span class="pln"> w</span><span class="pun">[</span><span class="pln">LOGN</span><span class="pun">],</span><span class="pln"> rv</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">bool</span><span class="pln"> precalced </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">void</span><span class="pln"> precalc</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">precalced</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
    precalced </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
    
    </span><span class="kwd">int</span><span class="pln"> wb </span><span class="pun">=</span><span class="pln"> binPow</span><span class="pun">(</span><span class="pln">g</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">MOD </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> LOGN</span><span class="pun">));</span><span class="pln">
    fore</span><span class="pun">(</span><span class="pln">st</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> LOGN</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        w</span><span class="pun">[</span><span class="pln">st</span><span class="pun">].</span><span class="pln">assign</span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> st</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
 
        </span><span class="kwd">int</span><span class="pln"> bw </span><span class="pun">=</span><span class="pln"> binPow</span><span class="pun">(</span><span class="pln">wb</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">LOGN </span><span class="pun">-</span><span class="pln"> st </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> cw </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
 
        fore</span><span class="pun">(</span><span class="pln">k</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> st</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            w</span><span class="pun">[</span><span class="pln">st</span><span class="pun">][</span><span class="pln">k</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cw</span><span class="pun">;</span><span class="pln">
            cw </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">cw</span><span class="pun">,</span><span class="pln"> bw</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    
    rv</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> LOGN</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">rv</span><span class="pun">))</span><span class="pln">
        rv</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rv</span><span class="pun">[</span><span class="pln">i </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">|</span><span class="pln"> </span><span class="pun">((</span><span class="pln">i </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">LOGN </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MX </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> LOGN</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">3</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">inline</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> fft</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">MX</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> inverse</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    precalc</span><span class="pun">();</span><span class="pln">
    
    </span><span class="kwd">int</span><span class="pln"> ln </span><span class="pun">=</span><span class="pln"> __builtin_ctz</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">assert</span><span class="pun">((</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> ln</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> MX</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">assert</span><span class="pun">((</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> ln</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">);</span><span class="pln">
 
    fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> ni </span><span class="pun">=</span><span class="pln"> rv</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">LOGN </span><span class="pun">-</span><span class="pln"> ln</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">i </span><span class="pun">&lt;</span><span class="pln"> ni</span><span class="pun">)</span><span class="pln"> swap</span><span class="pun">(</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">ni</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
 
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> st </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> st</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> st</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> st</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> k </span><span class="pun">+=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">len </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            fore</span><span class="pun">(</span><span class="pln">pos</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">,</span><span class="pln"> k </span><span class="pun">+</span><span class="pln"> len</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">int</span><span class="pln"> l </span><span class="pun">=</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">];</span><span class="pln">
                </span><span class="kwd">int</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">a</span><span class="pun">[</span><span class="pln">pos </span><span class="pun">+</span><span class="pln"> len</span><span class="pun">],</span><span class="pln"> w</span><span class="pun">[</span><span class="pln">st</span><span class="pun">][</span><span class="pln">pos </span><span class="pun">-</span><span class="pln"> k</span><span class="pun">]);</span><span class="pln">
 
                a</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> norm</span><span class="pun">(</span><span class="pln">l </span><span class="pun">+</span><span class="pln"> r</span><span class="pun">);</span><span class="pln">
                a</span><span class="pun">[</span><span class="pln">pos </span><span class="pun">+</span><span class="pln"> len</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> norm</span><span class="pun">(</span><span class="pln">l </span><span class="pun">-</span><span class="pln"> r</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">inverse</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> inv</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
        fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln">
            a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">in</span><span class="pun">);</span><span class="pln">
        reverse</span><span class="pun">(</span><span class="pln">a </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> a </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> aa</span><span class="pun">[</span><span class="pln">MX</span><span class="pun">],</span><span class="pln"> bb</span><span class="pun">[</span><span class="pln">MX</span><span class="pun">],</span><span class="pln"> cc</span><span class="pun">[</span><span class="pln">MX</span><span class="pun">];</span><span class="pln">
 
vector</span><span class="str">&lt;int&gt;</span><span class="pln"> multiply</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> vector</span><span class="str">&lt;int&gt;</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> vector</span><span class="str">&lt;int&gt;</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">b</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> cutoff</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> ln </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">ln </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sz</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)))</span><span class="pln">
        ln </span><span class="pun">&lt;&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    
    fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> ln</span><span class="pun">)</span><span class="pln">
        aa</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">&lt;</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> ln</span><span class="pun">)</span><span class="pln">
        bb</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">&lt;</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> b</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
        
    fft</span><span class="pun">(</span><span class="pln">aa</span><span class="pun">,</span><span class="pln"> ln</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    fft</span><span class="pun">(</span><span class="pln">bb</span><span class="pun">,</span><span class="pln"> ln</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    
    fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> ln</span><span class="pun">)</span><span class="pln">
        cc</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">aa</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> bb</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">
    fft</span><span class="pun">(</span><span class="pln">cc</span><span class="pun">,</span><span class="pln"> ln</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
    
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ans</span><span class="pun">(</span><span class="pln">cc</span><span class="pun">,</span><span class="pln"> cc </span><span class="pun">+</span><span class="pln"> ln</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">((</span><span class="pln">ans</span><span class="pun">.</span><span class="pln">size</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> ans</span><span class="pun">.</span><span class="pln">back</span><span class="pun">()</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> ans</span><span class="pun">.</span><span class="pln">size</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> cutoff</span><span class="pun">)</span><span class="pln">
        ans</span><span class="pun">.</span><span class="pln">pop_back</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> ans</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
vector</span><span class="str">&lt;int&gt;</span><span class="pln"> fact</span><span class="pun">,</span><span class="pln"> ifact</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">void</span><span class="pln"> precalc_factorials</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    fact</span><span class="pun">.</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln">
    fact</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> s</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
        fact</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">fact</span><span class="pun">[</span><span class="pln">i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">],</span><span class="pln"> i</span><span class="pun">);</span><span class="pln">
    ifact</span><span class="pun">.</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> s</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
        ifact</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> inv</span><span class="pun">(</span><span class="pln">fact</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> choose</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> k</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">n </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> n </span><span class="pun">&lt;</span><span class="pln"> k </span><span class="pun">||</span><span class="pln"> k </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">fact</span><span class="pun">[</span><span class="pln">n</span><span class="pun">],</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">ifact</span><span class="pun">[</span><span class="pln">n </span><span class="pun">-</span><span class="pln"> k</span><span class="pun">],</span><span class="pln"> ifact</span><span class="pun">[</span><span class="pln">k</span><span class="pun">]));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    ios_base</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> m </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> lens</span><span class="pun">(</span><span class="pln">k</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> lens</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
 
    </span><span class="kwd">int</span><span class="pln"> cutoff </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    precalc_factorials</span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> LOGN</span><span class="pun">);</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> segments</span><span class="pun">(</span><span class="lit">6</span><span class="pun">);</span><span class="pln">
    segments</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> len </span><span class="pun">:</span><span class="pln"> lens</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> len</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
            segments</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]++;</span><span class="pln">
    vector</span><span class="pun">&lt;</span><span class="pln">vector</span><span class="str">&lt;int&gt;</span><span class="pun">&gt;</span><span class="pln"> poly</span><span class="pun">(</span><span class="lit">6</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">6</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">segments</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
            poly</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">int</span><span class="pln"> choices </span><span class="pun">=</span><span class="pln"> norm</span><span class="pun">(</span><span class="pln">m </span><span class="pun">-</span><span class="pln"> i</span><span class="pun">);</span><span class="pln">
            </span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
            poly</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">cutoff</span><span class="pun">);</span><span class="pln">
            </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k </span><span class="pun">&lt;</span><span class="pln"> cutoff</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">int</span><span class="pln"> cur </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span><span class="pln"> choose</span><span class="pun">(</span><span class="pln">k </span><span class="pun">+</span><span class="pln"> segments</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">));</span><span class="pln">
                poly</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">k</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">;</span><span class="pln">
                p </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span><span class="pln"> choices</span><span class="pun">);</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">6</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
        ans </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> poly</span><span class="pun">[</span><span class="pln">i</span><span class="pun">],</span><span class="pln"> cutoff</span><span class="pun">);</span><span class="pln">
 
    </span><span class="kwd">int</span><span class="pln"> used </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> coef </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> len </span><span class="pun">:</span><span class="pln"> lens</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        coef </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">coef</span><span class="pun">,</span><span class="pln"> fact</span><span class="pun">[</span><span class="pln">len</span><span class="pun">]);</span><span class="pln">
        used </span><span class="pun">+=</span><span class="pln"> len</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> res </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">coef</span><span class="pun">,</span><span class="pln"> ans</span><span class="pun">[</span><span class="pln">n </span><span class="pun">-</span><span class="pln"> used</span><span class="pun">]);</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> res </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2169" class="notice" style="text-decoration: none;">Educational Codeforces Round 184 (Rated for Div. 2)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>