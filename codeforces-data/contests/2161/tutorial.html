<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/147941" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><p>We hope you've enjoyed the problems! (Certain problem editorials below may appear a bit late due to Polygon lag)</p> <div><h3><a href="https://codeforces.com/contest/2161/problem/A" title="Pinely Round 5 (Div. 1 + Div. 2)">2161A - Round Trip</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Since div.1 rounds are always rated for all participants, we need to maximize the number of div.2 rounds. This means we should always try to decrease our rating until it reaches <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1267"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1268">X</span><span class="MJXp-mo" id="MJXp-Span-1269" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-1270">1</span></span></span><script type="math/tex" id="MathJax-Element-230">X − 1</script> so we can participate in div.2 rounds too. After that, every round will be rated.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/B" title="Pinely Round 5 (Div. 1 + Div. 2)">2161B - Make Connected</a></h3><div class="ttypography"><div class="problem-statement"><div><p>There are two types of connected areas that satisfy the condition that "<span class="tex-font-style-it">No three consecutive black cells should be aligned vertically or horizontally</span>".</p><p><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1271"><span class="MJXp-mn" id="MJXp-Span-1272">2</span><span class="MJXp-mo" id="MJXp-Span-1273" style="margin-left: 0.267em; margin-right: 0.267em;">×</span><span class="MJXp-mn" id="MJXp-Span-1274">2</span></span></span><script type="math/tex" id="MathJax-Element-231">2 \times 2</script> square: </p><pre class="verbatim">##<br>##<br></pre><p>Zigzags (there are four kinds of them):</p><pre class="verbatim">##...<br>.##..<br>..##.<br>...##<br>....#<br><br>#....<br>##...<br>.##..<br>..##.<br>...##<br><br>...##<br>..##.<br>.##..<br>##...<br>#....<br><br>....#<br>...##<br>..##.<br>.##..<br>##...<br></pre><p>For the square, you can simply check that there is a square and no other black cells.</p><p>For the zigzags, you can handle just one kind and handle others by flipping and rotating the grid.</p><p>To check that a zigzag fits the current grid, you can find the top-left and bottom-right black cells (for the first and second kinds), then verify that other black cells are only along the zigzag path between these two cells.</p><p>An alternative solution relies on the diagonal characterization. The zigzag characterization above can be succinctly explained as "in one of the two diagonal orientations, the black cells are constrained to two neighbouring diagonals". Since <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1275"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1276">x</span><span class="MJXp-mo" id="MJXp-Span-1277" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1278">y</span></span></span><script type="math/tex" id="MathJax-Element-232">x + y</script> and <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1279"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1280">x</span><span class="MJXp-mo" id="MJXp-Span-1281" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1282">y</span></span></span><script type="math/tex" id="MathJax-Element-233">x - y</script> values enumerate the diagonals with respect to their order, we find that the answer is "<span class="tex-font-style-tt">YES</span>" if at least one of the following conditions holds:</p><ul> <li> among black cells <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1283"><span class="MJXp-mo" id="MJXp-Span-1284" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1285">x</span><span class="MJXp-mo" id="MJXp-Span-1286" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-1287">y</span><span class="MJXp-mo" id="MJXp-Span-1288" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-234">(x, y)</script>, <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1289"><span class="MJXp-mo" id="MJXp-Span-1290">max</span></span></span><script type="math/tex">\max (x + y) - \min(x + y) \leq 1</script>, </li><li> among black cells <span class="MathJax_Preview">(x, y)</span><script type="math/tex">(x, y)</script>, <span class="MathJax_Preview">\max (x - y) - \min(x - y) \leq 1</span><script type="math/tex">\max (x - y) - \min(x - y) \leq 1</script>, </li><li> black cells are constrained to a <span class="MathJax_Preview">2 \times 2</span><script type="math/tex">2 \times 2</script> square, that is <span class="MathJax_Preview">\max x - \min x \leq 1</span><script type="math/tex">\max x - \min x \leq 1</script>, and <span class="MathJax_Preview">\max y.- \min y \leq 1</span><script type="math/tex">\max y.- \min y \leq 1</script>.</li></ul></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/C" title="Pinely Round 5 (Div. 1 + Div. 2)">2161C - Loyalty</a></h3><div class="ttypography"><div class="problem-statement"><div><p>The best possible answer that we can achieve is obtaining bonus points for purchasing <span class="MathJax_Preview">\lfloor {\sum_1^n a_i \over X} \rfloor</span><script type="math/tex">\lfloor {\sum_1^n a_i \over X} \rfloor</script> of the most expensive items. And this number of bonus points always can be reached.</p><p>Let's sort the items in non-decreasing order by price and purchase the most expensive one if its purchasing increases loyalty level and adds bonus points; otherwise, just purchase the cheapest one.</p><p>It is easy to see that when <span class="MathJax_Preview">1 \leq a_i \leq X</span><script type="math/tex">1 \leq a_i \leq X</script>, we indeed always get bonuses for the prefix of the most expensive items with such strategy because purchasing one item can't increase our loyalty level by more than one.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/D" title="Pinely Round 5 (Div. 1 + Div. 2)">2161D - Locked Out</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let <span class="MathJax_Preview">b</span><script type="math/tex">b</script> denote the sequence of pairs (<span class="MathJax_Preview">a_i, i</span><script type="math/tex">a_i, i</script>), sorted by the first component in non-decreasing order and, in the case of equal first components, in non-increasing order by the second component. Denote the first element of the pair <span class="MathJax_Preview">b_i</span><script type="math/tex">b_i</script> as <span class="MathJax_Preview">b_{i,1}</span><script type="math/tex">b_{i,1}</script> and the second element as <span class="MathJax_Preview">b_{i,2}</span><script type="math/tex">b_{i,2}</script>.</p><p>For example, for the array <span class="MathJax_Preview">3, 1, 2, 5, 2</span><script type="math/tex">3, 1, 2, 5, 2</script>, this sequence will be <span class="MathJax_Preview">(1, 2), (2, 5), (2, 3), (3, 1), (5, 4)</span><script type="math/tex">(1, 2), (2, 5), (2, 3), (3, 1), (5, 4)</script>.</p><p>We will use this sequence to compute the following dynamic programming state <span class="MathJax_Preview">dp_i</span><script type="math/tex">dp_i</script>: the maximum number of elements that can be in a good array if we have considered the elements of the array corresponding to the prefix of sequence <span class="MathJax_Preview">b</span><script type="math/tex">b</script> of length <span class="MathJax_Preview">i</span><script type="math/tex">i</script>.</p><p>The transition is defined as: <span class="MathJax_Preview"> dp_i = max\left(1, \max_{1 \leq j &lt; i, (b_{i,1} \neq b_{j,1} + 1 \lor b_{i,2} &lt; b_{j,2})}(dp_j + 1)\right) </span><script type="math/tex; mode=display"> dp_i = max\left(1, \max_{1 \leq j < i, (b_{i,1} \neq b_{j,1} + 1 \lor b_{i,2} < b_{j,2})}(dp_j + 1)\right) </script></p><p>To eliminate the quadratic complexity of this transition, we can maintain:</p><ul> <li> A global maximum among such <span class="MathJax_Preview">j</span><script type="math/tex">j</script> that <span class="MathJax_Preview">b_{j,1} \leq b_{i,1} - 2</span><script type="math/tex">b_{j,1} \leq b_{i,1} - 2</script>;</li><li> Suffix maxima for such <span class="MathJax_Preview">j</span><script type="math/tex">j</script> that <span class="MathJax_Preview">b_{j,1} = b_{i,1} - 1</span><script type="math/tex">b_{j,1} = b_{i,1} - 1</script>;</li><li> The maximum among such <span class="MathJax_Preview">j</span><script type="math/tex">j</script> that <span class="MathJax_Preview">b_{j,1} = b_{i,1}</span><script type="math/tex">b_{j,1} = b_{i,1}</script>.</li></ul><p>The answer is <span class="MathJax_Preview">n - \max_{1 \leq i \leq n}(dp_i)</span><script type="math/tex">n - \max_{1 \leq i \leq n}(dp_i)</script></p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/E" title="Pinely Round 5 (Div. 1 + Div. 2)">2161E - Left is Always Right</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let <span class="MathJax_Preview">[l, r]</span><script type="math/tex">[l, r]</script> be the substring <span class="MathJax_Preview">s_l \ldots s_r</span><script type="math/tex">s_l \ldots s_r</script>, and <span class="MathJax_Preview">d[l, r]</span><script type="math/tex">d[l, r]</script> be (number of 1s) minus (number of 0s) among <span class="MathJax_Preview">s_l, \ldots, s_r</span><script type="math/tex">s_l, \ldots, s_r</script>.</p><p>Consider <span class="MathJax_Preview">d[1, k]</span><script type="math/tex">d[1, k]</script>. Note that it can't be 0 since <span class="MathJax_Preview">k</span><script type="math/tex">k</script> is odd. In the sequel we assume <span class="MathJax_Preview">d[1, k] &gt; 0</span><script type="math/tex">d[1, k] > 0</script> (the other case is fully symmetrical, and the answers for both options should just be added together).</p><p>We must then have <span class="MathJax_Preview">s_1 = 1</span><script type="math/tex">s_1 = 1</script>. If <span class="MathJax_Preview">d[1, k] &gt; 1</span><script type="math/tex">d[1, k] > 1</script> and <span class="MathJax_Preview">k &lt; n</span><script type="math/tex">k < n</script>, then <span class="MathJax_Preview">d[2, k + 1] \geq 1</span><script type="math/tex">d[2, k + 1] \geq 1</script>, therefore <span class="MathJax_Preview">s_2</span><script type="math/tex">s_2</script> is also <span class="MathJax_Preview">1</span><script type="math/tex">1</script>. Otherwise we have <span class="MathJax_Preview">d[2, k] = 0</span><script type="math/tex">d[2, k] = 0</script>, and <span class="MathJax_Preview">s_2 = s_{k + 1}</span><script type="math/tex">s_2 = s_{k + 1}</script> since <span class="MathJax_Preview">s_{k + 1}</span><script type="math/tex">s_{k + 1}</script> determines the majority in <span class="MathJax_Preview">[2, k + 1]</span><script type="math/tex">[2, k + 1]</script>.</p><p>Continuing these comparisons to the right, we have one of two options: </p><ul> <li> There is a first position <span class="MathJax_Preview">l \leq n - k + 1</span><script type="math/tex">l \leq n - k + 1</script> such that <span class="MathJax_Preview">d[l, l + k - 1] = 1</span><script type="math/tex">d[l, l + k - 1] = 1</script>. Then <span class="MathJax_Preview">s_1 = \ldots = s_l = 1</span><script type="math/tex">s_1 = \ldots = s_l = 1</script>, and since <span class="MathJax_Preview">d[l + 1, l + k - 1] = 0</span><script type="math/tex">d[l + 1, l + k - 1] = 0</script>, the rest of <span class="MathJax_Preview">s</span><script type="math/tex">s</script> is fully determined by copying characters in <span class="MathJax_Preview">[l + 1, l + k - 1]</span><script type="math/tex">[l + 1, l + k - 1]</script> with period <span class="MathJax_Preview">k</span><script type="math/tex">k</script>. Note that in this case, if <span class="MathJax_Preview">l &gt; 1</span><script type="math/tex">l > 1</script>, then we can't have <span class="MathJax_Preview">s_{l + k - 1} = 1</span><script type="math/tex">s_{l + k - 1} = 1</script>, since otherwise <span class="MathJax_Preview">l - 1</span><script type="math/tex">l - 1</script> would be an earlier valid candidate. </li><li> For all <span class="MathJax_Preview">l \leq n - k + 1</span><script type="math/tex">l \leq n - k + 1</script> we have <span class="MathJax_Preview">d[l, l + k - 1] &gt; 1</span><script type="math/tex">d[l, l + k - 1] > 1</script>. Then <span class="MathJax_Preview">s_1 = \ldots = s_{n - k + 1} = 1</span><script type="math/tex">s_1 = \ldots = s_{n - k + 1} = 1</script>, and the suffix <span class="MathJax_Preview">[n - k + 2, n]</span><script type="math/tex">[n - k + 2, n]</script> is arbitrary such that <span class="MathJax_Preview">d[n - k + 2, n] &gt; 0</span><script type="math/tex">d[n - k + 2, n] > 0</script>. </li></ul><p>We can enumerate valid strings satisfying these options separately. In the first case, for a fixed first position <span class="MathJax_Preview">l \leq n - k + 1</span><script type="math/tex">l \leq n - k + 1</script> we have to ensure all of the following: </p><ul> <li> <span class="MathJax_Preview">s_1 = \ldots = s_l = 1</span><script type="math/tex">s_1 = \ldots = s_l = 1</script>, </li><li> <span class="MathJax_Preview">d[l + 1, l + k - 1] = 0</span><script type="math/tex">d[l + 1, l + k - 1] = 0</script>, </li><li> <span class="MathJax_Preview">s_j = s_{j - k}</span><script type="math/tex">s_j = s_{j - k}</script> for all <span class="MathJax_Preview">j &gt; l + k</span><script type="math/tex">j > l + k</script>, </li><li> if <span class="MathJax_Preview">l &gt; 1</span><script type="math/tex">l > 1</script>, then <span class="MathJax_Preview">s_{l + k - 1} = 0</span><script type="math/tex">s_{l + k - 1} = 0</script>. </li></ul><p>Processing values of <span class="MathJax_Preview">l</span><script type="math/tex">l</script> from right to left, we can keep track of how much of the periodic suffix is fixed, namely, for each <span class="MathJax_Preview">j = l + 1, \ldots, l + k - 1</span><script type="math/tex">j = l + 1, \ldots, l + k - 1</script>, which non-? characters appear in the pattern in positions <span class="MathJax_Preview">j, j + k, \ldots</span><script type="math/tex">j, j + k, \ldots</script>. Assuming no contradictions arise, the number of valid suffixed can then be found as a binomial coefficient.</p><p>The case when all <span class="MathJax_Preview">d[l, l + k - 1] &gt; 1</span><script type="math/tex">d[l, l + k - 1] > 1</script> is somewhat easier, since we only need to count the number of ways to fill <span class="MathJax_Preview">[n - k + 2, n]</span><script type="math/tex">[n - k + 2, n]</script> such that the balance is positive; this is again a sum of binomials.</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/F" title="Pinely Round 5 (Div. 1 + Div. 2)">2161F - SubMST</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Consider a subset <span class="MathJax_Preview">S</span><script type="math/tex">S</script> of vertices, and its partition into connected components of the subgraph <span class="MathJax_Preview">G_S</span><script type="math/tex">G_S</script> if only those edges of <span class="MathJax_Preview">G</span><script type="math/tex">G</script> with weight at most <span class="MathJax_Preview">x</span><script type="math/tex">x</script> are considered. If <span class="MathJax_Preview">C(x)</span><script type="math/tex">C(x)</script> if the number of such components of <span class="MathJax_Preview">G_S</span><script type="math/tex">G_S</script>, the weight of MST can be found as <span class="MathJax_Preview">\sum_x x \cdot (C(x - 1) - C(x)) = \sum_x C(x)</span><script type="math/tex">\sum_x x \cdot (C(x - 1) - C(x)) = \sum_x C(x)</script>. Intuition: if <span class="MathJax_Preview">C(x - 1) - C(x) = k</span><script type="math/tex">C(x - 1) - C(x) = k</script>, then exactly <span class="MathJax_Preview">k</span><script type="math/tex">k</script> edges of weight <span class="MathJax_Preview">x</span><script type="math/tex">x</script> are going to be needed. </p><p> Let us provide a different way to describe the partition in terms of <span class="MathJax_Preview">T</span><script type="math/tex">T</script> that doesn't construct the graph explicitly.</p><p>Suppose that edges of <span class="MathJax_Preview">T</span><script type="math/tex">T</script> are subdivided: an edge of weight <span class="MathJax_Preview">w</span><script type="math/tex">w</script> becomes a chain of <span class="MathJax_Preview">2w</span><script type="math/tex">2w</script> edges, each new edge has weight <span class="MathJax_Preview">1/2</span><script type="math/tex">1/2</script>. For each <span class="MathJax_Preview">v \in S</span><script type="math/tex">v \in S</script>, put all vertices in the subdivided tree that are at distance at most <span class="MathJax_Preview">x/2</span><script type="math/tex">x/2</script> from <span class="MathJax_Preview">v</span><script type="math/tex">v</script> in the same component as <span class="MathJax_Preview">v</span><script type="math/tex">v</script>. Intuition: if any <span class="MathJax_Preview">v, u \in S</span><script type="math/tex">v, u \in S</script> are at distance at most <span class="MathJax_Preview">x</span><script type="math/tex">x</script> in <span class="MathJax_Preview">T</span><script type="math/tex">T</script>, they will share a component with the midpoint of the path <span class="MathJax_Preview">vu</span><script type="math/tex">vu</script>. On the other hand, separate component can never become connected because any pair of vertices is too far apart.</p><p>How do we find values of <span class="MathJax_Preview">x</span><script type="math/tex">x</script> when <span class="MathJax_Preview">C(x)</span><script type="math/tex">C(x)</script> changes? Consider a subdivided tree vertex <span class="MathJax_Preview">z</span><script type="math/tex">z</script>; we will say that <span class="MathJax_Preview">z</span><script type="math/tex">z</script> is a <span class="tex-font-style-it">point of contact</span> at time <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, if there at least two subtrees of <span class="MathJax_Preview">T</span><script type="math/tex">T</script> with respect to <span class="MathJax_Preview">z</span><script type="math/tex">z</script> such that the shortest distance between <span class="MathJax_Preview">z</span><script type="math/tex">z</script> and any <span class="MathJax_Preview">v \in S</span><script type="math/tex">v \in S</script> in the respective subtree is <span class="MathJax_Preview">x</span><script type="math/tex">x</script>. Intuition: that's exactly when a midpoint is reached by both ends. We are then going to find the answer by summing over all possible points of contact.</p><p>Let's now say that <span class="MathJax_Preview">S</span><script type="math/tex">S</script> is a random set, with probabilty of <span class="MathJax_Preview">v \in S</span><script type="math/tex">v \in S</script> equal to <span class="MathJax_Preview">1/2</span><script type="math/tex">1/2</script>. Which points of contact occur and with which probability?</p><ul><li> If <span class="MathJax_Preview">z</span><script type="math/tex">z</script> if an original vertex of <span class="MathJax_Preview">T</span><script type="math/tex">T</script>, we can find the probability distribution of the shortest distance to a <span class="MathJax_Preview">v \in S</span><script type="math/tex">v \in S</script> within each subtree with respect to <span class="MathJax_Preview">z</span><script type="math/tex">z</script>. The matching distances <span class="MathJax_Preview">d</span><script type="math/tex">d</script> between subtrees can be located, and <span class="MathJax_Preview">x = 2d</span><script type="math/tex">x = 2d</script> summed with corresponding probabilities easily enough.</li><li> If <span class="MathJax_Preview">z</span><script type="math/tex">z</script> belong to the proper interior of an edge <span class="MathJax_Preview">ab</span><script type="math/tex">ab</script>, we can still find probability distributions of closest <span class="MathJax_Preview">v \in S</span><script type="math/tex">v \in S</script> in the two halves of <span class="MathJax_Preview">T</span><script type="math/tex">T</script> with respect to the edge <span class="MathJax_Preview">ab</span><script type="math/tex">ab</script>. Suppose that the shortest distances end up being <span class="MathJax_Preview">d_1</span><script type="math/tex">d_1</script> and <span class="MathJax_Preview">d_2</span><script type="math/tex">d_2</script> respectively, and also that the length of <span class="MathJax_Preview">ab</span><script type="math/tex">ab</script> is <span class="MathJax_Preview">L</span><script type="math/tex">L</script>. A point of contact occurs somewhere on the edge <span class="MathJax_Preview">ab</span><script type="math/tex">ab</script> if and only if <span class="MathJax_Preview">|d_1 - d_2| &lt; L</span><script type="math/tex">|d_1 - d_2| < L</script>, with <span class="MathJax_Preview">x = d_1 + d_2 + L</span><script type="math/tex">x = d_1 + d_2 + L</script>. Summing this with respective probabilities can be done effiiciently with two pointers on the sorted probability distributions of <span class="MathJax_Preview">d_1, d_2</span><script type="math/tex">d_1, d_2</script>.</li></ul><p>The most demanding part of this is computing sorted distributions, which is done easiest if, for each vertex <span class="MathJax_Preview">v \in T</span><script type="math/tex">v \in T</script>, we have a separate list of all vertices <span class="MathJax_Preview">u \in T</span><script type="math/tex">u \in T</script> sorted by <span class="MathJax_Preview">\mathrm{dist}(u, v)</span><script type="math/tex">\mathrm{dist}(u, v)</script>. That is possible to do in <span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script> complexity in total.</p><p>Note: we've omitted the case where more than two directions come in contact simultaneously, but it is not that hard to handle (e.g. via considering subtrees of a proper vertex <span class="MathJax_Preview">z</span><script type="math/tex">z</script> one by one, and applying the usual treatment to "shortest distance in the new subtree" and "shortest distance among all the old subtrees").</p></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/G" title="Pinely Round 5 (Div. 1 + Div. 2)">2161G - Bitwise And Equals</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Let <span class="MathJax_Preview">up_X(z)</span><script type="math/tex">up_X(z)</script> be the lowest <span class="MathJax_Preview">y \ge z</span><script type="math/tex">y \ge z</script> such that <span class="MathJax_Preview">y \&amp; X = X</span><script type="math/tex">y \& X = X</script>. It's clear that <span class="MathJax_Preview">a'_k \ge up_X(a_k)</span><script type="math/tex">a'_k \ge up_X(a_k)</script> for all <span class="MathJax_Preview">k</span><script type="math/tex">k</script>. In fact in optimal solution at most one <span class="MathJax_Preview">a'_k \neq up_X(a_k)</span><script type="math/tex">a'_k \neq up_X(a_k)</script>. Indeed, if for some <span class="MathJax_Preview">k</span><script type="math/tex">k</script> that inequality holds, then <span class="MathJax_Preview">a'_k</span><script type="math/tex">a'_k</script> differs from <span class="MathJax_Preview">up_X(a_k)</span><script type="math/tex">up_X(a_k)</script> by changing one bit <span class="MathJax_Preview">b_k</span><script type="math/tex">b_k</script> from 0 to 1 and setting smaller bits equal to corresponding bits in <span class="MathJax_Preview">X</span><script type="math/tex">X</script>. Then over all <span class="MathJax_Preview">k</span><script type="math/tex">k</script> with condition <span class="MathJax_Preview">a'_k \neq up_X(a_k)</span><script type="math/tex">a'_k \neq up_X(a_k)</script> it's enough to change only one with highest <span class="MathJax_Preview">b_k</span><script type="math/tex">b_k</script>. </p><p>So for one test we need to calculate all <span class="MathJax_Preview">up_X(a_k)</span><script type="math/tex">up_X(a_k)</script>, find the highest bit in <span class="MathJax_Preview">(up_X(a_1) \,\&amp;\, up_X(a_2) \,\&amp;\, \ldots \,\&amp;\, up_X(a_n)) - X</span><script type="math/tex">(up_X(a_1) \,\&\, up_X(a_2) \,\&\, \ldots \,\&\, up_X(a_n)) - X</script> (let's call it <span class="MathJax_Preview">b</span><script type="math/tex">b</script>) and change one bit from <span class="MathJax_Preview">0</span><script type="math/tex">0</script> to <span class="MathJax_Preview">1</span><script type="math/tex">1</script> in <span class="MathJax_Preview">up_X(a_k)</span><script type="math/tex">up_X(a_k)</script> which is bigger than <span class="MathJax_Preview">b</span><script type="math/tex">b</script> (with corresponding change of lower bits). Here we need to be careful with the case when all but one values <span class="MathJax_Preview">a_k</span><script type="math/tex">a_k</script> contains some bit: We are not allowed to change this one.</p><p>We need to understand how to make this procedure fast enough. Let's start with calculating <span class="MathJax_Preview">\sum (up_X(a_k) - a_k)</span><script type="math/tex">\sum (up_X(a_k) - a_k)</script>. How to calculate <span class="MathJax_Preview">up_X(z)</span><script type="math/tex">up_X(z)</script> in a naive way? We need to find highest bit in <span class="MathJax_Preview">X</span><script type="math/tex">X</script> that is not contained in <span class="MathJax_Preview">z</span><script type="math/tex">z</script>, change this bit and set all smaller bits as in <span class="MathJax_Preview">X</span><script type="math/tex">X</script>. Let <span class="MathJax_Preview">x_1, \ldots, x_t</span><script type="math/tex">x_1, \ldots, x_t</script> are bits of <span class="MathJax_Preview">X</span><script type="math/tex">X</script> starting from highest. So to calculate <span class="MathJax_Preview">\sum (up_X(a_k) - a_k)</span><script type="math/tex">\sum (up_X(a_k) - a_k)</script> we need to</p><ul> <li> find all indices <span class="MathJax_Preview">i</span><script type="math/tex">i</script> that doesn't contains <span class="MathJax_Preview">x_1</span><script type="math/tex">x_1</script> and add <span class="MathJax_Preview">2^{x_1} + (X \&amp; (2^{x_1} - 1)) - (a_i \&amp; (2^{x_1} - 1))</span><script type="math/tex">2^{x_1} + (X \& (2^{x_1} - 1)) - (a_i \& (2^{x_1} - 1))</script> to the sum;</li><li> find all indices <span class="MathJax_Preview">i</span><script type="math/tex">i</script> that contains <span class="MathJax_Preview">x_1</span><script type="math/tex">x_1</script> and doesn't contain <span class="MathJax_Preview">x_2</span><script type="math/tex">x_2</script> and add <span class="MathJax_Preview">2^{x_2} + (X \&amp; (2^{x_2} - 1)) - (a_i \&amp; (2^{x_2} - 1))</span><script type="math/tex">2^{x_2} + (X \& (2^{x_2} - 1)) - (a_i \& (2^{x_2} - 1))</script> to the sum;<p>...</p></li><li> find all indices <span class="MathJax_Preview">i</span><script type="math/tex">i</script> that contains <span class="MathJax_Preview">x_t</span><script type="math/tex">x_t</script> and doesn't contain <span class="MathJax_Preview">x_1\, \ldots x_{t - 1}</span><script type="math/tex">x_1\, \ldots x_{t - 1}</script> and add <span class="MathJax_Preview">2^{x_t} + (X \&amp; (2^{x_t} - 1)) - (a_i \&amp; (2^{x_t} - 1))</span><script type="math/tex">2^{x_t} + (X \& (2^{x_t} - 1)) - (a_i \& (2^{x_t} - 1))</script> to the sum. </li></ul><p>Basically we need to calculate sum of expressions over all values that contains some set of zeros. We can precalculate these sums with <span class="MathJax_Preview">or</span><script type="math/tex">or</script>-convolution. </p><p>The rest is easy: We need to go over all bits <span class="MathJax_Preview">b</span><script type="math/tex">b</script> from highest to <span class="MathJax_Preview">x_1 + 1</span><script type="math/tex">x_1 + 1</script> and </p><ul> <li> if all numbers contains <span class="MathJax_Preview">1</span><script type="math/tex">1</script> in <span class="MathJax_Preview">b</span><script type="math/tex">b</script>-th bit, stop the procedure</li><li> if all but one contains <span class="MathJax_Preview">1</span><script type="math/tex">1</script> in <span class="MathJax_Preview">b</span><script type="math/tex">b</script>-th bit, skip the bit</li><li> if more than one contains <span class="MathJax_Preview">0</span><script type="math/tex">0</script> in <span class="MathJax_Preview">b</span><script type="math/tex">b</script>-th bit, choose <span class="MathJax_Preview">a_j</span><script type="math/tex">a_j</script> that doesn't contain this bit and has highest <span class="MathJax_Preview">a_j \&amp; (2^b - 1)</span><script type="math/tex">a_j \& (2^b - 1)</script> and set <span class="MathJax_Preview">1</span><script type="math/tex">1</script> for <span class="MathJax_Preview">b</span><script type="math/tex">b</script>-th bit (as before, lower bits should become equal to corresponding bits in <span class="MathJax_Preview">X</span><script type="math/tex">X</script>) and relax the result. </li></ul></div></div></div></div> <div><h3><a href="https://codeforces.com/contest/2161/problem/H" title="Pinely Round 5 (Div. 1 + Div. 2)">2161H - Cycle Sort</a></h3><div class="ttypography"><div class="problem-statement"><div><p>First, suppose that the arrays consist only of 0s and 1s.</p><p>Suppose we want to learn the final value of <span class="MathJax_Preview">b_i</span><script type="math/tex">b_i</script>. If <span class="MathJax_Preview">b_i = 1</span><script type="math/tex">b_i = 1</script> initially, it's never going to change. If <span class="MathJax_Preview">b_i = 0</span><script type="math/tex">b_i = 0</script>, then at times <span class="MathJax_Preview">t = i, i + m, i + 2m, \ldots</span><script type="math/tex">t = i, i + m, i + 2m, \ldots</script> we look at the current value of <span class="MathJax_Preview">a_{t \bmod n}</span><script type="math/tex">a_{t \bmod n}</script>; the first time we find <span class="MathJax_Preview">a_{t \bmod n} = 1</span><script type="math/tex">a_{t \bmod n} = 1</script> we put <span class="MathJax_Preview">b_i = 0</span><script type="math/tex">b_i = 0</script> and <span class="MathJax_Preview">a_{t \bmod n} = 1</span><script type="math/tex">a_{t \bmod n} = 1</script>. If no such <span class="MathJax_Preview">t &lt; k</span><script type="math/tex">t < k</script> is found, then <span class="MathJax_Preview">b_i</span><script type="math/tex">b_i</script> remains <span class="MathJax_Preview">1</span><script type="math/tex">1</script> throughout.</p><p>The same process can be modelled as follows: place "tokens" with numbers into positions <span class="MathJax_Preview">0, \ldots n-1</span><script type="math/tex">0, \ldots n-1</script> of the first array as follows: </p><ul> <li> If <span class="MathJax_Preview">a_i = 0</span><script type="math/tex">a_i = 0</script>, put a token with value <span class="MathJax_Preview">-\infty</span><script type="math/tex">-\infty</script> in its position. </li><li> If <span class="MathJax_Preview">b_j = 0</span><script type="math/tex">b_j = 0</script>, put a token with value <span class="MathJax_Preview">j</span><script type="math/tex">j</script> in position <span class="MathJax_Preview">j \bmod n</span><script type="math/tex">j \bmod n</script>. </li></ul><p>Meaning of a token <span class="MathJax_Preview">x</span><script type="math/tex">x</script> at position <span class="MathJax_Preview">i</span><script type="math/tex">i</script> is as follows: during operation <span class="MathJax_Preview">x</span><script type="math/tex">x</script> a zero from the second array is going to be compared against <span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script> (unless <span class="MathJax_Preview">x = -\infty</span><script type="math/tex">x = -\infty</script>, in which case <span class="MathJax_Preview">a_i = 0</span><script type="math/tex">a_i = 0</script> from the start).</p><p>With the tokens in place, we start applying the following operations: </p><ul> <li> If any token has <span class="MathJax_Preview">x \geq k</span><script type="math/tex">x \geq k</script>, it is discarded, and we conclude that <span class="MathJax_Preview">b_{x \bmod m} = 1</span><script type="math/tex">b_{x \bmod m} = 1</script>. </li><li> Otherwise, let <span class="MathJax_Preview">i</span><script type="math/tex">i</script> be any position which has more than one token. Then all tokens except for the smallest get moved to the position <span class="MathJax_Preview">(i + m) \bmod n</span><script type="math/tex">(i + m) \bmod n</script>, and <span class="MathJax_Preview">m</span><script type="math/tex">m</script> is added to each of their values. </li><li> If none of the above is applicable, terminate. Put final <span class="MathJax_Preview">a_i = 0</span><script type="math/tex">a_i = 0</script> if position <span class="MathJax_Preview">i</span><script type="math/tex">i</script> contains a token, and <span class="MathJax_Preview">1</span><script type="math/tex">1</script> otherwise. </li></ul><p>Observe that the order in which we apply the operations doesn't affect the final result.</p><p>To bridge with the original problem with numbers in <span class="MathJax_Preview">1, \ldots, n + m</span><script type="math/tex">1, \ldots, n + m</script>, consider a threshold <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, then replace all numbers less than <span class="MathJax_Preview">x</span><script type="math/tex">x</script> with 0s, and all numbers at least <span class="MathJax_Preview">x</span><script type="math/tex">x</script> with 1s. In the final configuration the 0s and 1s will still correspond to "small" and "large" values in some order.</p><p>Consider changing <span class="MathJax_Preview">x = 0, \ldots, n + m</span><script type="math/tex">x = 0, \ldots, n + m</script> in this order. Each time we increase <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, we may find the new final configuration and compare it with that of <span class="MathJax_Preview">x - 1</span><script type="math/tex">x - 1</script>. We argue that the only position among <span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script> and <span class="MathJax_Preview">b_i</span><script type="math/tex">b_i</script> that contains <span class="MathJax_Preview">1</span><script type="math/tex">1</script> for <span class="MathJax_Preview">x</span><script type="math/tex">x</script>, but <span class="MathJax_Preview">0</span><script type="math/tex">0</script> for <span class="MathJax_Preview">x-1</span><script type="math/tex">x-1</script>, is exactly the final placement of the number <span class="MathJax_Preview">x</span><script type="math/tex">x</script>. To solve the problem in reasonable time complexity we now need to handle the 0-1 token process efficiently, as well as support "change a single 1 to a 0" queries.</p><p>Note that if <span class="MathJax_Preview">\mathrm{GCD}(n, m) &gt; 1</span><script type="math/tex">\mathrm{GCD}(n, m) > 1</script>, we may reduce to <span class="MathJax_Preview">\mathrm{GCD}(n, m)</span><script type="math/tex">\mathrm{GCD}(n, m)</script> independent problems. Assume that <span class="MathJax_Preview">n</span><script type="math/tex">n</script> and <span class="MathJax_Preview">m</span><script type="math/tex">m</script> are coprime from now on. If that's the case, after placing the initial tokens, we can renumber <span class="MathJax_Preview">a_0, \ldots, a_{n - 1}</span><script type="math/tex">a_0, \ldots, a_{n - 1}</script> in such a way that the tokens from <span class="MathJax_Preview">i</span><script type="math/tex">i</script> are moved to <span class="MathJax_Preview">(i + 1) \bmod n</span><script type="math/tex">(i + 1) \bmod n</script> instead of <span class="MathJax_Preview">(i + m) \bmod n</span><script type="math/tex">(i + m) \bmod n</script>.</p><p>Suppose that for a threshold <span class="MathJax_Preview">x</span><script type="math/tex">x</script> both of the following conditions hold: </p><ul> <li> no tokens are ever expelled due to having <span class="MathJax_Preview">x \geq k</span><script type="math/tex">x \geq k</script> throughout the process, </li><li> the initial configuration of tokens has <span class="MathJax_Preview">c_i</span><script type="math/tex">c_i</script> tokens in position <span class="MathJax_Preview">i</span><script type="math/tex">i</script>. </li></ul><p>If we were only to determine which positions <span class="MathJax_Preview">i</span><script type="math/tex">i</script> contain tokens in the end, we could resort to a "bracket sequence balance"-like argument: for all <span class="MathJax_Preview">i \geq 0</span><script type="math/tex">i \geq 0</script>, we put </p><ul> <li> <span class="MathJax_Preview">\Delta_i = c_{i \bmod n} - 1</span><script type="math/tex">\Delta_i = c_{i \bmod n} - 1</script> to be the balance of the position <span class="MathJax_Preview">i</span><script type="math/tex">i</script> if the first array was repeated periodically (in practice two copies are enough). </li><li> <span class="MathJax_Preview">S_i = \sum_{j = 0}^i \Delta_j</span><script type="math/tex">S_i = \sum_{j = 0}^i \Delta_j</script>&nbsp;— the prefix sums. </li></ul><p>We argue that a position <span class="MathJax_Preview">i</span><script type="math/tex">i</script> doesn't contain a token in the end if and only if <span class="MathJax_Preview">S_{i + kn}</span><script type="math/tex">S_{i + kn}</script> is the unique minimum on the prefix <span class="MathJax_Preview">0, \ldots, i + kn</span><script type="math/tex">0, \ldots, i + kn</script> for all <span class="MathJax_Preview">k \geq 0</span><script type="math/tex">k \geq 0</script>. Intuition: we can think of each position to potentially "consume" a single token (hence the <span class="MathJax_Preview">-1</span><script type="math/tex">-1</script> in the definition of <span class="MathJax_Preview">\Delta)</span><script type="math/tex">\Delta)</script>. If <span class="MathJax_Preview">S_j - S_i \geq 0</span><script type="math/tex">S_j - S_i \geq 0</script>, then the space between <span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script> and <span class="MathJax_Preview">j</span><script type="math/tex">j</script> can't house enough tokens so that they become depleted as they are carried from <span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script> to <span class="MathJax_Preview">j</span><script type="math/tex">j</script>, therefore they must spill over to <span class="MathJax_Preview">j</span><script type="math/tex">j</script>.</p><p>While this is enough to process a single threshold <span class="MathJax_Preview">x</span><script type="math/tex">x</script> efficiently, we also need to process the "change <span class="MathJax_Preview">1 \to 0</span><script type="math/tex">1 \to 0</script>" queries, which essentially adds a token somewhere in the initial configuration. We do it as follows: </p><ul> <li> Modify the segment tree such that for a position <span class="MathJax_Preview">i</span><script type="math/tex">i</script> we store the value of the largest token visiting <span class="MathJax_Preview">i</span><script type="math/tex">i</script> at any point. To accomodate for segment tree operations, these values, as well as balance sums and minimums, are enough. </li><li> When we've added a token, check if a token with value <span class="MathJax_Preview">x \geq k</span><script type="math/tex">x \geq k</script> appears anywhere. If that is the case, we can argue that this token can never become settled as a minimum, and therefore can be removed from the initial configuration altogether. When this happens, we can also deduce that a particular <span class="MathJax_Preview">b_i</span><script type="math/tex">b_i</script> has become 1 in the final configuration. </li><li> Otherwise, some <span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script> has become 1. Its position can be found from considerations. Tl;dr: if the token was added at position <span class="MathJax_Preview">i</span><script type="math/tex">i</script>, locate which minimum positive segment of balances contains <span class="MathJax_Preview">i</span><script type="math/tex">i</script>, then find its new rightmost point. </li></ul></div></div></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2161" class="notice" style="text-decoration: none;">Pinely Round 5 (Div. 1 + Div. 2)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>