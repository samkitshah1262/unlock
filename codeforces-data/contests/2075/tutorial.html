<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tutorial</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
    }
    .ttypography {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h3 {
      color: #1a1a1a;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }
    h3 a {
      color: #0066cc;
      text-decoration: none;
    }
    h3 a:hover {
      text-decoration: underline;
    }
    .spoiler {
      margin: 15px 0;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
    }
    .spoiler-title {
      display: block;
      padding: 12px 15px;
      background: #f0f0f0;
      cursor: pointer;
      font-weight: 600;
      user-select: none;
      border-bottom: 1px solid #ddd;
    }
    .spoiler-title:hover {
      background: #e8e8e8;
    }
    .spoiler-title::before {
      content: '▶ ';
      font-size: 0.8em;
      transition: transform 0.2s;
      display: inline-block;
    }
    .spoiler.open .spoiler-title::before {
      content: '▼ ';
    }
    .spoiler-content {
      padding: 15px;
      background: #fff;
      display: none;
    }
    .spoiler.open .spoiler-content {
      display: block;
    }
    pre, code {
      background: #f5f5f5;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.85em;
    }
    pre {
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
    }
    code {
      padding: 2px 5px;
      border-radius: 3px;
    }
    p {
      margin: 10px 0;
    }
    .MathJax {
      font-size: 1.1em;
    }
  </style>
</head>
<body>
  <h1>Editorial</h1>
  <p><a href="https://codeforces.com/blog/entry/140781" target="_blank">View on Codeforces →</a></p>
  
  <div class="ttypography"><p><a href="https://codeforces.com/contest/2075/problem/A" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075A - To Zero</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2075/problem/A" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075A - To Zero</a></h3><div class="ttypography"><div class="problem-statement"><div><p>If you subtract an odd number from an odd number, you will get an even number. And if you subtract an even number from an even number, you will also get an even number. Therefore, after each operation, we obtain an even number.</p><p>Additionally, we can always subtract the maximum number that we can. If the result of the subtraction is less than $$$0$$$, we can simply use a smaller value of $$$x$$$ in the last operation.</p><p>Based on this, we can write the following solution: initially, if $$$n$$$ is odd, subtract $$$k$$$ from it to make it even (or do nothing if it is already even). Then subtract $$$(k-1)$$$ from the resulting $$$n$$$ until we reach $$$0$$$ or a negative number.</p><p>However, we may have to subtract $$$(k-1)$$$ from $$$n$$$ for a long time. Therefore, let's speed this up. We need to find the minimum number of operations $$$m$$$ such that $$$m(k-1) \ge n$$$. That is, $$$m$$$ is $$$\lceil \frac{n}{k-1} \rceil$$$ (the result of dividing $$$n$$$ by $$$(k-1)$$$, rounded up).</p><p>You can simply calculate $$$\lceil \frac{n}{k-1} \rceil$$$ using double precision floating-point numbers (type <span class="tex-font-style-tt">double</span>) and round it using some standard function like <span class="tex-font-style-tt">ceil</span>; in this problem, you won't have issues with calculation accuracy. However, with large values of $$$n$$$ and $$$k$$$, you may get an incorrect answer due to precision errors, so it's better to divide $$$n$$$ by $$$(k-1)$$$ with rounding up using integers. To divide the number $$$x$$$ by the number $$$y$$$ without using floating-point numbers, you can use one of two methods:</p><ul> <li> either perform integer division of $$$x$$$ by $$$y$$$ rounding down (this is standard integer division), and then add $$$1$$$ to the answer if $$$x \bmod y \ne 0$$$; </li><li> or divide $$$(x+y-1)$$$ by $$$y$$$ rounding down; this will automatically increase the answer by $$$1$$$ compared to dividing $$$x$$$ by $$$y$$$ if $$$x$$$ is not divisible by $$$y$$$. </li></ul></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (BledDest)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="pln">t </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">input</span><span class="pun">())</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> i </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="pln">t</span><span class="pun">):</span><span class="pln">
    n</span><span class="pun">,</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> map</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> input</span><span class="pun">().</span><span class="pln">split</span><span class="pun">())</span><span class="pln">
    ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> n </span><span class="pun">%</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pun">:</span><span class="pln">
        n </span><span class="pun">-=</span><span class="pln"> k
        ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
    k </span><span class="pun">-=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
    ans </span><span class="pun">+=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">+</span><span class="pln"> k </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="com">// k</span><span class="pln">
    </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">)</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2075/problem/B" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075B - Array Recoloring</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2075/problem/B" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075B - Array Recoloring</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Since the cost depends on the first $$$k$$$ painted elements and the last one, it cannot exceed the sum of $$$(k+1)$$$ maximum elements of the array. In fact, in most cases, you can get exactly that cost.</p><p>Let $$$k \ge 2$$$ and the positions of the $$$(k+1)$$$ maxima are $$$p_1, p_2, \dots, p_k, p_{k+1}$$$. In this case, you can initially color the elements $$$p_1, p_3, \dots, p_k, p_{k + 1}$$$, then all except $$$p_2$$$, and then color the element $$$p_2$$$ last. So the cost is exactly the sum of $$$(k+1)$$$ maxima. This works because the element we want to color last is between two elements we choose initially.</p><p>However, if $$$k=1$$$, then whatever element we choose and how we color the remaining elements, the first or the last element of the array will be the last to be colored. Therefore, in this case, you can consider two options (and pick the one with the maximum cost): the element among the first $$$(n-1)$$$ positions is painted first, and the $$$n$$$-th element is painted last; or the element among the last $$$(n-1)$$$ positions is painted first, and the $$$1$$$-st element is painted last.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (Neon)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">
    vector</span><span class="str">&lt;int&gt;</span><span class="pln"> a</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">x </span><span class="pun">:</span><span class="pln"> a</span><span class="pun">)</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      sort</span><span class="pun">(</span><span class="pln">a</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> a</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(),</span><span class="pln"> greater</span><span class="str">&lt;int&gt;</span><span class="pun">());</span><span class="pln">
      ans </span><span class="pun">=</span><span class="pln"> accumulate</span><span class="pun">(</span><span class="pln">a</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> a</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> k </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0LL</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> l </span><span class="pun">=</span><span class="pln"> </span><span class="pun">*</span><span class="pln">max_element</span><span class="pun">(</span><span class="pln">a</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> a</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">()</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> </span><span class="pun">*</span><span class="pln">max_element</span><span class="pun">(</span><span class="pln">a</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">()</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">());</span><span class="pln">
      ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">l </span><span class="pun">+</span><span class="pln"> a</span><span class="pun">.</span><span class="pln">back</span><span class="pun">(),</span><span class="pln"> r </span><span class="pun">+</span><span class="pln"> a</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2075/problem/C" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075C - Two Colors</a></p><p>Idea: <a class="rated-user user-violet" href="https://codeforces.com/profile/fcspartakm" title="Candidate Master fcspartakm">fcspartakm</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2075/problem/C" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075C - Two Colors</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Consider a general form of a fence: the planks from $$$1$$$ to $$$k$$$ are painted in one color, and the planks from $$$k + 1$$$ to $$$n$$$ are painted in another color.</p><p>Let's iterate over the value of $$$k$$$. It is then easy to determine which colors are suitable for the first half and which are suitable for the second half. Any color with $$$a_i \ge k$$$ will work for the first half, while for the second half, the colors must satisfy $$$a_i \ge n - k$$$. If we sort the values of $$$a_i$$$ in non-decreasing order, we can find the number of available colors using binary search. In C++, we can use lower_bound, and in Python, we can use bisect.bisect_left.</p><p>Let there be $$$x$$$ candidates for the first half and $$$y$$$ candidates for the second half. We would like the number of ways to choose two colors to be equal to $$$x \cdot y$$$. However, we have accidentally counted cases where we chose the same color for both halves of the fence. The number of such cases is $$$\min(x, y)$$$, as that color must be sufficient for both halves. Therefore, the contribution of $$$k$$$ to the answer is $$$x \cdot y - \min(x, y)$$$.</p><p>Sum up the answers for all $$$k$$$ to obtain the final answer to the problem.</p><p>Overall complexity: $$$O((n + m) \log m)$$$ for each test case.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (awoo)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="kwd">from</span><span class="pln"> bisect </span><span class="kwd">import</span><span class="pln"> bisect_left

</span><span class="kwd">for</span><span class="pln"> _ </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">(</span><span class="pln">input</span><span class="pun">())):</span><span class="pln">
    n</span><span class="pun">,</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> map</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> input</span><span class="pun">().</span><span class="pln">split</span><span class="pun">())</span><span class="pln">
    a </span><span class="pun">=</span><span class="pln"> sorted</span><span class="pun">(</span><span class="pln">list</span><span class="pun">(</span><span class="pln">map</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> input</span><span class="pun">().</span><span class="pln">split</span><span class="pun">())))</span><span class="pln">
    ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> k </span><span class="kwd">in</span><span class="pln"> range</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">):</span><span class="pln">
        x </span><span class="pun">=</span><span class="pln"> m </span><span class="pun">-</span><span class="pln"> bisect_left</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> k</span><span class="pun">)</span><span class="pln">
        y </span><span class="pun">=</span><span class="pln"> m </span><span class="pun">-</span><span class="pln"> bisect_left</span><span class="pun">(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> k</span><span class="pun">)</span><span class="pln">
        ans </span><span class="pun">+=</span><span class="pln"> x </span><span class="pun">*</span><span class="pln"> y </span><span class="pun">-</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">)</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2075/problem/D" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075D - Equalization</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2075/problem/D" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075D - Equalization</a></h3><div class="ttypography"><div class="problem-statement"><div><p>Note that for any positive integer $$$x$$$, the following equality holds: $$$\left\lfloor\frac{\left\lfloor\frac{x}{2^a}\right\rfloor}{2^b}\right\rfloor = \left\lfloor\frac{x}{2^{a+b}}\right\rfloor$$$. This means that for each number, only the total power of two by which it will be divided is significant.</p><p>Due to the restriction that the same power of two cannot be used twice, we can divide all powers (in this problem, we can consider powers from $$$1$$$ to $$$60$$$) into three groups: the powers by which $$$x$$$ will be divided; the powers by which $$$y$$$ will be divided; and the powers that will not be used.</p><p>However, there may be many suitable partitions, but we need to minimize the cost. To do so, we can use dynamic programming to calculate $$$dp_{k, i, j}$$$&nbsp;— the minimum cost if we considered the first $$$k$$$ powers, with the sum of the first group equal to $$$i$$$ and the sum of the second group equal to $$$j$$$. The transitions in this dynamic programming are straightforward: either we add the next power to the first group, or to the second, or we exclude it.</p><p>Note that this dynamic programming can be computed once and then used to calculate the answer for any given test case. Using this dynamic programming, the answer can be computed as follows: iterate over $$$i$$$ and $$$j$$$ such that $$$\left\lfloor\frac{x}{2^i}\right\rfloor = \left\lfloor\frac{y}{2^j}\right\rfloor$$$, and select the minimum among the values $$$dp_{60, i, j}$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (Neon)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">using</span><span class="pln"> li </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> B </span><span class="pun">=</span><span class="pln"> </span><span class="lit">60</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> li INF </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1e18</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  ios</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln"> cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
  array</span><span class="pun">&lt;</span><span class="pln">array</span><span class="pun">&lt;</span><span class="pln">li</span><span class="pun">,</span><span class="pln"> B</span><span class="pun">&gt;,</span><span class="pln"> B</span><span class="pun">&gt;</span><span class="pln"> dp</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> INF</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  dp</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> x </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> B </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">--</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> B </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span><span class="pun">--</span><span class="pln">j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> INF</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> x </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">)</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> x</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">dp</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> x</span><span class="pun">][</span><span class="pln">j</span><span class="pun">],</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1LL</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> x</span><span class="pun">));</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j </span><span class="pun">+</span><span class="pln"> x </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">)</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j </span><span class="pun">+</span><span class="pln"> x</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j </span><span class="pun">+</span><span class="pln"> x</span><span class="pun">],</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1LL</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> x</span><span class="pun">));</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    li x</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> x </span><span class="pun">&gt;&gt;</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
    li ans </span><span class="pun">=</span><span class="pln"> INF</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;</span><span class="pln"> B</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">x </span><span class="pun">&gt;&gt;</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="pun">(</span><span class="pln">y </span><span class="pun">&gt;&gt;</span><span class="pln"> j</span><span class="pun">))</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'\n'</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2075/problem/E" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075E - XOR Matrix</a></p><p>Idea: <a class="rated-user user-red" href="https://codeforces.com/profile/BledDest" title="International Grandmaster BledDest">BledDest</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2075/problem/E" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075E - XOR Matrix</a></h3><div class="ttypography"><div class="problem-statement"><div><p>If there are at least three pairwise distinct elements in one of the two arrays ($$$a$$$ and $$$b$$$), then there will also be at least three distinct elements in the matrix. Therefore, we can assume that the number of distinct elements in each of the arrays does not exceed $$$2$$$.</p><p>This allows us to construct the answer from the following parts:</p><ol> <li> the number of pairs of arrays where all elements in $$$a$$$ are the same and all elements in $$$b$$$ are the same; </li><li> the number of pairs of arrays where all elements in $$$a$$$ are the same, and the number of distinct elements in $$$b$$$ is $$$2$$$; </li><li> the number of pairs of arrays where the number of distinct elements in $$$a$$$ is $$$2$$$, and all elements in $$$b$$$ are the same; </li><li> the number of pairs of arrays where both $$$a$$$ and $$$b$$$ have two distinct elements each. </li></ol><p>The first part of the answer is simply $$$(A+1) \cdot (B+1)$$$, as we can choose which number all elements in $$$A$$$ will equal, and which number all elements in $$$B$$$ will equal.</p><p>The second and third parts are very similar to each other. Therefore, we will explain how the second part is calculated, and the third can be computed similarly. We can choose which number will be in $$$a$$$, and the number of ways to do this is $$$(A+1)$$$. We can also choose which two numbers will be in $$$b$$$, which can be done in $$$\frac{B(B+1)}{2}$$$ ways. Additionally, we need to choose the positions in $$$b$$$ where the first number will be; the number of ways to do this is $$$2^m - 2$$$ (not $$$2^m$$$, since we need to exclude the cases where the same number appears in all positions). Therefore, the second part of the answer is $$$(A+1) \cdot \frac{B(B+1)}{2} \cdot (2^m-2)$$$.</p><p>The fourth part is the most complex. The main problem is that it is important which specific values we choose for the arrays $$$a$$$ and $$$b$$$. Let all elements of $$$a$$$ be either $$$a_1$$$ or $$$a_2$$$ ($$$a_1 &gt; a_2$$$), and all elements of $$$b$$$ be either $$$b_1$$$ or $$$b_2$$$ ($$$b_1 &gt; b_2$$$). Then for this quadruple $$$(a_1, a_2, b_1, b_2)$$$, there are $$$(2^n-2) \cdot (2^m-2)$$$ ways to choose which positions in which arrays correspond to which numbers. This must be multiplied by the number of suitable quadruples, so let's learn how to count them.</p><p>We are interested in quadruples of numbers $$$(a_1, a_2, b_1, b_2)$$$ that satisfy the conditions:</p><ul> <li> $$$0 \le a_2 &lt; a_1 \le A$$$; </li><li> $$$0 \le b_2 &lt; b_1 \le B$$$; </li><li> $$$a_1 \oplus b_2 = a_2 \oplus b_1$$$ (otherwise, we will have more than two distinct values in the matrix, since $$$a_1 \oplus b_1 \ne a_1 \oplus b_2$$$). This condition is also equivalent to $$$a_1 \oplus b_1 = a_2 \oplus b_2$$$, so if it holds, there are exactly two distinct values in the matrix. </li></ul><p>The third condition can be rewritten as $$$a_1 \oplus a_2 = b_1 \oplus b_2$$$. Let's then count not the quadruples $$$(a_1, a_2, b_1, b_2)$$$, but the triples $$$(a_1, b_1, x)$$$ such that $$$0 \le a_1 \oplus x &lt; a_1 \le A$$$ and $$$0 \le b_1 \oplus x &lt; b_1 \le B$$$.</p><p>This can be done using digit dynamic programming on the bits of these three numbers from the most significant to the least significant. Let $$$dp[i][f_a][f_b][f_x]$$$ be the number of ways to set the $$$i$$$ most significant bits in these three numbers such that:</p><ul> <li> $$$f_a = 0$$$, if the number $$$a_1$$$ is still equal to the upper limit $$$A$$$, or $$$f_a = 1$$$, if it is definitely less; </li><li> $$$f_b = 0$$$, if the number $$$b_1$$$ is still equal to the upper limit $$$B$$$, or $$$f_b = 1$$$, if it is definitely less; </li><li> $$$f_x = 0$$$, if the number $$$x$$$ is still equal to $$$0$$$, or $$$f_x = 1$$$, if it is definitely not $$$0$$$. </li></ul><p>Transitions in this dynamic programming are done as follows: we iterate over which values will be in the next bit of these three numbers, check that this does not violate any conditions, and observe how the values of $$$f_a, f_b, f_x$$$ change.</p><p>What conditions do we need to check?</p><ul> <li> We need to ensure that $$$a_1 \le A$$$, so if $$$f_a$$$ is $$$0$$$ and the next bit in $$$A$$$ is $$$0$$$, we cannot set $$$1$$$ in the next bit of $$$a_1$$$; </li><li> We need to ensure that $$$b_1 \le B$$$ (similarly); </li><li> We need to ensure that $$$a_1 \oplus x &lt; a_1$$$, so if $$$f_x$$$ is $$$0$$$ and we set the next bit in $$$a_1$$$ to $$$0$$$, this bit must also be $$$0$$$ in the number $$$x$$$; </li><li> We need to ensure that $$$b_1 \oplus x &lt; b_1$$$ (similarly). </li></ul><p>The flags $$$f_a, f_b, f_x$$$ are recalculated quite trivially, and we will not discuss this in detail in the explanation.</p><p>The answer should be collected from all states of the form $$$dp[K][f_a][f_b][1]$$$, where $$$K$$$ is the number of bits in the numbers. This way, we will obtain the number of pairs $$$(a_1, a_2, b_1, b_2)$$$ that can be used.</p><p>This dynamic programming is the most computationally intensive part of the solution, so the entire solution works in $$$O(\log \max(A,B))$$$, but with a very large constant in the asymptotic notation.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (BledDest)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> MOD </span><span class="pun">=</span><span class="pln"> </span><span class="lit">998244353</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> K </span><span class="pun">=</span><span class="pln"> </span><span class="lit">31</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    x </span><span class="pun">+=</span><span class="pln"> y</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">x </span><span class="pun">&gt;=</span><span class="pln"> MOD</span><span class="pun">)</span><span class="pln"> x </span><span class="pun">-=</span><span class="pln"> MOD</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">x </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> x </span><span class="pun">+=</span><span class="pln"> MOD</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> </span><span class="kwd">sub</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="pln">y</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> mul</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">x </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1ll</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> y</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> MOD</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> binpow</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> y</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> z </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">y</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">y </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> z </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">z</span><span class="pun">,</span><span class="pln"> x</span><span class="pun">);</span><span class="pln">
        x </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">x</span><span class="pun">,</span><span class="pln"> x</span><span class="pun">);</span><span class="pln">
        y </span><span class="pun">&gt;&gt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> z</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">K</span><span class="pun">][</span><span class="lit">2</span><span class="pun">][</span><span class="lit">2</span><span class="pun">][</span><span class="lit">2</span><span class="pun">];</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> choose2</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> mul</span><span class="pun">(</span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> binpow</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> MOD </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">   
 
</span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">,</span><span class="pln"> A</span><span class="pun">,</span><span class="pln"> B</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n </span><span class="pun">&gt;&gt;</span><span class="pln"> m </span><span class="pun">&gt;&gt;</span><span class="pln"> A </span><span class="pun">&gt;&gt;</span><span class="pln"> B</span><span class="pun">;</span><span class="pln">
 
    memset</span><span class="pun">(</span><span class="pln">dp</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pln"> dp</span><span class="pun">);</span><span class="pln">
    dp</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> K</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> f1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> f1 </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> f1</span><span class="pun">++)</span><span class="pln">
            </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> f2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> f2 </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> f2</span><span class="pun">++)</span><span class="pln">
                </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> fx </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> fx </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> fx</span><span class="pun">++)</span><span class="pln">
                </span><span class="pun">{</span><span class="pln">
                    </span><span class="kwd">int</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">f1</span><span class="pun">][</span><span class="pln">f2</span><span class="pun">][</span><span class="pln">fx</span><span class="pun">];</span><span class="pln">
                    </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln">d</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
                    </span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> K </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> i</span><span class="pun">;</span><span class="pln">
                    </span><span class="kwd">int</span><span class="pln"> curA </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">A </span><span class="pun">&gt;&gt;</span><span class="pln"> j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
                    </span><span class="kwd">int</span><span class="pln"> curB </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">B </span><span class="pun">&gt;&gt;</span><span class="pln"> j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
                    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> bit_a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> bit_a </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> bit_a</span><span class="pun">++)</span><span class="pln">
                        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> bit_b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> bit_b </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> bit_b</span><span class="pun">++)</span><span class="pln">
                            </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> bit_x </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> bit_x </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> bit_x</span><span class="pun">++)</span><span class="pln">
                            </span><span class="pun">{</span><span class="pln">
                                </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">f1 </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> bit_a </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> curA </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
                                </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">f2 </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> bit_b </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> curB </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
                                </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">fx </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> bit_x </span><span class="pun">==</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">bit_a </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> bit_b </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">))</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
                                </span><span class="kwd">int</span><span class="pln"> nf1 </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">f1</span><span class="pun">,</span><span class="pln"> bit_a </span><span class="pun">^</span><span class="pln"> curA</span><span class="pun">);</span><span class="pln">
                                </span><span class="kwd">int</span><span class="pln"> nf2 </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">f2</span><span class="pun">,</span><span class="pln"> bit_b </span><span class="pun">^</span><span class="pln"> curB</span><span class="pun">);</span><span class="pln">
                                </span><span class="kwd">int</span><span class="pln"> nfx </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">fx</span><span class="pun">,</span><span class="pln"> bit_x</span><span class="pun">);</span><span class="pln">
                                </span><span class="kwd">int</span><span class="pun">&amp;</span><span class="pln"> d2 </span><span class="pun">=</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">nf1</span><span class="pun">][</span><span class="pln">nf2</span><span class="pun">][</span><span class="pln">nfx</span><span class="pun">];</span><span class="pln">
                                d2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">d2</span><span class="pun">,</span><span class="pln"> d</span><span class="pun">);</span><span class="pln">
                            </span><span class="pun">}</span><span class="pln">
                </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> pairs_of_pairs </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
        </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln">
            pairs_of_pairs </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">pairs_of_pairs</span><span class="pun">,</span><span class="pln"> dp</span><span class="pun">[</span><span class="pln">K </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">][</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
 
    </span><span class="kwd">int</span><span class="pln"> comb_a </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">binpow</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">),</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> comb_b </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">sub</span><span class="pun">(</span><span class="pln">binpow</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> m</span><span class="pun">),</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln">
 
    </span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">pairs_of_pairs</span><span class="pun">,</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">comb_a</span><span class="pun">,</span><span class="pln"> comb_b</span><span class="pun">));</span><span class="pln">
    ans </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> mul</span><span class="pun">(</span><span class="kwd">add</span><span class="pun">(</span><span class="pln">A</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">B</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)));</span><span class="pln">
    ans </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> mul</span><span class="pun">(</span><span class="kwd">add</span><span class="pun">(</span><span class="pln">A</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">comb_b</span><span class="pun">,</span><span class="pln"> choose2</span><span class="pun">(</span><span class="kwd">add</span><span class="pun">(</span><span class="pln">B</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)))));</span><span class="pln">
    ans </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> mul</span><span class="pun">(</span><span class="kwd">add</span><span class="pun">(</span><span class="pln">B</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> mul</span><span class="pun">(</span><span class="pln">comb_a</span><span class="pun">,</span><span class="pln"> choose2</span><span class="pun">(</span><span class="kwd">add</span><span class="pun">(</span><span class="pln">A</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)))));</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> solve</span><span class="pun">();</span><span class="pln">    
</span><span class="pun">}</span></code></pre></div></div><p><a href="https://codeforces.com/contest/2075/problem/F" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075F - Beautiful Sequence Returns</a></p><p>Idea: <a class="rated-user user-orange" href="https://codeforces.com/profile/adedalic" title="International Master adedalic">adedalic</a></p> <div class="spoiler"><b class="spoiler-title">Tutorial</b><div class="spoiler-content" style="display: block;"><div><h3><a href="https://codeforces.com/contest/2075/problem/F" title="Educational Codeforces Round 176 (Rated for Div. 2)">2075F - Beautiful Sequence Returns</a></h3><div class="ttypography"><div class="problem-statement"><div><p>For the start, let's note that the definition of the beauty of a sequence is equivalent to the following: a sequence is <span class="tex-font-style-it">beautiful</span> if and only if the first element is a unique minimum and the last element is a unique maximum.</p><p>Next, consider each element of the array as a point in $$$2D$$$: let's transform $$$a_i$$$ into the point $$$(i, a_i)$$$. Observe that the length of the longest beautiful subsequence can be found as follows: </p><ol> <li> iterate over the position $$$i$$$ of the start of the subsequence and the position $$$j$$$ of the end of the subsequence; </li><li> look at the rectangle where the bottom left point is $$$(i, a_i)$$$ and the top right point is $$$(j, a_j)$$$; </li><li> take the corners and all points that lie strictly inside this rectangle. </li></ol> The algorithm described above will definitely find the answer, but it works too slowly, so let's try to speed it up.<p>Notice that if the chosen point $$$(i, a_i)$$$ has another point $$$i'$$$, such that $$$i' &lt; i$$$ and $$$a_{i'} \le a_i$$$, then the answer for $$$i'$$$ will definitely be no worse than for $$$i$$$, which means we do not need to check the answer for $$$i$$$. Therefore, let's write down in a separate array $$$\mathrm{left}$$$ only those elements that make sense to choose as the bottom left corners of the rectangle. These will be indices $$$i$$$ such that for all $$$i' &lt; i$$$, $$$a_{i'} &gt; a_i$$$ (we will call them prefix minimums).</p><p>Note that the resulting array $$$\mathrm{left}$$$ has interesting monotonicity properties: $$$\mathrm{left}_k &lt; \mathrm{left}_{k+1}$$$ and at the same time $$$a[\mathrm{left}_k] &gt; a[\mathrm{left}_{k + 1}]$$$. Therefore, if we look at an arbitrary point $$$(x, a_x)$$$, the left corners of the rectangles it falls into form an <span class="tex-font-style-bf">interval</span> $$$\mathrm{seg}_x = [l, r)$$$ in the array $$$\mathrm{left}$$$, the boundaries of which can be found using binary search: </p><ul> <li> $$$l$$$ is the minimum $$$l$$$ such that $$$a[\mathrm{left}_l] &lt; a[x]$$$; </li><li> $$$r$$$ is the minimum $$$r$$$ such that $$$\mathrm{left}_r \ge x$$$. </li></ul> Thus, for each point, we can precompute which bottom left corners are "suitable" for it.<p>Now, let's note that a similar situation occurs with the top right point: we are only interested in points that form "suffix maximums". They will have similar monotonicity: as we move from right to left, the values $$$a_k$$$ will only increase.</p><p>Therefore, let's iterate over the right corner of the rectangle from right to left, maintaining the necessary information for all left corners. Specifically, we will "include" and "exclude" points, and for each left corner, we will keep track of how many included points are located to its top right.</p><p>Assume that for the current right corner $$$k$$$, we have included only points that lie strictly to its bottom left. Then we can already find the answer for it as follows: let's take the maximum over the left corners from the interval $$$\mathrm{seg}_k$$$&nbsp;— only these corners can be bottom left for the current corner, and the necessary values are already there.</p><p>When we need to move from the right corner $$$k$$$ to the corner $$$k' &lt; k$$$, we know that $$$a[k'] &gt; a[k]$$$. Therefore, we need to: </p><ol> <li> include all points $$$x$$$ for which $$$a[k] \le a[x] &lt; a[k']$$$; </li><li> exclude all points $$$x$$$ for which $$$k' \le x &lt; k$$$. </li></ol><p>Including/excluding a point is simply adding $$$\pm 1$$$ over the interval $$$\mathrm{seg}_x$$$.</p><p>Note that each point is included and excluded no more than once, which means there will be no more than $$$2n$$$ operations of addition over the segment.</p><p>To handle the addition over a segment and the maximum over a segment, it is sufficient to use a Segment Tree. Thus, the resulting asymptotic complexity is $$$O(n \log{n})$$$.</p></div></div></div></div></div></div> <div class="spoiler"><b class="spoiler-title">Solution (adedalic)</b><div class="spoiler-content" style="display: block;"><pre><code class="prettyprint prettyprinted" style=""><span class="com">#include</span><span class="pun">&lt;</span><span class="pln">bits</span><span class="pun">/</span><span class="pln">stdc</span><span class="pun">++.</span><span class="pln">h</span><span class="pun">&gt;</span><span class="pln">
 
</span><span class="kwd">using</span><span class="pln"> </span><span class="kwd">namespace</span><span class="pln"> std</span><span class="pun">;</span><span class="pln">
 
</span><span class="com">#define</span><span class="pln"> fore</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">for</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">l</span><span class="pun">);</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">r</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
</span><span class="com">#define</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">a</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">((</span><span class="pln">a</span><span class="pun">).</span><span class="pln">size</span><span class="pun">())</span><span class="pln">
 
</span><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> </span><span class="kwd">long</span><span class="pln"> li</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">typedef</span><span class="pln"> pair</span><span class="pun">&lt;</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">&gt;</span><span class="pln"> pt</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> INF </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="lit">1e9</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> li INF64 </span><span class="pun">=</span><span class="pln"> li</span><span class="pun">(</span><span class="lit">1e18</span><span class="pun">);</span><span class="pln">
 
vector</span><span class="str">&lt;int&gt;</span><span class="pln"> </span><span class="typ">Tadd</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Tmax</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> getmax</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Tmax</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="typ">Tadd</span><span class="pun">[</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">void</span><span class="pln"> push</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="typ">Tadd</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> </span><span class="typ">Tadd</span><span class="pun">[</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
	</span><span class="typ">Tadd</span><span class="pun">[</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> </span><span class="typ">Tadd</span><span class="pun">[</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
	</span><span class="typ">Tadd</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">void</span><span class="pln"> upd</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="typ">Tmax</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">getmax</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln"> getmax</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">void</span><span class="pln"> addVal</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> r</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> lf</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> rg</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> val</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">l </span><span class="pun">==</span><span class="pln"> lf </span><span class="pun">&amp;&amp;</span><span class="pln"> r </span><span class="pun">==</span><span class="pln"> rg</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="typ">Tadd</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> val</span><span class="pun">;</span><span class="pln">
		</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	push</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> mid </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">l </span><span class="pun">+</span><span class="pln"> r</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lf </span><span class="pun">&lt;</span><span class="pln"> mid</span><span class="pun">)</span><span class="pln">
		addVal</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> l</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">,</span><span class="pln"> lf</span><span class="pun">,</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">mid</span><span class="pun">,</span><span class="pln"> rg</span><span class="pun">),</span><span class="pln"> val</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">rg </span><span class="pun">&gt;</span><span class="pln"> mid</span><span class="pun">)</span><span class="pln">
		addVal</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">,</span><span class="pln"> r</span><span class="pun">,</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">lf</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">),</span><span class="pln"> rg</span><span class="pun">,</span><span class="pln"> val</span><span class="pun">);</span><span class="pln">
	upd</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">
vector</span><span class="str">&lt;int&gt;</span><span class="pln"> a</span><span class="pun">;</span><span class="pln">
 
</span><span class="kwd">inline</span><span class="pln"> </span><span class="kwd">bool</span><span class="pln"> read</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	</span><span class="kwd">if</span><span class="pun">(!(</span><span class="pln">cin </span><span class="pun">&gt;&gt;</span><span class="pln"> n</span><span class="pun">))</span><span class="pln">
		</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
	a</span><span class="pun">.</span><span class="pln">resize</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
	fore </span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln">
		cin </span><span class="pun">&gt;&gt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">inline</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> solve</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ask</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> mx </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> mx</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			ask</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
			mx </span><span class="pun">=</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> left</span><span class="pun">;</span><span class="pln">
	fore </span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">left</span><span class="pun">.</span><span class="pln">empty</span><span class="pun">()</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">left</span><span class="pun">.</span><span class="pln">back</span><span class="pun">()]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln">
			left</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
 
	vector</span><span class="str">&lt;pt&gt;</span><span class="pln"> seg</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
	fore </span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> lf </span><span class="pun">=</span><span class="pln"> upper_bound</span><span class="pun">(</span><span class="pln">left</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> left</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(),</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[&amp;</span><span class="pln">left</span><span class="pun">](</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">return</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
		</span><span class="pun">})</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> left</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">();</span><span class="pln">
		</span><span class="kwd">int</span><span class="pln"> rg </span><span class="pun">=</span><span class="pln"> lower_bound</span><span class="pun">(</span><span class="pln">left</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> left</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(),</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> left</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">();</span><span class="pln">
		seg</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">lf</span><span class="pun">,</span><span class="pln"> rg</span><span class="pun">};</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
 
	</span><span class="typ">Tadd</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">(</span><span class="lit">4</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="typ">Tmax</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">(</span><span class="lit">4</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
 
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> ordToAdd</span><span class="pun">(</span><span class="pln">n</span><span class="pun">);</span><span class="pln">
	iota</span><span class="pun">(</span><span class="pln">ordToAdd</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> ordToAdd</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(),</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	sort</span><span class="pun">(</span><span class="pln">ordToAdd</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> ordToAdd</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">(),</span><span class="pln"> </span><span class="pun">[](</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> j</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">return</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
	</span><span class="pun">});</span><span class="pln">
 
	</span><span class="kwd">auto</span><span class="pln"> addToSeg </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[&amp;</span><span class="pln">left</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">seg</span><span class="pun">](</span><span class="kwd">int</span><span class="pln"> id</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> val</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">[</span><span class="pln">lf</span><span class="pun">,</span><span class="pln"> rg</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> seg</span><span class="pun">[</span><span class="pln">id</span><span class="pun">];</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lf </span><span class="pun">&lt;</span><span class="pln"> rg</span><span class="pun">)</span><span class="pln">
			addVal</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> sz</span><span class="pun">(</span><span class="pln">left</span><span class="pun">),</span><span class="pln"> lf</span><span class="pun">,</span><span class="pln"> rg</span><span class="pun">,</span><span class="pln"> val</span><span class="pun">);</span><span class="pln">
	</span><span class="pun">};</span><span class="pln">
 
	</span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> pos </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
	vector</span><span class="str">&lt;int&gt;</span><span class="pln"> added</span><span class="pun">(</span><span class="pln">n</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pos </span><span class="pun">&lt;</span><span class="pln"> n </span><span class="pun">&amp;&amp;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">ordToAdd</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> a</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ordToAdd</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
				addToSeg</span><span class="pun">(</span><span class="pln">ordToAdd</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">],</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
				added</span><span class="pun">[</span><span class="pln">ordToAdd</span><span class="pun">[</span><span class="pln">pos</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
			</span><span class="pun">}</span><span class="pln">
			pos</span><span class="pun">++;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ask</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			</span><span class="kwd">auto</span><span class="pln"> </span><span class="pun">[</span><span class="pln">lf</span><span class="pun">,</span><span class="pln"> rg</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> seg</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
			ans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">ans</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">lf </span><span class="pun">&lt;</span><span class="pln"> rg </span><span class="pun">?</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> getmax</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">));</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
		</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">added</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
			addToSeg</span><span class="pun">(</span><span class="pln">i</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
			added</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
		</span><span class="pun">}</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	cout </span><span class="pun">&lt;&lt;</span><span class="pln"> ans </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
 
</span><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
</span><span class="com">#ifdef</span><span class="pln"> _DEBUG
	freopen</span><span class="pun">(</span><span class="str">"input.txt"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"r"</span><span class="pun">,</span><span class="pln"> stdin</span><span class="pun">);</span><span class="pln">
	</span><span class="kwd">int</span><span class="pln"> tt </span><span class="pun">=</span><span class="pln"> clock</span><span class="pun">();</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
	ios_base</span><span class="pun">::</span><span class="pln">sync_with_stdio</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
	cin</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">),</span><span class="pln"> cout</span><span class="pun">.</span><span class="pln">tie</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
	cout </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="kwd">fixed</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> setprecision</span><span class="pun">(</span><span class="lit">15</span><span class="pun">);</span><span class="pln">
	
	</span><span class="kwd">int</span><span class="pln"> t</span><span class="pun">;</span><span class="pln"> cin </span><span class="pun">&gt;&gt;</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">
	</span><span class="kwd">while</span><span class="pun">(</span><span class="pln">t</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
		</span><span class="pun">(</span><span class="pln">read</span><span class="pun">());</span><span class="pln">
		solve</span><span class="pun">();</span><span class="pln">
		
</span><span class="com">#ifdef</span><span class="pln"> _DEBUG
		cerr </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">"TIME = "</span><span class="pln"> </span><span class="pun">&lt;&lt;</span><span class="pln"> clock</span><span class="pun">()</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> tt </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">
		tt </span><span class="pun">=</span><span class="pln"> clock</span><span class="pun">();</span><span class="pln">
</span><span class="com">#endif</span><span class="pln">
	</span><span class="pun">}</span><span class="pln">
	</span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre></div></div></div>

    </div>


        <div style="font-size: 1.1rem;line-height: 1.1rem;padding-bottom: 0.5em;">
            <img src="https://codeforces.com//codeforces.com/codeforces.org/s/52448/images/icons/paperclip-16x16.png" style="vertical-align: middle;"> <span style="padding: 0 0.35em;">Tutorial of <a href="https://codeforces.com/contest/2075" class="notice" style="text-decoration: none;">Educational Codeforces Round 176 (Rated for Div. 2)</a> </span>
        </div>
        
            

  <script>
    // Make all spoilers toggleable
    document.querySelectorAll('.spoiler-title').forEach(title => {
      title.addEventListener('click', function() {
        const spoiler = this.closest('.spoiler');
        spoiler.classList.toggle('open');
      });
    });
    
    // Open all spoilers by default for easier reading
    document.querySelectorAll('.spoiler').forEach(spoiler => {
      spoiler.classList.add('open');
    });
  </script>
</body>
</html>