[
  {
    "id": "ai-o1-key-ideas-1",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Overview",
    "title": "Key Ideas",
    "subtitle": "Overview",
    "contentHtml": "<ul>\n  <li><strong>Chain-of-thought reasoning</strong> using large-scale RL for improved problem-solving, enabling the model to break down tasks into manageable steps.</li>\n  <li><strong>Longer response times</strong>, ranging from seconds to minutes, allowing the model to generate more thoughtful and accurate results by producing more internal reasoning tokens (these tokens are hidden from the user but billed).</li>\n  <li>The models <strong>do not support tool usage</strong>, <strong>batch calls</strong>, or <strong>image inputs</strong>. They are designed for reasoning-based tasks without relying on external information.</li>\n  <li>API access is limited to high-tier users with a minimum <strong>$1,000 spend</strong>, emphasizing exclusivity for advanced applications.</li>\n  <li>Increased <strong>output token limits</strong> (32,768 for <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> and 65,536 for <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>) ensure enough space for reasoning and responses in complex tasks.</li>\n</ul>",
    "contentMarkdown": "*   **Chain-of-thought reasoning** using large-scale RL for improved problem-solving, enabling the model to break down tasks into manageable steps.\n*   **Longer response times**, ranging from seconds to minutes, allowing the model to generate more thoughtful and accurate results by producing more internal reasoning tokens (these tokens are hidden from the user but billed).\n*   The models **do not support tool usage**, **batch calls**, or **image inputs**. They are designed for reasoning-based tasks without relying on external information.\n*   API access is limited to high-tier users with a minimum **$1,000 spend**, emphasizing exclusivity for advanced applications.\n*   Increased **output token limits** (32,768 for `o1-preview` and 65,536 for `o1-mini`) ensure enough space for reasoning and responses in complex tasks.",
    "order": 1,
    "orderInChapter": 1,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 117,
      "contentLength": 1077
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#key-ideas",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-inference-scaling-a-new-paradigm-2",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Test-time Compute: Shifting Focus to Inference Scaling",
    "title": "Inference Scaling: a New Paradigm",
    "subtitle": "Test-time Compute: Shifting Focus to Inference Scaling",
    "contentHtml": "<ul>\n  <li>The key innovation in o1 lies in the interplay between training and inference scaling, recognizing that the two curves must work together. While many AI researchers expected diminishing returns by focusing exclusively on training scaling laws, o1 has shifted the focus to inference scaling, which allows the model to think through tasks during inference by simulating possible solutions. This approach enables o1 to overcome the diminishing returns seen in training alone, leading to significantly enhanced capabilities during inference.</li>\n  <li>Unlike earlier models, o1 leverages inference scaling to handle complex reasoning tasks more efficiently. During inference, the model refines its outputs through real-time search, similar to AlphaGo’s approach to gameplay. This search-based refinement allows the model to reach better solutions by rolling out multiple strategies in real-time.</li>\n  <li>Below are some of the key ideas in test-time compute:</li>\n</ul>\n<ol>\n  <li>\n    <p><strong>Decoupling Reasoning from Knowledge</strong>: The o1 models demonstrate that massive models aren’t necessary for reasoning tasks. In previous models, a large portion of parameters was dedicated to memorizing facts for benchmarks like Trivia QA. However, o1 introduces a smaller, more efficient “reasoning core”, separating reasoning from knowledge. This core can call on external tools (e.g., browser, code verifier) to handle specialized tasks, reducing the need for large pre-trained models and allowing for a reduction in pre-training compute.</p>\n  </li>\n  <li>\n    <p><strong>Inference Scaling and Longer Response Times</strong>: o1 models shift a substantial amount of compute to serving inference instead of pre- or post-training. This shift allows the models to generate longer, more detailed reasoning outputs, especially for complex tasks in coding, mathematics, and scientific problem-solving. The extended response times (ranging from several seconds to minutes) allow for deeper reasoning, as the models generate additional internal reasoning tokens during inference, improving overall accuracy and depth.</p>\n  </li>\n  <li>\n    <p><strong>Dynamic Resource Allocation</strong>: Leveraging more test-time compute, o1 models can dynamically enhance performance by adjusting computational resources based on task complexity. This contrasts with earlier models like GPT-4o, which had fixed test-time compute limits. By enabling dynamic resource allocation, o1 ensures that more compute is used where necessary, improving performance on tasks that require deeper thought.</p>\n  </li>\n  <li>\n    <p><strong>Data Flywheel Effect</strong>: The o1 models have the potential to create a data flywheel by generating search traces during inference. When a correct answer is produced, the search trace becomes a mini dataset of training examples containing both positive and negative rewards. These examples can improve the reasoning core for future iterations of the model, much like how AlphaGo’s value network refined itself through MCTS-generated training data.</p>\n  </li>\n</ol>\n<p><strong>Decoupling Reasoning from Knowledge</strong>: The o1 models demonstrate that massive models aren’t necessary for reasoning tasks. In previous models, a large portion of parameters was dedicated to memorizing facts for benchmarks like Trivia QA. However, o1 introduces a smaller, more efficient “reasoning core”, separating reasoning from knowledge. This core can call on external tools (e.g., browser, code verifier) to handle specialized tasks, reducing the need for large pre-trained models and allowing for a reduction in pre-training compute.</p>\n<p><strong>Inference Scaling and Longer Response Times</strong>: o1 models shift a substantial amount of compute to serving inference instead of pre- or post-training. This shift allows the models to generate longer, more detailed reasoning outputs, especially for complex tasks in coding, mathematics, and scientific problem-solving. The extended response times (ranging from several seconds to minutes) allow for deeper reasoning, as the models generate additional internal reasoning tokens during inference, improving overall accuracy and depth.</p>\n<p><strong>Dynamic Resource Allocation</strong>: Leveraging more test-time compute, o1 models can dynamically enhance performance by adjusting computational resources based on task complexity. This contrasts with earlier models like GPT-4o, which had fixed test-time compute limits. By enabling dynamic resource allocation, o1 ensures that more compute is used where necessary, improving performance on tasks that require deeper thought.</p>\n<p><strong>Data Flywheel Effect</strong>: The o1 models have the potential to create a data flywheel by generating search traces during inference. When a correct answer is produced, the search trace becomes a mini dataset of training examples containing both positive and negative rewards. These examples can improve the reasoning core for future iterations of the model, much like how AlphaGo’s value network refined itself through MCTS-generated training data.</p>",
    "contentMarkdown": "*   The key innovation in o1 lies in the interplay between training and inference scaling, recognizing that the two curves must work together. While many AI researchers expected diminishing returns by focusing exclusively on training scaling laws, o1 has shifted the focus to inference scaling, which allows the model to think through tasks during inference by simulating possible solutions. This approach enables o1 to overcome the diminishing returns seen in training alone, leading to significantly enhanced capabilities during inference.\n*   Unlike earlier models, o1 leverages inference scaling to handle complex reasoning tasks more efficiently. During inference, the model refines its outputs through real-time search, similar to AlphaGo’s approach to gameplay. This search-based refinement allows the model to reach better solutions by rolling out multiple strategies in real-time.\n*   Below are some of the key ideas in test-time compute:\n\n1.  **Decoupling Reasoning from Knowledge**: The o1 models demonstrate that massive models aren’t necessary for reasoning tasks. In previous models, a large portion of parameters was dedicated to memorizing facts for benchmarks like Trivia QA. However, o1 introduces a smaller, more efficient “reasoning core”, separating reasoning from knowledge. This core can call on external tools (e.g., browser, code verifier) to handle specialized tasks, reducing the need for large pre-trained models and allowing for a reduction in pre-training compute.\n    \n2.  **Inference Scaling and Longer Response Times**: o1 models shift a substantial amount of compute to serving inference instead of pre- or post-training. This shift allows the models to generate longer, more detailed reasoning outputs, especially for complex tasks in coding, mathematics, and scientific problem-solving. The extended response times (ranging from several seconds to minutes) allow for deeper reasoning, as the models generate additional internal reasoning tokens during inference, improving overall accuracy and depth.\n    \n3.  **Dynamic Resource Allocation**: Leveraging more test-time compute, o1 models can dynamically enhance performance by adjusting computational resources based on task complexity. This contrasts with earlier models like GPT-4o, which had fixed test-time compute limits. By enabling dynamic resource allocation, o1 ensures that more compute is used where necessary, improving performance on tasks that require deeper thought.\n    \n4.  **Data Flywheel Effect**: The o1 models have the potential to create a data flywheel by generating search traces during inference. When a correct answer is produced, the search trace becomes a mini dataset of training examples containing both positive and negative rewards. These examples can improve the reasoning core for future iterations of the model, much like how AlphaGo’s value network refined itself through MCTS-generated training data.\n    \n\n**Decoupling Reasoning from Knowledge**: The o1 models demonstrate that massive models aren’t necessary for reasoning tasks. In previous models, a large portion of parameters was dedicated to memorizing facts for benchmarks like Trivia QA. However, o1 introduces a smaller, more efficient “reasoning core”, separating reasoning from knowledge. This core can call on external tools (e.g., browser, code verifier) to handle specialized tasks, reducing the need for large pre-trained models and allowing for a reduction in pre-training compute.\n\n**Inference Scaling and Longer Response Times**: o1 models shift a substantial amount of compute to serving inference instead of pre- or post-training. This shift allows the models to generate longer, more detailed reasoning outputs, especially for complex tasks in coding, mathematics, and scientific problem-solving. The extended response times (ranging from several seconds to minutes) allow for deeper reasoning, as the models generate additional internal reasoning tokens during inference, improving overall accuracy and depth.\n\n**Dynamic Resource Allocation**: Leveraging more test-time compute, o1 models can dynamically enhance performance by adjusting computational resources based on task complexity. This contrasts with earlier models like GPT-4o, which had fixed test-time compute limits. By enabling dynamic resource allocation, o1 ensures that more compute is used where necessary, improving performance on tasks that require deeper thought.\n\n**Data Flywheel Effect**: The o1 models have the potential to create a data flywheel by generating search traces during inference. When a correct answer is produced, the search trace becomes a mini dataset of training examples containing both positive and negative rewards. These examples can improve the reasoning core for future iterations of the model, much like how AlphaGo’s value network refined itself through MCTS-generated training data.",
    "order": 2,
    "orderInChapter": 1,
    "difficulty": 2,
    "estimatedMinutes": 4,
    "tags": [
      "models",
      "gpt"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 688,
      "contentLength": 5114
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#inference-scaling:-a-new-paradigm",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-the-role-of-reinforcement-learning-in-o1-3",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Test-time Compute: Shifting Focus to Inference Scaling",
    "title": "The Role of Reinforcement Learning in O1",
    "subtitle": "Test-time Compute: Shifting Focus to Inference Scaling",
    "contentHtml": "<ul>\n  <li>o1’s large-scale RL algorithm teaches the model how to think productively using its chain of thought. This RL-based training process is highly data-efficient, allowing the model to improve with more RL (train-time compute) and more time spent thinking (test-time compute). As the model spends more time on reasoning during inference, its performance consistently improves, highlighting the importance of test-time compute scaling.</li>\n  <li>The constraints on scaling this RL-based approach differ substantially from those of traditional LLM pretraining. Rather than relying on vast datasets and expensive training regimes, o1 models can achieve significant improvements by focusing on how to think during inference, as shown in the plot from <a href=\"https://openai.com/index/learning-to-reason-with-llms/\">Learning to Reason with LLMs</a>:</li>\n</ul>\n<p><img src=\"/primers/ai/assets/o1/ttc.jpg\" alt=\"Test-time Compute\"></p>\n<ul>\n  <li>This process mirrors how AlphaGo used additional compute to extend its performance envelope beyond human-level abilities by integrating real-time search during gameplay. In a similar vein, o1’s test-time compute scaling may signal the beginning of a new era in LLM capabilities.</li>\n</ul>",
    "contentMarkdown": "*   o1’s large-scale RL algorithm teaches the model how to think productively using its chain of thought. This RL-based training process is highly data-efficient, allowing the model to improve with more RL (train-time compute) and more time spent thinking (test-time compute). As the model spends more time on reasoning during inference, its performance consistently improves, highlighting the importance of test-time compute scaling.\n*   The constraints on scaling this RL-based approach differ substantially from those of traditional LLM pretraining. Rather than relying on vast datasets and expensive training regimes, o1 models can achieve significant improvements by focusing on how to think during inference, as shown in the plot from [Learning to Reason with LLMs](https://openai.com/index/learning-to-reason-with-llms/):\n\n![Test-time Compute](/primers/ai/assets/o1/ttc.jpg)\n\n*   This process mirrors how AlphaGo used additional compute to extend its performance envelope beyond human-level abilities by integrating real-time search during gameplay. In a similar vein, o1’s test-time compute scaling may signal the beginning of a new era in LLM capabilities.",
    "order": 3,
    "orderInChapter": 2,
    "difficulty": 2,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "llm"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 157,
      "contentLength": 1238
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#the-role-of-reinforcement-learning-in-o1",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-advanced-math-competitions-4",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Test Results",
    "title": "Advanced Math Competitions",
    "subtitle": "Test Results",
    "contentHtml": "<ul>\n  <li>On the AIME (American Invitational Mathematics Examination):\n    <ul>\n      <li>GPT-4o solved ~12% of the problems.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">o1-preview</code> solved 74% of the problems on the first try, reaching up to 93% when using more advanced techniques like consensus re-ranking.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>GPT-4o solved ~12% of the problems.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">o1-preview</code> solved 74% of the problems on the first try, reaching up to 93% when using more advanced techniques like consensus re-ranking.</li>\n    </ul>",
    "contentMarkdown": "*   On the AIME (American Invitational Mathematics Examination):\n    *   GPT-4o solved ~12% of the problems.\n    *   `o1-preview` solved 74% of the problems on the first try, reaching up to 93% when using more advanced techniques like consensus re-ranking.\n\n*   GPT-4o solved ~12% of the problems.\n*   `o1-preview` solved 74% of the problems on the first try, reaching up to 93% when using more advanced techniques like consensus re-ranking.",
    "order": 4,
    "orderInChapter": 1,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "gpt"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 68,
      "contentLength": 643
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#advanced-math-competitions",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-coding-competitions-5",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Test Results",
    "title": "Coding Competitions",
    "subtitle": "Test Results",
    "contentHtml": "<ul>\n  <li>In Codeforces competitions, <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> achieved a performance level in the 86th percentile, showcasing advanced abilities in solving and debugging code. This far exceeded the previous generation’s GPT-4o performance.</li>\n</ul>",
    "contentMarkdown": "*   In Codeforces competitions, `o1-mini` achieved a performance level in the 86th percentile, showcasing advanced abilities in solving and debugging code. This far exceeded the previous generation’s GPT-4o performance.",
    "order": 5,
    "orderInChapter": 2,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "gpt"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 29,
      "contentLength": 293
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#coding-competitions",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-stem-expertise-6",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Test Results",
    "title": "STEM Expertise",
    "subtitle": "Test Results",
    "contentHtml": "<ul>\n  <li>In evaluations like the GPQA benchmark, which tests advanced knowledge in chemistry, physics, and biology, o1 models outperformed human experts, marking a significant milestone in AI-driven scientific problem-solving.</li>\n</ul>",
    "contentMarkdown": "*   In evaluations like the GPQA benchmark, which tests advanced knowledge in chemistry, physics, and biology, o1 models outperformed human experts, marking a significant milestone in AI-driven scientific problem-solving.",
    "order": 6,
    "orderInChapter": 3,
    "difficulty": 2,
    "estimatedMinutes": 1,
    "tags": [
      "models"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 29,
      "contentLength": 239
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#stem-expertise",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-preparedness-framework-7",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Safety and Advancements",
    "title": "Preparedness Framework",
    "subtitle": "Safety and Advancements",
    "contentHtml": "<ul>\n  <li>OpenAI follows a comprehensive <a href=\"https://cdn.openai.com/openai-preparedness-framework-beta.pdf\">Preparedness Framework</a> for ensuring the safety and reliability of the o1 models. This framework includes a series of internal and external safety tests, red-teaming exercises, and real-world evaluations across challenging scenarios to assess how well the models adhere to ethical standards and avoid harmful behavior.</li>\n  <li>Chain-of-thought reasoning plays a critical role in safety by helping the models reason through the implications of their responses, particularly when faced with sensitive or potentially dangerous prompts. By embedding safety rules directly into their reasoning processes, o1 models can make more informed and cautious decisions.</li>\n  <li>In evaluations, <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> showed significant improvements over GPT-4o, with a substantial increase in safe completions, particularly on jailbreaks and edge cases, such as avoiding violent content, illegal activities, and harmful advice.</li>\n</ul>",
    "contentMarkdown": "*   OpenAI follows a comprehensive [Preparedness Framework](https://cdn.openai.com/openai-preparedness-framework-beta.pdf) for ensuring the safety and reliability of the o1 models. This framework includes a series of internal and external safety tests, red-teaming exercises, and real-world evaluations across challenging scenarios to assess how well the models adhere to ethical standards and avoid harmful behavior.\n*   Chain-of-thought reasoning plays a critical role in safety by helping the models reason through the implications of their responses, particularly when faced with sensitive or potentially dangerous prompts. By embedding safety rules directly into their reasoning processes, o1 models can make more informed and cautious decisions.\n*   In evaluations, `o1-preview` showed significant improvements over GPT-4o, with a substantial increase in safe completions, particularly on jailbreaks and edge cases, such as avoiding violent content, illegal activities, and harmful advice.",
    "order": 7,
    "orderInChapter": 1,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "embedding",
      "gpt"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 129,
      "contentLength": 1094
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#preparedness-framework",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-external-red-teaming-8",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Safety and Advancements",
    "title": "External Red-teaming",
    "subtitle": "Safety and Advancements",
    "contentHtml": "<ul>\n  <li>Both <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> and <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> underwent rigorous external red-teaming evaluations to test their responses to adversarial inputs. These tests, conducted by third-party experts in cybersecurity, content policy, and international security, confirmed the models’ robustness in resisting manipulation and providing responsible outputs.</li>\n</ul>",
    "contentMarkdown": "*   Both `o1-preview` and `o1-mini` underwent rigorous external red-teaming evaluations to test their responses to adversarial inputs. These tests, conducted by third-party experts in cybersecurity, content policy, and international security, confirmed the models’ robustness in resisting manipulation and providing responsible outputs.",
    "order": 8,
    "orderInChapter": 2,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 41,
      "contentLength": 466
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#external-red-teaming",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-safety-performance-metrics-9",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Safety and Advancements",
    "title": "Safety Performance Metrics",
    "subtitle": "Safety and Advancements",
    "contentHtml": "<ul>\n  <li>On difficult safety benchmarks like StrongREJECT, <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> scored 84 out of 100, compared to GPT-4o’s 22, reflecting a major improvement in the model’s ability to adhere to ethical guidelines.</li>\n  <li>In other safety categories, such as avoiding illegal sexual content, violent harassment, and self-harm encouragement, <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> showed a marked increase in safe completions, surpassing earlier models and ensuring better alignment with human values.</li>\n</ul>",
    "contentMarkdown": "*   On difficult safety benchmarks like StrongREJECT, `o1-preview` scored 84 out of 100, compared to GPT-4o’s 22, reflecting a major improvement in the model’s ability to adhere to ethical guidelines.\n*   In other safety categories, such as avoiding illegal sexual content, violent harassment, and self-harm encouragement, `o1-preview` showed a marked increase in safe completions, surpassing earlier models and ensuring better alignment with human values.",
    "order": 9,
    "orderInChapter": 3,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "gpt"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 64,
      "contentLength": 593
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#safety-performance-metrics",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-key-safety-enhancements-10",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Safety and Advancements",
    "title": "Key Safety Enhancements",
    "subtitle": "Safety and Advancements",
    "contentHtml": "<ul>\n  <li><strong>Reduced Jailbreak Vulnerability</strong>: The o1 models performed exceptionally well in preventing jailbreak attempts, where malicious users attempt to manipulate the model into producing harmful or unethical content.</li>\n  <li><strong>Improved Compliance</strong>: The models demonstrated enhanced compliance with safety guidelines, even in challenging or ambiguous situations, outperforming earlier versions like GPT-4o across a wide range of harmful prompts.</li>\n  <li>\n    <p><strong>Edge Case Handling</strong>: The models were also tested on benign edge cases, where the goal was to avoid unnecessary refusals while still adhering to safety standards. <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> and <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> both showed a high level of compliance, maintaining a balance between safety and responsiveness.</p>\n  </li>\n  <li>By integrating chain-of-thought reasoning directly into the models’ architecture, OpenAI has made significant strides in ensuring that the o1 models not only solve complex tasks but do so in a way that aligns with ethical standards and safety regulations.</li>\n</ul>\n<p><strong>Edge Case Handling</strong>: The models were also tested on benign edge cases, where the goal was to avoid unnecessary refusals while still adhering to safety standards. <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> and <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> both showed a high level of compliance, maintaining a balance between safety and responsiveness.</p>",
    "contentMarkdown": "*   **Reduced Jailbreak Vulnerability**: The o1 models performed exceptionally well in preventing jailbreak attempts, where malicious users attempt to manipulate the model into producing harmful or unethical content.\n*   **Improved Compliance**: The models demonstrated enhanced compliance with safety guidelines, even in challenging or ambiguous situations, outperforming earlier versions like GPT-4o across a wide range of harmful prompts.\n*   **Edge Case Handling**: The models were also tested on benign edge cases, where the goal was to avoid unnecessary refusals while still adhering to safety standards. `o1-preview` and `o1-mini` both showed a high level of compliance, maintaining a balance between safety and responsiveness.\n    \n*   By integrating chain-of-thought reasoning directly into the models’ architecture, OpenAI has made significant strides in ensuring that the o1 models not only solve complex tasks but do so in a way that aligns with ethical standards and safety regulations.\n\n**Edge Case Handling**: The models were also tested on benign edge cases, where the goal was to avoid unnecessary refusals while still adhering to safety standards. `o1-preview` and `o1-mini` both showed a high level of compliance, maintaining a balance between safety and responsiveness.",
    "order": 10,
    "orderInChapter": 4,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "gpt"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 184,
      "contentLength": 1620
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#key-safety-enhancements",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-adding-a-side-network-to-openais-o1-models-a-dual--11",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "title": "Adding a Side Network to OpenAI’s O1 Models: a Dual-Net Approach",
    "subtitle": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "contentHtml": "<ul>\n  <li>Based on the concept proposed in <a href=\"https://arxiv.org/abs/2007.13512\">Add a SideNet to your MainNet</a>, a potential enhancement to OpenAI’s o1 series involves integrating a smaller, faster “side network” alongside the primary “main network” to optimize performance across various tasks. The side net acts as a preliminary filter, handling simpler tasks while routing complex problems to the more powerful o1 model. This dynamic delegation improves efficiency, reduces costs, and speeds up response times by reserving o1’s deep reasoning capabilities for tasks that genuinely require it. This concept mirrors strategies from earlier AI systems, where a smaller network is paired with a larger one, creating an efficient and scalable architecture.</li>\n  <li>Below, we detail how this approach could work with o1.</li>\n</ul>\n<h4 id=\"side-net-for-task-routing-and-efficiency\">Side Net for Task Routing and Efficiency</h4>\n<p>The primary challenge in AI performance optimization lies in dynamically determining the computational resources necessary for each task. A side network—a smaller, less resource-intensive model—could serve as a preliminary filter, assessing the complexity of the task before deciding whether to route it to the more powerful main o1 network.</p>\n<p>The side net would operate as follows:</p>\n<ul>\n  <li>\n    <p><strong>Confidence Estimation</strong>: For any given input, the side net would first estimate the difficulty and provide a confidence score based on its ability to solve the task. If the side net is confident in solving the task (e.g., a simpler coding or reasoning query), it handles the problem, saving both time and cost.</p>\n  </li>\n  <li>\n    <p><strong>Routing Complex Tasks</strong>: If the side net exhibits low confidence or identifies the task as too complex (e.g., tasks requiring deep mathematical reasoning or intricate multi-step logic), it passes the task to the o1 model for more in-depth reasoning.</p>\n  </li>\n</ul>\n<p><strong>Confidence Estimation</strong>: For any given input, the side net would first estimate the difficulty and provide a confidence score based on its ability to solve the task. If the side net is confident in solving the task (e.g., a simpler coding or reasoning query), it handles the problem, saving both time and cost.</p>\n<p><strong>Routing Complex Tasks</strong>: If the side net exhibits low confidence or identifies the task as too complex (e.g., tasks requiring deep mathematical reasoning or intricate multi-step logic), it passes the task to the o1 model for more in-depth reasoning.</p>\n<h4 id=\"practical-implementation-in-o1\">Practical Implementation in O1</h4>\n<ul>\n  <li>For o1, the addition of a side net would be beneficial in several ways:</li>\n</ul>\n<ol>\n  <li><strong>Efficiency Gains</strong>:\n    <ul>\n      <li><strong>Faster Task Resolution</strong>: Tasks that are less complex can be quickly handled by the side net, allowing for faster response times and reducing the need to invoke the more resource-heavy o1 model.</li>\n      <li><strong>Cost-Effectiveness</strong>: By delegating simpler tasks to the side net, users could minimize the computational costs associated with the o1 model’s deep reasoning cycles, as lower-tier models generally cost less to operate.</li>\n    </ul>\n  </li>\n  <li><strong>Dynamic Resource Allocation</strong>:\n    <ul>\n      <li>In practice, this would mean reserving the high-level reasoning capabilities of o1 for problems that genuinely require it, thereby reducing the need for extended computation times on tasks where simpler models could suffice. This aligns with the philosophy of <strong>test-time compute scaling</strong>, where resources are allocated dynamically based on the task’s complexity.</li>\n    </ul>\n  </li>\n  <li><strong>Estimation-Based Computation</strong>:\n    <ul>\n      <li>Estimating the difficulty of tasks is often easier than solving them outright. This allows the side net to perform a lightweight analysis and decide whether it’s worth utilizing the more advanced reasoning processes of o1 or solving it directly. Such a strategy can prevent the o1 network from being overused on simple queries, thereby maximizing overall throughput.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li><strong>Faster Task Resolution</strong>: Tasks that are less complex can be quickly handled by the side net, allowing for faster response times and reducing the need to invoke the more resource-heavy o1 model.</li>\n      <li><strong>Cost-Effectiveness</strong>: By delegating simpler tasks to the side net, users could minimize the computational costs associated with the o1 model’s deep reasoning cycles, as lower-tier models generally cost less to operate.</li>\n    </ul>\n<ul>\n      <li>In practice, this would mean reserving the high-level reasoning capabilities of o1 for problems that genuinely require it, thereby reducing the need for extended computation times on tasks where simpler models could suffice. This aligns with the philosophy of <strong>test-time compute scaling</strong>, where resources are allocated dynamically based on the task’s complexity.</li>\n    </ul>\n<ul>\n      <li>Estimating the difficulty of tasks is often easier than solving them outright. This allows the side net to perform a lightweight analysis and decide whether it’s worth utilizing the more advanced reasoning processes of o1 or solving it directly. Such a strategy can prevent the o1 network from being overused on simple queries, thereby maximizing overall throughput.</li>\n    </ul>\n<h4 id=\"routing-and-use-case-scenarios\">Routing and Use-Case Scenarios</h4>\n<ul>\n  <li>The side net approach could improve the performance of o1 in several use cases:\n    <ul>\n      <li>\n        <p><strong>Routine Coding Tasks</strong>: In scenarios like basic debugging or syntax correction, the side net could handle the tasks independently without involving the <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> model, significantly reducing response times and token consumption.</p>\n      </li>\n      <li>\n        <p><strong>Complex STEM Reasoning</strong>: On more complex STEM tasks (e.g., physics problem-solving or advanced algorithmic challenges), the side net might quickly recognize its limitations and forward the problem to the o1 network, ensuring a thorough and accurate solution.</p>\n      </li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>\n        <p><strong>Routine Coding Tasks</strong>: In scenarios like basic debugging or syntax correction, the side net could handle the tasks independently without involving the <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> model, significantly reducing response times and token consumption.</p>\n      </li>\n      <li>\n        <p><strong>Complex STEM Reasoning</strong>: On more complex STEM tasks (e.g., physics problem-solving or advanced algorithmic challenges), the side net might quickly recognize its limitations and forward the problem to the o1 network, ensuring a thorough and accurate solution.</p>\n      </li>\n    </ul>\n<p><strong>Routine Coding Tasks</strong>: In scenarios like basic debugging or syntax correction, the side net could handle the tasks independently without involving the <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> model, significantly reducing response times and token consumption.</p>\n<p><strong>Complex STEM Reasoning</strong>: On more complex STEM tasks (e.g., physics problem-solving or advanced algorithmic challenges), the side net might quickly recognize its limitations and forward the problem to the o1 network, ensuring a thorough and accurate solution.</p>\n<h4 id=\"conclusion\">Conclusion</h4>\n<ul>\n  <li>Integrating a side net into OpenAI’s o1 architecture offers a promising pathway for enhancing performance and cost-effectiveness. By dynamically assessing the complexity of tasks and delegating them appropriately, this dual-net approach could optimize resource use, reduce computation times, and offer users a more efficient solution tailored to the difficulty of the task at hand. This fusion of side and main nets, where confidence in simpler tasks dictates the computational path, has the potential to push o1’s capabilities even further while controlling costs and maximizing response efficiency.</li>\n</ul>",
    "contentMarkdown": "*   Based on the concept proposed in [Add a SideNet to your MainNet](https://arxiv.org/abs/2007.13512), a potential enhancement to OpenAI’s o1 series involves integrating a smaller, faster “side network” alongside the primary “main network” to optimize performance across various tasks. The side net acts as a preliminary filter, handling simpler tasks while routing complex problems to the more powerful o1 model. This dynamic delegation improves efficiency, reduces costs, and speeds up response times by reserving o1’s deep reasoning capabilities for tasks that genuinely require it. This concept mirrors strategies from earlier AI systems, where a smaller network is paired with a larger one, creating an efficient and scalable architecture.\n*   Below, we detail how this approach could work with o1.\n\n#### Side Net for Task Routing and Efficiency\n\nThe primary challenge in AI performance optimization lies in dynamically determining the computational resources necessary for each task. A side network—a smaller, less resource-intensive model—could serve as a preliminary filter, assessing the complexity of the task before deciding whether to route it to the more powerful main o1 network.\n\nThe side net would operate as follows:\n\n*   **Confidence Estimation**: For any given input, the side net would first estimate the difficulty and provide a confidence score based on its ability to solve the task. If the side net is confident in solving the task (e.g., a simpler coding or reasoning query), it handles the problem, saving both time and cost.\n    \n*   **Routing Complex Tasks**: If the side net exhibits low confidence or identifies the task as too complex (e.g., tasks requiring deep mathematical reasoning or intricate multi-step logic), it passes the task to the o1 model for more in-depth reasoning.\n    \n\n**Confidence Estimation**: For any given input, the side net would first estimate the difficulty and provide a confidence score based on its ability to solve the task. If the side net is confident in solving the task (e.g., a simpler coding or reasoning query), it handles the problem, saving both time and cost.\n\n**Routing Complex Tasks**: If the side net exhibits low confidence or identifies the task as too complex (e.g., tasks requiring deep mathematical reasoning or intricate multi-step logic), it passes the task to the o1 model for more in-depth reasoning.\n\n#### Practical Implementation in O1\n\n*   For o1, the addition of a side net would be beneficial in several ways:\n\n1.  **Efficiency Gains**:\n    *   **Faster Task Resolution**: Tasks that are less complex can be quickly handled by the side net, allowing for faster response times and reducing the need to invoke the more resource-heavy o1 model.\n    *   **Cost-Effectiveness**: By delegating simpler tasks to the side net, users could minimize the computational costs associated with the o1 model’s deep reasoning cycles, as lower-tier models generally cost less to operate.\n2.  **Dynamic Resource Allocation**:\n    *   In practice, this would mean reserving the high-level reasoning capabilities of o1 for problems that genuinely require it, thereby reducing the need for extended computation times on tasks where simpler models could suffice. This aligns with the philosophy of **test-time compute scaling**, where resources are allocated dynamically based on the task’s complexity.\n3.  **Estimation-Based Computation**:\n    *   Estimating the difficulty of tasks is often easier than solving them outright. This allows the side net to perform a lightweight analysis and decide whether it’s worth utilizing the more advanced reasoning processes of o1 or solving it directly. Such a strategy can prevent the o1 network from being overused on simple queries, thereby maximizing overall throughput.\n\n*   **Faster Task Resolution**: Tasks that are less complex can be quickly handled by the side net, allowing for faster response times and reducing the need to invoke the more resource-heavy o1 model.\n*   **Cost-Effectiveness**: By delegating simpler tasks to the side net, users could minimize the computational costs associated with the o1 model’s deep reasoning cycles, as lower-tier models generally cost less to operate.\n\n*   In practice, this would mean reserving the high-level reasoning capabilities of o1 for problems that genuinely require it, thereby reducing the need for extended computation times on tasks where simpler models could suffice. This aligns with the philosophy of **test-time compute scaling**, where resources are allocated dynamically based on the task’s complexity.\n\n*   Estimating the difficulty of tasks is often easier than solving them outright. This allows the side net to perform a lightweight analysis and decide whether it’s worth utilizing the more advanced reasoning processes of o1 or solving it directly. Such a strategy can prevent the o1 network from being overused on simple queries, thereby maximizing overall throughput.\n\n#### Routing and Use-Case Scenarios\n\n*   The side net approach could improve the performance of o1 in several use cases:\n    *   **Routine Coding Tasks**: In scenarios like basic debugging or syntax correction, the side net could handle the tasks independently without involving the `o1-preview` model, significantly reducing response times and token consumption.\n        \n    *   **Complex STEM Reasoning**: On more complex STEM tasks (e.g., physics problem-solving or advanced algorithmic challenges), the side net might quickly recognize its limitations and forward the problem to the o1 network, ensuring a thorough and accurate solution.\n        \n\n*   **Routine Coding Tasks**: In scenarios like basic debugging or syntax correction, the side net could handle the tasks independently without involving the `o1-preview` model, significantly reducing response times and token consumption.\n    \n*   **Complex STEM Reasoning**: On more complex STEM tasks (e.g., physics problem-solving or advanced algorithmic challenges), the side net might quickly recognize its limitations and forward the problem to the o1 network, ensuring a thorough and accurate solution.\n    \n\n**Routine Coding Tasks**: In scenarios like basic debugging or syntax correction, the side net could handle the tasks independently without involving the `o1-preview` model, significantly reducing response times and token consumption.\n\n**Complex STEM Reasoning**: On more complex STEM tasks (e.g., physics problem-solving or advanced algorithmic challenges), the side net might quickly recognize its limitations and forward the problem to the o1 network, ensuring a thorough and accurate solution.\n\n#### Conclusion\n\n*   Integrating a side net into OpenAI’s o1 architecture offers a promising pathway for enhancing performance and cost-effectiveness. By dynamically assessing the complexity of tasks and delegating them appropriately, this dual-net approach could optimize resource use, reduce computation times, and offer users a more efficient solution tailored to the difficulty of the task at hand. This fusion of side and main nets, where confidence in simpler tasks dictates the computational path, has the potential to push o1’s capabilities even further while controlling costs and maximizing response efficiency.",
    "order": 11,
    "orderInChapter": 1,
    "difficulty": 3,
    "estimatedMinutes": 6,
    "tags": [
      "models",
      "optimization"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 1067,
      "contentLength": 8318
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#adding-a-side-network-to-openai’s-o1-models:-a-dual-net-approach",
    "scrapedAt": "2025-12-28T11:51:47.952Z"
  },
  {
    "id": "ai-o1-adopting-a-router-setup-to-divert-queries-12",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "title": "Adopting a Router Setup to Divert Queries",
    "subtitle": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "contentHtml": "<ul>\n  <li>In addition to integrating a smaller side network alongside OpenAI’s o1 models, another compelling paradigm involves leveraging <a href=\"https://arxiv.org/abs/2406.18665\">RouteLLM</a>, a routing framework proposed for dynamic model routing between a large model (such as o1) and a smaller, cost-efficient model. This will lead to a system that intelligently decides which model—a large, accurate model (<code class=\"language-plaintext highlighter-rouge\">o1-preview</code>) or a smaller, cost-efficient one (<code class=\"language-plaintext highlighter-rouge\">o1-mini</code> or side net)—should handle a given task. By using preference data and performance thresholds, this setup balances the cost and quality trade-off, reducing reliance on larger models without sacrificing significant response quality. This approach builds on the foundational idea of routing queries based on task complexity, allowing for cost-effective and high-performance inference.</li>\n</ul>\n<h4 id=\"routellm-intelligent-query-routing-between-big-and-small-models\">RouteLLM: Intelligent Query Routing Between Big and Small Models</h4>\n<ul>\n  <li>RouteLLM introduces an efficient way to determine the appropriate model for a task dynamically, based on the complexity and expected performance requirements. This strategy is useful when deciding between a smaller model (such as <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> or even a simpler side net) and a larger model like <code class=\"language-plaintext highlighter-rouge\">o1-preview</code>. The router system evaluates the complexity of a given query and decides which model to invoke, thereby balancing cost and performance. The main idea is to use lightweight “routers” trained on preference data and additional techniques, such as data augmentation, to optimize the decision-making process.</li>\n</ul>\n<p><strong>Key aspects of RouteLLM routing</strong>:</p>\n<ul>\n  <li><strong>Performance vs. Cost Trade-off</strong>: The larger model (<code class=\"language-plaintext highlighter-rouge\">o1-preview</code>) is typically more accurate but costly to run, while the smaller model (<code class=\"language-plaintext highlighter-rouge\">o1-mini</code> or side net) is less accurate but cheaper. The router determines which model to invoke based on the task complexity.</li>\n  <li><strong>Cost Savings</strong>: According to RouteLLM’s results, routing can save up to <strong>2x in cost</strong> without sacrificing significant response quality. The router essentially ensures that only complex queries are passed to the more powerful model.</li>\n  <li><strong>Human Preference Data</strong>: RouteLLM uses human preference data to learn which types of queries require the larger model and which can be handled by the smaller one. This learning allows the router to generalize across a wide variety of tasks, making it effective for real-world applications.</li>\n</ul>\n<h4 id=\"implementation-with-o1-models\">Implementation with O1 Models</h4>\n<ul>\n  <li>For OpenAI’s o1 architecture, RouteLLM could provide the following advantages:</li>\n</ul>\n<ol>\n  <li><strong>Dynamic Query Evaluation</strong>:\n    <ul>\n      <li>For tasks requiring deeper reasoning, the RouteLLM system would send the query to <code class=\"language-plaintext highlighter-rouge\">o1-preview</code>, where more extensive test-time compute can be allocated.</li>\n      <li>For simpler tasks, it could route queries to a smaller model (e.g., <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>) or a dedicated side net to reduce computational load and costs.</li>\n    </ul>\n  </li>\n  <li><strong>Training the Router</strong>:\n    <ul>\n      <li>The router can be trained using preference data similar to the RouteLLM framework, which captures the complexity of queries and the performance differences between <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> and <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>.</li>\n      <li><strong>Data Augmentation</strong>: To improve the router’s generalization across different domains, synthetic data (e.g., from MMLU benchmarks) or automatically generated preference labels could be used to train the routing system further.</li>\n    </ul>\n  </li>\n  <li><strong>Cost and Performance Optimization</strong>:\n    <ul>\n      <li>RouteLLM demonstrated the effectiveness of this system by achieving <strong>50% less reliance on larger models</strong> while maintaining quality through intelligent routing. This method would allow developers using o1 models to optimize for budget constraints while ensuring top-tier performance for complex tasks.</li>\n      <li><strong>Metrics like Cost-Performance Threshold (CPT)</strong> can help determine the best balance, with thresholds adjusted based on user preferences or task criticality.</li>\n    </ul>\n  </li>\n</ol>\n<ul>\n      <li>For tasks requiring deeper reasoning, the RouteLLM system would send the query to <code class=\"language-plaintext highlighter-rouge\">o1-preview</code>, where more extensive test-time compute can be allocated.</li>\n      <li>For simpler tasks, it could route queries to a smaller model (e.g., <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>) or a dedicated side net to reduce computational load and costs.</li>\n    </ul>\n<ul>\n      <li>The router can be trained using preference data similar to the RouteLLM framework, which captures the complexity of queries and the performance differences between <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> and <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>.</li>\n      <li><strong>Data Augmentation</strong>: To improve the router’s generalization across different domains, synthetic data (e.g., from MMLU benchmarks) or automatically generated preference labels could be used to train the routing system further.</li>\n    </ul>\n<ul>\n      <li>RouteLLM demonstrated the effectiveness of this system by achieving <strong>50% less reliance on larger models</strong> while maintaining quality through intelligent routing. This method would allow developers using o1 models to optimize for budget constraints while ensuring top-tier performance for complex tasks.</li>\n      <li><strong>Metrics like Cost-Performance Threshold (CPT)</strong> can help determine the best balance, with thresholds adjusted based on user preferences or task criticality.</li>\n    </ul>",
    "contentMarkdown": "*   In addition to integrating a smaller side network alongside OpenAI’s o1 models, another compelling paradigm involves leveraging [RouteLLM](https://arxiv.org/abs/2406.18665), a routing framework proposed for dynamic model routing between a large model (such as o1) and a smaller, cost-efficient model. This will lead to a system that intelligently decides which model—a large, accurate model (`o1-preview`) or a smaller, cost-efficient one (`o1-mini` or side net)—should handle a given task. By using preference data and performance thresholds, this setup balances the cost and quality trade-off, reducing reliance on larger models without sacrificing significant response quality. This approach builds on the foundational idea of routing queries based on task complexity, allowing for cost-effective and high-performance inference.\n\n#### RouteLLM: Intelligent Query Routing Between Big and Small Models\n\n*   RouteLLM introduces an efficient way to determine the appropriate model for a task dynamically, based on the complexity and expected performance requirements. This strategy is useful when deciding between a smaller model (such as `o1-mini` or even a simpler side net) and a larger model like `o1-preview`. The router system evaluates the complexity of a given query and decides which model to invoke, thereby balancing cost and performance. The main idea is to use lightweight “routers” trained on preference data and additional techniques, such as data augmentation, to optimize the decision-making process.\n\n**Key aspects of RouteLLM routing**:\n\n*   **Performance vs. Cost Trade-off**: The larger model (`o1-preview`) is typically more accurate but costly to run, while the smaller model (`o1-mini` or side net) is less accurate but cheaper. The router determines which model to invoke based on the task complexity.\n*   **Cost Savings**: According to RouteLLM’s results, routing can save up to **2x in cost** without sacrificing significant response quality. The router essentially ensures that only complex queries are passed to the more powerful model.\n*   **Human Preference Data**: RouteLLM uses human preference data to learn which types of queries require the larger model and which can be handled by the smaller one. This learning allows the router to generalize across a wide variety of tasks, making it effective for real-world applications.\n\n#### Implementation with O1 Models\n\n*   For OpenAI’s o1 architecture, RouteLLM could provide the following advantages:\n\n1.  **Dynamic Query Evaluation**:\n    *   For tasks requiring deeper reasoning, the RouteLLM system would send the query to `o1-preview`, where more extensive test-time compute can be allocated.\n    *   For simpler tasks, it could route queries to a smaller model (e.g., `o1-mini`) or a dedicated side net to reduce computational load and costs.\n2.  **Training the Router**:\n    *   The router can be trained using preference data similar to the RouteLLM framework, which captures the complexity of queries and the performance differences between `o1-preview` and `o1-mini`.\n    *   **Data Augmentation**: To improve the router’s generalization across different domains, synthetic data (e.g., from MMLU benchmarks) or automatically generated preference labels could be used to train the routing system further.\n3.  **Cost and Performance Optimization**:\n    *   RouteLLM demonstrated the effectiveness of this system by achieving **50% less reliance on larger models** while maintaining quality through intelligent routing. This method would allow developers using o1 models to optimize for budget constraints while ensuring top-tier performance for complex tasks.\n    *   **Metrics like Cost-Performance Threshold (CPT)** can help determine the best balance, with thresholds adjusted based on user preferences or task criticality.\n\n*   For tasks requiring deeper reasoning, the RouteLLM system would send the query to `o1-preview`, where more extensive test-time compute can be allocated.\n*   For simpler tasks, it could route queries to a smaller model (e.g., `o1-mini`) or a dedicated side net to reduce computational load and costs.\n\n*   The router can be trained using preference data similar to the RouteLLM framework, which captures the complexity of queries and the performance differences between `o1-preview` and `o1-mini`.\n*   **Data Augmentation**: To improve the router’s generalization across different domains, synthetic data (e.g., from MMLU benchmarks) or automatically generated preference labels could be used to train the routing system further.\n\n*   RouteLLM demonstrated the effectiveness of this system by achieving **50% less reliance on larger models** while maintaining quality through intelligent routing. This method would allow developers using o1 models to optimize for budget constraints while ensuring top-tier performance for complex tasks.\n*   **Metrics like Cost-Performance Threshold (CPT)** can help determine the best balance, with thresholds adjusted based on user preferences or task criticality.",
    "order": 12,
    "orderInChapter": 2,
    "difficulty": 3,
    "estimatedMinutes": 4,
    "tags": [
      "models",
      "llm",
      "optimization",
      "data augmentation"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 715,
      "contentLength": 6445
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#adopting-a-router-setup-to-divert-queries",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-integration-with-openais-o1-test-time-compute-13",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "title": "Integration with OpenAI’s O1 Test-Time Compute",
    "subtitle": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "contentHtml": "<ul>\n  <li>\n    <p><strong>Extended Decision-Making</strong>: By integrating RouteLLM’s router system, the decision of how long to compute or which model to use becomes more dynamic and data-driven. The router helps decide if a task truly requires the deep reasoning capabilities of <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> or if the faster <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> would suffice.</p>\n  </li>\n  <li>\n    <p><strong>Use Case Adaptability</strong>: In environments where budget and speed are priorities, RouteLLM’s architecture ensures that only necessary computational resources are allocated for complex queries, while simpler queries are handled more efficiently. For instance, in a <strong>coding task</strong>, basic syntax fixes can be routed to <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>, while complex algorithm debugging is processed by <code class=\"language-plaintext highlighter-rouge\">o1-preview</code>.</p>\n  </li>\n</ul>\n<p><strong>Extended Decision-Making</strong>: By integrating RouteLLM’s router system, the decision of how long to compute or which model to use becomes more dynamic and data-driven. The router helps decide if a task truly requires the deep reasoning capabilities of <code class=\"language-plaintext highlighter-rouge\">o1-preview</code> or if the faster <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> would suffice.</p>\n<p><strong>Use Case Adaptability</strong>: In environments where budget and speed are priorities, RouteLLM’s architecture ensures that only necessary computational resources are allocated for complex queries, while simpler queries are handled more efficiently. For instance, in a <strong>coding task</strong>, basic syntax fixes can be routed to <code class=\"language-plaintext highlighter-rouge\">o1-mini</code>, while complex algorithm debugging is processed by <code class=\"language-plaintext highlighter-rouge\">o1-preview</code>.</p>",
    "contentMarkdown": "*   **Extended Decision-Making**: By integrating RouteLLM’s router system, the decision of how long to compute or which model to use becomes more dynamic and data-driven. The router helps decide if a task truly requires the deep reasoning capabilities of `o1-preview` or if the faster `o1-mini` would suffice.\n    \n*   **Use Case Adaptability**: In environments where budget and speed are priorities, RouteLLM’s architecture ensures that only necessary computational resources are allocated for complex queries, while simpler queries are handled more efficiently. For instance, in a **coding task**, basic syntax fixes can be routed to `o1-mini`, while complex algorithm debugging is processed by `o1-preview`.\n    \n\n**Extended Decision-Making**: By integrating RouteLLM’s router system, the decision of how long to compute or which model to use becomes more dynamic and data-driven. The router helps decide if a task truly requires the deep reasoning capabilities of `o1-preview` or if the faster `o1-mini` would suffice.\n\n**Use Case Adaptability**: In environments where budget and speed are priorities, RouteLLM’s architecture ensures that only necessary computational resources are allocated for complex queries, while simpler queries are handled more efficiently. For instance, in a **coding task**, basic syntax fixes can be routed to `o1-mini`, while complex algorithm debugging is processed by `o1-preview`.",
    "order": 13,
    "orderInChapter": 3,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "llm"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 200,
      "contentLength": 1998
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#integration-with-openai’s-o1-test-time-compute",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-conclusion-14",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "title": "Conclusion",
    "subtitle": "Deployment Patterns for O1 Using Dynamic Task Routing",
    "contentHtml": "<ul>\n  <li>Incorporating a dual-model routing system like RouteLLM into OpenAI’s o1 framework enhances the decision-making process around model usage. It allows for intelligent, cost-effective routing, balancing the performance of the smaller <code class=\"language-plaintext highlighter-rouge\">o1-mini</code> with the deeper reasoning capabilities of <code class=\"language-plaintext highlighter-rouge\">o1-preview</code>. This ensures that resources are used efficiently, optimizing both cost and task performance dynamically based on query complexity【6†source】.</li>\n</ul>",
    "contentMarkdown": "*   Incorporating a dual-model routing system like RouteLLM into OpenAI’s o1 framework enhances the decision-making process around model usage. It allows for intelligent, cost-effective routing, balancing the performance of the smaller `o1-mini` with the deeper reasoning capabilities of `o1-preview`. This ensures that resources are used efficiently, optimizing both cost and task performance dynamically based on query complexity【6†source】.",
    "order": 14,
    "orderInChapter": 4,
    "difficulty": 3,
    "estimatedMinutes": 1,
    "tags": [
      "models",
      "llm"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": false,
      "wordCount": 57,
      "contentLength": 572
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#conclusion",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-lets-verify-step-by-step-15",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Let’s Verify Step by Step",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Lightman et al. from OpenAI presents a detailed investigation into the effectiveness of process supervision compared to outcome supervision in training language models for complex multi-step reasoning.</li>\n  <li>The authors explore the concepts of outcome and process supervision. Outcome-supervised reward models (ORMs) focus on the final result of a model’s reasoning chain, while process-supervised reward models (PRMs) receive feedback at each step in the reasoning chain.</li>\n  <li>To collect process supervision data, they present human data-labelers with step-by-step solutions to MATH problems sampled by the large-scale generator.\nTheir task is to assign each step in the solution a label of positive, negative, or neutral, as shown in the below figure. A positive label indicates that the step is correct and reasonable. A negative label indicates that the step is either incorrect or unreasonable. A neutral label indicates ambiguity. In practice, a step may be labelled neutral if it is subtly misleading, or if it is a poor suggestion that is technically still valid. Neutral labels allows them to defer the decision about how to handle ambiguity: at test time, we can treat neutral labels as either positive or negative.  The following figure from the paper shows a screenshot of the interface used to collect feedback for each step in a solution.</li>\n</ul>\n<p><img src=\"../../../images/papers/PRM1.jpg\" alt=\"\"></p>\n<ul>\n  <li>The following figure from the paper shows two solutions to the same problem, graded by the PRM. The solution on the left is correct while the solution on the right is incorrect. A green background indicates a high PRM score, and a red background indicates a low score. The PRM correctly identifies the mistake in the incorrect solution.</li>\n</ul>\n<p><img src=\"../../../images/papers/PRM2.jpg\" alt=\"\"></p>\n<ul>\n  <li>For their experiments, they used large-scale models fine-tuned from GPT-4 and smaller models for detailed comparisons. These models were trained on the MATH dataset, which includes complex mathematical problems.</li>\n  <li>The paper introduces a new dataset, PRM800K, comprising 800,000 step-level human feedback labels, which was instrumental in training their PRM models.</li>\n  <li>The key findings show that process supervision significantly outperforms outcome supervision in training models to solve complex problems. Specifically, their PRM model solved 78.2% of problems from a representative subset of the MATH test set.</li>\n  <li>The researchers also demonstrate that active learning significantly improves the efficiency of process supervision, leading to better data utilization.</li>\n  <li>They conducted out-of-distribution generalization tests using recent STEM tests like AP Physics and Calculus exams, where the PRM continued to outperform other methods.</li>\n  <li>The paper discusses the implications of their findings for AI alignment, highlighting the advantages of process supervision in producing more interpretable and aligned models.</li>\n  <li>They acknowledge potential limitations related to test set contamination but argue that the relative comparisons made in their work are robust against such issues.</li>\n  <li>This research contributes to the field by showing the effectiveness of process supervision and active learning in improving the reasoning capabilities of language models, especially in complex domains like mathematics.</li>\n</ul>",
    "contentMarkdown": "*   This paper by Lightman et al. from OpenAI presents a detailed investigation into the effectiveness of process supervision compared to outcome supervision in training language models for complex multi-step reasoning.\n*   The authors explore the concepts of outcome and process supervision. Outcome-supervised reward models (ORMs) focus on the final result of a model’s reasoning chain, while process-supervised reward models (PRMs) receive feedback at each step in the reasoning chain.\n*   To collect process supervision data, they present human data-labelers with step-by-step solutions to MATH problems sampled by the large-scale generator. Their task is to assign each step in the solution a label of positive, negative, or neutral, as shown in the below figure. A positive label indicates that the step is correct and reasonable. A negative label indicates that the step is either incorrect or unreasonable. A neutral label indicates ambiguity. In practice, a step may be labelled neutral if it is subtly misleading, or if it is a poor suggestion that is technically still valid. Neutral labels allows them to defer the decision about how to handle ambiguity: at test time, we can treat neutral labels as either positive or negative. The following figure from the paper shows a screenshot of the interface used to collect feedback for each step in a solution.\n\n![](../../../images/papers/PRM1.jpg)\n\n*   The following figure from the paper shows two solutions to the same problem, graded by the PRM. The solution on the left is correct while the solution on the right is incorrect. A green background indicates a high PRM score, and a red background indicates a low score. The PRM correctly identifies the mistake in the incorrect solution.\n\n![](../../../images/papers/PRM2.jpg)\n\n*   For their experiments, they used large-scale models fine-tuned from GPT-4 and smaller models for detailed comparisons. These models were trained on the MATH dataset, which includes complex mathematical problems.\n*   The paper introduces a new dataset, PRM800K, comprising 800,000 step-level human feedback labels, which was instrumental in training their PRM models.\n*   The key findings show that process supervision significantly outperforms outcome supervision in training models to solve complex problems. Specifically, their PRM model solved 78.2% of problems from a representative subset of the MATH test set.\n*   The researchers also demonstrate that active learning significantly improves the efficiency of process supervision, leading to better data utilization.\n*   They conducted out-of-distribution generalization tests using recent STEM tests like AP Physics and Calculus exams, where the PRM continued to outperform other methods.\n*   The paper discusses the implications of their findings for AI alignment, highlighting the advantages of process supervision in producing more interpretable and aligned models.\n*   They acknowledge potential limitations related to test set contamination but argue that the relative comparisons made in their work are robust against such issues.\n*   This research contributes to the field by showing the effectiveness of process supervision and active learning in improving the reasoning capabilities of language models, especially in complex domains like mathematics.",
    "order": 15,
    "orderInChapter": 1,
    "difficulty": 2,
    "estimatedMinutes": 3,
    "tags": [
      "models",
      "gpt"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 489,
      "contentLength": 3461
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#let’s-verify-step-by-step",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-scaling-llm-test-time-compute-optimally-can-be-mor-16",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Scaling LLM Test-Time Compute Optimally Can be More Effective Than Scaling Model Parameters",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Snell et al. from UC Berkeley and Google DeepMind explores the scaling of inference-time computation in large language models (LLMs) and addresses the question of how much a fixed amount of test-time compute can improve model performance, particularly on difficult prompts. The authors focus on two primary mechanisms to scale test-time compute: (1) searching against dense process-based verifier reward models (PRMs) and (2) adaptively updating the model’s response distribution during test time.</li>\n  <li>The study reveals that the optimal approach for scaling test-time compute depends heavily on prompt difficulty. Based on this insight, the authors propose a “compute-optimal” scaling strategy, which adaptively allocates test-time compute depending on the problem’s complexity. This strategy improves efficiency by more than 4× compared to standard best-of-N sampling and can, under certain conditions, outperform models 14× larger with matched FLOPs.</li>\n  <li>In their experimental setup, they use PaLM 2-S (Codey) models fine-tuned for revision and verification tasks, evaluated on the challenging MATH benchmark. They evaluate methods to scale test-time compute, including revising answers iteratively and searching for correct solutions using PRMs. Key findings include:\n    <ul>\n      <li><strong>Revisions</strong>: When the LLM iteratively refines its responses, it achieves better performance on easier tasks by revising and optimizing its original answers. For more complex problems, parallel sampling (best-of-N) is generally more effective, especially when multiple high-level solution approaches must be explored.</li>\n      <li><strong>PRM-based Search</strong>: Process-based verifiers perform step-by-step evaluations of solutions, offering better guidance on complex problems. Beam search and lookahead search methods were explored, with beam search showing higher efficiency on more difficult prompts when the compute budget is limited. The following figure from the paper shows a comparison of different PRM search methods. Left: Best-of-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-1-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-2\"><span class=\"mi\" id=\"MathJax-Span-3\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-1\">N</script> samples <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-2-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-4\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-5\"><span class=\"mi\" id=\"MathJax-Span-6\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-2\">N</script> full answers and then selects the best answer according to the PRM final score. Center: Beam search samples <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-3-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-7\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-8\"><span class=\"mi\" id=\"MathJax-Span-9\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-3\">N</script> candidates at each step, and selects the top <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-4-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-10\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.94em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-11\"><span class=\"mi\" id=\"MathJax-Span-12\" style=\"font-family: STIXGeneral-Italic;\">M<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>M</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-4\">M</script> according to the PRM to continue the search from. Right: lookahead-search extends each step in beam-search to utilize a k-step lookahead while assessing which steps to retain and continue the search from. Thus lookahead-search needs more compute.</li>\n    </ul>\n\n    <p><img src=\"../../../images/papers/PRMSearch.jpg\" alt=\"\"></p>\n  </li>\n  <li>The following figure from the paper shows parallel sampling (e.g., Best-of-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-5-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-13\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-14\"><span class=\"mi\" id=\"MathJax-Span-15\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-5\">N</script>) verses sequential revisions. Left: Parallel sampling generates <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-6-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-16\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-17\"><span class=\"mi\" id=\"MathJax-Span-18\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-6\">N</script> answers independently in parallel, whereas sequential revisions generates each one in sequence conditioned on previous attempts. Right: In both the sequential and parallel cases, we can use the verifier to determine the best-of-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-7-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-19\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-20\"><span class=\"mi\" id=\"MathJax-Span-21\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-7\">N</script> answers (e.g. by applying best-of-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-8-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-22\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-23\"><span class=\"mi\" id=\"MathJax-Span-24\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-8\">N</script> weighted). We can also allocate some of our budget to parallel and some to sequential, effectively enabling a combination of the two sampling strategies. In this case, we use the verifier to first select the best answer within each sequential chain and then select the best answer accross chains.</li>\n</ul>\n<ul>\n      <li><strong>Revisions</strong>: When the LLM iteratively refines its responses, it achieves better performance on easier tasks by revising and optimizing its original answers. For more complex problems, parallel sampling (best-of-N) is generally more effective, especially when multiple high-level solution approaches must be explored.</li>\n      <li><strong>PRM-based Search</strong>: Process-based verifiers perform step-by-step evaluations of solutions, offering better guidance on complex problems. Beam search and lookahead search methods were explored, with beam search showing higher efficiency on more difficult prompts when the compute budget is limited. The following figure from the paper shows a comparison of different PRM search methods. Left: Best-of-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-1-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-1\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-2\"><span class=\"mi\" id=\"MathJax-Span-3\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-1\">N</script> samples <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-2-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-4\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-5\"><span class=\"mi\" id=\"MathJax-Span-6\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-2\">N</script> full answers and then selects the best answer according to the PRM final score. Center: Beam search samples <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-3-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-7\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-8\"><span class=\"mi\" id=\"MathJax-Span-9\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-3\">N</script> candidates at each step, and selects the top <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-4-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>M</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-10\" style=\"width: 1.148em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.94em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.94em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-11\"><span class=\"mi\" id=\"MathJax-Span-12\" style=\"font-family: STIXGeneral-Italic;\">M<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>M</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-4\">M</script> according to the PRM to continue the search from. Right: lookahead-search extends each step in beam-search to utilize a k-step lookahead while assessing which steps to retain and continue the search from. Thus lookahead-search needs more compute.</li>\n    </ul>\n<p><img src=\"../../../images/papers/PRMSearch.jpg\" alt=\"\"></p>\n<p><img src=\"../../../images/papers/ParallelSeqverifier.jpg\" alt=\"\"></p>\n<ul>\n  <li>The paper emphasizes that adaptive test-time compute scaling, based on the difficulty of the question, is essential. The proposed compute-optimal scaling strategy outperforms best-of-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-9-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-25\" style=\"width: 0.94em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.784em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.78em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-26\"><span class=\"mi\" id=\"MathJax-Span-27\" style=\"font-family: STIXGeneral-Italic;\">N<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.055em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>N</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-9\">N</script> with significantly less computation, particularly for easy and intermediate tasks. By dynamically choosing between search-based and revision-based methods, the authors demonstrate a practical way to optimize LLM performance within a constrained computational budget.</li>\n  <li>In addition, they show that test-time compute can be a viable substitute for additional pretraining, especially when handling easier questions or lower inference workloads. On the other hand, for harder questions, additional pretraining remains more effective. This tradeoff suggests that in specific deployment scenarios (e.g., where smaller models are desirable), emphasizing test-time compute scaling might reduce the need for training significantly larger models.</li>\n  <li>Finally, the authors propose future directions, including combining different methods of test-time compute (e.g., revisions and PRM-based search) and refining difficulty assessment during inference to further optimize test-time compute allocation.</li>\n</ul>",
    "contentMarkdown": "*   This paper by Snell et al. from UC Berkeley and Google DeepMind explores the scaling of inference-time computation in large language models (LLMs) and addresses the question of how much a fixed amount of test-time compute can improve model performance, particularly on difficult prompts. The authors focus on two primary mechanisms to scale test-time compute: (1) searching against dense process-based verifier reward models (PRMs) and (2) adaptively updating the model’s response distribution during test time.\n*   The study reveals that the optimal approach for scaling test-time compute depends heavily on prompt difficulty. Based on this insight, the authors propose a “compute-optimal” scaling strategy, which adaptively allocates test-time compute depending on the problem’s complexity. This strategy improves efficiency by more than 4× compared to standard best-of-N sampling and can, under certain conditions, outperform models 14× larger with matched FLOPs.\n*   In their experimental setup, they use PaLM 2-S (Codey) models fine-tuned for revision and verification tasks, evaluated on the challenging MATH benchmark. They evaluate methods to scale test-time compute, including revising answers iteratively and searching for correct solutions using PRMs. Key findings include:\n    \n    *   **Revisions**: When the LLM iteratively refines its responses, it achieves better performance on easier tasks by revising and optimizing its original answers. For more complex problems, parallel sampling (best-of-N) is generally more effective, especially when multiple high-level solution approaches must be explored.\n    *   **PRM-based Search**: Process-based verifiers perform step-by-step evaluations of solutions, offering better guidance on complex problems. Beam search and lookahead search methods were explored, with beam search showing higher efficiency on more difficult prompts when the compute budget is limited. The following figure from the paper shows a comparison of different PRM search methods. Left: Best-of-NNN samples NNN full answers and then selects the best answer according to the PRM final score. Center: Beam search samples NNN candidates at each step, and selects the top MMM according to the PRM to continue the search from. Right: lookahead-search extends each step in beam-search to utilize a k-step lookahead while assessing which steps to retain and continue the search from. Thus lookahead-search needs more compute.\n    \n    ![](../../../images/papers/PRMSearch.jpg)\n    \n*   The following figure from the paper shows parallel sampling (e.g., Best-of-NNN) verses sequential revisions. Left: Parallel sampling generates NNN answers independently in parallel, whereas sequential revisions generates each one in sequence conditioned on previous attempts. Right: In both the sequential and parallel cases, we can use the verifier to determine the best-of-NNN answers (e.g. by applying best-of-NNN weighted). We can also allocate some of our budget to parallel and some to sequential, effectively enabling a combination of the two sampling strategies. In this case, we use the verifier to first select the best answer within each sequential chain and then select the best answer accross chains.\n\n*   **Revisions**: When the LLM iteratively refines its responses, it achieves better performance on easier tasks by revising and optimizing its original answers. For more complex problems, parallel sampling (best-of-N) is generally more effective, especially when multiple high-level solution approaches must be explored.\n*   **PRM-based Search**: Process-based verifiers perform step-by-step evaluations of solutions, offering better guidance on complex problems. Beam search and lookahead search methods were explored, with beam search showing higher efficiency on more difficult prompts when the compute budget is limited. The following figure from the paper shows a comparison of different PRM search methods. Left: Best-of-NNN samples NNN full answers and then selects the best answer according to the PRM final score. Center: Beam search samples NNN candidates at each step, and selects the top MMM according to the PRM to continue the search from. Right: lookahead-search extends each step in beam-search to utilize a k-step lookahead while assessing which steps to retain and continue the search from. Thus lookahead-search needs more compute.\n\n![](../../../images/papers/PRMSearch.jpg)\n\n![](../../../images/papers/ParallelSeqverifier.jpg)\n\n*   The paper emphasizes that adaptive test-time compute scaling, based on the difficulty of the question, is essential. The proposed compute-optimal scaling strategy outperforms best-of-NNN with significantly less computation, particularly for easy and intermediate tasks. By dynamically choosing between search-based and revision-based methods, the authors demonstrate a practical way to optimize LLM performance within a constrained computational budget.\n*   In addition, they show that test-time compute can be a viable substitute for additional pretraining, especially when handling easier questions or lower inference workloads. On the other hand, for harder questions, additional pretraining remains more effective. This tradeoff suggests that in specific deployment scenarios (e.g., where smaller models are desirable), emphasizing test-time compute scaling might reduce the need for training significantly larger models.\n*   Finally, the authors propose future directions, including combining different methods of test-time compute (e.g., revisions and PRM-based search) and refining difficulty assessment during inference to further optimize test-time compute allocation.",
    "order": 16,
    "orderInChapter": 2,
    "difficulty": 4,
    "estimatedMinutes": 4,
    "tags": [
      "models",
      "llm"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": true,
      "hasImages": true,
      "wordCount": 778,
      "contentLength": 22277
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#scaling-llm-test-time-compute-optimally-can-be-more-effective-than-scaling-model-parameters",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-star-self-taught-reasoner-bootstrapping-reasoning--17",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "STaR: Self-Taught Reasoner: Bootstrapping Reasoning with Reasoning",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Zelikman et al. from Stanford and Google introduces the Self-Taught Reasoner (STaR), a technique for bootstrapping the ability of large language models (LLMs) to generate reasoning-based answers (rationales) iteratively. The goal of STaR is to improve the LLM’s performance on complex reasoning tasks like arithmetic and commonsense question answering without the need for manually curated large datasets of rationales. Instead, the method iteratively generates and fine-tunes rationales using a small set of initial examples, allowing the model to “teach itself” more complex reasoning over time.</li>\n  <li>The core of the STaR approach relies on a simple yet iterative loop:\n    <ol>\n      <li><strong>Rationale Generation</strong>: A pretrained LLM is prompted with a few rationale examples (e.g., 10 for arithmetic) and tasked with generating rationales for a set of questions. Only rationales that yield correct answers are retained.</li>\n      <li><strong>Fine-Tuning</strong>: The model is fine-tuned on these filtered correct rationales to improve its ability to generate them.</li>\n      <li><strong>Rationalization</strong>: For problems where the model fails to generate correct answers, it is provided with the correct answer and asked to “rationalize” it by generating a rationale. This technique allows the model to improve by reasoning backward from the correct answer.</li>\n    </ol>\n  </li>\n  <li>This process is repeated across multiple iterations, with the model learning to solve increasingly complex tasks through rationale generation and rationalization.</li>\n  <li>The following figure from the paper shows an overview of STaR and a STaR-generated rationale on CommonsenseQA. We indicate the fine-tuning outer loop with a dashed line. The questions and ground truth answers are expected to be present in the dataset, while the rationales are generated using STaR.</li>\n</ul>\n<ol>\n      <li><strong>Rationale Generation</strong>: A pretrained LLM is prompted with a few rationale examples (e.g., 10 for arithmetic) and tasked with generating rationales for a set of questions. Only rationales that yield correct answers are retained.</li>\n      <li><strong>Fine-Tuning</strong>: The model is fine-tuned on these filtered correct rationales to improve its ability to generate them.</li>\n      <li><strong>Rationalization</strong>: For problems where the model fails to generate correct answers, it is provided with the correct answer and asked to “rationalize” it by generating a rationale. This technique allows the model to improve by reasoning backward from the correct answer.</li>\n    </ol>\n<p><img src=\"../../../images/papers/STaR.jpg\" alt=\"\"></p>\n<ul>\n  <li><strong>Implementation Details:</strong>\n    <ul>\n      <li><strong>Initial Setup</strong>: STaR starts with a small prompt set of rationale-annotated examples (e.g., 10 examples in the case of arithmetic). Each example in the dataset is then augmented with these few-shot rationales, encouraging the model to generate a rationale for the given question.</li>\n      <li><strong>Filtering</strong>: Rationales are filtered by whether they result in the correct final answer, and only correct rationales are used for fine-tuning.</li>\n      <li><strong>Training Process</strong>: The model is fine-tuned in a loop, with the number of fine-tuning steps increased by 20% per iteration. Fine-tuning starts with 40 training steps and slowly scales up.</li>\n      <li><strong>Rationalization</strong>: When the model fails to generate a correct rationale, it is prompted with the correct answer and asked to generate a rationale based on this information. These rationales are added to the fine-tuning dataset for further improvement.</li>\n      <li><strong>Avoiding Overfitting</strong>: The model is always retrained from the original pre-trained model rather than continuing to train the same model across iterations, to prevent overfitting.</li>\n    </ul>\n  </li>\n  <li><strong>Results:</strong>\n    <ul>\n      <li><strong>Arithmetic</strong>: The model’s performance improved significantly after each iteration. Without rationalization, STaR improved performance on n-digit addition problems in a stage-wise fashion (improving on simpler problems first), while rationalization enabled the model to learn across different problem sizes simultaneously.</li>\n      <li><strong>CommonsenseQA</strong>: STaR outperformed a GPT-J model fine-tuned directly on answers, achieving 72.5% accuracy compared to 73.0% for a 30× larger GPT-3 model. STaR with rationalization outperformed models without rationalization, indicating the added benefit of rationalizing incorrect answers.</li>\n      <li><strong>Generalization</strong>: The STaR approach also demonstrated the ability to generalize beyond training data, solving unseen, out-of-distribution problems in arithmetic.</li>\n    </ul>\n  </li>\n  <li><strong>Key Contributions:</strong>\n    <ol>\n      <li>STaR provides a scalable bootstrapping technique that allows models to iteratively improve their reasoning abilities without relying on large rationale-annotated datasets.</li>\n      <li>The inclusion of rationalization as a mechanism for solving problems that the model initially fails to answer correctly enhances the training process by exposing the model to more difficult problems.</li>\n      <li>STaR’s iterative approach makes it a broadly applicable method for improving model reasoning across domains, including arithmetic and commonsense reasoning tasks.</li>\n    </ol>\n  </li>\n  <li>In summary, STaR introduces a novel iterative reasoning-based training approach that improves the reasoning capability of LLMs using a small set of rationale examples and a large dataset without rationales. This method significantly enhances model performance on both symbolic and natural language reasoning tasks.</li>\n</ul>\n<ul>\n      <li><strong>Initial Setup</strong>: STaR starts with a small prompt set of rationale-annotated examples (e.g., 10 examples in the case of arithmetic). Each example in the dataset is then augmented with these few-shot rationales, encouraging the model to generate a rationale for the given question.</li>\n      <li><strong>Filtering</strong>: Rationales are filtered by whether they result in the correct final answer, and only correct rationales are used for fine-tuning.</li>\n      <li><strong>Training Process</strong>: The model is fine-tuned in a loop, with the number of fine-tuning steps increased by 20% per iteration. Fine-tuning starts with 40 training steps and slowly scales up.</li>\n      <li><strong>Rationalization</strong>: When the model fails to generate a correct rationale, it is prompted with the correct answer and asked to generate a rationale based on this information. These rationales are added to the fine-tuning dataset for further improvement.</li>\n      <li><strong>Avoiding Overfitting</strong>: The model is always retrained from the original pre-trained model rather than continuing to train the same model across iterations, to prevent overfitting.</li>\n    </ul>\n<ul>\n      <li><strong>Arithmetic</strong>: The model’s performance improved significantly after each iteration. Without rationalization, STaR improved performance on n-digit addition problems in a stage-wise fashion (improving on simpler problems first), while rationalization enabled the model to learn across different problem sizes simultaneously.</li>\n      <li><strong>CommonsenseQA</strong>: STaR outperformed a GPT-J model fine-tuned directly on answers, achieving 72.5% accuracy compared to 73.0% for a 30× larger GPT-3 model. STaR with rationalization outperformed models without rationalization, indicating the added benefit of rationalizing incorrect answers.</li>\n      <li><strong>Generalization</strong>: The STaR approach also demonstrated the ability to generalize beyond training data, solving unseen, out-of-distribution problems in arithmetic.</li>\n    </ul>\n<ol>\n      <li>STaR provides a scalable bootstrapping technique that allows models to iteratively improve their reasoning abilities without relying on large rationale-annotated datasets.</li>\n      <li>The inclusion of rationalization as a mechanism for solving problems that the model initially fails to answer correctly enhances the training process by exposing the model to more difficult problems.</li>\n      <li>STaR’s iterative approach makes it a broadly applicable method for improving model reasoning across domains, including arithmetic and commonsense reasoning tasks.</li>\n    </ol>",
    "contentMarkdown": "*   This paper by Zelikman et al. from Stanford and Google introduces the Self-Taught Reasoner (STaR), a technique for bootstrapping the ability of large language models (LLMs) to generate reasoning-based answers (rationales) iteratively. The goal of STaR is to improve the LLM’s performance on complex reasoning tasks like arithmetic and commonsense question answering without the need for manually curated large datasets of rationales. Instead, the method iteratively generates and fine-tunes rationales using a small set of initial examples, allowing the model to “teach itself” more complex reasoning over time.\n*   The core of the STaR approach relies on a simple yet iterative loop:\n    1.  **Rationale Generation**: A pretrained LLM is prompted with a few rationale examples (e.g., 10 for arithmetic) and tasked with generating rationales for a set of questions. Only rationales that yield correct answers are retained.\n    2.  **Fine-Tuning**: The model is fine-tuned on these filtered correct rationales to improve its ability to generate them.\n    3.  **Rationalization**: For problems where the model fails to generate correct answers, it is provided with the correct answer and asked to “rationalize” it by generating a rationale. This technique allows the model to improve by reasoning backward from the correct answer.\n*   This process is repeated across multiple iterations, with the model learning to solve increasingly complex tasks through rationale generation and rationalization.\n*   The following figure from the paper shows an overview of STaR and a STaR-generated rationale on CommonsenseQA. We indicate the fine-tuning outer loop with a dashed line. The questions and ground truth answers are expected to be present in the dataset, while the rationales are generated using STaR.\n\n1.  **Rationale Generation**: A pretrained LLM is prompted with a few rationale examples (e.g., 10 for arithmetic) and tasked with generating rationales for a set of questions. Only rationales that yield correct answers are retained.\n2.  **Fine-Tuning**: The model is fine-tuned on these filtered correct rationales to improve its ability to generate them.\n3.  **Rationalization**: For problems where the model fails to generate correct answers, it is provided with the correct answer and asked to “rationalize” it by generating a rationale. This technique allows the model to improve by reasoning backward from the correct answer.\n\n![](../../../images/papers/STaR.jpg)\n\n*   **Implementation Details:**\n    *   **Initial Setup**: STaR starts with a small prompt set of rationale-annotated examples (e.g., 10 examples in the case of arithmetic). Each example in the dataset is then augmented with these few-shot rationales, encouraging the model to generate a rationale for the given question.\n    *   **Filtering**: Rationales are filtered by whether they result in the correct final answer, and only correct rationales are used for fine-tuning.\n    *   **Training Process**: The model is fine-tuned in a loop, with the number of fine-tuning steps increased by 20% per iteration. Fine-tuning starts with 40 training steps and slowly scales up.\n    *   **Rationalization**: When the model fails to generate a correct rationale, it is prompted with the correct answer and asked to generate a rationale based on this information. These rationales are added to the fine-tuning dataset for further improvement.\n    *   **Avoiding Overfitting**: The model is always retrained from the original pre-trained model rather than continuing to train the same model across iterations, to prevent overfitting.\n*   **Results:**\n    *   **Arithmetic**: The model’s performance improved significantly after each iteration. Without rationalization, STaR improved performance on n-digit addition problems in a stage-wise fashion (improving on simpler problems first), while rationalization enabled the model to learn across different problem sizes simultaneously.\n    *   **CommonsenseQA**: STaR outperformed a GPT-J model fine-tuned directly on answers, achieving 72.5% accuracy compared to 73.0% for a 30× larger GPT-3 model. STaR with rationalization outperformed models without rationalization, indicating the added benefit of rationalizing incorrect answers.\n    *   **Generalization**: The STaR approach also demonstrated the ability to generalize beyond training data, solving unseen, out-of-distribution problems in arithmetic.\n*   **Key Contributions:**\n    1.  STaR provides a scalable bootstrapping technique that allows models to iteratively improve their reasoning abilities without relying on large rationale-annotated datasets.\n    2.  The inclusion of rationalization as a mechanism for solving problems that the model initially fails to answer correctly enhances the training process by exposing the model to more difficult problems.\n    3.  STaR’s iterative approach makes it a broadly applicable method for improving model reasoning across domains, including arithmetic and commonsense reasoning tasks.\n*   In summary, STaR introduces a novel iterative reasoning-based training approach that improves the reasoning capability of LLMs using a small set of rationale examples and a large dataset without rationales. This method significantly enhances model performance on both symbolic and natural language reasoning tasks.\n\n*   **Initial Setup**: STaR starts with a small prompt set of rationale-annotated examples (e.g., 10 examples in the case of arithmetic). Each example in the dataset is then augmented with these few-shot rationales, encouraging the model to generate a rationale for the given question.\n*   **Filtering**: Rationales are filtered by whether they result in the correct final answer, and only correct rationales are used for fine-tuning.\n*   **Training Process**: The model is fine-tuned in a loop, with the number of fine-tuning steps increased by 20% per iteration. Fine-tuning starts with 40 training steps and slowly scales up.\n*   **Rationalization**: When the model fails to generate a correct rationale, it is prompted with the correct answer and asked to generate a rationale based on this information. These rationales are added to the fine-tuning dataset for further improvement.\n*   **Avoiding Overfitting**: The model is always retrained from the original pre-trained model rather than continuing to train the same model across iterations, to prevent overfitting.\n\n*   **Arithmetic**: The model’s performance improved significantly after each iteration. Without rationalization, STaR improved performance on n-digit addition problems in a stage-wise fashion (improving on simpler problems first), while rationalization enabled the model to learn across different problem sizes simultaneously.\n*   **CommonsenseQA**: STaR outperformed a GPT-J model fine-tuned directly on answers, achieving 72.5% accuracy compared to 73.0% for a 30× larger GPT-3 model. STaR with rationalization outperformed models without rationalization, indicating the added benefit of rationalizing incorrect answers.\n*   **Generalization**: The STaR approach also demonstrated the ability to generalize beyond training data, solving unseen, out-of-distribution problems in arithmetic.\n\n1.  STaR provides a scalable bootstrapping technique that allows models to iteratively improve their reasoning abilities without relying on large rationale-annotated datasets.\n2.  The inclusion of rationalization as a mechanism for solving problems that the model initially fails to answer correctly enhances the training process by exposing the model to more difficult problems.\n3.  STaR’s iterative approach makes it a broadly applicable method for improving model reasoning across domains, including arithmetic and commonsense reasoning tasks.",
    "order": 17,
    "orderInChapter": 3,
    "difficulty": 3,
    "estimatedMinutes": 6,
    "tags": [
      "models",
      "gpt",
      "llm",
      "fine-tuning"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 1088,
      "contentLength": 8558
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#star:-self-taught-reasoner:-bootstrapping-reasoning-with-reasoning",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-quiet-star-language-models-can-teach-themselves-to-18",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Zelikman from Stanford and Notbad AI, generalizes the Self-Taught Reasoner (STaR) method by teaching language models (LMs) to reason implicitly through continuous text without relying on curated reasoning datasets. The key idea behind Quiet-STaR is to allow LMs to generate “thoughts” or rationales at each token position, helping predict future tokens and improving overall performance. The authors extend the STaR approach, which previously focused on specific tasks like question-answering, to a more general framework where the LM generates and learns from rationales embedded in arbitrary text.</li>\n  <li>The core implementation of Quiet-STaR involves three major steps:\n    <ol>\n      <li><strong>Parallel Rationale Generation</strong>: The LM generates rationales after every token to explain the continuation of future tokens. A key challenge resolved here is the computational inefficiency of generating continuations at every token. The authors propose a token-wise parallel sampling algorithm that allows for efficient generation by caching forward passes and employing diagonal attention masking.</li>\n      <li><strong>Mixing Head for Prediction Integration</strong>: A “mixing head” model is trained to combine predictions made with and without rationales. This helps manage the distribution shift caused by introducing rationales in a pre-trained model. The head outputs a weight that determines how much the rationale-based prediction should influence the overall token prediction.</li>\n      <li><strong>Rationale Optimization with REINFORCE</strong>: The model’s rationale generation is optimized using a REINFORCE-based objective, rewarding rationales that improve the likelihood of future token predictions. This method allows the LM to learn to generate rationales that help predict the next tokens more effectively, based on feedback from their impact on future token prediction.</li>\n    </ol>\n  </li>\n  <li>The following figure from the paper shows Quiet-STaR visualized as applied during training to a single thought. We generate thoughts, in parallel, following all tokens in the text (think). The model produces a mixture of its next-token predictions with and without a thought (talk). They apply REINFORCE, as in STaR, to increase the likelihood of thoughts that help the model predict future text while discarding thoughts that make the future text less likely (learn).</li>\n</ul>\n<ol>\n      <li><strong>Parallel Rationale Generation</strong>: The LM generates rationales after every token to explain the continuation of future tokens. A key challenge resolved here is the computational inefficiency of generating continuations at every token. The authors propose a token-wise parallel sampling algorithm that allows for efficient generation by caching forward passes and employing diagonal attention masking.</li>\n      <li><strong>Mixing Head for Prediction Integration</strong>: A “mixing head” model is trained to combine predictions made with and without rationales. This helps manage the distribution shift caused by introducing rationales in a pre-trained model. The head outputs a weight that determines how much the rationale-based prediction should influence the overall token prediction.</li>\n      <li><strong>Rationale Optimization with REINFORCE</strong>: The model’s rationale generation is optimized using a REINFORCE-based objective, rewarding rationales that improve the likelihood of future token predictions. This method allows the LM to learn to generate rationales that help predict the next tokens more effectively, based on feedback from their impact on future token prediction.</li>\n    </ol>\n<p><img src=\"../../../images/papers/Quiet-STaR.jpg\" alt=\"\"></p>\n<ul>\n  <li>The following figure from the paper shows parallel generation. By constructing an attention mask that allows all thought tokens to pay attention to themselves, all preceding thought tokens within the same thought, and the preceding text, we can generate continuations of all of the thoughts in parallel. Each inference call is used to generate one additional thought token for all text tokens.</li>\n</ul>\n<p><img src=\"../../../images/papers/Quiet-STaR1.jpg\" alt=\"\"></p>\n<ul>\n  <li>The following figure from the paper shows the forward pass and teacher forcing. We visualize a single forward pass of our algorithm. Solid lines denote language model computation, while dashed lines indicate tokens are inserted via teacher forcing, and the mixer represents the mixing head. In particular, we visualize predicting three tokens ahead. Thought generation is shown in more detail in the above two figures.</li>\n</ul>\n<p><img src=\"../../../images/papers/Quiet-STaR2.jpg\" alt=\"\"></p>\n<ul>\n  <li>The authors also introduce custom tokens, specifically <code class=\"language-plaintext highlighter-rouge\">&lt;|startofthought|&gt;</code> and <code class=\"language-plaintext highlighter-rouge\">&lt;|endofthought|&gt;</code>, which mark the beginning and end of the rationale generation. These tokens are initialized based on the LM’s existing knowledge (e.g., em dash “<code class=\"language-plaintext highlighter-rouge\">−−−</code>”) and fine-tuned for optimal performance.</li>\n  <li>One of the significant findings from the experiments was that training with Quiet-STaR on diverse text datasets (like C4 and OpenWebMath) improved zero-shot reasoning abilities on commonsense reasoning tasks like GSM8K and CommonsenseQA. The LM showed improved performance in reasoning tasks without any task-specific fine-tuning, demonstrating the effectiveness of Quiet-STaR in enhancing reasoning in LMs in a generalizable and scalable way.</li>\n  <li>For example, zero-shot performance on GSM8K improved from 5.9% to 10.9%, and on CommonsenseQA from 36.3% to 47.2%. These improvements are primarily driven by difficult-to-predict tokens, where Quiet-STaR’s rationales prove most beneficial. Furthermore, longer thought sequences resulted in better predictions, suggesting that more detailed reasoning steps enhance token prediction accuracy.</li>\n  <li>The computational overhead of Quiet-STaR is notable, as generating rationales adds complexity. However, the authors argue that this overhead can be leveraged to improve the model’s performance in tasks that require deeper reasoning. The results suggest that Quiet-STaR can enhance not only language modeling but also chain-of-thought reasoning, where reasoning steps are crucial for solving more complex tasks.</li>\n  <li>In conclusion, Quiet-STaR represents a significant step towards generalizable reasoning in language models by embedding continuous rationales in text generation, ultimately leading to better zero-shot reasoning performance across a range of tasks. The method also opens up potential future directions, such as dynamically predicting when rationale generation is needed and ensembling rationales for further improvements in reasoning capabilities.</li>\n</ul>",
    "contentMarkdown": "*   This paper by Zelikman from Stanford and Notbad AI, generalizes the Self-Taught Reasoner (STaR) method by teaching language models (LMs) to reason implicitly through continuous text without relying on curated reasoning datasets. The key idea behind Quiet-STaR is to allow LMs to generate “thoughts” or rationales at each token position, helping predict future tokens and improving overall performance. The authors extend the STaR approach, which previously focused on specific tasks like question-answering, to a more general framework where the LM generates and learns from rationales embedded in arbitrary text.\n*   The core implementation of Quiet-STaR involves three major steps:\n    1.  **Parallel Rationale Generation**: The LM generates rationales after every token to explain the continuation of future tokens. A key challenge resolved here is the computational inefficiency of generating continuations at every token. The authors propose a token-wise parallel sampling algorithm that allows for efficient generation by caching forward passes and employing diagonal attention masking.\n    2.  **Mixing Head for Prediction Integration**: A “mixing head” model is trained to combine predictions made with and without rationales. This helps manage the distribution shift caused by introducing rationales in a pre-trained model. The head outputs a weight that determines how much the rationale-based prediction should influence the overall token prediction.\n    3.  **Rationale Optimization with REINFORCE**: The model’s rationale generation is optimized using a REINFORCE-based objective, rewarding rationales that improve the likelihood of future token predictions. This method allows the LM to learn to generate rationales that help predict the next tokens more effectively, based on feedback from their impact on future token prediction.\n*   The following figure from the paper shows Quiet-STaR visualized as applied during training to a single thought. We generate thoughts, in parallel, following all tokens in the text (think). The model produces a mixture of its next-token predictions with and without a thought (talk). They apply REINFORCE, as in STaR, to increase the likelihood of thoughts that help the model predict future text while discarding thoughts that make the future text less likely (learn).\n\n1.  **Parallel Rationale Generation**: The LM generates rationales after every token to explain the continuation of future tokens. A key challenge resolved here is the computational inefficiency of generating continuations at every token. The authors propose a token-wise parallel sampling algorithm that allows for efficient generation by caching forward passes and employing diagonal attention masking.\n2.  **Mixing Head for Prediction Integration**: A “mixing head” model is trained to combine predictions made with and without rationales. This helps manage the distribution shift caused by introducing rationales in a pre-trained model. The head outputs a weight that determines how much the rationale-based prediction should influence the overall token prediction.\n3.  **Rationale Optimization with REINFORCE**: The model’s rationale generation is optimized using a REINFORCE-based objective, rewarding rationales that improve the likelihood of future token predictions. This method allows the LM to learn to generate rationales that help predict the next tokens more effectively, based on feedback from their impact on future token prediction.\n\n![](../../../images/papers/Quiet-STaR.jpg)\n\n*   The following figure from the paper shows parallel generation. By constructing an attention mask that allows all thought tokens to pay attention to themselves, all preceding thought tokens within the same thought, and the preceding text, we can generate continuations of all of the thoughts in parallel. Each inference call is used to generate one additional thought token for all text tokens.\n\n![](../../../images/papers/Quiet-STaR1.jpg)\n\n*   The following figure from the paper shows the forward pass and teacher forcing. We visualize a single forward pass of our algorithm. Solid lines denote language model computation, while dashed lines indicate tokens are inserted via teacher forcing, and the mixer represents the mixing head. In particular, we visualize predicting three tokens ahead. Thought generation is shown in more detail in the above two figures.\n\n![](../../../images/papers/Quiet-STaR2.jpg)\n\n*   The authors also introduce custom tokens, specifically `<|startofthought|>` and `<|endofthought|>`, which mark the beginning and end of the rationale generation. These tokens are initialized based on the LM’s existing knowledge (e.g., em dash “`−−−`”) and fine-tuned for optimal performance.\n*   One of the significant findings from the experiments was that training with Quiet-STaR on diverse text datasets (like C4 and OpenWebMath) improved zero-shot reasoning abilities on commonsense reasoning tasks like GSM8K and CommonsenseQA. The LM showed improved performance in reasoning tasks without any task-specific fine-tuning, demonstrating the effectiveness of Quiet-STaR in enhancing reasoning in LMs in a generalizable and scalable way.\n*   For example, zero-shot performance on GSM8K improved from 5.9% to 10.9%, and on CommonsenseQA from 36.3% to 47.2%. These improvements are primarily driven by difficult-to-predict tokens, where Quiet-STaR’s rationales prove most beneficial. Furthermore, longer thought sequences resulted in better predictions, suggesting that more detailed reasoning steps enhance token prediction accuracy.\n*   The computational overhead of Quiet-STaR is notable, as generating rationales adds complexity. However, the authors argue that this overhead can be leveraged to improve the model’s performance in tasks that require deeper reasoning. The results suggest that Quiet-STaR can enhance not only language modeling but also chain-of-thought reasoning, where reasoning steps are crucial for solving more complex tasks.\n*   In conclusion, Quiet-STaR represents a significant step towards generalizable reasoning in language models by embedding continuous rationales in text generation, ultimately leading to better zero-shot reasoning performance across a range of tasks. The method also opens up potential future directions, such as dynamically predicting when rationale generation is needed and ensembling rationales for further improvements in reasoning capabilities.",
    "order": 18,
    "orderInChapter": 4,
    "difficulty": 4,
    "estimatedMinutes": 5,
    "tags": [
      "models",
      "attention",
      "embedding",
      "optimization",
      "fine-tuning"
    ],
    "metadata": {
      "hasCode": true,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 898,
      "contentLength": 6955
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#quiet-star:-language-models-can-teach-themselves-to-think-before-speaking",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-large-language-monkeys-scaling-inference-compute-w-19",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Large Language Monkeys: Scaling Inference Compute with Repeated Sampling",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Brown et al. from Stanford, University of Oxford, and Google DeepMind, explores a novel methodology for scaling inference compute in large language models (LLMs) by utilizing repeated sampling. Instead of relying on a single inference attempt per problem, the authors propose increasing the number of generated samples to improve task coverage, particularly in tasks where answers can be automatically verified.</li>\n  <li>The paper investigates two key aspects of the repeated sampling strategy:\n    <ol>\n      <li><strong>Coverage</strong>: The fraction of problems that can be solved by any generated sample.</li>\n      <li><strong>Precision</strong>: The ability to identify the correct solution from the generated samples.</li>\n    </ol>\n  </li>\n  <li><strong>Technical Details:</strong>\n  The authors demonstrate that by scaling the number of inference samples, task coverage can increase exponentially across various domains such as coding and formal proofs, where answers are verifiable. For instance, using the SWE-bench Lite benchmark, the fraction of issues solved with DeepSeek-V2-Coder-Instruct increased from 15.9% with one sample to 56% with 250 samples, surpassing the state-of-the-art performance of 43% by more capable models like GPT-4o and Claude 3.5 Sonnet.</li>\n  <li><strong>Key Observations:</strong>\n    <ul>\n      <li><strong>Log-linear scaling of coverage</strong>: Across multiple models (e.g., Llama-3 and Gemma), the coverage exhibits a nearly log-linear relationship with the number of generated samples. This scaling behavior is modeled with an exponentiated power law, indicating the existence of potential inference-time scaling laws.</li>\n      <li><strong>Cost-efficiency</strong>: Repeated sampling of cheaper models like DeepSeek can outperform single-sample inferences from premium models (e.g., GPT-4o) in terms of both performance and cost-effectiveness, providing up to 3x cost savings.</li>\n    </ul>\n  </li>\n  <li>The following figure from the paper shows the proposed repeated sampling procedure: (i) Generate many candidate solutions for a given problem by sampling from an LLM with a positive temperature. (ii) Use a domain-specific verifier (ex. unit tests for code) to select a final answer from the generated samples.</li>\n</ul>\n<ol>\n      <li><strong>Coverage</strong>: The fraction of problems that can be solved by any generated sample.</li>\n      <li><strong>Precision</strong>: The ability to identify the correct solution from the generated samples.</li>\n    </ol>\n<ul>\n      <li><strong>Log-linear scaling of coverage</strong>: Across multiple models (e.g., Llama-3 and Gemma), the coverage exhibits a nearly log-linear relationship with the number of generated samples. This scaling behavior is modeled with an exponentiated power law, indicating the existence of potential inference-time scaling laws.</li>\n      <li><strong>Cost-efficiency</strong>: Repeated sampling of cheaper models like DeepSeek can outperform single-sample inferences from premium models (e.g., GPT-4o) in terms of both performance and cost-effectiveness, providing up to 3x cost savings.</li>\n    </ul>\n<p><img src=\"../../../images/papers/LLMonkeys.jpg\" alt=\"\"></p>\n<ul>\n  <li><strong>Implementation:</strong>\n  The repeated sampling methodology is implemented through the following steps:\n    <ol>\n      <li><strong>Sample generation</strong>: For each problem, multiple candidate solutions are generated by the LLM with a positive sampling temperature.</li>\n      <li><strong>Verification</strong>: Solutions are verified using domain-specific verifiers (e.g., unit tests for code or proof checkers for formal proofs). In domains like coding, verification is fully automatic, translating the increased coverage into better performance.</li>\n      <li><strong>Evaluation of Coverage</strong>: Coverage is evaluated using metrics such as pass@k, where k is the number of generated samples. For example, pass@10,000 was used to evaluate the CodeContests and MATH datasets.</li>\n    </ol>\n  </li>\n  <li><strong>Empirical Results:</strong>\n    <ul>\n      <li><strong>Programming tasks</strong>: On the CodeContests dataset, the coverage of weaker models like Gemma-2B increased from 0.02% with one sample to 7.1% with 10,000 samples.</li>\n      <li><strong>Mathematical problems</strong>: For math word problems from the GSM8K and MATH datasets, coverage increased to over 95% with 10,000 samples. However, methods to select the correct solution, such as majority voting or reward models, plateau after several hundred samples, highlighting the need for better solution selection mechanisms.</li>\n    </ul>\n  </li>\n  <li><strong>Future Directions:</strong>\n  The paper points out that identifying correct solutions from multiple samples remains a challenge in domains without automatic verifiers (e.g., math word problems). Additionally, the work opens up further research avenues, including optimizing sample diversity and leveraging multi-turn interactions for iterative problem-solving.</li>\n  <li>This work underscores the potential of scaling inference compute through repeated sampling, demonstrating significant improvements in model performance while offering a cost-effective alternative to using larger, more expensive models.</li>\n</ul>\n<ol>\n      <li><strong>Sample generation</strong>: For each problem, multiple candidate solutions are generated by the LLM with a positive sampling temperature.</li>\n      <li><strong>Verification</strong>: Solutions are verified using domain-specific verifiers (e.g., unit tests for code or proof checkers for formal proofs). In domains like coding, verification is fully automatic, translating the increased coverage into better performance.</li>\n      <li><strong>Evaluation of Coverage</strong>: Coverage is evaluated using metrics such as pass@k, where k is the number of generated samples. For example, pass@10,000 was used to evaluate the CodeContests and MATH datasets.</li>\n    </ol>\n<ul>\n      <li><strong>Programming tasks</strong>: On the CodeContests dataset, the coverage of weaker models like Gemma-2B increased from 0.02% with one sample to 7.1% with 10,000 samples.</li>\n      <li><strong>Mathematical problems</strong>: For math word problems from the GSM8K and MATH datasets, coverage increased to over 95% with 10,000 samples. However, methods to select the correct solution, such as majority voting or reward models, plateau after several hundred samples, highlighting the need for better solution selection mechanisms.</li>\n    </ul>",
    "contentMarkdown": "*   This paper by Brown et al. from Stanford, University of Oxford, and Google DeepMind, explores a novel methodology for scaling inference compute in large language models (LLMs) by utilizing repeated sampling. Instead of relying on a single inference attempt per problem, the authors propose increasing the number of generated samples to improve task coverage, particularly in tasks where answers can be automatically verified.\n*   The paper investigates two key aspects of the repeated sampling strategy:\n    1.  **Coverage**: The fraction of problems that can be solved by any generated sample.\n    2.  **Precision**: The ability to identify the correct solution from the generated samples.\n*   **Technical Details:** The authors demonstrate that by scaling the number of inference samples, task coverage can increase exponentially across various domains such as coding and formal proofs, where answers are verifiable. For instance, using the SWE-bench Lite benchmark, the fraction of issues solved with DeepSeek-V2-Coder-Instruct increased from 15.9% with one sample to 56% with 250 samples, surpassing the state-of-the-art performance of 43% by more capable models like GPT-4o and Claude 3.5 Sonnet.\n*   **Key Observations:**\n    *   **Log-linear scaling of coverage**: Across multiple models (e.g., Llama-3 and Gemma), the coverage exhibits a nearly log-linear relationship with the number of generated samples. This scaling behavior is modeled with an exponentiated power law, indicating the existence of potential inference-time scaling laws.\n    *   **Cost-efficiency**: Repeated sampling of cheaper models like DeepSeek can outperform single-sample inferences from premium models (e.g., GPT-4o) in terms of both performance and cost-effectiveness, providing up to 3x cost savings.\n*   The following figure from the paper shows the proposed repeated sampling procedure: (i) Generate many candidate solutions for a given problem by sampling from an LLM with a positive temperature. (ii) Use a domain-specific verifier (ex. unit tests for code) to select a final answer from the generated samples.\n\n1.  **Coverage**: The fraction of problems that can be solved by any generated sample.\n2.  **Precision**: The ability to identify the correct solution from the generated samples.\n\n*   **Log-linear scaling of coverage**: Across multiple models (e.g., Llama-3 and Gemma), the coverage exhibits a nearly log-linear relationship with the number of generated samples. This scaling behavior is modeled with an exponentiated power law, indicating the existence of potential inference-time scaling laws.\n*   **Cost-efficiency**: Repeated sampling of cheaper models like DeepSeek can outperform single-sample inferences from premium models (e.g., GPT-4o) in terms of both performance and cost-effectiveness, providing up to 3x cost savings.\n\n![](../../../images/papers/LLMonkeys.jpg)\n\n*   **Implementation:** The repeated sampling methodology is implemented through the following steps:\n    1.  **Sample generation**: For each problem, multiple candidate solutions are generated by the LLM with a positive sampling temperature.\n    2.  **Verification**: Solutions are verified using domain-specific verifiers (e.g., unit tests for code or proof checkers for formal proofs). In domains like coding, verification is fully automatic, translating the increased coverage into better performance.\n    3.  **Evaluation of Coverage**: Coverage is evaluated using metrics such as pass@k, where k is the number of generated samples. For example, pass@10,000 was used to evaluate the CodeContests and MATH datasets.\n*   **Empirical Results:**\n    *   **Programming tasks**: On the CodeContests dataset, the coverage of weaker models like Gemma-2B increased from 0.02% with one sample to 7.1% with 10,000 samples.\n    *   **Mathematical problems**: For math word problems from the GSM8K and MATH datasets, coverage increased to over 95% with 10,000 samples. However, methods to select the correct solution, such as majority voting or reward models, plateau after several hundred samples, highlighting the need for better solution selection mechanisms.\n*   **Future Directions:** The paper points out that identifying correct solutions from multiple samples remains a challenge in domains without automatic verifiers (e.g., math word problems). Additionally, the work opens up further research avenues, including optimizing sample diversity and leveraging multi-turn interactions for iterative problem-solving.\n*   This work underscores the potential of scaling inference compute through repeated sampling, demonstrating significant improvements in model performance while offering a cost-effective alternative to using larger, more expensive models.\n\n1.  **Sample generation**: For each problem, multiple candidate solutions are generated by the LLM with a positive sampling temperature.\n2.  **Verification**: Solutions are verified using domain-specific verifiers (e.g., unit tests for code or proof checkers for formal proofs). In domains like coding, verification is fully automatic, translating the increased coverage into better performance.\n3.  **Evaluation of Coverage**: Coverage is evaluated using metrics such as pass@k, where k is the number of generated samples. For example, pass@10,000 was used to evaluate the CodeContests and MATH datasets.\n\n*   **Programming tasks**: On the CodeContests dataset, the coverage of weaker models like Gemma-2B increased from 0.02% with one sample to 7.1% with 10,000 samples.\n*   **Mathematical problems**: For math word problems from the GSM8K and MATH datasets, coverage increased to over 95% with 10,000 samples. However, methods to select the correct solution, such as majority voting or reward models, plateau after several hundred samples, highlighting the need for better solution selection mechanisms.",
    "order": 19,
    "orderInChapter": 5,
    "difficulty": 3,
    "estimatedMinutes": 5,
    "tags": [
      "models",
      "gpt",
      "llm"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 811,
      "contentLength": 6558
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#large-language-monkeys:-scaling-inference-compute-with-repeated-sampling",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-learn-beyond-the-answer-training-language-models-w-20",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Learn Beyond the Answer: Training Language Models with Reflection for Mathematical Reasoning",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Zhang et al. from the University of Notre Dame and Tencent AI Lab introduces Reflective Augmentation (RefAug), a novel method designed to improve the performance of language models (LMs) in mathematical reasoning tasks, particularly those requiring deeper comprehension through reflection. Traditional data augmentation approaches have focused on increasing the quantity of training instances, which improves problem-solving skills in simple, single-round question-answering (QA) tasks. However, these methods are less effective for complex reasoning scenarios where a more reflective approach is needed. RefAug addresses this limitation by adding reflective components to the training sequences, encouraging LMs to engage in alternative reasoning and <strong>follow-up reasoning</strong>.</li>\n  <li><strong>Key Contributions</strong>:\n    <ol>\n      <li><strong>Reflective Augmentation</strong>:\n        <ul>\n          <li>RefAug enhances each training instance by appending a reflective section after the standard solution. This section helps the LM reflect on the problem, promoting deeper understanding and enabling it to consider alternative methods and apply abstractions or analogies.</li>\n          <li>Two types of reflection are included:\n            <ul>\n              <li><strong>Alternative reasoning</strong>: Encourages the model to consider different methods for solving the problem.</li>\n              <li><strong>Follow-up reasoning</strong>: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Implementation</strong>:\n        <ul>\n          <li>The paper uses <strong>GPT-4-turbo</strong> as an expert model to annotate reflective sections for training, minimizing human involvement and ensuring high-quality reasoning.</li>\n          <li>The training objective is extended to optimize for the concatenation of the original answer and the reflective section. During training, the model learns the full reasoning sequence but during inference, the reflective part is excluded to maintain efficiency.</li>\n          <li>Experiments were conducted with LMs such as Mistral-7B and Gemma-7B, testing them on mathematical reasoning tasks with and without reflective augmentation.</li>\n          <li>The following figure from the paper shows that question augmentation creates new questions based on existing ones. Answer augmentation re-samples answers for each problem to increase diversity. Both methods expand the size of the training set. Reflective augmentation appends the original answer with a reflective section, which is complementary to traditional approaches. Corresponding training sequences are shown in an (input, output) format, where augmented parts are in red.</li>\n        </ul>\n\n        <p><img src=\"../../../images/papers/RefAug.jpg\" alt=\"\"></p>\n\n        <ul>\n          <li>The following figure from the paper shows that the model that learned the standard solution does not fully understand when and how to apply substitution when facing a different scenario. In contrast, the model trained with reflection on the substitution technique gains a deeper understanding of its principles, patterns, and its flexible application in new contexts.</li>\n        </ul>\n\n        <p><img src=\"../../../images/papers/RefAug2.jpg\" alt=\"\"></p>\n      </li>\n      <li><strong>Performance</strong>:\n        <ul>\n          <li><strong>Substantial improvement in standard QA</strong>: RefAug enhances performance in single-round QA by +7.2 accuracy points, demonstrating its ability to help models learn problem-solving skills more effectively.</li>\n          <li><strong>Superior results in reflective reasoning tasks</strong>: RefAug significantly boosts the model’s capabilities in handling follow-up questions and error correction, areas where traditional augmentation techniques falter.</li>\n          <li><strong>Complementary to traditional augmentation</strong>: Combining RefAug with other augmentation methods (such as question and answer augmentation) leads to further gains, showing its effectiveness as a complementary approach.</li>\n        </ul>\n      </li>\n      <li><strong>Scalability</strong>:\n        <ul>\n          <li>RefAug proved effective even when applied to large datasets, like MetaMath, with results improving by 2 percentage points over baseline models trained on the same data without reflective sections.</li>\n        </ul>\n      </li>\n    </ol>\n  </li>\n  <li><strong>Experimental Results</strong>:\n    <ul>\n      <li>Models trained with RefAug outperformed their standard counterparts in both in-distribution and out-of-distribution mathematical tasks (such as GSM8k, MATH, MAWPS, etc.).</li>\n      <li>On reflective reasoning tasks (e.g., MathChat and MINT), RefAug-augmented models demonstrated a marked improvement, particularly in multi-step and follow-up questions.</li>\n    </ul>\n  </li>\n  <li><strong>Significance</strong>:\n    <ul>\n      <li>RefAug goes beyond conventional data expansion techniques by embedding reflective thinking into training data, which strengthens a model’s ability to generalize and reason in diverse mathematical contexts. This method shows great promise for enhancing LMs in tasks requiring <strong>flexible problem-solving</strong> and deeper conceptual understanding.</li>\n    </ul>\n  </li>\n  <li>The approach is designed to be easily integrated with other augmentation methods, improving the overall efficiency and effectiveness of language models in mathematical reasoning tasks.</li>\n</ul>\n<ol>\n      <li><strong>Reflective Augmentation</strong>:\n        <ul>\n          <li>RefAug enhances each training instance by appending a reflective section after the standard solution. This section helps the LM reflect on the problem, promoting deeper understanding and enabling it to consider alternative methods and apply abstractions or analogies.</li>\n          <li>Two types of reflection are included:\n            <ul>\n              <li><strong>Alternative reasoning</strong>: Encourages the model to consider different methods for solving the problem.</li>\n              <li><strong>Follow-up reasoning</strong>: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li><strong>Implementation</strong>:\n        <ul>\n          <li>The paper uses <strong>GPT-4-turbo</strong> as an expert model to annotate reflective sections for training, minimizing human involvement and ensuring high-quality reasoning.</li>\n          <li>The training objective is extended to optimize for the concatenation of the original answer and the reflective section. During training, the model learns the full reasoning sequence but during inference, the reflective part is excluded to maintain efficiency.</li>\n          <li>Experiments were conducted with LMs such as Mistral-7B and Gemma-7B, testing them on mathematical reasoning tasks with and without reflective augmentation.</li>\n          <li>The following figure from the paper shows that question augmentation creates new questions based on existing ones. Answer augmentation re-samples answers for each problem to increase diversity. Both methods expand the size of the training set. Reflective augmentation appends the original answer with a reflective section, which is complementary to traditional approaches. Corresponding training sequences are shown in an (input, output) format, where augmented parts are in red.</li>\n        </ul>\n\n        <p><img src=\"../../../images/papers/RefAug.jpg\" alt=\"\"></p>\n\n        <ul>\n          <li>The following figure from the paper shows that the model that learned the standard solution does not fully understand when and how to apply substitution when facing a different scenario. In contrast, the model trained with reflection on the substitution technique gains a deeper understanding of its principles, patterns, and its flexible application in new contexts.</li>\n        </ul>\n\n        <p><img src=\"../../../images/papers/RefAug2.jpg\" alt=\"\"></p>\n      </li>\n      <li><strong>Performance</strong>:\n        <ul>\n          <li><strong>Substantial improvement in standard QA</strong>: RefAug enhances performance in single-round QA by +7.2 accuracy points, demonstrating its ability to help models learn problem-solving skills more effectively.</li>\n          <li><strong>Superior results in reflective reasoning tasks</strong>: RefAug significantly boosts the model’s capabilities in handling follow-up questions and error correction, areas where traditional augmentation techniques falter.</li>\n          <li><strong>Complementary to traditional augmentation</strong>: Combining RefAug with other augmentation methods (such as question and answer augmentation) leads to further gains, showing its effectiveness as a complementary approach.</li>\n        </ul>\n      </li>\n      <li><strong>Scalability</strong>:\n        <ul>\n          <li>RefAug proved effective even when applied to large datasets, like MetaMath, with results improving by 2 percentage points over baseline models trained on the same data without reflective sections.</li>\n        </ul>\n      </li>\n    </ol>\n<ul>\n          <li>RefAug enhances each training instance by appending a reflective section after the standard solution. This section helps the LM reflect on the problem, promoting deeper understanding and enabling it to consider alternative methods and apply abstractions or analogies.</li>\n          <li>Two types of reflection are included:\n            <ul>\n              <li><strong>Alternative reasoning</strong>: Encourages the model to consider different methods for solving the problem.</li>\n              <li><strong>Follow-up reasoning</strong>: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).</li>\n            </ul>\n          </li>\n        </ul>\n<ul>\n              <li><strong>Alternative reasoning</strong>: Encourages the model to consider different methods for solving the problem.</li>\n              <li><strong>Follow-up reasoning</strong>: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).</li>\n            </ul>\n<ul>\n          <li>The paper uses <strong>GPT-4-turbo</strong> as an expert model to annotate reflective sections for training, minimizing human involvement and ensuring high-quality reasoning.</li>\n          <li>The training objective is extended to optimize for the concatenation of the original answer and the reflective section. During training, the model learns the full reasoning sequence but during inference, the reflective part is excluded to maintain efficiency.</li>\n          <li>Experiments were conducted with LMs such as Mistral-7B and Gemma-7B, testing them on mathematical reasoning tasks with and without reflective augmentation.</li>\n          <li>The following figure from the paper shows that question augmentation creates new questions based on existing ones. Answer augmentation re-samples answers for each problem to increase diversity. Both methods expand the size of the training set. Reflective augmentation appends the original answer with a reflective section, which is complementary to traditional approaches. Corresponding training sequences are shown in an (input, output) format, where augmented parts are in red.</li>\n        </ul>\n<p><img src=\"../../../images/papers/RefAug.jpg\" alt=\"\"></p>\n<ul>\n          <li>The following figure from the paper shows that the model that learned the standard solution does not fully understand when and how to apply substitution when facing a different scenario. In contrast, the model trained with reflection on the substitution technique gains a deeper understanding of its principles, patterns, and its flexible application in new contexts.</li>\n        </ul>\n<p><img src=\"../../../images/papers/RefAug2.jpg\" alt=\"\"></p>\n<ul>\n          <li><strong>Substantial improvement in standard QA</strong>: RefAug enhances performance in single-round QA by +7.2 accuracy points, demonstrating its ability to help models learn problem-solving skills more effectively.</li>\n          <li><strong>Superior results in reflective reasoning tasks</strong>: RefAug significantly boosts the model’s capabilities in handling follow-up questions and error correction, areas where traditional augmentation techniques falter.</li>\n          <li><strong>Complementary to traditional augmentation</strong>: Combining RefAug with other augmentation methods (such as question and answer augmentation) leads to further gains, showing its effectiveness as a complementary approach.</li>\n        </ul>\n<ul>\n          <li>RefAug proved effective even when applied to large datasets, like MetaMath, with results improving by 2 percentage points over baseline models trained on the same data without reflective sections.</li>\n        </ul>\n<ul>\n      <li>Models trained with RefAug outperformed their standard counterparts in both in-distribution and out-of-distribution mathematical tasks (such as GSM8k, MATH, MAWPS, etc.).</li>\n      <li>On reflective reasoning tasks (e.g., MathChat and MINT), RefAug-augmented models demonstrated a marked improvement, particularly in multi-step and follow-up questions.</li>\n    </ul>\n<ul>\n      <li>RefAug goes beyond conventional data expansion techniques by embedding reflective thinking into training data, which strengthens a model’s ability to generalize and reason in diverse mathematical contexts. This method shows great promise for enhancing LMs in tasks requiring <strong>flexible problem-solving</strong> and deeper conceptual understanding.</li>\n    </ul>",
    "contentMarkdown": "*   This paper by Zhang et al. from the University of Notre Dame and Tencent AI Lab introduces Reflective Augmentation (RefAug), a novel method designed to improve the performance of language models (LMs) in mathematical reasoning tasks, particularly those requiring deeper comprehension through reflection. Traditional data augmentation approaches have focused on increasing the quantity of training instances, which improves problem-solving skills in simple, single-round question-answering (QA) tasks. However, these methods are less effective for complex reasoning scenarios where a more reflective approach is needed. RefAug addresses this limitation by adding reflective components to the training sequences, encouraging LMs to engage in alternative reasoning and **follow-up reasoning**.\n*   **Key Contributions**:\n    1.  **Reflective Augmentation**:\n        *   RefAug enhances each training instance by appending a reflective section after the standard solution. This section helps the LM reflect on the problem, promoting deeper understanding and enabling it to consider alternative methods and apply abstractions or analogies.\n        *   Two types of reflection are included:\n            *   **Alternative reasoning**: Encourages the model to consider different methods for solving the problem.\n            *   **Follow-up reasoning**: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).\n    2.  **Implementation**:\n        \n        *   The paper uses **GPT-4-turbo** as an expert model to annotate reflective sections for training, minimizing human involvement and ensuring high-quality reasoning.\n        *   The training objective is extended to optimize for the concatenation of the original answer and the reflective section. During training, the model learns the full reasoning sequence but during inference, the reflective part is excluded to maintain efficiency.\n        *   Experiments were conducted with LMs such as Mistral-7B and Gemma-7B, testing them on mathematical reasoning tasks with and without reflective augmentation.\n        *   The following figure from the paper shows that question augmentation creates new questions based on existing ones. Answer augmentation re-samples answers for each problem to increase diversity. Both methods expand the size of the training set. Reflective augmentation appends the original answer with a reflective section, which is complementary to traditional approaches. Corresponding training sequences are shown in an (input, output) format, where augmented parts are in red.\n        \n        ![](../../../images/papers/RefAug.jpg)\n        \n        *   The following figure from the paper shows that the model that learned the standard solution does not fully understand when and how to apply substitution when facing a different scenario. In contrast, the model trained with reflection on the substitution technique gains a deeper understanding of its principles, patterns, and its flexible application in new contexts.\n        \n        ![](../../../images/papers/RefAug2.jpg)\n        \n    3.  **Performance**:\n        *   **Substantial improvement in standard QA**: RefAug enhances performance in single-round QA by +7.2 accuracy points, demonstrating its ability to help models learn problem-solving skills more effectively.\n        *   **Superior results in reflective reasoning tasks**: RefAug significantly boosts the model’s capabilities in handling follow-up questions and error correction, areas where traditional augmentation techniques falter.\n        *   **Complementary to traditional augmentation**: Combining RefAug with other augmentation methods (such as question and answer augmentation) leads to further gains, showing its effectiveness as a complementary approach.\n    4.  **Scalability**:\n        *   RefAug proved effective even when applied to large datasets, like MetaMath, with results improving by 2 percentage points over baseline models trained on the same data without reflective sections.\n*   **Experimental Results**:\n    *   Models trained with RefAug outperformed their standard counterparts in both in-distribution and out-of-distribution mathematical tasks (such as GSM8k, MATH, MAWPS, etc.).\n    *   On reflective reasoning tasks (e.g., MathChat and MINT), RefAug-augmented models demonstrated a marked improvement, particularly in multi-step and follow-up questions.\n*   **Significance**:\n    *   RefAug goes beyond conventional data expansion techniques by embedding reflective thinking into training data, which strengthens a model’s ability to generalize and reason in diverse mathematical contexts. This method shows great promise for enhancing LMs in tasks requiring **flexible problem-solving** and deeper conceptual understanding.\n*   The approach is designed to be easily integrated with other augmentation methods, improving the overall efficiency and effectiveness of language models in mathematical reasoning tasks.\n\n1.  **Reflective Augmentation**:\n    *   RefAug enhances each training instance by appending a reflective section after the standard solution. This section helps the LM reflect on the problem, promoting deeper understanding and enabling it to consider alternative methods and apply abstractions or analogies.\n    *   Two types of reflection are included:\n        *   **Alternative reasoning**: Encourages the model to consider different methods for solving the problem.\n        *   **Follow-up reasoning**: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).\n2.  **Implementation**:\n    \n    *   The paper uses **GPT-4-turbo** as an expert model to annotate reflective sections for training, minimizing human involvement and ensuring high-quality reasoning.\n    *   The training objective is extended to optimize for the concatenation of the original answer and the reflective section. During training, the model learns the full reasoning sequence but during inference, the reflective part is excluded to maintain efficiency.\n    *   Experiments were conducted with LMs such as Mistral-7B and Gemma-7B, testing them on mathematical reasoning tasks with and without reflective augmentation.\n    *   The following figure from the paper shows that question augmentation creates new questions based on existing ones. Answer augmentation re-samples answers for each problem to increase diversity. Both methods expand the size of the training set. Reflective augmentation appends the original answer with a reflective section, which is complementary to traditional approaches. Corresponding training sequences are shown in an (input, output) format, where augmented parts are in red.\n    \n    ![](../../../images/papers/RefAug.jpg)\n    \n    *   The following figure from the paper shows that the model that learned the standard solution does not fully understand when and how to apply substitution when facing a different scenario. In contrast, the model trained with reflection on the substitution technique gains a deeper understanding of its principles, patterns, and its flexible application in new contexts.\n    \n    ![](../../../images/papers/RefAug2.jpg)\n    \n3.  **Performance**:\n    *   **Substantial improvement in standard QA**: RefAug enhances performance in single-round QA by +7.2 accuracy points, demonstrating its ability to help models learn problem-solving skills more effectively.\n    *   **Superior results in reflective reasoning tasks**: RefAug significantly boosts the model’s capabilities in handling follow-up questions and error correction, areas where traditional augmentation techniques falter.\n    *   **Complementary to traditional augmentation**: Combining RefAug with other augmentation methods (such as question and answer augmentation) leads to further gains, showing its effectiveness as a complementary approach.\n4.  **Scalability**:\n    *   RefAug proved effective even when applied to large datasets, like MetaMath, with results improving by 2 percentage points over baseline models trained on the same data without reflective sections.\n\n*   RefAug enhances each training instance by appending a reflective section after the standard solution. This section helps the LM reflect on the problem, promoting deeper understanding and enabling it to consider alternative methods and apply abstractions or analogies.\n*   Two types of reflection are included:\n    *   **Alternative reasoning**: Encourages the model to consider different methods for solving the problem.\n    *   **Follow-up reasoning**: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).\n\n*   **Alternative reasoning**: Encourages the model to consider different methods for solving the problem.\n*   **Follow-up reasoning**: Either focuses on abstraction (generalizing the problem) or analogy (applying the same technique to more complex problems).\n\n*   The paper uses **GPT-4-turbo** as an expert model to annotate reflective sections for training, minimizing human involvement and ensuring high-quality reasoning.\n*   The training objective is extended to optimize for the concatenation of the original answer and the reflective section. During training, the model learns the full reasoning sequence but during inference, the reflective part is excluded to maintain efficiency.\n*   Experiments were conducted with LMs such as Mistral-7B and Gemma-7B, testing them on mathematical reasoning tasks with and without reflective augmentation.\n*   The following figure from the paper shows that question augmentation creates new questions based on existing ones. Answer augmentation re-samples answers for each problem to increase diversity. Both methods expand the size of the training set. Reflective augmentation appends the original answer with a reflective section, which is complementary to traditional approaches. Corresponding training sequences are shown in an (input, output) format, where augmented parts are in red.\n\n![](../../../images/papers/RefAug.jpg)\n\n*   The following figure from the paper shows that the model that learned the standard solution does not fully understand when and how to apply substitution when facing a different scenario. In contrast, the model trained with reflection on the substitution technique gains a deeper understanding of its principles, patterns, and its flexible application in new contexts.\n\n![](../../../images/papers/RefAug2.jpg)\n\n*   **Substantial improvement in standard QA**: RefAug enhances performance in single-round QA by +7.2 accuracy points, demonstrating its ability to help models learn problem-solving skills more effectively.\n*   **Superior results in reflective reasoning tasks**: RefAug significantly boosts the model’s capabilities in handling follow-up questions and error correction, areas where traditional augmentation techniques falter.\n*   **Complementary to traditional augmentation**: Combining RefAug with other augmentation methods (such as question and answer augmentation) leads to further gains, showing its effectiveness as a complementary approach.\n\n*   RefAug proved effective even when applied to large datasets, like MetaMath, with results improving by 2 percentage points over baseline models trained on the same data without reflective sections.\n\n*   Models trained with RefAug outperformed their standard counterparts in both in-distribution and out-of-distribution mathematical tasks (such as GSM8k, MATH, MAWPS, etc.).\n*   On reflective reasoning tasks (e.g., MathChat and MINT), RefAug-augmented models demonstrated a marked improvement, particularly in multi-step and follow-up questions.\n\n*   RefAug goes beyond conventional data expansion techniques by embedding reflective thinking into training data, which strengthens a model’s ability to generalize and reason in diverse mathematical contexts. This method shows great promise for enhancing LMs in tasks requiring **flexible problem-solving** and deeper conceptual understanding.",
    "order": 20,
    "orderInChapter": 6,
    "difficulty": 3,
    "estimatedMinutes": 8,
    "tags": [
      "models",
      "embedding",
      "gpt",
      "data augmentation"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 1574,
      "contentLength": 13897
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#learn-beyond-the-answer:-training-language-models-with-reflection-for-mathematical-reasoning",
    "scrapedAt": "2025-12-28T11:51:47.953Z"
  },
  {
    "id": "ai-o1-agent-q-advanced-reasoning-and-learning-for-autono-21",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Agent Q: Advanced Reasoning and Learning for Autonomous AI Agents",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Putta et al. from MultiOn and Stanford, presents “Agent Q,” a novel framework that enhances the reasoning and decision-making capabilities of large language models (LLMs) in agentic, multi-step tasks in dynamic environments such as web navigation. The framework tackles challenges related to compounding errors and limited exploration data that hinder LLMs from excelling in autonomous, real-time decision-making scenarios.</li>\n  <li>The authors propose a method that integrates guided Monte Carlo Tree Search (MCTS) with a self-critique mechanism. This enables the agent to iteratively improve by learning from both successful and unsuccessful trajectories, using an off-policy variant of Direct Preference Optimization (DPO). The agent operates in a Partially Observable Markov Decision Process (POMDP) framework, where the LLM is responsible for planning, reasoning, and interacting with the environment, such as executing commands on web pages.\n-<strong>Key Components of Agent Q</strong>:\n    <ol>\n      <li>\n        <p><strong>Monte Carlo Tree Search (MCTS)</strong>: MCTS is used for exploring multiple action trajectories. It evaluates possible actions at each node (web page) by calculating rewards and assigning values to each action. The Upper Confidence Bound (UCB1) strategy guides the exploration versus exploitation trade-off. To handle the sparse reward environment, an AI-based feedback mechanism is employed to rank actions and provide step-level guidance.</p>\n      </li>\n      <li>\n        <p><strong>Direct Preference Optimization (DPO)</strong>: DPO helps optimize the agent by using preference pairs (successful vs. unsuccessful actions) collected during interaction. This approach mitigates the need for a large number of online samples, making it computationally efficient for offline training. The DPO algorithm allows the agent to refine its decision-making policy by comparing trajectory outcomes and constructing preference pairs for learning.</p>\n      </li>\n      <li>\n        <p><strong>Self-Critique Mechanism</strong>: To overcome credit assignment problems (where small errors can lead to overall task failure), the model incorporates a self-critique mechanism. At each step, the LLM provides intermediate feedback, which serves as an implicit reward, helping the agent refine its future actions.\n-<strong>Implementation Details</strong>:</p>\n        <ul>\n          <li><strong>Initial Setup</strong>: The LLaMA-3 70B model serves as the base agent. The agent is evaluated in the WebShop environment (a simulated e-commerce platform) and a real-world reservation system (OpenTable). Initial observations and user queries are represented as HTML DOM trees, and the agent’s actions are composite, consisting of planning, reasoning, environment interaction, and explanation steps.</li>\n        </ul>\n      </li>\n    </ol>\n\n    <ul>\n      <li><strong>Training Process</strong>: The agent is trained using a combination of offline and online learning methods. Offline learning leverages the DPO algorithm to learn from past trajectories, while online learning uses MCTS to guide real-time action selection. The model continuously improves through iterative fine-tuning based on the outcomes of the agent’s decisions.</li>\n    </ul>\n  </li>\n  <li>The following figure from the paper shows the use of Monte Carlo Tree Search (MCTS) to guide trajectory collection and iteratively improve model performance using direct preference optimization (DPO). We begin on the left by sampling a user query from the list of tasks in the dataset. We iteratively expand the search tree using UCB1 as a heuristic to balance exploration and exploitation of different actions. We store the accumulated reward obtained for each node in the tree, where in this image darker green indicates higher reward and darker red indicates lower reward. To construct the preference dataset, we compute a weighted score of the MCTS average Q-value and score generated by a feedback language model to construct contrastive pairs for DPO. The policy is optimized and can be iteratively improved.</li>\n</ul>\n<ol>\n      <li>\n        <p><strong>Monte Carlo Tree Search (MCTS)</strong>: MCTS is used for exploring multiple action trajectories. It evaluates possible actions at each node (web page) by calculating rewards and assigning values to each action. The Upper Confidence Bound (UCB1) strategy guides the exploration versus exploitation trade-off. To handle the sparse reward environment, an AI-based feedback mechanism is employed to rank actions and provide step-level guidance.</p>\n      </li>\n      <li>\n        <p><strong>Direct Preference Optimization (DPO)</strong>: DPO helps optimize the agent by using preference pairs (successful vs. unsuccessful actions) collected during interaction. This approach mitigates the need for a large number of online samples, making it computationally efficient for offline training. The DPO algorithm allows the agent to refine its decision-making policy by comparing trajectory outcomes and constructing preference pairs for learning.</p>\n      </li>\n      <li>\n        <p><strong>Self-Critique Mechanism</strong>: To overcome credit assignment problems (where small errors can lead to overall task failure), the model incorporates a self-critique mechanism. At each step, the LLM provides intermediate feedback, which serves as an implicit reward, helping the agent refine its future actions.\n-<strong>Implementation Details</strong>:</p>\n        <ul>\n          <li><strong>Initial Setup</strong>: The LLaMA-3 70B model serves as the base agent. The agent is evaluated in the WebShop environment (a simulated e-commerce platform) and a real-world reservation system (OpenTable). Initial observations and user queries are represented as HTML DOM trees, and the agent’s actions are composite, consisting of planning, reasoning, environment interaction, and explanation steps.</li>\n        </ul>\n      </li>\n    </ol>\n<p><strong>Monte Carlo Tree Search (MCTS)</strong>: MCTS is used for exploring multiple action trajectories. It evaluates possible actions at each node (web page) by calculating rewards and assigning values to each action. The Upper Confidence Bound (UCB1) strategy guides the exploration versus exploitation trade-off. To handle the sparse reward environment, an AI-based feedback mechanism is employed to rank actions and provide step-level guidance.</p>\n<p><strong>Direct Preference Optimization (DPO)</strong>: DPO helps optimize the agent by using preference pairs (successful vs. unsuccessful actions) collected during interaction. This approach mitigates the need for a large number of online samples, making it computationally efficient for offline training. The DPO algorithm allows the agent to refine its decision-making policy by comparing trajectory outcomes and constructing preference pairs for learning.</p>\n<p><strong>Self-Critique Mechanism</strong>: To overcome credit assignment problems (where small errors can lead to overall task failure), the model incorporates a self-critique mechanism. At each step, the LLM provides intermediate feedback, which serves as an implicit reward, helping the agent refine its future actions.\n-<strong>Implementation Details</strong>:</p>\n<ul>\n          <li><strong>Initial Setup</strong>: The LLaMA-3 70B model serves as the base agent. The agent is evaluated in the WebShop environment (a simulated e-commerce platform) and a real-world reservation system (OpenTable). Initial observations and user queries are represented as HTML DOM trees, and the agent’s actions are composite, consisting of planning, reasoning, environment interaction, and explanation steps.</li>\n        </ul>\n<ul>\n      <li><strong>Training Process</strong>: The agent is trained using a combination of offline and online learning methods. Offline learning leverages the DPO algorithm to learn from past trajectories, while online learning uses MCTS to guide real-time action selection. The model continuously improves through iterative fine-tuning based on the outcomes of the agent’s decisions.</li>\n    </ul>\n<p><img src=\"../../../images/papers/AgentQ1.jpg\" alt=\"\"></p>\n<ul>\n  <li>The following figure from the paper shows that they provide the following input format to the Agent, consisting of the system prompt, execution history, the current observation as a DOM representation, and the user query containing the goal. We divide our Agent output format into an overall step-by-step plan, thought, a command, and a status code.</li>\n</ul>\n<p><img src=\"../../../images/papers/AgentQ2.jpg\" alt=\"\"></p>\n<p>-<strong>Results</strong>:\n    - In WebShop, Agent Q outperforms baseline models such as behavior cloning and reinforced fine-tuning, achieving a success rate of 50.5%, surpassing the average human performance of 50%.\n    - In real-world experiments on OpenTable, the Agent Q framework improves the LLaMA-3 model’s zero-shot performance from 18.6% to 81.7%, with a further increase to 95.4% when MCTS is utilized during inference.</p>\n<ul>\n  <li>This framework demonstrates significant progress in building autonomous web agents that can generalize and learn from their experiences in complex, multi-step reasoning tasks.</li>\n</ul>",
    "contentMarkdown": "*   This paper by Putta et al. from MultiOn and Stanford, presents “Agent Q,” a novel framework that enhances the reasoning and decision-making capabilities of large language models (LLMs) in agentic, multi-step tasks in dynamic environments such as web navigation. The framework tackles challenges related to compounding errors and limited exploration data that hinder LLMs from excelling in autonomous, real-time decision-making scenarios.\n*   The authors propose a method that integrates guided Monte Carlo Tree Search (MCTS) with a self-critique mechanism. This enables the agent to iteratively improve by learning from both successful and unsuccessful trajectories, using an off-policy variant of Direct Preference Optimization (DPO). The agent operates in a Partially Observable Markov Decision Process (POMDP) framework, where the LLM is responsible for planning, reasoning, and interacting with the environment, such as executing commands on web pages. -**Key Components of Agent Q**:\n    \n    1.  **Monte Carlo Tree Search (MCTS)**: MCTS is used for exploring multiple action trajectories. It evaluates possible actions at each node (web page) by calculating rewards and assigning values to each action. The Upper Confidence Bound (UCB1) strategy guides the exploration versus exploitation trade-off. To handle the sparse reward environment, an AI-based feedback mechanism is employed to rank actions and provide step-level guidance.\n        \n    2.  **Direct Preference Optimization (DPO)**: DPO helps optimize the agent by using preference pairs (successful vs. unsuccessful actions) collected during interaction. This approach mitigates the need for a large number of online samples, making it computationally efficient for offline training. The DPO algorithm allows the agent to refine its decision-making policy by comparing trajectory outcomes and constructing preference pairs for learning.\n        \n    3.  **Self-Critique Mechanism**: To overcome credit assignment problems (where small errors can lead to overall task failure), the model incorporates a self-critique mechanism. At each step, the LLM provides intermediate feedback, which serves as an implicit reward, helping the agent refine its future actions. -**Implementation Details**:\n        \n        *   **Initial Setup**: The LLaMA-3 70B model serves as the base agent. The agent is evaluated in the WebShop environment (a simulated e-commerce platform) and a real-world reservation system (OpenTable). Initial observations and user queries are represented as HTML DOM trees, and the agent’s actions are composite, consisting of planning, reasoning, environment interaction, and explanation steps.\n    \n    *   **Training Process**: The agent is trained using a combination of offline and online learning methods. Offline learning leverages the DPO algorithm to learn from past trajectories, while online learning uses MCTS to guide real-time action selection. The model continuously improves through iterative fine-tuning based on the outcomes of the agent’s decisions.\n*   The following figure from the paper shows the use of Monte Carlo Tree Search (MCTS) to guide trajectory collection and iteratively improve model performance using direct preference optimization (DPO). We begin on the left by sampling a user query from the list of tasks in the dataset. We iteratively expand the search tree using UCB1 as a heuristic to balance exploration and exploitation of different actions. We store the accumulated reward obtained for each node in the tree, where in this image darker green indicates higher reward and darker red indicates lower reward. To construct the preference dataset, we compute a weighted score of the MCTS average Q-value and score generated by a feedback language model to construct contrastive pairs for DPO. The policy is optimized and can be iteratively improved.\n\n1.  **Monte Carlo Tree Search (MCTS)**: MCTS is used for exploring multiple action trajectories. It evaluates possible actions at each node (web page) by calculating rewards and assigning values to each action. The Upper Confidence Bound (UCB1) strategy guides the exploration versus exploitation trade-off. To handle the sparse reward environment, an AI-based feedback mechanism is employed to rank actions and provide step-level guidance.\n    \n2.  **Direct Preference Optimization (DPO)**: DPO helps optimize the agent by using preference pairs (successful vs. unsuccessful actions) collected during interaction. This approach mitigates the need for a large number of online samples, making it computationally efficient for offline training. The DPO algorithm allows the agent to refine its decision-making policy by comparing trajectory outcomes and constructing preference pairs for learning.\n    \n3.  **Self-Critique Mechanism**: To overcome credit assignment problems (where small errors can lead to overall task failure), the model incorporates a self-critique mechanism. At each step, the LLM provides intermediate feedback, which serves as an implicit reward, helping the agent refine its future actions. -**Implementation Details**:\n    \n    *   **Initial Setup**: The LLaMA-3 70B model serves as the base agent. The agent is evaluated in the WebShop environment (a simulated e-commerce platform) and a real-world reservation system (OpenTable). Initial observations and user queries are represented as HTML DOM trees, and the agent’s actions are composite, consisting of planning, reasoning, environment interaction, and explanation steps.\n\n**Monte Carlo Tree Search (MCTS)**: MCTS is used for exploring multiple action trajectories. It evaluates possible actions at each node (web page) by calculating rewards and assigning values to each action. The Upper Confidence Bound (UCB1) strategy guides the exploration versus exploitation trade-off. To handle the sparse reward environment, an AI-based feedback mechanism is employed to rank actions and provide step-level guidance.\n\n**Direct Preference Optimization (DPO)**: DPO helps optimize the agent by using preference pairs (successful vs. unsuccessful actions) collected during interaction. This approach mitigates the need for a large number of online samples, making it computationally efficient for offline training. The DPO algorithm allows the agent to refine its decision-making policy by comparing trajectory outcomes and constructing preference pairs for learning.\n\n**Self-Critique Mechanism**: To overcome credit assignment problems (where small errors can lead to overall task failure), the model incorporates a self-critique mechanism. At each step, the LLM provides intermediate feedback, which serves as an implicit reward, helping the agent refine its future actions. -**Implementation Details**:\n\n*   **Initial Setup**: The LLaMA-3 70B model serves as the base agent. The agent is evaluated in the WebShop environment (a simulated e-commerce platform) and a real-world reservation system (OpenTable). Initial observations and user queries are represented as HTML DOM trees, and the agent’s actions are composite, consisting of planning, reasoning, environment interaction, and explanation steps.\n\n*   **Training Process**: The agent is trained using a combination of offline and online learning methods. Offline learning leverages the DPO algorithm to learn from past trajectories, while online learning uses MCTS to guide real-time action selection. The model continuously improves through iterative fine-tuning based on the outcomes of the agent’s decisions.\n\n![](../../../images/papers/AgentQ1.jpg)\n\n*   The following figure from the paper shows that they provide the following input format to the Agent, consisting of the system prompt, execution history, the current observation as a DOM representation, and the user query containing the goal. We divide our Agent output format into an overall step-by-step plan, thought, a command, and a status code.\n\n![](../../../images/papers/AgentQ2.jpg)\n\n\\-**Results**: - In WebShop, Agent Q outperforms baseline models such as behavior cloning and reinforced fine-tuning, achieving a success rate of 50.5%, surpassing the average human performance of 50%. - In real-world experiments on OpenTable, the Agent Q framework improves the LLaMA-3 model’s zero-shot performance from 18.6% to 81.7%, with a further increase to 95.4% when MCTS is utilized during inference.\n\n*   This framework demonstrates significant progress in building autonomous web agents that can generalize and learn from their experiences in complex, multi-step reasoning tasks.",
    "order": 21,
    "orderInChapter": 7,
    "difficulty": 3,
    "estimatedMinutes": 6,
    "tags": [
      "models",
      "llm",
      "optimization",
      "fine-tuning"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 1196,
      "contentLength": 9256
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#agent-q:-advanced-reasoning-and-learning-for-autonomous-ai-agents",
    "scrapedAt": "2025-12-28T11:51:47.954Z"
  },
  {
    "id": "ai-o1-v-star-training-verifiers-for-self-taught-reasoner-22",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "V-STaR: Training Verifiers for Self-Taught Reasoners",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Hosseini et al. from Mila, MSR, University of Edinburgh, and Google Deepmind, published in COLM 2024, introduces V-STaR, a novel approach designed to improve the reasoning capabilities of large language models (LLMs) by training both a verifier and a generator using correct and incorrect solutions. The authors aim to address a key limitation in previous self-improvement approaches, such as STaR and Rejection Fine-Tuning (RFT), which discard incorrect solutions, potentially missing valuable learning opportunities. V-STaR instead leverages both correct and incorrect model-generated solutions in an iterative self-improvement process, leading to better performance in tasks like math problem-solving and code generation.</li>\n  <li>The core idea of V-STaR is to iteratively train a generator to produce solutions and a verifier to judge their correctness using Direct Preference Optimization (DPO). By utilizing both correct and incorrect solutions, V-STaR ensures that the verifier learns from the generator’s errors, making it more robust.</li>\n  <li><strong>Methodology and Implementation Details</strong>:\n    <ol>\n      <li><strong>Training the Generator (GSFT)</strong>: The generator is initially fine-tuned using supervised fine-tuning (SFT) on the original dataset, producing solutions for various problem instances. After each iteration, correct solutions are added to the training data for future iterations.</li>\n      <li><strong>Training the Verifier (VT)</strong>: Both correct and incorrect generated solutions are added to the verifier’s training data. The verifier is trained using DPO, which optimizes for preference learning by contrasting correct and incorrect solutions, improving its ability to rank solutions based on correctness.</li>\n      <li><strong>Iterative Process</strong>: This process is repeated for multiple iterations. In each iteration, the generator produces solutions, and the verifier learns from both the correct and incorrect solutions, progressively improving the overall performance of both models.</li>\n      <li><strong>Test-time Verification</strong>: At test time, the generator produces multiple candidate solutions for a problem, and the verifier selects the best one by ranking them.</li>\n    </ol>\n  </li>\n  <li>The following figure from the paper shows generator and verifier training in V-STaR. Left: In each training iteration, the generator $G^t$ is fine-tuned (from a pretrained LLM) on the current buffer of problem instances and correct solutions $\\mathcal{D}<em>{\\text {GEN }}$. Generated solutions that yielded a correct answer are added to $\\mathcal{D}</em>{\\mathrm{GEN}}$ to be used in future iterations, and all the generated solutions (correct and incorrect) are added to $\\mathcal{D}<em>{\\text {VER }}$. The verifier $V^t$ is trained using DPO with a preference dataset constructed from pairs of correct and incorrect solutions from $\\mathcal{D}</em>{\\text {VER }}$. Right: At test time, the verifier is used to rank solutions produced by the generator. Such iterative training and inference-time ranking yields large improvements over generator-only self-improvement.</li>\n</ul>\n<ol>\n      <li><strong>Training the Generator (GSFT)</strong>: The generator is initially fine-tuned using supervised fine-tuning (SFT) on the original dataset, producing solutions for various problem instances. After each iteration, correct solutions are added to the training data for future iterations.</li>\n      <li><strong>Training the Verifier (VT)</strong>: Both correct and incorrect generated solutions are added to the verifier’s training data. The verifier is trained using DPO, which optimizes for preference learning by contrasting correct and incorrect solutions, improving its ability to rank solutions based on correctness.</li>\n      <li><strong>Iterative Process</strong>: This process is repeated for multiple iterations. In each iteration, the generator produces solutions, and the verifier learns from both the correct and incorrect solutions, progressively improving the overall performance of both models.</li>\n      <li><strong>Test-time Verification</strong>: At test time, the generator produces multiple candidate solutions for a problem, and the verifier selects the best one by ranking them.</li>\n    </ol>\n<p><img src=\"../../../images/papers/V-STaR.jpg\" alt=\"\"></p>\n<ul>\n  <li><strong>Key Results</strong>:\n    <ul>\n      <li>V-STaR demonstrates a <strong>4% to 17% improvement</strong> in test accuracy over baseline self-improvement and verification methods in tasks like code generation and math reasoning. In some cases, it even surpasses much larger models.</li>\n      <li>When evaluated on math reasoning benchmarks such as GSM8K and MATH, and code-generation datasets like MBPP and HumanEval, V-STaR outperforms prior approaches by combining both correct and incorrect examples for training the verifier.</li>\n    </ul>\n  </li>\n  <li><strong>Empirical Findings</strong>:\n    <ul>\n      <li>The paper compares V-STaR against several baselines, including non-iterative versions of STaR and RFT combined with a verifier, and demonstrates significant improvements in Pass@1 and Best-of-64 metrics.</li>\n      <li>V-STaR is highly data-efficient, with the iterative collection of correct and incorrect solutions leading to more challenging examples for the verifier, which enhances both the generator and verifier over time.</li>\n    </ul>\n  </li>\n  <li><strong>Conclusions</strong>:\n  The V-STaR approach significantly enhances reasoning tasks by training LLMs to learn from both correct and incorrect solutions. The iterative training process allows both the generator and verifier to continuously improve, and the use of DPO for training verifiers has been shown to outperform more traditional ORM-style verification methods. This framework is simple to implement and applicable to a wide range of reasoning problems, provided there is access to correctness feedback during training.</li>\n</ul>\n<ul>\n      <li>V-STaR demonstrates a <strong>4% to 17% improvement</strong> in test accuracy over baseline self-improvement and verification methods in tasks like code generation and math reasoning. In some cases, it even surpasses much larger models.</li>\n      <li>When evaluated on math reasoning benchmarks such as GSM8K and MATH, and code-generation datasets like MBPP and HumanEval, V-STaR outperforms prior approaches by combining both correct and incorrect examples for training the verifier.</li>\n    </ul>\n<ul>\n      <li>The paper compares V-STaR against several baselines, including non-iterative versions of STaR and RFT combined with a verifier, and demonstrates significant improvements in Pass@1 and Best-of-64 metrics.</li>\n      <li>V-STaR is highly data-efficient, with the iterative collection of correct and incorrect solutions leading to more challenging examples for the verifier, which enhances both the generator and verifier over time.</li>\n    </ul>",
    "contentMarkdown": "*   This paper by Hosseini et al. from Mila, MSR, University of Edinburgh, and Google Deepmind, published in COLM 2024, introduces V-STaR, a novel approach designed to improve the reasoning capabilities of large language models (LLMs) by training both a verifier and a generator using correct and incorrect solutions. The authors aim to address a key limitation in previous self-improvement approaches, such as STaR and Rejection Fine-Tuning (RFT), which discard incorrect solutions, potentially missing valuable learning opportunities. V-STaR instead leverages both correct and incorrect model-generated solutions in an iterative self-improvement process, leading to better performance in tasks like math problem-solving and code generation.\n*   The core idea of V-STaR is to iteratively train a generator to produce solutions and a verifier to judge their correctness using Direct Preference Optimization (DPO). By utilizing both correct and incorrect solutions, V-STaR ensures that the verifier learns from the generator’s errors, making it more robust.\n*   **Methodology and Implementation Details**:\n    1.  **Training the Generator (GSFT)**: The generator is initially fine-tuned using supervised fine-tuning (SFT) on the original dataset, producing solutions for various problem instances. After each iteration, correct solutions are added to the training data for future iterations.\n    2.  **Training the Verifier (VT)**: Both correct and incorrect generated solutions are added to the verifier’s training data. The verifier is trained using DPO, which optimizes for preference learning by contrasting correct and incorrect solutions, improving its ability to rank solutions based on correctness.\n    3.  **Iterative Process**: This process is repeated for multiple iterations. In each iteration, the generator produces solutions, and the verifier learns from both the correct and incorrect solutions, progressively improving the overall performance of both models.\n    4.  **Test-time Verification**: At test time, the generator produces multiple candidate solutions for a problem, and the verifier selects the best one by ranking them.\n*   The following figure from the paper shows generator and verifier training in V-STaR. Left: In each training iteration, the generator $G^t$ is fine-tuned (from a pretrained LLM) on the current buffer of problem instances and correct solutions $\\\\mathcal{D}_{\\\\text {GEN }}$. Generated solutions that yielded a correct answer are added to $\\\\mathcal{D}_{\\\\mathrm{GEN}}$ to be used in future iterations, and all the generated solutions (correct and incorrect) are added to $\\\\mathcal{D}_{\\\\text {VER }}$. The verifier $V^t$ is trained using DPO with a preference dataset constructed from pairs of correct and incorrect solutions from $\\\\mathcal{D}_{\\\\text {VER }}$. Right: At test time, the verifier is used to rank solutions produced by the generator. Such iterative training and inference-time ranking yields large improvements over generator-only self-improvement.\n\n1.  **Training the Generator (GSFT)**: The generator is initially fine-tuned using supervised fine-tuning (SFT) on the original dataset, producing solutions for various problem instances. After each iteration, correct solutions are added to the training data for future iterations.\n2.  **Training the Verifier (VT)**: Both correct and incorrect generated solutions are added to the verifier’s training data. The verifier is trained using DPO, which optimizes for preference learning by contrasting correct and incorrect solutions, improving its ability to rank solutions based on correctness.\n3.  **Iterative Process**: This process is repeated for multiple iterations. In each iteration, the generator produces solutions, and the verifier learns from both the correct and incorrect solutions, progressively improving the overall performance of both models.\n4.  **Test-time Verification**: At test time, the generator produces multiple candidate solutions for a problem, and the verifier selects the best one by ranking them.\n\n![](../../../images/papers/V-STaR.jpg)\n\n*   **Key Results**:\n    *   V-STaR demonstrates a **4% to 17% improvement** in test accuracy over baseline self-improvement and verification methods in tasks like code generation and math reasoning. In some cases, it even surpasses much larger models.\n    *   When evaluated on math reasoning benchmarks such as GSM8K and MATH, and code-generation datasets like MBPP and HumanEval, V-STaR outperforms prior approaches by combining both correct and incorrect examples for training the verifier.\n*   **Empirical Findings**:\n    *   The paper compares V-STaR against several baselines, including non-iterative versions of STaR and RFT combined with a verifier, and demonstrates significant improvements in Pass@1 and Best-of-64 metrics.\n    *   V-STaR is highly data-efficient, with the iterative collection of correct and incorrect solutions leading to more challenging examples for the verifier, which enhances both the generator and verifier over time.\n*   **Conclusions**: The V-STaR approach significantly enhances reasoning tasks by training LLMs to learn from both correct and incorrect solutions. The iterative training process allows both the generator and verifier to continuously improve, and the use of DPO for training verifiers has been shown to outperform more traditional ORM-style verification methods. This framework is simple to implement and applicable to a wide range of reasoning problems, provided there is access to correctness feedback during training.\n\n*   V-STaR demonstrates a **4% to 17% improvement** in test accuracy over baseline self-improvement and verification methods in tasks like code generation and math reasoning. In some cases, it even surpasses much larger models.\n*   When evaluated on math reasoning benchmarks such as GSM8K and MATH, and code-generation datasets like MBPP and HumanEval, V-STaR outperforms prior approaches by combining both correct and incorrect examples for training the verifier.\n\n*   The paper compares V-STaR against several baselines, including non-iterative versions of STaR and RFT combined with a verifier, and demonstrates significant improvements in Pass@1 and Best-of-64 metrics.\n*   V-STaR is highly data-efficient, with the iterative collection of correct and incorrect solutions leading to more challenging examples for the verifier, which enhances both the generator and verifier over time.",
    "order": 22,
    "orderInChapter": 8,
    "difficulty": 3,
    "estimatedMinutes": 5,
    "tags": [
      "models",
      "llm",
      "optimization",
      "fine-tuning"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 900,
      "contentLength": 6982
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#v-star:-training-verifiers-for-self-taught-reasoners",
    "scrapedAt": "2025-12-28T11:51:47.954Z"
  },
  {
    "id": "ai-o1-improve-mathematical-reasoning-in-language-models--23",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Improve Mathematical Reasoning in Language Models by Automated Process Supervision",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper from Luo et al. from Google DeepMind introduces a novel approach to enhance the mathematical reasoning capabilities of large language models (LLMs) through automated process supervision, focusing on intermediate reasoning steps rather than just final outcomes. Traditional techniques like Outcome Reward Models (ORM) verify the final answer’s correctness, but these models do not reward or penalize the intermediate steps, leading to challenges in solving complex multi-step reasoning tasks such as mathematical problem solving.</li>\n  <li>The authors propose a new divide-and-conquer Monte Carlo Tree Search (MCTS) algorithm, named OmegaPRM, for the efficient collection of process supervision data. OmegaPRM improves upon previous methods by utilizing a binary search technique to locate errors in the chain of thought, identifying the first error in a reasoning path. This method ensures a balanced collection of positive and negative examples, leading to high-quality data collection.</li>\n  <li>The implementation of OmegaPRM allows the automatic generation of over 1.5 million process supervision annotations, which are used to train a Process Reward Model (PRM). These annotations are generated without human intervention, making the process both cost-effective and scalable. The PRM, when integrated with a weighted self-consistency algorithm, achieves a 69.4% success rate on the MATH benchmark, which is a significant 36% relative improvement over the base model performance of 51%.</li>\n  <li>The following figure from the paper shows an example tree structure built with our proposed OmegaPRM algorithm. Each node in the tree indicates a state of partial chain-of-thought solution, with information including accuracy of rollouts and other statistics. Each edge indicates an action, i.e., a reasoning step, from the last state. Yellow edges are correct steps and blue edges are wrong.</li>\n</ul>\n<p><img src=\"../../../images/papers/OmegaPRM1.jpg\" alt=\"\"></p>\n<ul>\n  <li>Key implementation details include:\n    <ul>\n      <li><strong>Monte Carlo Tree Search (MCTS)</strong>: A tree is built for each mathematical question, with nodes representing intermediate reasoning steps. The binary search efficiently narrows down to the first incorrect step by performing rollouts at each stage.</li>\n      <li><strong>Tree Structure</strong>: Each node stores statistics, such as visit counts and Monte Carlo estimations, to guide future rollouts. This structure enables reuse of rollouts, reducing computational redundancy and enhancing the training data collection efficiency.</li>\n      <li><strong>PRM Training</strong>: The PRM is trained using pointwise soft labels derived from the Monte Carlo rollouts. The soft label approach provides better performance compared to hard labels and pairwise loss functions, achieving 70.1% accuracy in classifying per-step correctness.</li>\n      <li><strong>Data Generation</strong>: The PRM was trained on the MATH dataset, generating process annotations using OmegaPRM’s binary search method. This process reduced the number of policy calls while maintaining high-quality annotations.</li>\n    </ul>\n  </li>\n  <li>The following figure from the paper shows an illustration of the process supervision rollouts, Monte Carlo estimation using binary search and the MCTS process. (a) An example of Monte Carlo estimation of a prefix solution. Two out of the three rollouts are correct, producing the Monte Carlo estimation <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-10-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>MC</mi><mo>&amp;#x2061;</mo><mrow><mo>(</mo><mrow><mi>q</mi><mo>,</mo><msub><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn><mo>:</mo><mi>t</mi></mrow></msub></mrow><mo>)</mo></mrow><mo>=</mo><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>3</mn><mo>&amp;#x2248;</mo><mn>0.67</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-28\" style=\"width: 11.878em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 9.898em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1009.85em, 2.555em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-29\"><span class=\"mi\" id=\"MathJax-Span-30\" style=\"font-family: STIXGeneral-Regular;\">MC</span><span class=\"mo\" id=\"MathJax-Span-31\"></span><span class=\"mrow\" id=\"MathJax-Span-32\"><span class=\"mo\" id=\"MathJax-Span-33\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">(</span></span><span class=\"mrow\" id=\"MathJax-Span-34\"><span class=\"mi\" id=\"MathJax-Span-35\" style=\"font-family: STIXGeneral-Italic;\">q</span><span class=\"mo\" id=\"MathJax-Span-36\" style=\"font-family: STIXGeneral-Regular;\">,</span><span class=\"msubsup\" id=\"MathJax-Span-37\" style=\"padding-left: 0.211em;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.44em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mi\" id=\"MathJax-Span-38\" style=\"font-family: STIXGeneral-Italic;\">x<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -3.852em; left: 0.471em;\"><span class=\"texatom\" id=\"MathJax-Span-39\"><span class=\"mrow\" id=\"MathJax-Span-40\"><span class=\"mn\" id=\"MathJax-Span-41\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">1</span><span class=\"mo\" id=\"MathJax-Span-42\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">:</span><span class=\"mi\" id=\"MathJax-Span-43\" style=\"font-size: 70.7%; font-family: STIXGeneral-Italic;\">t<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span class=\"mo\" id=\"MathJax-Span-44\" style=\"vertical-align: 0em;\"><span style=\"font-family: STIXGeneral-Regular;\">)</span></span></span><span class=\"mo\" id=\"MathJax-Span-45\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">=</span><span class=\"mn\" id=\"MathJax-Span-46\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">2</span><span class=\"texatom\" id=\"MathJax-Span-47\"><span class=\"mrow\" id=\"MathJax-Span-48\"><span class=\"mo\" id=\"MathJax-Span-49\" style=\"font-family: STIXGeneral-Regular;\">/</span></span></span><span class=\"mn\" id=\"MathJax-Span-50\" style=\"font-family: STIXGeneral-Regular;\">3</span><span class=\"mo\" id=\"MathJax-Span-51\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">≈</span><span class=\"mn\" id=\"MathJax-Span-52\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0.67</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.309em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>MC</mi><mo>⁡</mo><mrow><mo>(</mo><mrow><mi>q</mi><mo>,</mo><msub><mi>x</mi><mrow class=\"MJX-TeXAtom-ORD\"><mn>1</mn><mo>:</mo><mi>t</mi></mrow></msub></mrow><mo>)</mo></mrow><mo>=</mo><mn>2</mn><mrow class=\"MJX-TeXAtom-ORD\"><mo>/</mo></mrow><mn>3</mn><mo>≈</mo><mn>0.67</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-10\">\\operatorname{MC}\\left(q, x_{1: t}\\right)=2 / 3 \\approx 0.67</script>. (b) An example of error locating using binary search. The first error step is located at the <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-11-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>7</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mtext>th&amp;#xA0;</mtext></mrow></msup></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-53\" style=\"width: 1.565em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.096em, 1001.3em, 2.294em, -999.997em); top: -2.133em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-54\"><span class=\"msubsup\" id=\"MathJax-Span-55\"><span style=\"display: inline-block; position: relative; width: 1.305em; height: 0px;\"><span style=\"position: absolute; clip: rect(3.18em, 1000.47em, 4.169em, -999.997em); top: -4.008em; left: 0em;\"><span class=\"mn\" id=\"MathJax-Span-56\" style=\"font-family: STIXGeneral-Regular;\">7</span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span><span style=\"position: absolute; top: -4.372em; left: 0.523em;\"><span class=\"texatom\" id=\"MathJax-Span-57\"><span class=\"mrow\" id=\"MathJax-Span-58\"><span class=\"mtext\" id=\"MathJax-Span-59\" style=\"font-size: 70.7%; font-family: STIXGeneral-Regular;\">th&nbsp;</span></span></span><span style=\"display: inline-block; width: 0px; height: 4.013em;\"></span></span></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.138em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 1.191em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><msup><mn>7</mn><mrow class=\"MJX-TeXAtom-ORD\"><mtext>th&nbsp;</mtext></mrow></msup></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-11\">7^{\\text {th }}</script> step after three divide-and-rollouts, where the rollout positions are indicated by the vertical dashed lines. (c) The MCTS process. The dotted lines in Select stage represent the available rollouts for binary search. The bold colored edges represent steps with correctness estimations. The yellow color indicates a correct step, i.e., with a preceding state <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-12-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-60\" style=\"width: 0.471em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.367em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.617em, 1000.37em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-61\"><span class=\"mi\" id=\"MathJax-Span-62\" style=\"font-family: STIXGeneral-Italic;\">s</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.691em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>s</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-12\">s</script> that <span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-13-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>M</mi><mi mathvariant=&quot;normal&quot;>C</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;gt;</mo><mn>0</mn></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-63\" style=\"width: 5.211em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 4.326em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1004.33em, 2.503em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-64\"><span class=\"texatom\" id=\"MathJax-Span-65\"><span class=\"mrow\" id=\"MathJax-Span-66\"><span class=\"mi\" id=\"MathJax-Span-67\" style=\"font-family: STIXGeneral-Regular;\">M</span><span class=\"mi\" id=\"MathJax-Span-68\" style=\"font-family: STIXGeneral-Regular;\">C</span></span></span><span class=\"mo\" id=\"MathJax-Span-69\" style=\"font-family: STIXGeneral-Regular;\">(</span><span class=\"mi\" id=\"MathJax-Span-70\" style=\"font-family: STIXGeneral-Italic;\">s</span><span class=\"mo\" id=\"MathJax-Span-71\" style=\"font-family: STIXGeneral-Regular;\">)</span><span class=\"mo\" id=\"MathJax-Span-72\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">&gt;</span><span class=\"mn\" id=\"MathJax-Span-73\" style=\"font-family: STIXGeneral-Regular; padding-left: 0.315em;\">0</span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.247em; border-left: 0px solid; width: 0px; height: 1.128em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mrow class=\"MJX-TeXAtom-ORD\"><mi mathvariant=\"normal\">M</mi><mi mathvariant=\"normal\">C</mi></mrow><mo stretchy=\"false\">(</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>&gt;</mo><mn>0</mn></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-13\">\\mathrm{MC}(s)>0</script> and the blue color indicates an incorrect step, i.e., with $$\\mathrm{MC}(s)=0$. The number of dashes in each colored edge indicates the number of steps.</li>\n</ul>\n<ul>\n      <li><strong>Monte Carlo Tree Search (MCTS)</strong>: A tree is built for each mathematical question, with nodes representing intermediate reasoning steps. The binary search efficiently narrows down to the first incorrect step by performing rollouts at each stage.</li>\n      <li><strong>Tree Structure</strong>: Each node stores statistics, such as visit counts and Monte Carlo estimations, to guide future rollouts. This structure enables reuse of rollouts, reducing computational redundancy and enhancing the training data collection efficiency.</li>\n      <li><strong>PRM Training</strong>: The PRM is trained using pointwise soft labels derived from the Monte Carlo rollouts. The soft label approach provides better performance compared to hard labels and pairwise loss functions, achieving 70.1% accuracy in classifying per-step correctness.</li>\n      <li><strong>Data Generation</strong>: The PRM was trained on the MATH dataset, generating process annotations using OmegaPRM’s binary search method. This process reduced the number of policy calls while maintaining high-quality annotations.</li>\n    </ul>\n<p><img src=\"../../../images/papers/OmegaPRM2.jpg\" alt=\"\"></p>\n<ul>\n  <li>The paper also highlights the cost-effectiveness of the OmegaPRM approach, as it automates the collection of process supervision data without human annotators, overcoming the limitations of previous methods that required expensive and labor-intensive human annotations. The resulting PRM significantly improves the reasoning accuracy of LLMs in multi-step mathematical tasks.</li>\n</ul>",
    "contentMarkdown": "*   This paper from Luo et al. from Google DeepMind introduces a novel approach to enhance the mathematical reasoning capabilities of large language models (LLMs) through automated process supervision, focusing on intermediate reasoning steps rather than just final outcomes. Traditional techniques like Outcome Reward Models (ORM) verify the final answer’s correctness, but these models do not reward or penalize the intermediate steps, leading to challenges in solving complex multi-step reasoning tasks such as mathematical problem solving.\n*   The authors propose a new divide-and-conquer Monte Carlo Tree Search (MCTS) algorithm, named OmegaPRM, for the efficient collection of process supervision data. OmegaPRM improves upon previous methods by utilizing a binary search technique to locate errors in the chain of thought, identifying the first error in a reasoning path. This method ensures a balanced collection of positive and negative examples, leading to high-quality data collection.\n*   The implementation of OmegaPRM allows the automatic generation of over 1.5 million process supervision annotations, which are used to train a Process Reward Model (PRM). These annotations are generated without human intervention, making the process both cost-effective and scalable. The PRM, when integrated with a weighted self-consistency algorithm, achieves a 69.4% success rate on the MATH benchmark, which is a significant 36% relative improvement over the base model performance of 51%.\n*   The following figure from the paper shows an example tree structure built with our proposed OmegaPRM algorithm. Each node in the tree indicates a state of partial chain-of-thought solution, with information including accuracy of rollouts and other statistics. Each edge indicates an action, i.e., a reasoning step, from the last state. Yellow edges are correct steps and blue edges are wrong.\n\n![](../../../images/papers/OmegaPRM1.jpg)\n\n*   Key implementation details include:\n    *   **Monte Carlo Tree Search (MCTS)**: A tree is built for each mathematical question, with nodes representing intermediate reasoning steps. The binary search efficiently narrows down to the first incorrect step by performing rollouts at each stage.\n    *   **Tree Structure**: Each node stores statistics, such as visit counts and Monte Carlo estimations, to guide future rollouts. This structure enables reuse of rollouts, reducing computational redundancy and enhancing the training data collection efficiency.\n    *   **PRM Training**: The PRM is trained using pointwise soft labels derived from the Monte Carlo rollouts. The soft label approach provides better performance compared to hard labels and pairwise loss functions, achieving 70.1% accuracy in classifying per-step correctness.\n    *   **Data Generation**: The PRM was trained on the MATH dataset, generating process annotations using OmegaPRM’s binary search method. This process reduced the number of policy calls while maintaining high-quality annotations.\n*   The following figure from the paper shows an illustration of the process supervision rollouts, Monte Carlo estimation using binary search and the MCTS process. (a) An example of Monte Carlo estimation of a prefix solution. Two out of the three rollouts are correct, producing the Monte Carlo estimation MC(q,x1:t)\\=2/3≈0.67MC⁡(q,x1:t)\\=2/3≈0.67\\\\operatorname{MC}\\\\left(q, x\\_{1: t}\\\\right)=2 / 3 \\\\approx 0.67. (b) An example of error locating using binary search. The first error step is located at the 7th 7th 7^{\\\\text {th }} step after three divide-and-rollouts, where the rollout positions are indicated by the vertical dashed lines. (c) The MCTS process. The dotted lines in Select stage represent the available rollouts for binary search. The bold colored edges represent steps with correctness estimations. The yellow color indicates a correct step, i.e., with a preceding state sss that MC(s)\\>0MC(s)\\>0\\\\mathrm{MC}(s)>0 and the blue color indicates an incorrect step, i.e., with $$\\\\mathrm{MC}(s)=0$. The number of dashes in each colored edge indicates the number of steps.\n\n*   **Monte Carlo Tree Search (MCTS)**: A tree is built for each mathematical question, with nodes representing intermediate reasoning steps. The binary search efficiently narrows down to the first incorrect step by performing rollouts at each stage.\n*   **Tree Structure**: Each node stores statistics, such as visit counts and Monte Carlo estimations, to guide future rollouts. This structure enables reuse of rollouts, reducing computational redundancy and enhancing the training data collection efficiency.\n*   **PRM Training**: The PRM is trained using pointwise soft labels derived from the Monte Carlo rollouts. The soft label approach provides better performance compared to hard labels and pairwise loss functions, achieving 70.1% accuracy in classifying per-step correctness.\n*   **Data Generation**: The PRM was trained on the MATH dataset, generating process annotations using OmegaPRM’s binary search method. This process reduced the number of policy calls while maintaining high-quality annotations.\n\n![](../../../images/papers/OmegaPRM2.jpg)\n\n*   The paper also highlights the cost-effectiveness of the OmegaPRM approach, as it automates the collection of process supervision data without human annotators, overcoming the limitations of previous methods that required expensive and labor-intensive human annotations. The resulting PRM significantly improves the reasoning accuracy of LLMs in multi-step mathematical tasks.",
    "order": 23,
    "orderInChapter": 9,
    "difficulty": 4,
    "estimatedMinutes": 4,
    "tags": [
      "models",
      "llm",
      "loss function"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": true,
      "hasImages": true,
      "wordCount": 775,
      "contentLength": 15487
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#improve-mathematical-reasoning-in-language-models-by-automated-process-supervision",
    "scrapedAt": "2025-12-28T11:51:47.954Z"
  },
  {
    "id": "ai-o1-chain-of-thought-reasoning-without-prompting-24",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Chain-of-Thought Reasoning Without Prompting",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Wang and Zhou from Google DeepMind investigates an alternative approach to elicit reasoning capabilities from large language models (LLMs) without the need for prompting techniques such as few-shot or zero-shot chain-of-thought (CoT) prompting. The key focus is on altering the decoding process to reveal inherent CoT reasoning paths within the models, avoiding the conventional reliance on manual prompt engineering.</li>\n  <li>The authors demonstrate that by adjusting the decoding procedure, particularly moving away from greedy decoding to exploring top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-14-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-74\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-75\"><span class=\"mi\" id=\"MathJax-Span-76\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-14\">k</script> alternative tokens, it is possible to uncover CoT paths that the model naturally possesses. This method, termed CoT-decoding, effectively bypasses the limitations of standard prompting strategies and instead emphasizes a more task-agnostic way of assessing LLMs’ intrinsic reasoning capabilities.</li>\n  <li>The following figure from the paper shows an illustration of CoT-decoding. Pre-trained LLMs are capable of inherent reasoning without prompting by considering alternative top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-15-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-77\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-78\"><span class=\"mi\" id=\"MathJax-Span-79\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-15\">k</script> tokens, rather than solely relying on the top-1 greedy decoding path. Moreover, these models tend to display higher confidence in decoding the final answer (indicated by a darker shaded color) when a CoT reasoning path is present.</li>\n</ul>\n<p><img src=\"../../../images/papers/CoT-decoding.jpg\" alt=\"\"></p>\n<ul>\n  <li><strong>Technical Contributions</strong>:\n    <ul>\n      <li>The authors show that when alternative decoding paths (top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-16-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-80\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-81\"><span class=\"mi\" id=\"MathJax-Span-82\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-16\">k</script> tokens) are considered, CoT reasoning paths often emerge naturally. This reveals reasoning capabilities that are typically hidden when models rely on the standard greedy decoding path.</li>\n      <li>The presence of CoT in a decoding path correlates with a higher confidence in the final decoded answer. This confidence measure can be leveraged to differentiate between CoT and non-CoT paths.</li>\n      <li>The method enables LLMs to solve reasoning tasks such as mathematical problems and commonsense reasoning more effectively compared to using prompting methods or greedy decoding alone.</li>\n    </ul>\n  </li>\n  <li><strong>Implementation Details</strong>:\n    <ul>\n      <li><strong>CoT-decoding</strong>: This involves generating multiple alternative decoding paths by selecting the top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-17-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-83\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-84\"><span class=\"mi\" id=\"MathJax-Span-85\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-17\">k</script> tokens at each decoding step. After generating the paths, the model’s confidence in each path is evaluated based on the difference between the top two token probabilities in the final answer. This probability difference helps identify the most reliable CoT paths.</li>\n      <li>The method is tested on various reasoning benchmarks such as GSM8K (math reasoning) and commonsense tasks (e.g., year parity questions). For example, in a mathematical task, a correct CoT path was found by selecting alternative decoding paths that consider intermediate steps, such as calculating the price of items and applying discounts sequentially, rather than providing a direct answer.</li>\n      <li>The authors implemented CoT-decoding across several language models, including PaLM-2 and Mistral-7B. Across these models, CoT-decoding consistently yielded significant accuracy improvements over greedy decoding in tasks that require multi-step reasoning.</li>\n      <li>The paper also explores the effect of different values for top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-18-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-86\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-87\"><span class=\"mi\" id=\"MathJax-Span-88\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-18\">k</script>, showing that higher values generally improve model performance by increasing the likelihood of finding the correct reasoning paths.</li>\n    </ul>\n  </li>\n  <li><strong>Experimental Results</strong>:\n    <ul>\n      <li>CoT-decoding yielded a significant accuracy boost compared to greedy decoding, particularly on complex reasoning tasks. For example, on GSM8K, CoT-decoding improved accuracy from 9.9% to 25.1% on the Mistral-7B model, showcasing the effectiveness of this approach.</li>\n      <li>The method partially closes the performance gap between pre-trained and instruction-tuned models. For instance, CoT-decoding improved the pre-trained PaLM-2 large model’s accuracy to levels close to that of instruction-tuned models without requiring any additional supervised data.</li>\n      <li>This work presents a significant step forward in understanding LLMs’ intrinsic reasoning abilities without relying on human intervention through prompt engineering, making it easier to evaluate and harness these capabilities across a broader range of tasks.</li>\n    </ul>\n  </li>\n</ul>\n<ul>\n      <li>The authors show that when alternative decoding paths (top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-16-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-80\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-81\"><span class=\"mi\" id=\"MathJax-Span-82\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-16\">k</script> tokens) are considered, CoT reasoning paths often emerge naturally. This reveals reasoning capabilities that are typically hidden when models rely on the standard greedy decoding path.</li>\n      <li>The presence of CoT in a decoding path correlates with a higher confidence in the final decoded answer. This confidence measure can be leveraged to differentiate between CoT and non-CoT paths.</li>\n      <li>The method enables LLMs to solve reasoning tasks such as mathematical problems and commonsense reasoning more effectively compared to using prompting methods or greedy decoding alone.</li>\n    </ul>\n<ul>\n      <li><strong>CoT-decoding</strong>: This involves generating multiple alternative decoding paths by selecting the top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-17-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-83\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-84\"><span class=\"mi\" id=\"MathJax-Span-85\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-17\">k</script> tokens at each decoding step. After generating the paths, the model’s confidence in each path is evaluated based on the difference between the top two token probabilities in the final answer. This probability difference helps identify the most reliable CoT paths.</li>\n      <li>The method is tested on various reasoning benchmarks such as GSM8K (math reasoning) and commonsense tasks (e.g., year parity questions). For example, in a mathematical task, a correct CoT path was found by selecting alternative decoding paths that consider intermediate steps, such as calculating the price of items and applying discounts sequentially, rather than providing a direct answer.</li>\n      <li>The authors implemented CoT-decoding across several language models, including PaLM-2 and Mistral-7B. Across these models, CoT-decoding consistently yielded significant accuracy improvements over greedy decoding in tasks that require multi-step reasoning.</li>\n      <li>The paper also explores the effect of different values for top-<span class=\"MathJax_Preview\" style=\"color: inherit; display: none;\"></span><span class=\"MathJax\" id=\"MathJax-Element-18-Frame\" tabindex=\"0\" data-mathml=\"<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>\" role=\"presentation\" style=\"position: relative;\"><nobr aria-hidden=\"true\"><span class=\"math\" id=\"MathJax-Span-86\" style=\"width: 0.628em; display: inline-block;\"><span style=\"display: inline-block; position: relative; width: 0.523em; height: 0px; font-size: 120%;\"><span style=\"position: absolute; clip: rect(1.357em, 1000.52em, 2.346em, -999.997em); top: -2.185em; left: 0em;\"><span class=\"mrow\" id=\"MathJax-Span-87\"><span class=\"mi\" id=\"MathJax-Span-88\" style=\"font-family: STIXGeneral-Italic;\">k<span style=\"display: inline-block; overflow: hidden; height: 1px; width: 0.003em;\"></span></span></span><span style=\"display: inline-block; width: 0px; height: 2.19em;\"></span></span></span><span style=\"display: inline-block; overflow: hidden; vertical-align: -0.059em; border-left: 0px solid; width: 0px; height: 0.941em;\"></span></span></nobr><span class=\"MJX_Assistive_MathML\" role=\"presentation\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><mi>k</mi></math></span></span><script type=\"math/tex\" id=\"MathJax-Element-18\">k</script>, showing that higher values generally improve model performance by increasing the likelihood of finding the correct reasoning paths.</li>\n    </ul>\n<ul>\n      <li>CoT-decoding yielded a significant accuracy boost compared to greedy decoding, particularly on complex reasoning tasks. For example, on GSM8K, CoT-decoding improved accuracy from 9.9% to 25.1% on the Mistral-7B model, showcasing the effectiveness of this approach.</li>\n      <li>The method partially closes the performance gap between pre-trained and instruction-tuned models. For instance, CoT-decoding improved the pre-trained PaLM-2 large model’s accuracy to levels close to that of instruction-tuned models without requiring any additional supervised data.</li>\n      <li>This work presents a significant step forward in understanding LLMs’ intrinsic reasoning abilities without relying on human intervention through prompt engineering, making it easier to evaluate and harness these capabilities across a broader range of tasks.</li>\n    </ul>",
    "contentMarkdown": "*   This paper by Wang and Zhou from Google DeepMind investigates an alternative approach to elicit reasoning capabilities from large language models (LLMs) without the need for prompting techniques such as few-shot or zero-shot chain-of-thought (CoT) prompting. The key focus is on altering the decoding process to reveal inherent CoT reasoning paths within the models, avoiding the conventional reliance on manual prompt engineering.\n*   The authors demonstrate that by adjusting the decoding procedure, particularly moving away from greedy decoding to exploring top-kkk alternative tokens, it is possible to uncover CoT paths that the model naturally possesses. This method, termed CoT-decoding, effectively bypasses the limitations of standard prompting strategies and instead emphasizes a more task-agnostic way of assessing LLMs’ intrinsic reasoning capabilities.\n*   The following figure from the paper shows an illustration of CoT-decoding. Pre-trained LLMs are capable of inherent reasoning without prompting by considering alternative top-kkk tokens, rather than solely relying on the top-1 greedy decoding path. Moreover, these models tend to display higher confidence in decoding the final answer (indicated by a darker shaded color) when a CoT reasoning path is present.\n\n![](../../../images/papers/CoT-decoding.jpg)\n\n*   **Technical Contributions**:\n    *   The authors show that when alternative decoding paths (top-kkk tokens) are considered, CoT reasoning paths often emerge naturally. This reveals reasoning capabilities that are typically hidden when models rely on the standard greedy decoding path.\n    *   The presence of CoT in a decoding path correlates with a higher confidence in the final decoded answer. This confidence measure can be leveraged to differentiate between CoT and non-CoT paths.\n    *   The method enables LLMs to solve reasoning tasks such as mathematical problems and commonsense reasoning more effectively compared to using prompting methods or greedy decoding alone.\n*   **Implementation Details**:\n    *   **CoT-decoding**: This involves generating multiple alternative decoding paths by selecting the top-kkk tokens at each decoding step. After generating the paths, the model’s confidence in each path is evaluated based on the difference between the top two token probabilities in the final answer. This probability difference helps identify the most reliable CoT paths.\n    *   The method is tested on various reasoning benchmarks such as GSM8K (math reasoning) and commonsense tasks (e.g., year parity questions). For example, in a mathematical task, a correct CoT path was found by selecting alternative decoding paths that consider intermediate steps, such as calculating the price of items and applying discounts sequentially, rather than providing a direct answer.\n    *   The authors implemented CoT-decoding across several language models, including PaLM-2 and Mistral-7B. Across these models, CoT-decoding consistently yielded significant accuracy improvements over greedy decoding in tasks that require multi-step reasoning.\n    *   The paper also explores the effect of different values for top-kkk, showing that higher values generally improve model performance by increasing the likelihood of finding the correct reasoning paths.\n*   **Experimental Results**:\n    *   CoT-decoding yielded a significant accuracy boost compared to greedy decoding, particularly on complex reasoning tasks. For example, on GSM8K, CoT-decoding improved accuracy from 9.9% to 25.1% on the Mistral-7B model, showcasing the effectiveness of this approach.\n    *   The method partially closes the performance gap between pre-trained and instruction-tuned models. For instance, CoT-decoding improved the pre-trained PaLM-2 large model’s accuracy to levels close to that of instruction-tuned models without requiring any additional supervised data.\n    *   This work presents a significant step forward in understanding LLMs’ intrinsic reasoning abilities without relying on human intervention through prompt engineering, making it easier to evaluate and harness these capabilities across a broader range of tasks.\n\n*   The authors show that when alternative decoding paths (top-kkk tokens) are considered, CoT reasoning paths often emerge naturally. This reveals reasoning capabilities that are typically hidden when models rely on the standard greedy decoding path.\n*   The presence of CoT in a decoding path correlates with a higher confidence in the final decoded answer. This confidence measure can be leveraged to differentiate between CoT and non-CoT paths.\n*   The method enables LLMs to solve reasoning tasks such as mathematical problems and commonsense reasoning more effectively compared to using prompting methods or greedy decoding alone.\n\n*   **CoT-decoding**: This involves generating multiple alternative decoding paths by selecting the top-kkk tokens at each decoding step. After generating the paths, the model’s confidence in each path is evaluated based on the difference between the top two token probabilities in the final answer. This probability difference helps identify the most reliable CoT paths.\n*   The method is tested on various reasoning benchmarks such as GSM8K (math reasoning) and commonsense tasks (e.g., year parity questions). For example, in a mathematical task, a correct CoT path was found by selecting alternative decoding paths that consider intermediate steps, such as calculating the price of items and applying discounts sequentially, rather than providing a direct answer.\n*   The authors implemented CoT-decoding across several language models, including PaLM-2 and Mistral-7B. Across these models, CoT-decoding consistently yielded significant accuracy improvements over greedy decoding in tasks that require multi-step reasoning.\n*   The paper also explores the effect of different values for top-kkk, showing that higher values generally improve model performance by increasing the likelihood of finding the correct reasoning paths.\n\n*   CoT-decoding yielded a significant accuracy boost compared to greedy decoding, particularly on complex reasoning tasks. For example, on GSM8K, CoT-decoding improved accuracy from 9.9% to 25.1% on the Mistral-7B model, showcasing the effectiveness of this approach.\n*   The method partially closes the performance gap between pre-trained and instruction-tuned models. For instance, CoT-decoding improved the pre-trained PaLM-2 large model’s accuracy to levels close to that of instruction-tuned models without requiring any additional supervised data.\n*   This work presents a significant step forward in understanding LLMs’ intrinsic reasoning abilities without relying on human intervention through prompt engineering, making it easier to evaluate and harness these capabilities across a broader range of tasks.",
    "order": 24,
    "orderInChapter": 10,
    "difficulty": 4,
    "estimatedMinutes": 5,
    "tags": [
      "models",
      "llm"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": true,
      "hasImages": true,
      "wordCount": 953,
      "contentLength": 17388
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#chain-of-thought-reasoning-without-prompting",
    "scrapedAt": "2025-12-28T11:51:47.954Z"
  },
  {
    "id": "ai-o1-training-language-models-to-self-correct-via-reinf-25",
    "domain": "ai_primers",
    "category": "Models",
    "article": "OpenAI o1",
    "articleSlug": "o1",
    "chapter": "Related Papers",
    "title": "Training Language Models to Self-Correct Via Reinforcement Learning",
    "subtitle": "Related Papers",
    "contentHtml": "<ul>\n  <li>This paper by Kumar et al. from Google DeepMind introduces SCoRe, a novel multi-turn online reinforcement learning (RL) approach that enhances LLMs’ intrinsic self-correction capabilities by training on self-generated data. Unlike previous self-correction methods that require multiple models or external supervision, SCoRe is designed to operate without any oracle feedback, relying entirely on data generated by the model itself.</li>\n  <li>The authors first highlight the limitations of traditional supervised fine-tuning (SFT) approaches, which suffer from a distribution mismatch between training data and model outputs. These approaches often bias the model towards minimal edits that fail to generalize well to unseen problems, leading to ineffective self-correction. In response, SCoRe addresses these issues through multi-turn RL, allowing the model to iteratively refine its outputs across multiple attempts.</li>\n  <li>The SCoRe method is implemented in two distinct stages:\n    <ol>\n      <li><strong>Stage I: Initialization</strong> – The model is fine-tuned to produce high-reward second-attempt responses while constraining its first attempt to remain close to the base model’s outputs. This initialization is critical in preventing collapse into trivial strategies like minimal edits.</li>\n      <li><strong>Stage II: Multi-turn RL with Reward Shaping</strong> – The RL training optimizes both the first and second attempts, with an emphasis on improving from the first to the second attempt. A reward shaping mechanism is introduced to amplify self-correction behaviors by providing bonus rewards for meaningful improvements between attempts.</li>\n    </ol>\n  </li>\n  <li>The following figure from the paper shows an example trace and the problem setting of self-correction.</li>\n</ul>\n<ol>\n      <li><strong>Stage I: Initialization</strong> – The model is fine-tuned to produce high-reward second-attempt responses while constraining its first attempt to remain close to the base model’s outputs. This initialization is critical in preventing collapse into trivial strategies like minimal edits.</li>\n      <li><strong>Stage II: Multi-turn RL with Reward Shaping</strong> – The RL training optimizes both the first and second attempts, with an emphasis on improving from the first to the second attempt. A reward shaping mechanism is introduced to amplify self-correction behaviors by providing bonus rewards for meaningful improvements between attempts.</li>\n    </ol>\n<p><img src=\"../../../images/papers/SCoRe.jpg\" alt=\"\"></p>\n<ul>\n  <li>Key components of the implementation include:\n    <ul>\n      <li><strong>On-policy RL</strong>: SCoRe uses on-policy policy gradient methods to optimize for self-correction, ensuring that the model learns from its own mistakes and adapts to its own response distribution.</li>\n      <li><strong>Reward Shaping</strong>: The model receives additional rewards for making corrections that change an incorrect response to correct, encouraging it to explore self-correction strategies.</li>\n      <li><strong>KL-Divergence Regularization</strong>: The model’s first attempt is constrained via KL-divergence to stay close to the base model’s outputs, avoiding drastic changes that could degrade initial performance.</li>\n    </ul>\n  </li>\n  <li>The approach was tested on two key tasks: mathematical reasoning (using the MATH dataset) and coding (using the HumanEval and MBPP datasets). SCoRe demonstrated significant improvements over baseline models, achieving a 15.6% gain in self-correction accuracy on MATH and a 9.1% improvement on coding benchmarks. Importantly, the model improved not only in its ability to correct mistakes but also in maintaining correct responses across attempts.</li>\n  <li>In terms of evaluation, SCoRe’s success was measured using metrics such as accuracy at each attempt (t1 and t2), the net improvement between attempts (Δ(t1, t2)), and the frequency of problems corrected in subsequent attempts. SCoRe outperformed other approaches by substantially reducing the number of correct answers that became incorrect in the second attempt and improving the rate of incorrect-to-correct transformations.</li>\n  <li>The paper also provides ablation studies demonstrating the importance of each component in the SCoRe pipeline, highlighting the necessity of multi-turn training and reward shaping in achieving effective self-correction behavior.</li>\n  <li>In summary, SCoRe presents a robust solution to the problem of self-correction in LLMs by leveraging reinforcement learning techniques that focus on improving performance iteratively over multiple attempts.</li>\n</ul>\n<ul>\n      <li><strong>On-policy RL</strong>: SCoRe uses on-policy policy gradient methods to optimize for self-correction, ensuring that the model learns from its own mistakes and adapts to its own response distribution.</li>\n      <li><strong>Reward Shaping</strong>: The model receives additional rewards for making corrections that change an incorrect response to correct, encouraging it to explore self-correction strategies.</li>\n      <li><strong>KL-Divergence Regularization</strong>: The model’s first attempt is constrained via KL-divergence to stay close to the base model’s outputs, avoiding drastic changes that could degrade initial performance.</li>\n    </ul>",
    "contentMarkdown": "*   This paper by Kumar et al. from Google DeepMind introduces SCoRe, a novel multi-turn online reinforcement learning (RL) approach that enhances LLMs’ intrinsic self-correction capabilities by training on self-generated data. Unlike previous self-correction methods that require multiple models or external supervision, SCoRe is designed to operate without any oracle feedback, relying entirely on data generated by the model itself.\n*   The authors first highlight the limitations of traditional supervised fine-tuning (SFT) approaches, which suffer from a distribution mismatch between training data and model outputs. These approaches often bias the model towards minimal edits that fail to generalize well to unseen problems, leading to ineffective self-correction. In response, SCoRe addresses these issues through multi-turn RL, allowing the model to iteratively refine its outputs across multiple attempts.\n*   The SCoRe method is implemented in two distinct stages:\n    1.  **Stage I: Initialization** – The model is fine-tuned to produce high-reward second-attempt responses while constraining its first attempt to remain close to the base model’s outputs. This initialization is critical in preventing collapse into trivial strategies like minimal edits.\n    2.  **Stage II: Multi-turn RL with Reward Shaping** – The RL training optimizes both the first and second attempts, with an emphasis on improving from the first to the second attempt. A reward shaping mechanism is introduced to amplify self-correction behaviors by providing bonus rewards for meaningful improvements between attempts.\n*   The following figure from the paper shows an example trace and the problem setting of self-correction.\n\n1.  **Stage I: Initialization** – The model is fine-tuned to produce high-reward second-attempt responses while constraining its first attempt to remain close to the base model’s outputs. This initialization is critical in preventing collapse into trivial strategies like minimal edits.\n2.  **Stage II: Multi-turn RL with Reward Shaping** – The RL training optimizes both the first and second attempts, with an emphasis on improving from the first to the second attempt. A reward shaping mechanism is introduced to amplify self-correction behaviors by providing bonus rewards for meaningful improvements between attempts.\n\n![](../../../images/papers/SCoRe.jpg)\n\n*   Key components of the implementation include:\n    *   **On-policy RL**: SCoRe uses on-policy policy gradient methods to optimize for self-correction, ensuring that the model learns from its own mistakes and adapts to its own response distribution.\n    *   **Reward Shaping**: The model receives additional rewards for making corrections that change an incorrect response to correct, encouraging it to explore self-correction strategies.\n    *   **KL-Divergence Regularization**: The model’s first attempt is constrained via KL-divergence to stay close to the base model’s outputs, avoiding drastic changes that could degrade initial performance.\n*   The approach was tested on two key tasks: mathematical reasoning (using the MATH dataset) and coding (using the HumanEval and MBPP datasets). SCoRe demonstrated significant improvements over baseline models, achieving a 15.6% gain in self-correction accuracy on MATH and a 9.1% improvement on coding benchmarks. Importantly, the model improved not only in its ability to correct mistakes but also in maintaining correct responses across attempts.\n*   In terms of evaluation, SCoRe’s success was measured using metrics such as accuracy at each attempt (t1 and t2), the net improvement between attempts (Δ(t1, t2)), and the frequency of problems corrected in subsequent attempts. SCoRe outperformed other approaches by substantially reducing the number of correct answers that became incorrect in the second attempt and improving the rate of incorrect-to-correct transformations.\n*   The paper also provides ablation studies demonstrating the importance of each component in the SCoRe pipeline, highlighting the necessity of multi-turn training and reward shaping in achieving effective self-correction behavior.\n*   In summary, SCoRe presents a robust solution to the problem of self-correction in LLMs by leveraging reinforcement learning techniques that focus on improving performance iteratively over multiple attempts.\n\n*   **On-policy RL**: SCoRe uses on-policy policy gradient methods to optimize for self-correction, ensuring that the model learns from its own mistakes and adapts to its own response distribution.\n*   **Reward Shaping**: The model receives additional rewards for making corrections that change an incorrect response to correct, encouraging it to explore self-correction strategies.\n*   **KL-Divergence Regularization**: The model’s first attempt is constrained via KL-divergence to stay close to the base model’s outputs, avoiding drastic changes that could degrade initial performance.",
    "order": 25,
    "orderInChapter": 11,
    "difficulty": 3,
    "estimatedMinutes": 4,
    "tags": [
      "models",
      "llm",
      "reinforcement learning",
      "regularization",
      "fine-tuning"
    ],
    "metadata": {
      "hasCode": false,
      "hasMath": false,
      "hasImages": true,
      "wordCount": 689,
      "contentLength": 5336
    },
    "nextCards": [],
    "relatedCards": [],
    "prerequisites": [],
    "sourceUrl": "https://aman.ai/primers/ai/o1/#training-language-models-to-self-correct-via-reinforcement-learning",
    "scrapedAt": "2025-12-28T11:51:47.954Z"
  }
]